/*
Deployment script for ZIP

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "ZIP"
:setvar DefaultFilePrefix "ZIP"
:setvar DefaultDataPath "C:\Developer\Tools\Microsoft SQL Server\MSSQL13.SQL2016\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Developer\Tools\Microsoft SQL Server\MSSQL13.SQL2016\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [master];


GO

IF (DB_ID(N'$(DatabaseName)') IS NOT NULL) 
BEGIN
    ALTER DATABASE [$(DatabaseName)]
    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [$(DatabaseName)];
END

GO
PRINT N'Creating $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)]
    ON 
    PRIMARY(NAME = [$(DatabaseName)], FILENAME = N'$(DefaultDataPath)$(DefaultFilePrefix)_Primary.mdf')
    LOG ON (NAME = [$(DatabaseName)_log], FILENAME = N'$(DefaultLogPath)$(DefaultFilePrefix)_Primary.ldf') COLLATE SQL_Latin1_General_CP1_CI_AS
GO
USE [$(DatabaseName)];


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL,
                RECOVERY FULL,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK OFF,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CLOSE OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET READ_COMMITTED_SNAPSHOT OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                PAGE_VERIFY NONE,
                DATE_CORRELATION_OPTIMIZATION OFF,
                DISABLE_BROKER,
                PARAMETERIZATION SIMPLE,
                SUPPLEMENTAL_LOGGING OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY OFF,
        DB_CHAINING OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET HONOR_BROKER_PRIORITY OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET FILESTREAM(NON_TRANSACTED_ACCESS = OFF),
                CONTAINMENT = NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CREATE_STATISTICS ON(INCREMENTAL = OFF),
                MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = OFF,
                DELAYED_DURABILITY = DISABLED 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE SCOPED CONFIGURATION SET MAXDOP = 0;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET MAXDOP = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET LEGACY_CARDINALITY_ESTIMATION = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET LEGACY_CARDINALITY_ESTIMATION = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET PARAMETER_SNIFFING = ON;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET PARAMETER_SNIFFING = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET QUERY_OPTIMIZER_HOTFIXES = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET QUERY_OPTIMIZER_HOTFIXES = PRIMARY;
    END


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'enable';


GO
PRINT N'Creating [acct]...';


GO
CREATE SCHEMA [acct]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [api]...';


GO
CREATE SCHEMA [api]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [app]...';


GO
CREATE SCHEMA [app]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [auto]...';


GO
CREATE SCHEMA [auto]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [bo]...';


GO
CREATE SCHEMA [bo]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [brkg]...';


GO
CREATE SCHEMA [brkg]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [co]...';


GO
CREATE SCHEMA [co]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [core]...';


GO
CREATE SCHEMA [core]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [hub]...';


GO
CREATE SCHEMA [hub]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [ic]...';


GO
CREATE SCHEMA [ic]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [invt]...';


GO
CREATE SCHEMA [invt]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [loc]...';


GO
CREATE SCHEMA [loc]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [rpt]...';


GO
CREATE SCHEMA [rpt]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [shpt]...';


GO
CREATE SCHEMA [shpt]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [svc]...';


GO
CREATE SCHEMA [svc]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [tms]...';


GO
CREATE SCHEMA [tms]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [tvp]...';


GO
CREATE SCHEMA [tvp]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [vmi]...';


GO
CREATE SCHEMA [vmi]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [whse]...';


GO
CREATE SCHEMA [whse]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [xpd]...';


GO
CREATE SCHEMA [xpd]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [zeb]...';


GO
CREATE SCHEMA [zeb]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [Zebra.DB]...';


GO
CREATE ASSEMBLY [Zebra.DB]
    AUTHORIZATION [dbo]
    FROM 0x4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000800000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000504500004C01030037D4B05A0000000000000000E00022200B013000000C000000060000000000007A2B0000002000000040000000000010002000000002000004000000000000000600000000000000008000000002000000000000030060850000100000100000000010000010000000000000100000000000000000000000282B00004F00000000400000A802000000000000000000000000000000000000006000000C000000F02900001C0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000080000000000000000000000082000004800000000000000000000002E74657874000000800B000000200000000C000000020000000000000000000000000000200000602E72737263000000A80200000040000000040000000E0000000000000000000000000000400000402E72656C6F6300000C00000000600000000200000012000000000000000000000000000040000042000000000000000000000000000000005C2B00000000000048000000020005004C220000A4070000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022020328050000062A4A0302740B000001730600000A810A0000012A1E02280700000A2AC2026F0800000A2D22036F0800000A2D1A026F0900000A2C12026F0A00000A036F0A00000A73060000062A7E010000042AF602280700000A02037D0700000402047D0800000402038E697D0400000402048E69D27D0500000402027B0500000417FE017D060000040228080000062A7E027B07000004027B02000004027B03000004027B0200000459730B00000A2A5A02167D0200000402027B05000004155A7D030000042A0000133003007100000001000011027B03000004027B040000043202162A02280B000006027B020000040A2B3C0206280D0000062C2F02067D0300000402280C0000062C02172A06027B050000041759580A02027B02000004027B05000004587D020000040617580A06027B0400000432BB02280A00000602280C0000062A4E02280B00000602027B040000047D030000042A5202027B03000004027B05000004587D020000042A4A027B03000004027B02000004FE0416FE012A000000133003005000000002000011027B060000042C13027B070000040393027B080000041693FE012A160A2B260306580B07027B040000042F12027B070000040793027B0800000406932E02162A061758D20A06027B0500000432D1172A5E168D0C000001168D0C000001730600000680010000042A42534A4201000100000000000C00000076342E302E33303331390000000005006C000000E0020000237E00004C0300007C02000023537472696E677300000000C80500000400000023555300CC050000100000002347554944000000DC050000C801000023426C6F6200000000000000020000015717A2010902000000FA013300160000010000000C00000003000000080000000E0000000B000000010000000B000000090000000200000001000000010000000100000001000000020000000100000000000B0101000000000006007500C9010600A700C90106004C00AA010F00E90100000600480223010A0060003E01060080010D020A0095003E010A003F02F8010A00DC00F8010600DF00230106002A012301000000000100000000000100010001001000BD0100001500010001000201100036010000150001000500310073023C0001002D0240000100360240002100F10040002100FC004300210099014600210044004900210075014900502000000000960065014D000100502000000000960059014D00030059200000000096002F01560005006C200000000086188C0106000700742000000000960071015E000700A5200000000081188C0167000900E32000000000E60955026F000B00032100000000E6014F0206000B001C2100000000E601610215000B009921000000008100320006000B00AD21000000008100200206000B00C221000000008100CF0015000B00D821000000008100280073000B003422000000009118920178000C00000001004500000002007601000001004500000002007601000001000701020002003E00000001004500000002007601000001004500000002007601000001006A0203001D0009008C01010011008C01060019008C010A0031008C01060041008C01060051008C01100029008C0106004900180115004900E60019004900C5001D0059008C01220020002300B10024002B00A0012E000B0080002E00130089002E001B00A80040002300280144002B00B30164002B00A00184002B00B3012A002E0003000100000059027C000200070003000480000000000000000000000000000000000A00000004000000000000000000000033001F000000000004000000000000000000000033001300000000000300020000000000003C4D6F64756C653E005A656272612E44420053797374656D2E44617461006D73636F726C69620069734D6174636865640073746570466F7277617264007069656365005F736F757263650044656275676761626C654174747269627574650053716C46756E6374696F6E41747472696275746500436F6D70696C6174696F6E52656C61786174696F6E734174747269627574650053716C46616365744174747269627574650052756E74696D65436F6D7061746962696C697479417474726962757465006765745F56616C75650068617352656D61696E696E670053716C537472696E67006765745F4C656E677468005F7372634C656E677468005F7370724C656E677468006F626A005A656272612E44422E646C6C006765745F49734E756C6C0053797374656D00436861720046696C6C65720043686F70706572004D6963726F736F66742E53716C5365727665722E536572766572004E3430536C696365436C7200547670536C696365436C7200466F72005F736570617261746F720049456E756D657261746F72002E63746F72002E6363746F72005F697353696E676C65436861725370720053797374656D2E446961676E6F73746963730053716C54767046756E63730053797374656D2E52756E74696D652E436F6D70696C6572536572766963657300446562756767696E674D6F6465730053797374656D2E446174612E53716C54797065730053797374656D2E436F6C6C656374696F6E730074616C6C794C617374506F73005F6C617374506F73005F6E657874506F730053716C4368617273004F626A656374005265736574006765745F43757272656E74004D6F76654E65787400737263496E64657800456D7074790000000000000000791DF771E0D25D4C927329056C1DA51A00042001010803200001052001011111042001010E032000020320000A0420001D03072003011D03080803070108040702050808B77A5C561934E0890306120C02060802060502060203061D03080002121D12251225070002011C101129080002120C12251225072002011D031D030320001C0420010208030000010328001C0801000800000000001E01000100540216577261704E6F6E457863657074696F6E5468726F7773010801000200000000007601000500540E044E616D65094E415823536C69636554020F497344657465726D696E69737469630154020949735072656369736501540E0F5461626C65446566696E6974696F6E135069656365206E76617263686172286D617829540E1146696C6C526F774D6574686F644E616D650646696C6C65727701000500540E044E616D65094E344B23536C69636554020F497344657465726D696E69737469630154020949735072656369736501540E0F5461626C65446566696E6974696F6E145069656365206E76617263686172283430303029540E1146696C6C526F774D6574686F644E616D650646696C6C657212010001005408074D617853697A65FFFFFFFF12010001005408074D617853697A65FF00000000000000000037D4B05A00000000020000001C0100000C2A00000C0C000052534453AF16A837D19221479D602FE2F6BCB30E01000000433A5C535344545C5A656272612E44425C5A656272612E44425C6F626A5C52656C656173655C5A656272612E44422E706462000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000502B000000000000000000006A2B00000020000000000000000000000000000000000000000000005C2B0000000000000000000000005F436F72446C6C4D61696E006D73636F7265652E646C6C0000000000FF25002000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001001000000018000080000000000000000000000000000001000100000030000080000000000000000000000000000001000000000048000000584000004C02000000000000000000004C0234000000560053005F00560045005200530049004F004E005F0049004E0046004F0000000000BD04EFFE00000100000000000000000000000000000000003F000000000000000400000002000000000000000000000000000000440000000100560061007200460069006C00650049006E0066006F00000000002400040000005400720061006E0073006C006100740069006F006E00000000000000B004AC010000010053007400720069006E006700460069006C00650049006E0066006F0000008801000001003000300030003000300034006200300000002C0002000100460069006C0065004400650073006300720069007000740069006F006E000000000020000000300008000100460069006C006500560065007200730069006F006E000000000030002E0030002E0030002E00300000003A000D00010049006E007400650072006E0061006C004E0061006D00650000005A0065006200720061002E00440042002E0064006C006C00000000002800020001004C006500670061006C0043006F00700079007200690067006800740000002000000042000D0001004F0072006900670069006E0061006C00460069006C0065006E0061006D00650000005A0065006200720061002E00440042002E0064006C006C0000000000340008000100500072006F006400750063007400560065007200730069006F006E00000030002E0030002E0030002E003000000038000800010041007300730065006D0062006C0079002000560065007200730069006F006E00000030002E0030002E0030002E0030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000C0000007C3B00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;


GO
ALTER ASSEMBLY [Zebra.DB]
    DROP FILE ALL
    ADD FILE FROM 0x4D6963726F736F667420432F432B2B204D534620372E30300D0A1A445300000000020000020000001F000000A0000000000000001D000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF380000C0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0BCA3101380000000010000000100000000000001000FFFF04000000FFFF03000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BCA3101380000000010000000100000000000001100FFFF04000000FFFF0300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000942E310137D4B05A01000000AF16A837D19221479D602FE2F6BCB30E00000000000000000100000001000000000000000000000000000000DC51330100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BCA310138000000001000000010000000000000FFFFFFFF04000000FFFF030000000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BCA310138000000001000000010000000000000FFFFFFFF04000000FFFF030000000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F862513FC607D311905300C04FA302A1C4454B99E9E6D211903F00C04FA302A10B9D865A1166D311BD2A0000F80849BDEC1618FF5EAA104D87F76F49638334601400000000000000F87D48E74C7790E40D86230992AA21BC55C1ED76000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F862513FC607D311905300C04FA302A1C4454B99E9E6D211903F00C04FA302A10B9D865A1166D311BD2A0000F80849BDEC1618FF5EAA104D87F76F496383346014000000000000008F6C27DC5516EECCEEBD7B04CC9E3EDBC19447DF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000D501000000000000D5010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FEEFFEEF01000000C400000000433A5C535344545C5A656272612E44425C5A656272612E44425C636C725C53716C54767046756E63732E63730000633A5C737364745C7A656272612E64625C7A656272612E64625C636C725C73716C74767066756E63732E637300433A5C535344545C5A656272612E44425C5A656272612E44425C636C725C53716C54767046756E63732E46696C6C65722E637300633A5C737364745C7A656272612E64625C7A656272612E64625C636C725C73716C74767066756E63732E66696C6C65722E63730007000000000000002E00000000000000010000002F0000005C0000009000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001BE23001AC000000FC041ECB2DC0D301010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000400000001000000090000000000000090000000280000001BE23001C6E270785C0000005C0000002E000000900000006500000000000000000000002F000000280000001BE230010635E30E5C000000010000002E0000002F000000650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000036002A1100000000DC0000000000000008000000000000000000000001000006000000000100000000547670536C696365436C72000000001600031104000000A8000000080000000000000001000000160024115553797374656D2E436F6C6C656374696F6E73001A0024115553797374656D2E446174612E53716C54797065730000001E002411554D6963726F736F66742E53716C5365727665722E53657276657200020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040000000C000000010003000200060036002A11000000004801000000000000080000000000000000000000020000060800000001000000004E3430536C696365436C72000000002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C00000001000006020006002E002A1100000000FC010000000000001200000000000000000000000300000610000000010000000046696C6C657200160003114C010000C8010000120000001000000001000000160024115553797374656D2E436F6C6C656374696F6E73001A0024115553797374656D2E446174612E53716C5479706573000000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040000000C0000000100020002000600F200000024000000000000000100010008000000000000000100000018000000000000000D00008003002900F200000024000000080000000100010008000000000000000100000018000000000000001600008003002900F200000030000000100000000100010012000000080000000200000024000000000000000700008011000000070000803F00620063006400F40000001000000001000000000000005C0000000000000018000000000000001C0000003400000050000000680000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000002E002A1100000000640000000000000030000000000000000000000005000006220000000100000000466F72000000002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C00000003000006020006002E002A1100000000C8000000000000003D0000000000000000000000060000065200000001000000002E63746F7200002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C000000030000060200060036002A110000000034010000000000001F0000000000000000000000070000068F00000001000000006765745F43757272656E74000000002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C00000003000006020006002E002A1100000000980100000000000016000000000000000000000008000006AE0000000100000000526573657400002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C000000030000060200060032002A1100000000500200000000000071000000000000000000000009000006C400000001000000004D6F76654E657874000000160003119C0100001C02000071000000C40000000100000016000311D0010000180200004E000000DA0000000100000016002011000000000100001100000000000000006900000002000600020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C000000030000060200060036002A1100000000BC020000000000001300000000000000000000000A00000635010000010000000073746570466F7277617264000000002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C000000030000060200060036002A110000000028030000000000001400000000000000000000000B00000648010000010000000074616C6C794C617374506F730000002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C000000030000060200060036002A110000000094030000000000001200000000000000000000000C0000065C010000010000000068617352656D61696E696E670000002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C000000030000060200060032002A110000000084040000000000005000000000000000000000000D0000066E010000010000000069734D6174636865640000160003119803000050040000500000006E0100000100000016000311CC0300004C04000033000000890100000100000016002011000000000200001100000000000000006900000016000311E403000048040000210000008D010000010000001A002011010000000200001100000000000000006F666673657400000200060002000600020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C00000003000006020006002E002A1100000000E8040000000000001700000000000000000000000E000006BE01000001000000002E6363746F72002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000000300000602000600F200000024000000220000000100010030000000000000000100000018000000000000000D00008104003A00F20000007800000052000000010001003D00000000000000080000006C000000000000001200008006000000140000800D0000001500008014000000160000801D00000017000080270000001800008036000000190000803C0000001A000080030033000400150004001B0004001F0004002A000400290004000C0003000400F2000000240000008F000000010001001F000000000000000100000018000000000000002100008021005B00F20000003C000000AE0000000100010016000000000000000300000030000000000000002200008007000000220000801500000022000080190026002700420043004400F2000000CC000000C40000000100010071000000000000000F000000C000000000000000250000800E00000025000080100000002700008016000000280000801D000000EEEFFE801F0000002A000080280000002C0000802F0000002D000080370000002D0000803900000030000080440000003100008057000000280000805B0000002800008064000000350000806A0000003600008004001F0020002D000400130009001900000000000500160006001300060019001A00260007001D0007001E002B002E001B0029000400120004001A00F20000003C00000035010000010001001300000000000000030000003000000000000000390000800600000039000080120000003900008020002F003000460047004800F200000030000000480100000100010014000000000000000200000024000000000000003A000080130000003A0000802100420043004400F2000000240000005C0100000100010012000000000000000100000018000000000000003C00008021003D00F2000000900000006E0100000100010050000000000000000A00000084000000000000003F000080080000003F0000801B000000410000801D000000EEEFFE801F0000004300008023000000440000803E00000045000080400000004100008045000000410000804E00000047000080040019001A004600090013000000000005001F000500420006001300250028001500230004001000F200000024000000BE0100000100010017000000000000000100000018000000000000001000008003005100F4000000080000005C000000000000005000000098000000AC000000C4000000D8000000F00000000C01000024010000380100005001000068010000800100009C010000B4010000D0010000E8010000040200001C020000340200004C0200006402000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFF1A092FF1D00000006C0200005100000001000000D1010000010000001D0200000100000081000000010000000502000001000000C5000000010000001D000000010000009D010000010000000100000001000000D9000000010000000D010000010000003502000001000000E901000001000000AD000000010000006502000001000000F100000001000000810100000100000035000000010000004D020000010000003901000001000000690000000100000069010000010000009900000001000000B50100000100000025010000010000005101000001000000010400000000000000000000000000000000000000000000000000000000004001040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000010400000000000000000000000004000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000001000000000000000000000000001040000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000400000000000000100000000000000000400000000000000000000000000000000000002000000000000000000000000000000000000000000000020000000000000000200002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000002000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C0000001800000024000000300000003C0000004800000054000000600000006C0000007800000084000000900000009C000000A8000000B4000000C0000000CC000000D8000000E4000000F0000000FC0000000801000014010000200100002C0100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001A00251100000000040000000100547670536C696365436C720000001600291100000000040000000100303630303030303100001A00251100000000E000000001004E3430536C696365436C720000001600291100000000E000000001003036303030303032000016002511000000004C010000010046696C6C65720000000016002911000000004C0100000100303630303030303300001200251100000000040000000200466F7200000016002911000000000400000002003036303030303035000012002511000000006800000002002E63746F72001600291100000000680000000200303630303030303600001A00251100000000CC00000002006765745F43757272656E740000001600291100000000CC000000020030363030303030370000120025110000000038010000020052657365740016002911000000003801000002003036303030303038000016002511000000009C01000002004D6F76654E657874000016002911000000009C0100000200303630303030303900001A0025110000000054020000020073746570466F72776172640000001600291100000000540200000200303630303030306100001A00251100000000C0020000020074616C6C794C617374506F7300001600291100000000C00200000200303630303030306200001A002511000000002C030000020068617352656D61696E6910000000000000000000000000000000000000000000000000000000FFFFFFFF1A092FF100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006E67000016002911000000002C030000020030363030303030630000160025110000000098030000020069734D6174636865640016002911000000009803000002003036303030303064000016002511000000008804000002002E6363746F720000000016002911000000008804000002003036303030303065000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFF77093101010000000D000D8E0E00A4650F000000B8000000700100002C0000007C000000000000000000000016000000190000000000EEC00000000000000000FFFF000000000000FFFFFFFF00000000FFFF0000000000000000000000000B000002000000000000A80000000200000000000000000000000000000053716C54767046756E63730034394232314345370000000000000000FFFF000000000000FFFFFFFF00000000FFFF0000000000000000000000000C00EC040000000000006C0300000100000000000000000000000000000053716C54767046756E63732E43686F70706572004438353543304636000000002DBA2EF10100000000000000080000000000000000000000000000000000000001000000080000000800000000000000000000000000000000000000010000001000000012000000000000000000000000000000000000000100000022000000300000000000000001000000000000000000000001000000520000003D00000000000000010000000000000000000000010000008F0000001F0000000000000001000000000000000000000001000000AE000000160000000000000001000000000000000000000001000000C400000071000000000000000100000000000000000000000100000035010000130000000000000001000000000000000000000001000000480100001400000000000000010000000000000000000000010000005C0100001200000000000000010000000000000000000000010000006E010000500000000000000001000000000000000000000001000000BE0100001700000000000000010000000000000000000000020002000D01000000000100FFFFFFFF00000000D50100000802000000000000FFFFFFFF00000000FFFFFFFF020003000000020002000100000000002D0000002D000000433A5C535344545C5A656272612E44425C5A656272612E44425C636C725C53716C54767046756E63732E637300433A5C535344545C5A656272612E44425C5A656272612E44425C636C725C53716C54767046756E63732E46696C6C65722E637300000000FEEFFEEF010000000100000000010000000000000000000000FFFFFFFFFFFFFFFFFFFF0A00FFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000942E310137D4B05A01000000AF16A837D19221479D602FE2F6BCB30E990000002F4C696E6B496E666F002F6E616D6573002F7372632F686561646572626C6F636B002F7372632F66696C65732F633A5C737364745C7A656272612E64625C7A656272612E64625C636C725C73716C74767066756E63732E6373002F7372632F66696C65732F633A5C737364745C7A656272612E64625C7A656272612E64625C636C725C73716C74767066756E63732E66696C6C65722E637300050000000A000000010000002E010000000000001100000007000000000000000500000022000000080000000A000000060000005A0000000900000000000000DC513301000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000020000000FD000000380000003F0300003800000000000000F4000000AC0000005C0000005C00000028000000C4020000AC0800004C0300002C0000007C020000030000001B00000006000000190000001A000000070000000B0000000C00000008000000090000000A0000000D0000000E0000000F000000100000001100000012000000130000001400000015000000170000001600000018000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 AS N'Zebra.DB.pdb';


GO
PRINT N'Creating [loc].[Alias]...';


GO
CREATE TYPE [loc].[Alias]
    FROM NVARCHAR (40) NOT NULL;


GO
PRINT N'Creating [loc].[RefNbr]...';


GO
CREATE TYPE [loc].[RefNbr]
    FROM VARCHAR (40) NOT NULL;


GO
PRINT N'Creating [loc].[SkuNbr]...';


GO
CREATE TYPE [loc].[SkuNbr]
    FROM VARCHAR (40) NOT NULL;


GO
PRINT N'Creating [dbo].[amt]...';


GO
CREATE TYPE [dbo].[amt]
    FROM BIGINT NOT NULL;


GO
PRINT N'Creating [dbo].[DT]...';


GO
CREATE TYPE [dbo].[DT]
    FROM DATETIME2 (2) NOT NULL;


GO
PRINT N'Creating [dbo].[E32]...';


GO
CREATE TYPE [dbo].[E32]
    FROM INT NOT NULL;


GO
PRINT N'Creating [dbo].[E64]...';


GO
CREATE TYPE [dbo].[E64]
    FROM BIGINT NOT NULL;


GO
PRINT N'Creating [dbo].[E8]...';


GO
CREATE TYPE [dbo].[E8]
    FROM TINYINT NOT NULL;


GO
PRINT N'Creating [dbo].[I16]...';


GO
CREATE TYPE [dbo].[I16]
    FROM SMALLINT NOT NULL;


GO
PRINT N'Creating [dbo].[I32]...';


GO
CREATE TYPE [dbo].[I32]
    FROM INT NOT NULL;


GO
PRINT N'Creating [dbo].[I64]...';


GO
CREATE TYPE [dbo].[I64]
    FROM BIGINT NOT NULL;


GO
PRINT N'Creating [dbo].[info]...';


GO
CREATE TYPE [dbo].[info]
    FROM NVARCHAR (4000) NOT NULL;


GO
PRINT N'Creating [dbo].[json]...';


GO
CREATE TYPE [dbo].[json]
    FROM NVARCHAR (MAX) NOT NULL;


GO
PRINT N'Creating [dbo].[msg]...';


GO
CREATE TYPE [dbo].[msg]
    FROM NVARCHAR (2048) NOT NULL;


GO
PRINT N'Creating [dbo].[nax]...';


GO
CREATE TYPE [dbo].[nax]
    FROM NVARCHAR (MAX) NOT NULL;


GO
PRINT N'Creating [dbo].[RC]...';


GO
CREATE TYPE [dbo].[RC]
    FROM INT NOT NULL;


GO
PRINT N'Creating [dbo].[spr]...';


GO
CREATE TYPE [dbo].[spr]
    FROM NVARCHAR (255) NOT NULL;


GO
PRINT N'Creating [dbo].[tvp]...';


GO
CREATE TYPE [dbo].[tvp]
    FROM NVARCHAR (MAX) NOT NULL;


GO
PRINT N'Creating [dbo].[vax]...';


GO
CREATE TYPE [dbo].[vax]
    FROM VARCHAR (MAX) NOT NULL;


GO
PRINT N'Creating [core].[TransitionSpec]...';


GO
CREATE TYPE [core].[TransitionSpec] AS TABLE (
    [Seq]       INT          IDENTITY (1, 1) NOT NULL,
    [MatterID]  [dbo].[I64]  NOT NULL,
    [ActionID]  [dbo].[I32]  NOT NULL,
    [OnStateID] [dbo].[I32]  NOT NULL,
    [ToStateID] [dbo].[I32]  NOT NULL,
    [ToStage]   [dbo].[E32]  NOT NULL,
    [Source]    [dbo].[E8]   NOT NULL,
    [OutboundQ] VARCHAR (20) NOT NULL,
    [TodoHours] TINYINT      NOT NULL,
    PRIMARY KEY CLUSTERED ([Seq] ASC));


GO
PRINT N'Creating [tms].[PicResult]...';


GO
CREATE TYPE [tms].[PicResult] AS TABLE (
    [SeqNbr]    INT      NOT NULL PRIMARY KEY CLUSTERED ([SeqNbr] ASC),
    [SvcClass]  TINYINT  NOT NULL,
    [SvcCode]   CHAR (3) NOT NULL,
    [MailerID]  CHAR (9) NOT NULL,
    [MailerSeq] INT      NOT NULL,
    [POA]       CHAR (3) NOT NULL,
    [OnZip3]    CHAR (3) NOT NULL);


GO
PRINT N'Creating [tms].[PicSpec]...';


GO
CREATE TYPE [tms].[PicSpec] AS TABLE (
    [SeqNbr]     INT          IDENTITY (1, 1) NOT NULL PRIMARY KEY CLUSTERED ([SeqNbr] ASC),
    [MeasuredWt] REAL         NOT NULL,
    [SvcType]    INT          NOT NULL,
    [Zip3]       CHAR (3)     NOT NULL,
    [Plus2]      CHAR (2)     NOT NULL,
    [RefNbr]     VARCHAR (20) DEFAULT ('') NOT NULL);


GO
PRINT N'Creating [dbo].[Cells]...';


GO
CREATE TYPE [dbo].[Cells] AS TABLE (
    [Col] [dbo].[I32]    NOT NULL,
    [Row] [dbo].[I64]    NOT NULL,
    [Val] NVARCHAR (MAX) NOT NULL,
    PRIMARY KEY CLUSTERED ([Col] ASC, [Row] ASC));


GO
PRINT N'Creating [dbo].[I32Array]...';


GO
CREATE TYPE [dbo].[I32Array] AS TABLE (
    [ID] [dbo].[I32] NOT NULL,
    PRIMARY KEY CLUSTERED ([ID] ASC));


GO
PRINT N'Creating [dbo].[I32AutoSeqs]...';


GO
CREATE TYPE [dbo].[I32AutoSeqs] AS TABLE (
    [ID]  [dbo].[I32] NOT NULL,
    [Seq] INT         IDENTITY (1, 1) NOT NULL,
    PRIMARY KEY CLUSTERED ([Seq] ASC));


GO
PRINT N'Creating [dbo].[I32PairAmts]...';


GO
CREATE TYPE [dbo].[I32PairAmts] AS TABLE (
    [LID] [dbo].[I32] NOT NULL,
    [RID] [dbo].[I32] NOT NULL,
    [Amt] [dbo].[amt] NOT NULL,
    PRIMARY KEY CLUSTERED ([LID] ASC, [RID] ASC, [Amt] ASC));


GO
PRINT N'Creating [dbo].[I32Pairs]...';


GO
CREATE TYPE [dbo].[I32Pairs] AS TABLE (
    [LID] [dbo].[I32] NOT NULL,
    [RID] [dbo].[I32] NOT NULL,
    PRIMARY KEY CLUSTERED ([LID] ASC, [RID] ASC));


GO
PRINT N'Creating [dbo].[I32Seqs]...';


GO
CREATE TYPE [dbo].[I32Seqs] AS TABLE (
    [ID]  [dbo].[I32] NOT NULL,
    [Seq] INT         NOT NULL,
    PRIMARY KEY CLUSTERED ([Seq] ASC));


GO
PRINT N'Creating [dbo].[I64Amts]...';


GO
CREATE TYPE [dbo].[I64Amts] AS TABLE (
    [ID]  [dbo].[I64] NOT NULL,
    [Amt] [dbo].[amt] NOT NULL,
    PRIMARY KEY CLUSTERED ([ID] ASC));


GO
PRINT N'Creating [dbo].[I64Array]...';


GO
CREATE TYPE [dbo].[I64Array] AS TABLE (
    [ID] [dbo].[I64] NOT NULL,
    PRIMARY KEY CLUSTERED ([ID] ASC));


GO
PRINT N'Creating [dbo].[I64AutoSeqs]...';


GO
CREATE TYPE [dbo].[I64AutoSeqs] AS TABLE (
    [ID]  [dbo].[I64] NOT NULL,
    [Seq] INT         IDENTITY (1, 1) NOT NULL,
    PRIMARY KEY CLUSTERED ([Seq] ASC));


GO
PRINT N'Creating [dbo].[I64Enums]...';


GO
CREATE TYPE [dbo].[I64Enums] AS TABLE (
    [ID]  [dbo].[I64] NOT NULL,
    [Val] [dbo].[E32] NOT NULL,
    PRIMARY KEY CLUSTERED ([ID] ASC));


GO
PRINT N'Creating [dbo].[I64Infos]...';


GO
CREATE TYPE [dbo].[I64Infos] AS TABLE (
    [ID]   [dbo].[I64]     NOT NULL,
    [Info] NVARCHAR (4000) NOT NULL,
    [Type] [dbo].[E32]     DEFAULT (0) NOT NULL,
    PRIMARY KEY CLUSTERED ([ID] ASC));


GO
PRINT N'Creating [dbo].[I64Msgs]...';


GO
CREATE TYPE [dbo].[I64Msgs] AS TABLE (
    [ID]   [dbo].[I64]     NOT NULL,
    [Msg]  NVARCHAR (2048) NOT NULL,
    [Type] [dbo].[E32]     DEFAULT (0) NOT NULL,
    PRIMARY KEY CLUSTERED ([ID] ASC));


GO
PRINT N'Creating [dbo].[I64PairAmts]...';


GO
CREATE TYPE [dbo].[I64PairAmts] AS TABLE (
    [LID] [dbo].[I64] NOT NULL,
    [RID] [dbo].[I64] NOT NULL,
    [Amt] [dbo].[amt] NOT NULL,
    PRIMARY KEY CLUSTERED ([LID] ASC, [RID] ASC, [Amt] ASC));


GO
PRINT N'Creating [dbo].[I64Pairs]...';


GO
CREATE TYPE [dbo].[I64Pairs] AS TABLE (
    [LID] [dbo].[I64] NOT NULL,
    [RID] [dbo].[I64] NOT NULL,
    PRIMARY KEY CLUSTERED ([LID] ASC, [RID] ASC));


GO
PRINT N'Creating [dbo].[I64Refs]...';


GO
CREATE TYPE [dbo].[I64Refs] AS TABLE (
    [ID]   [dbo].[I64]  NOT NULL,
    [Ref]  VARCHAR (40) NOT NULL,
    [Type] [dbo].[E32]  DEFAULT (0) NOT NULL,
    PRIMARY KEY CLUSTERED ([ID] ASC));


GO
PRINT N'Creating [dbo].[I64Seqs]...';


GO
CREATE TYPE [dbo].[I64Seqs] AS TABLE (
    [ID]  [dbo].[I64] NOT NULL,
    [Seq] INT         NOT NULL,
    PRIMARY KEY CLUSTERED ([Seq] ASC));


GO
PRINT N'Creating [dbo].[I64Texts]...';


GO
CREATE TYPE [dbo].[I64Texts] AS TABLE (
    [ID]   [dbo].[I64]    NOT NULL,
    [Text] NVARCHAR (MAX) NOT NULL,
    PRIMARY KEY CLUSTERED ([ID] ASC));


GO
PRINT N'Creating [dbo].[I64TrioAmts]...';


GO
CREATE TYPE [dbo].[I64TrioAmts] AS TABLE (
    [LID] [dbo].[I64] NOT NULL,
    [MID] [dbo].[I64] NOT NULL,
    [RID] [dbo].[I64] NOT NULL,
    [Amt] [dbo].[amt] NOT NULL,
    PRIMARY KEY CLUSTERED ([LID] ASC, [MID] ASC, [RID] ASC, [Amt] ASC));


GO
PRINT N'Creating [dbo].[I64Trios]...';


GO
CREATE TYPE [dbo].[I64Trios] AS TABLE (
    [LID] [dbo].[I64] NOT NULL,
    [MID] [dbo].[I64] NOT NULL,
    [RID] [dbo].[I64] NOT NULL,
    PRIMARY KEY CLUSTERED ([LID] ASC, [MID] ASC, [RID] ASC));


GO
PRINT N'Creating [dbo].[PcsAutoSeqs]...';


GO
CREATE TYPE [dbo].[PcsAutoSeqs] AS TABLE (
    [Seq]   INT            IDENTITY (1, 1) NOT NULL,
    [Piece] NVARCHAR (MAX) NOT NULL,
    PRIMARY KEY CLUSTERED ([Seq] ASC));


GO
PRINT N'Creating [dbo].[PcsSeqs]...';


GO
CREATE TYPE [dbo].[PcsSeqs] AS TABLE (
    [Seq]   INT            NOT NULL,
    [Piece] NVARCHAR (MAX) NOT NULL,
    PRIMARY KEY CLUSTERED ([Seq] ASC));


GO
PRINT N'Creating [acct].[_Charge]...';


GO
CREATE TABLE [acct].[_Charge] (
    [ID]        [dbo].[I32]  NOT NULL,
    [Code]      VARCHAR (20) NOT NULL,
    [APCoa]     CHAR (9)     NOT NULL,
    [ARCoa]     CHAR (9)     NOT NULL,
    [VaultTag]  [dbo].[E8]   NOT NULL,
    [VaultType] [dbo].[E8]   NOT NULL,
    CONSTRAINT [PK_Charge] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [UK_Charge] UNIQUE NONCLUSTERED ([Code] ASC)
);


GO
PRINT N'Creating [acct].[_Commission]...';


GO
CREATE TABLE [acct].[_Commission] (
    [ContractID] [dbo].[I32] NOT NULL,
    [SalesRepID] [dbo].[I32] NOT NULL,
    [Percentage] REAL        NOT NULL,
    CONSTRAINT [PK_Commission] PRIMARY KEY CLUSTERED ([ContractID] ASC, [SalesRepID] ASC)
);


GO
PRINT N'Creating [acct].[_Commission].[IC_Commission_SalesRep]...';


GO
CREATE NONCLUSTERED INDEX [IC_Commission_SalesRep]
    ON [acct].[_Commission]([SalesRepID] ASC)
    INCLUDE([ContractID], [Percentage]);


GO
PRINT N'Creating [acct].[_Contract]...';


GO
CREATE TABLE [acct].[_Contract] (
    [ID]           [dbo].[I32] IDENTITY (10000, 5) NOT NULL,
    [TenantID]     [dbo].[I32] NOT NULL,
    [BizUnitID]    [dbo].[I32] NOT NULL,
    [SourceID]     [dbo].[E8]  NOT NULL,
    [BillingCycle] TINYINT     NOT NULL,
    [DutyTerms]    TINYINT     NOT NULL,
    [NonDutyTerms] TINYINT     NOT NULL,
    [EffectiveOn]  [dbo].[DT]  NOT NULL,
    [ExpiredOn]    [dbo].[DT]  NOT NULL,
    CONSTRAINT [PK_Contract] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [acct].[_Contract].[IC_Contract_SourcedTenant]...';


GO
CREATE NONCLUSTERED INDEX [IC_Contract_SourcedTenant]
    ON [acct].[_Contract]([TenantID] ASC, [SourceID] ASC, [EffectiveOn] ASC, [ExpiredOn] ASC)
    INCLUDE([BizUnitID], [BillingCycle], [DutyTerms], [NonDutyTerms]);


GO
PRINT N'Creating [acct].[_Currency]...';


GO
CREATE TABLE [acct].[_Currency] (
    [ID]   [dbo].[E8] NOT NULL,
    [Code] CHAR (3)   NOT NULL,
    CONSTRAINT [PK_Currency] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [UK_Currency] UNIQUE NONCLUSTERED ([Code] ASC)
);


GO
PRINT N'Creating [acct].[_CurrencyRate]...';


GO
CREATE TABLE [acct].[_CurrencyRate] (
    [FmCurrencyID]   [dbo].[E8] NOT NULL,
    [ToCurrencyID]   [dbo].[E8] NOT NULL,
    [EffectiveOn]    [dbo].[DT] NOT NULL,
    [ForPayment]     REAL       NOT NULL,
    [ForDeclaration] REAL       NOT NULL,
    CONSTRAINT [PK_CurrencyRate] PRIMARY KEY CLUSTERED ([FmCurrencyID] ASC, [ToCurrencyID] ASC, [EffectiveOn] ASC)
);


GO
PRINT N'Creating [acct].[_Invoice]...';


GO
CREATE TABLE [acct].[_Invoice] (
    [ID]         [dbo].[I64] IDENTITY (10000, 1) NOT NULL,
    [PartyID]    [dbo].[I32] NOT NULL,
    [ContractID] [dbo].[I32] NOT NULL,
    [VaultTag]   [dbo].[E8]  NOT NULL,
    [LedgerSide] [dbo].[E8]  NOT NULL,
    [CurrencyID] [dbo].[E8]  NOT NULL,
    [DueBalance] [dbo].[amt] NOT NULL,
    [InvoiceAmt] [dbo].[amt] NOT NULL,
    [InvoicedOn] [dbo].[DT]  NOT NULL,
    [IssueDate]  [dbo].[DT]  NOT NULL,
    [DueDate]    [dbo].[DT]  NOT NULL,
    CONSTRAINT [PK_Invoice] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [acct].[_Ledger]...';


GO
CREATE TABLE [acct].[_Ledger] (
    [ID]         [dbo].[I64] IDENTITY (1000, 1) NOT NULL,
    [PartyID]    [dbo].[I32] NOT NULL,
    [MatterID]   [dbo].[I64] NOT NULL,
    [ChargeID]   [dbo].[I32] NOT NULL,
    [ChargeAmt]  [dbo].[amt] NOT NULL,
    [CurrencyID] [dbo].[E8]  NOT NULL,
    [LedgerSide] [dbo].[E8]  NOT NULL,
    [TalliedOn]  [dbo].[DT]  NOT NULL,
    [InvoiceID]  [dbo].[I64] NOT NULL,
    CONSTRAINT [PK_Ledger] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [acct].[_Ledger].[IC_Ledger_Invoice]...';


GO
CREATE NONCLUSTERED INDEX [IC_Ledger_Invoice]
    ON [acct].[_Ledger]([InvoiceID] ASC)
    INCLUDE([TalliedOn], [CurrencyID], [LedgerSide], [MatterID], [PartyID], [ChargeID], [ChargeAmt]);


GO
PRINT N'Creating [acct].[_Ledger].[IC_Ledger_Matter]...';


GO
CREATE NONCLUSTERED INDEX [IC_Ledger_Matter]
    ON [acct].[_Ledger]([MatterID] ASC)
    INCLUDE([TalliedOn], [CurrencyID], [LedgerSide], [InvoiceID], [PartyID], [ChargeID], [ChargeAmt]);


GO
PRINT N'Creating [acct].[_Payment]...';


GO
CREATE TABLE [acct].[_Payment] (
    [ID]         [dbo].[I64] IDENTITY (10000, 1) NOT NULL,
    [XID]        [dbo].[I64] NOT NULL,
    [PartyID]    [dbo].[I32] NOT NULL,
    [LedgerSide] [dbo].[E8]  NOT NULL,
    [CurrencyID] [dbo].[E8]  NOT NULL,
    [PayMethod]  [dbo].[E8]  NOT NULL,
    [PaidOn]     [dbo].[DT]  NOT NULL,
    [PaidAmt]    [dbo].[amt] NOT NULL,
    CONSTRAINT [PK_Payment] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [acct].[_Terms]...';


GO
CREATE TABLE [acct].[_Terms] (
    [PartyID]  [dbo].[I32] NOT NULL,
    [VaultTag] [dbo].[E8]  NOT NULL,
    [NetDays]  TINYINT     NOT NULL,
    CONSTRAINT [PK_Terms] PRIMARY KEY CLUSTERED ([PartyID] ASC, [VaultTag] ASC)
);


GO
PRINT N'Creating [acct].[_Vault]...';


GO
CREATE TABLE [acct].[_Vault] (
    [ID]            [dbo].[I32] IDENTITY (10000, 1) NOT NULL,
    [PartyID]       [dbo].[I32] NOT NULL,
    [SourceID]      [dbo].[E8]  NOT NULL,
    [VaultType]     [dbo].[E8]  NOT NULL,
    [CurrencyID]    [dbo].[E8]  NOT NULL,
    [VaultBal]      [dbo].[amt] NOT NULL,
    [CreditLimit]   [dbo].[amt] NOT NULL,
    [InvoicedAmt]   [dbo].[amt] NOT NULL,
    [UninvoicedAmt] [dbo].[amt] NOT NULL,
    [TalliedOn]     [dbo].[DT]  NOT NULL,
    CONSTRAINT [PK_Vault] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [UK_Vault] UNIQUE NONCLUSTERED ([PartyID] ASC, [SourceID] ASC, [CurrencyID] ASC, [VaultType] ASC)
);


GO
PRINT N'Creating [acct].[_Vault].[IC_Vault_Party]...';


GO
CREATE NONCLUSTERED INDEX [IC_Vault_Party]
    ON [acct].[_Vault]([PartyID] ASC, [CurrencyID] ASC)
    INCLUDE([VaultBal], [TalliedOn], [VaultType], [CreditLimit], [InvoicedAmt], [UninvoicedAmt]);


GO
PRINT N'Creating [acct].[_VaultXact]...';


GO
CREATE TABLE [acct].[_VaultXact] (
    [ID]        [dbo].[I64] IDENTITY (1000, 1) NOT NULL,
    [PaymentID] [dbo].[I64] NOT NULL,
    [InvoiceID] [dbo].[I64] NOT NULL,
    [VaultID]   [dbo].[I32] NOT NULL,
    [PrevBal]   [dbo].[amt] NOT NULL,
    [XactAmt]   [dbo].[amt] NOT NULL,
    [XactedOn]  [dbo].[DT]  NOT NULL,
    CONSTRAINT [PK_VaultXact] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [UK_VaultXact] UNIQUE NONCLUSTERED ([PaymentID] ASC, [InvoiceID] ASC, [VaultID] ASC)
);


GO
PRINT N'Creating [acct].[_VaultXact].[IC_VaultXact_Vault]...';


GO
CREATE NONCLUSTERED INDEX [IC_VaultXact_Vault]
    ON [acct].[_VaultXact]([VaultID] ASC)
    INCLUDE([XactedOn], [XactAmt], [PrevBal], [PaymentID], [InvoiceID]);


GO
PRINT N'Creating [api].[_ActivitySubscription]...';


GO
CREATE TABLE [api].[_ActivitySubscription] (
    [MatterID] BIGINT       NOT NULL,
    [RefNbr]   VARCHAR (16) NOT NULL,
    PRIMARY KEY CLUSTERED ([MatterID] ASC)
);


GO
PRINT N'Creating [brkg].[_Broker]...';


GO
CREATE TABLE [brkg].[_Broker] (
    [ID]          [dbo].[I32]   NOT NULL,
    [FlatRate]    REAL          NOT NULL,
    [PercentRate] REAL          NOT NULL,
    [ApiToken]    VARCHAR (50)  NOT NULL,
    [ApiUrl]      VARCHAR (200) NOT NULL,
    [Alias]       [loc].[Alias] NOT NULL,
    CONSTRAINT [PK_Broker] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [brkg].[_ClrMethod]...';


GO
CREATE TABLE [brkg].[_ClrMethod] (
    [ID]            [dbo].[I32]  NOT NULL,
    [ClrMethodCode] VARCHAR (20) NOT NULL,
    [CountryCode]   CHAR (2)     NOT NULL,
    [CurrencyID]    [dbo].[E8]   NOT NULL,
    [IDRequirement] [dbo].[E8]   NOT NULL,
    [Exemption]     REAL         NOT NULL,
    CONSTRAINT [PK_ClrMethod] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [UK_ClrMethod] UNIQUE NONCLUSTERED ([ClrMethodCode] ASC)
);


GO
PRINT N'Creating [brkg].[_ClrMethodRate]...';


GO
CREATE TABLE [brkg].[_ClrMethodRate] (
    [TenantID]    [dbo].[I32] NOT NULL,
    [ClrMethodID] [dbo].[I32] NOT NULL,
    [FlatRate]    REAL        NOT NULL,
    [PercentRate] REAL        NOT NULL,
    CONSTRAINT [PK_ClrMethodRate] PRIMARY KEY CLUSTERED ([TenantID] ASC, [ClrMethodID] ASC)
);


GO
PRINT N'Creating [brkg].[_Commodity]...';


GO
CREATE TABLE [brkg].[_Commodity] (
    [ID]        [dbo].[I32]   NOT NULL,
    [PID]       [dbo].[I32]   NOT NULL,
    [DutyID]    [dbo].[I32]   NOT NULL,
    [Name]      NVARCHAR (50) NOT NULL,
    [Surcharge] REAL          NOT NULL,
    CONSTRAINT [PK_Commodity] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [brkg].[_Commodity].[IC_Commodity_PID]...';


GO
CREATE NONCLUSTERED INDEX [IC_Commodity_PID]
    ON [brkg].[_Commodity]([PID] ASC)
    INCLUDE([DutyID], [Name], [Surcharge]);


GO
PRINT N'Creating [brkg].[_Duty]...';


GO
CREATE TABLE [brkg].[_Duty] (
    [ID]           [dbo].[I32]  IDENTITY (10000, 1) NOT NULL,
    [CountryCode]  CHAR (2)     NOT NULL,
    [DutyCode]     VARCHAR (15) NOT NULL,
    [DutyRate]     REAL         NOT NULL,
    [CustomsValue] REAL         NOT NULL,
    [CommodityUoM] INT          NOT NULL,
    CONSTRAINT [PK_Duty] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [UK_Duty] UNIQUE NONCLUSTERED ([CountryCode] ASC, [DutyCode] ASC)
);


GO
PRINT N'Creating [core].[_Action]...';


GO
CREATE TABLE [core].[_Action] (
    [ID]          [dbo].[I32]  NOT NULL,
    [LoopEntryID] [dbo].[I32]  NOT NULL,
    [Name]        VARCHAR (30) NOT NULL,
    CONSTRAINT [PK_Action] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [core].[_Activity]...';


GO
CREATE TABLE [core].[_Activity] (
    [ID]        [dbo].[I64] IDENTITY (1, 1) NOT NULL,
    [MatterID]  [dbo].[I64] NOT NULL,
    [StateID]   [dbo].[I32] NOT NULL,
    [ActionID]  [dbo].[I32] NOT NULL,
    [UserID]    [dbo].[I32] NOT NULL,
    [TalliedOn] [dbo].[DT]  NOT NULL,
    CONSTRAINT [PK_Activity] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [core].[_Activity].[IC_Activity_Track]...';


GO
CREATE NONCLUSTERED INDEX [IC_Activity_Track]
    ON [core].[_Activity]([MatterID] ASC, [StateID] ASC)
    INCLUDE([UserID], [TalliedOn]);


GO
PRINT N'Creating [core].[_AddOnSvc]...';


GO
CREATE TABLE [core].[_AddOnSvc] (
    [ID]         [dbo].[I64] IDENTITY (10000, 1) NOT NULL,
    [MatterID]   [dbo].[I64] NOT NULL,
    [OperatorID] [dbo].[I32] NOT NULL,
    [Type]       [dbo].[E8]  NOT NULL,
    [StartedOn]  [dbo].[DT]  NOT NULL,
    [EndedOn]    [dbo].[DT]  NOT NULL,
    CONSTRAINT [PK_AddOnSvc] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [core].[_AddOnSvc].[IC_AddOnSvc_Matter]...';


GO
CREATE NONCLUSTERED INDEX [IC_AddOnSvc_Matter]
    ON [core].[_AddOnSvc]([MatterID] ASC, [OperatorID] ASC)
    INCLUDE([Type], [StartedOn], [EndedOn]);


GO
PRINT N'Creating [core].[_Announcement]...';


GO
CREATE TABLE [core].[_Announcement] (
    [ID]          [dbo].[I32]   IDENTITY (1, 1) NOT NULL,
    [SourceID]    [dbo].[E8]    NOT NULL,
    [EffectiveOn] [dbo].[DT]    NOT NULL,
    [ExpiredOn]   [dbo].[DT]    NOT NULL,
    [Body]        VARCHAR (MAX) NOT NULL,
    CONSTRAINT [PK_Announcement] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [core].[_Announcement].[IC_Announcement_Source]...';


GO
CREATE NONCLUSTERED INDEX [IC_Announcement_Source]
    ON [core].[_Announcement]([SourceID] ASC, [EffectiveOn] ASC, [ExpiredOn] ASC)
    INCLUDE([Body]);


GO
PRINT N'Creating [core].[_Attachment]...';


GO
CREATE TABLE [core].[_Attachment] (
    [ID]         [dbo].[I32] IDENTITY (1, 1) NOT NULL,
    [RegID]      [dbo].[I32] NOT NULL,
    [RowID]      [dbo].[I64] NOT NULL,
    [AuxID]      [dbo].[E32] NOT NULL,
    [PostedOn]   [dbo].[DT]  NOT NULL,
    [PosterID]   [dbo].[I32] NOT NULL,
    [FileBankID] CHAR (33)   NOT NULL,
    CONSTRAINT [PK_Attachment] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [core].[_Attachment].[IC_Attachment]...';


GO
CREATE NONCLUSTERED INDEX [IC_Attachment]
    ON [core].[_Attachment]([RegID] ASC, [RowID] ASC)
    INCLUDE([AuxID], [PostedOn], [PosterID], [FileBankID]);


GO
PRINT N'Creating [core].[_Challenge]...';


GO
CREATE TABLE [core].[_Challenge] (
    [MatterID]   [dbo].[I64] NOT NULL,
    [Type]       [dbo].[E8]  NOT NULL,
    [BoundStage] [dbo].[E32] NOT NULL,
    CONSTRAINT [PK_Challenge] PRIMARY KEY CLUSTERED ([MatterID] ASC, [Type] ASC)
);


GO
PRINT N'Creating [core].[_ChangeLog]...';


GO
CREATE TABLE [core].[_ChangeLog] (
    [RegID]     [dbo].[I32] NOT NULL,
    [RowID]     [dbo].[I64] NOT NULL,
    [ChangedOn] [dbo].[DT]  NOT NULL,
    [ChangedBy] [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_ChangeLog] PRIMARY KEY CLUSTERED ([RegID] ASC, [RowID] ASC, [ChangedOn] ASC)
);


GO
PRINT N'Creating [core].[_Concern]...';


GO
CREATE TABLE [core].[_Concern] (
    [MatterID] [dbo].[I64] NOT NULL,
    [Type]     [dbo].[E8]  NOT NULL,
    CONSTRAINT [PK_Concern] PRIMARY KEY CLUSTERED ([MatterID] ASC, [Type] ASC)
);


GO
PRINT N'Creating [core].[_Concern].[IX_Concern_Type]...';


GO
CREATE NONCLUSTERED INDEX [IX_Concern_Type]
    ON [core].[_Concern]([Type] ASC);


GO
PRINT N'Creating [core].[_Contact]...';


GO
CREATE TABLE [core].[_Contact] (
    [ID]          [dbo].[I32]   IDENTITY (10000, 1) NOT NULL,
    [PartyID]     [dbo].[I32]   NOT NULL,
    [Type]        [dbo].[E8]    NOT NULL,
    [IsDefault]   BIT           NOT NULL,
    [Name]        NVARCHAR (30) NOT NULL,
    [Phone]       VARCHAR (20)  NOT NULL,
    [Email]       VARCHAR (50)  NOT NULL,
    [Company]     NVARCHAR (50) NOT NULL,
    [Street1]     NVARCHAR (35) NOT NULL,
    [Street2]     NVARCHAR (35) NOT NULL,
    [Street3]     NVARCHAR (35) NOT NULL,
    [District]    NVARCHAR (20) NOT NULL,
    [City]        NVARCHAR (35) NOT NULL,
    [Province]    NVARCHAR (20) NOT NULL,
    [PostalCode]  VARCHAR (10)  NOT NULL,
    [CountryCode] CHAR (2)      NOT NULL,
    CONSTRAINT [PK_Contact] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [core].[_Contact].[IC_Contact_Party]...';


GO
CREATE NONCLUSTERED INDEX [IC_Contact_Party]
    ON [core].[_Contact]([PartyID] ASC, [Type] ASC)
    INCLUDE([Name], [Phone], [Email], [Company], [Street1], [Street2], [Street3], [District], [City], [Province], [PostalCode], [CountryCode]);


GO
PRINT N'Creating [core].[_LoopStack]...';


GO
CREATE TABLE [core].[_LoopStack] (
    [ID]       [dbo].[I32] IDENTITY (1, 1) NOT NULL,
    [MatterID] [dbo].[I64] NOT NULL,
    [ReturnID] [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_LoopStack] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [core].[_LoopStack].[IC_LoopStack]...';


GO
CREATE NONCLUSTERED INDEX [IC_LoopStack]
    ON [core].[_LoopStack]([MatterID] ASC)
    INCLUDE([ReturnID]);


GO
PRINT N'Creating [core].[_Matter]...';


GO
CREATE TABLE [core].[_Matter] (
    [ID]        [dbo].[I64] NOT NULL,
    [PID]       [dbo].[I64] NOT NULL,
    [AID]       [dbo].[I64] NOT NULL,
    [Type]      [dbo].[E8]  NOT NULL,
    [Source]    [dbo].[E8]  NOT NULL,
    [LockCnt]   TINYINT     NOT NULL,
    [Stage]     [dbo].[E32] NOT NULL,
    [StateID]   [dbo].[I32] NOT NULL,
    [StatedOn]  [dbo].[DT]  NOT NULL,
    [PostedOn]  [dbo].[DT]  NOT NULL,
    [PosterID]  [dbo].[I32] NOT NULL,
    [HandlerID] [dbo].[I32] NOT NULL,
    [RejoinID]  [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_Matter] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [core].[_Matter].[IC_Matter_PID]...';


GO
CREATE NONCLUSTERED INDEX [IC_Matter_PID]
    ON [core].[_Matter]([PID] ASC, [Stage] ASC)
    INCLUDE([StateID], [Type], [Source]);


GO
PRINT N'Creating [core].[_Matter].[IC_Matter_PostedOn]...';


GO
CREATE NONCLUSTERED INDEX [IC_Matter_PostedOn]
    ON [core].[_Matter]([PostedOn] ASC)
    INCLUDE([Source], [Type]);


GO
PRINT N'Creating [core].[_Matter].[IC_Matter_Poster]...';


GO
CREATE NONCLUSTERED INDEX [IC_Matter_Poster]
    ON [core].[_Matter]([PosterID] ASC)
    INCLUDE([PostedOn], [StatedOn], [Stage]);


GO
PRINT N'Creating [core].[_Matter].[IC_Matter_Stage]...';


GO
CREATE NONCLUSTERED INDEX [IC_Matter_Stage]
    ON [core].[_Matter]([Stage] ASC)
    INCLUDE([Source], [Type], [StateID], [LockCnt]);


GO
PRINT N'Creating [core].[_Matter].[IC_Matter_State]...';


GO
CREATE NONCLUSTERED INDEX [IC_Matter_State]
    ON [core].[_Matter]([StateID] ASC)
    INCLUDE([Source], [Type], [Stage], [LockCnt]);


GO
PRINT N'Creating [core].[_Message]...';


GO
CREATE TABLE [core].[_Message] (
    [RegID]    [dbo].[I32] NOT NULL,
    [RowID]    [dbo].[I64] NOT NULL,
    [AuxID]    [dbo].[E32] NOT NULL,
    [PostedOn] [dbo].[DT]  NOT NULL,
    [PosterID] [dbo].[I32] NOT NULL,
    [Body]     [dbo].[msg] NOT NULL,
    CONSTRAINT [PK_Message] PRIMARY KEY CLUSTERED ([RegID] ASC, [RowID] ASC, [PostedOn] ASC, [AuxID] ASC)
);


GO
PRINT N'Creating [core].[_OutboundQ]...';


GO
CREATE TABLE [core].[_OutboundQ] (
    [ToSource]  [dbo].[E8]  NOT NULL,
    [QueueType] [dbo].[E8]  NOT NULL,
    [QueuedOn]  [dbo].[DT]  NOT NULL,
    [MatterID]  [dbo].[I64] NOT NULL,
    [StateID]   [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_OutboundQ] PRIMARY KEY CLUSTERED ([ToSource] ASC, [QueueType] ASC, [QueuedOn] ASC, [MatterID] ASC)
);


GO
PRINT N'Creating [core].[_OutboundX]...';


GO
CREATE TABLE [core].[_OutboundX] (
    [ToSource]  [dbo].[E8]  NOT NULL,
    [QueueType] [dbo].[E8]  NOT NULL,
    [QueuedOn]  [dbo].[DT]  NOT NULL,
    [MatterID]  [dbo].[I64] NOT NULL,
    [StateID]   [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_OutboundX] PRIMARY KEY CLUSTERED ([QueuedOn] ASC, [ToSource] ASC, [QueueType] ASC, [MatterID] ASC)
);


GO
PRINT N'Creating [core].[_Party]...';


GO
CREATE TABLE [core].[_Party] (
    [ID]     [dbo].[I32]   NOT NULL,
    [PID]    [dbo].[I32]   NOT NULL,
    [AID]    [dbo].[I32]   NOT NULL,
    [Type]   [dbo].[E8]    NOT NULL,
    [Source] [dbo].[E8]    NOT NULL,
    [Alias]  [loc].[Alias] NOT NULL,
    CONSTRAINT [PK_Party] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [core].[_Party].[IC_Party_AID]...';


GO
CREATE NONCLUSTERED INDEX [IC_Party_AID]
    ON [core].[_Party]([AID] ASC)
    INCLUDE([Source], [Type], [PID], [Alias]);


GO
PRINT N'Creating [core].[_Party].[IC_Party_Alias]...';


GO
CREATE NONCLUSTERED INDEX [IC_Party_Alias]
    ON [core].[_Party]([Alias] ASC)
    INCLUDE([Source], [Type], [PID], [AID]);


GO
PRINT N'Creating [core].[_Party].[IC_Party_PID]...';


GO
CREATE NONCLUSTERED INDEX [IC_Party_PID]
    ON [core].[_Party]([PID] ASC)
    INCLUDE([Source], [Type], [AID], [Alias]);


GO
PRINT N'Creating [core].[_Party].[IC_Party_SRC]...';


GO
CREATE NONCLUSTERED INDEX [IC_Party_SRC]
    ON [core].[_Party]([Source] ASC)
    INCLUDE([Type], [PID], [AID], [Alias]);


GO
PRINT N'Creating [core].[_Port]...';


GO
CREATE TABLE [core].[_Port] (
    [Code]       CHAR (3)    NOT NULL,
    [Type]       [dbo].[E8]  NOT NULL,
    [Country]    CHAR (2)    NOT NULL,
    [UtcOffset]  SMALLINT    NOT NULL,
    [UtcPlaceID] [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_Port] PRIMARY KEY CLUSTERED ([Code] ASC)
);


GO
PRINT N'Creating [core].[_Port].[IC_Port_Country]...';


GO
CREATE NONCLUSTERED INDEX [IC_Port_Country]
    ON [core].[_Port]([Country] ASC)
    INCLUDE([Type], [Code], [UtcOffset], [UtcPlaceID]);


GO
PRINT N'Creating [core].[_QueueType]...';


GO
CREATE TABLE [core].[_QueueType] (
    [ID]   [dbo].[E8]   NOT NULL,
    [Name] VARCHAR (30) NOT NULL,
    CONSTRAINT [PK_QueueType] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [core].[_RefInfo]...';


GO
CREATE TABLE [core].[_RefInfo] (
    [MatterID] [dbo].[I64]    NOT NULL,
    [Type]     [dbo].[E8]     NOT NULL,
    [Info]     NVARCHAR (MAX) NOT NULL,
    CONSTRAINT [PK_RefInfo] PRIMARY KEY CLUSTERED ([MatterID] ASC, [Type] ASC)
);


GO
PRINT N'Creating [core].[_RefNbr]...';


GO
CREATE TABLE [core].[_RefNbr] (
    [MatterID] [dbo].[I64]    NOT NULL,
    [Type]     [dbo].[E8]     NOT NULL,
    [Number]   [loc].[RefNbr] NOT NULL,
    CONSTRAINT [PK_RefNbr] PRIMARY KEY CLUSTERED ([MatterID] ASC, [Type] ASC)
);


GO
PRINT N'Creating [core].[_RefNbr].[IC_MatterNbr]...';


GO
CREATE NONCLUSTERED INDEX [IC_MatterNbr]
    ON [core].[_RefNbr]([Number] ASC)
    INCLUDE([Type], [MatterID]);


GO
PRINT N'Creating [core].[_RefParty]...';


GO
CREATE TABLE [core].[_RefParty] (
    [MatterID]  [dbo].[I64] NOT NULL,
    [PartyRole] [dbo].[E8]  NOT NULL,
    [PartyID]   [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_RefParty] PRIMARY KEY CLUSTERED ([MatterID] ASC, [PartyRole] ASC)
);


GO
PRINT N'Creating [core].[_RefParty].[IC_RefParty]...';


GO
CREATE NONCLUSTERED INDEX [IC_RefParty]
    ON [core].[_RefParty]([PartyID] ASC)
    INCLUDE([MatterID], [PartyRole]);


GO
PRINT N'Creating [core].[_RefStamp]...';


GO
CREATE TABLE [core].[_RefStamp] (
    [MatterID]   [dbo].[I64] NOT NULL,
    [StateID]    [dbo].[I32] NOT NULL,
    [UtcTime]    [dbo].[DT]  NOT NULL,
    [UtcOffset]  SMALLINT    NOT NULL,
    [UtcPlaceID] [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_RefStamp] PRIMARY KEY CLUSTERED ([MatterID] ASC, [StateID] ASC)
);


GO
PRINT N'Creating [core].[_Role]...';


GO
CREATE TABLE [core].[_Role] (
    [ID]   [dbo].[I32]  NOT NULL,
    [Name] VARCHAR (30) NOT NULL,
    CONSTRAINT [PK_Role] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [core].[_Setting]...';


GO
CREATE TABLE [core].[_Setting] (
    [Name]        VARCHAR (20)   NOT NULL,
    [Value]       VARCHAR (50)   NOT NULL,
    [Description] NVARCHAR (100) NOT NULL,
    PRIMARY KEY CLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating [core].[_Setting].[UX_Settings_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Settings_Name]
    ON [core].[_Setting]([Name] ASC);


GO
PRINT N'Creating [core].[_Source]...';


GO
CREATE TABLE [core].[_Source] (
    [ID]   [dbo].[E8]   NOT NULL,
    [Name] VARCHAR (30) NOT NULL,
    CONSTRAINT [PK_Source] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [core].[_State]...';


GO
CREATE TABLE [core].[_State] (
    [ID]         [dbo].[I32]  NOT NULL,
    [Stage]      [dbo].[E32]  NOT NULL,
    [IsInternal] BIT          NOT NULL,
    [Name]       VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_State] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [core].[_State].[IC_State_Stage]...';


GO
CREATE NONCLUSTERED INDEX [IC_State_Stage]
    ON [core].[_State]([Stage] ASC)
    INCLUDE([IsInternal], [Name]);


GO
PRINT N'Creating [core].[_Supplement]...';


GO
CREATE TABLE [core].[_Supplement] (
    [RegID]      [dbo].[I32] NOT NULL,
    [RowID]      [dbo].[I64] NOT NULL,
    [Supplement] [dbo].[nax] NOT NULL,
    CONSTRAINT [PK_Supplement] PRIMARY KEY CLUSTERED ([RegID] ASC, [RowID] ASC)
);


GO
PRINT N'Creating [core].[_Tenant]...';


GO
CREATE TABLE [core].[_Tenant] (
    [ID]         [dbo].[I32]   NOT NULL,
    [SalesRepID] [dbo].[I32]   NOT NULL,
    [Source]     [dbo].[E8]    NOT NULL,
    [NoLogo]     BIT           NOT NULL,
    [Alias]      [loc].[Alias] NOT NULL,
    [UtcPlace]   [loc].[Alias] NOT NULL,
    [UtcOffset]  SMALLINT      NOT NULL,
    CONSTRAINT [PK_Tenant] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [UK_Tenant] UNIQUE NONCLUSTERED ([Source] ASC, [Alias] ASC)
);


GO
PRINT N'Creating [core].[_Todo]...';


GO
CREATE TABLE [core].[_Todo] (
    [MatterID] [dbo].[I64] NOT NULL,
    [RoleID]   [dbo].[I32] NOT NULL,
    [ActionID] [dbo].[I32] NOT NULL,
    [ToSource] [dbo].[E8]  NOT NULL,
    [DueOn]    [dbo].[DT]  NOT NULL,
    CONSTRAINT [PK_Todo] PRIMARY KEY CLUSTERED ([MatterID] ASC, [RoleID] ASC, [ActionID] ASC)
);


GO
PRINT N'Creating [core].[_Todo].[IC_Todo_RoledAction]...';


GO
CREATE NONCLUSTERED INDEX [IC_Todo_RoledAction]
    ON [core].[_Todo]([RoleID] ASC, [ActionID] ASC, [ToSource] ASC)
    INCLUDE([DueOn]);


GO
PRINT N'Creating [core].[_Transition]...';


GO
CREATE TABLE [core].[_Transition] (
    [ID]        [dbo].[I32]  NOT NULL,
    [OnStateID] [dbo].[I32]  NOT NULL,
    [RoleID]    [dbo].[I32]  NOT NULL,
    [ActionID]  [dbo].[I32]  NOT NULL,
    [ToStateID] [dbo].[I32]  NOT NULL,
    [OutboundQ] VARCHAR (20) NOT NULL,
    [TodoHours] TINYINT      NOT NULL,
    CONSTRAINT [PK_Transition] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [UK_Transition] UNIQUE NONCLUSTERED ([OnStateID] ASC, [RoleID] ASC, [ActionID] ASC)
);


GO
PRINT N'Creating [core].[_Transition].[IC_Transition]...';


GO
CREATE NONCLUSTERED INDEX [IC_Transition]
    ON [core].[_Transition]([OnStateID] ASC, [RoleID] ASC, [ActionID] ASC, [ToStateID] ASC)
    INCLUDE([OutboundQ], [TodoHours]);


GO
PRINT N'Creating [core].[_User]...';


GO
CREATE TABLE [core].[_User] (
    [ID]    [dbo].[I32]   NOT NULL,
    [RC]    [dbo].[RC]    NOT NULL,
    [Alias] [loc].[Alias] NOT NULL,
    CONSTRAINT [PK_User] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [core].[_UserRole]...';


GO
CREATE TABLE [core].[_UserRole] (
    [UserID] [dbo].[I32] NOT NULL,
    [RoleID] [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_UserRole] PRIMARY KEY CLUSTERED ([UserID] ASC, [RoleID] ASC),
    CONSTRAINT [UK_UserRole] UNIQUE NONCLUSTERED ([RoleID] ASC, [UserID] ASC)
);


GO
PRINT N'Creating [invt].[_Sku]...';


GO
CREATE TABLE [invt].[_Sku] (
    [ID]        [dbo].[I32]  IDENTITY (10000, 1) NOT NULL,
    [TenantID]  [dbo].[I32]  NOT NULL,
    [SkuNbr]    VARCHAR (40) NOT NULL,
    [FiledInfo] [dbo].[info] NOT NULL,
    CONSTRAINT [PK_Sku] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [UK_Sku] UNIQUE NONCLUSTERED ([TenantID] ASC, [SkuNbr] ASC)
);


GO
PRINT N'Creating [invt].[_Sku].[IC_Sku_Tenant]...';


GO
CREATE NONCLUSTERED INDEX [IC_Sku_Tenant]
    ON [invt].[_Sku]([TenantID] ASC)
    INCLUDE([SkuNbr]);


GO
PRINT N'Creating [invt].[_SkuBrokerage]...';


GO
CREATE TABLE [invt].[_SkuBrokerage] (
    [SkuID]       [dbo].[I32]  NOT NULL,
    [ClrMethodID] [dbo].[I32]  NOT NULL,
    [BrokerID]    [dbo].[I32]  NOT NULL,
    [DutyID]      [dbo].[I32]  NOT NULL,
    [Endorsement] [dbo].[info] NOT NULL,
    CONSTRAINT [PK_SkuBrokerage] PRIMARY KEY CLUSTERED ([SkuID] ASC, [ClrMethodID] ASC, [BrokerID] ASC)
);


GO
PRINT N'Creating [loc].[_Country]...';


GO
CREATE TABLE [loc].[_Country] (
    [Code]  CHAR (2) NOT NULL,
    [Code3] CHAR (3) NOT NULL,
    [CodeN] CHAR (3) NOT NULL,
    CONSTRAINT [PK_Country] PRIMARY KEY CLUSTERED ([Code] ASC)
);


GO
PRINT N'Creating [shpt].[_Appointment]...';


GO
CREATE TABLE [shpt].[_Appointment] (
    [ID]        [dbo].[I64] NOT NULL,
    [PickupOn]  [dbo].[DT]  NOT NULL,
    [EstWeight] REAL        NOT NULL,
    CONSTRAINT [PK_Appointment] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [shpt].[_Batch]...';


GO
CREATE TABLE [shpt].[_Batch] (
    [ID]        [dbo].[I64] IDENTITY (10000, 1) NOT NULL,
    [SiteID]    [dbo].[I32] NOT NULL,
    [BatchedOn] [dbo].[DT]  NOT NULL,
    [ErrorCnt]  INT         NOT NULL,
    CONSTRAINT [PK_Batch] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [shpt].[_Batch].[IC_Batch_Site]...';


GO
CREATE NONCLUSTERED INDEX [IC_Batch_Site]
    ON [shpt].[_Batch]([SiteID] ASC)
    INCLUDE([BatchedOn], [ErrorCnt]);


GO
PRINT N'Creating [shpt].[_Parcel]...';


GO
CREATE TABLE [shpt].[_Parcel] (
    [ID]          [dbo].[I64] NOT NULL,
    [BatchID]     [dbo].[I64] NOT NULL,
    [RouteID]     [dbo].[I32] NOT NULL,
    [RcvHubID]    [dbo].[I32] NOT NULL,
    [LastMilerID] [dbo].[I32] NOT NULL,
    [ContractID]  [dbo].[I32] NOT NULL,
    [SvcType]     [dbo].[I32] NOT NULL,
    [SvcZone]     [dbo].[E8]  NOT NULL,
    [SvcClass]    [dbo].[E8]  NOT NULL,
    [ZoneCode]    CHAR (5)    NOT NULL,
    [POA]         CHAR (3)    NOT NULL,
    [DeclaredWt]  REAL        NOT NULL,
    [Weight]      REAL        NOT NULL,
    [Length]      REAL        NOT NULL,
    [Width]       REAL        NOT NULL,
    [Height]      REAL        NOT NULL,
    CONSTRAINT [PK_Parcel] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [shpt].[_Parcel].[IC_Parcel_Batch]...';


GO
CREATE NONCLUSTERED INDEX [IC_Parcel_Batch]
    ON [shpt].[_Parcel]([BatchID] ASC)
    INCLUDE([SvcZone], [SvcClass], [Weight]);


GO
PRINT N'Creating [shpt].[_RackXact]...';


GO
CREATE TABLE [shpt].[_RackXact] (
    [ParcelID]   [dbo].[I64] NOT NULL,
    [RackID]     [dbo].[I32] NOT NULL,
    [OrderInID]  [dbo].[I32] NOT NULL,
    [OrderOutID] [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_RackXact] PRIMARY KEY CLUSTERED ([ParcelID] ASC, [RackID] ASC)
);


GO
PRINT N'Creating [shpt].[_RackXact].[IC_RackXact_Rack]...';


GO
CREATE NONCLUSTERED INDEX [IC_RackXact_Rack]
    ON [shpt].[_RackXact]([RackID] ASC)
    INCLUDE([OrderInID], [OrderOutID], [ParcelID]);


GO
PRINT N'Creating [shpt].[_Sack]...';


GO
CREATE TABLE [shpt].[_Sack] (
    [ID]          [dbo].[I64] NOT NULL,
    [BrokerID]    [dbo].[I32] NOT NULL,
    [ClrMethodID] [dbo].[I32] NOT NULL,
    [POA]         CHAR (3)    NOT NULL,
    [SackWt]      FLOAT (53)  NOT NULL,
    CONSTRAINT [PK_Sack] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [shpt].[_SackLoad]...';


GO
CREATE TABLE [shpt].[_SackLoad] (
    [ID]        [dbo].[I64] NOT NULL,
    [TruckerID] [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_SackLoad] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [shpt].[_SackMft]...';


GO
CREATE TABLE [shpt].[_SackMft] (
    [ID]        [dbo].[I64] NOT NULL,
    [BrokerID]  [dbo].[I32] NOT NULL,
    [POD]       CHAR (3)    NOT NULL,
    [POA]       CHAR (3)    NOT NULL,
    [MawbNbr]   CHAR (11)   NOT NULL,
    [FlightNbr] CHAR (8)    NOT NULL,
    CONSTRAINT [PK_SackMft] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [tms].[_Airline]...';


GO
CREATE TABLE [tms].[_Airline] (
    [ID]    [dbo].[I32]   NOT NULL,
    [Alias] [loc].[Alias] NOT NULL,
    CONSTRAINT [PK_Airline] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [UK_Airline_Alias] UNIQUE NONCLUSTERED ([Alias] ASC)
);


GO
PRINT N'Creating [tms].[_AreaSurcharge]...';


GO
CREATE TABLE [tms].[_AreaSurcharge] (
    [CourierID]     [dbo].[I32] NOT NULL,
    [ZoneCode]      CHAR (5)    NOT NULL,
    [AreaSurcharge] REAL        NOT NULL,
    CONSTRAINT [PK__AreaSurcharge] PRIMARY KEY CLUSTERED ([CourierID] ASC, [ZoneCode] ASC) ON [PRIMARY]
) ON [PRIMARY];


GO
PRINT N'Creating [tms].[_Courier]...';


GO
CREATE TABLE [tms].[_Courier] (
    [ID]    [dbo].[I32]   NOT NULL,
    [Code]  VARCHAR (20)  NOT NULL,
    [Alias] [loc].[Alias] NOT NULL,
    CONSTRAINT [PK_Courier] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [UK_Courier_Alias] UNIQUE NONCLUSTERED ([Alias] ASC)
);


GO
PRINT N'Creating [tms].[_CourierAlias]...';


GO
CREATE TABLE [tms].[_CourierAlias] (
    [Alias]     [loc].[Alias] NOT NULL,
    [CourierID] [dbo].[I32]   NOT NULL,
    CONSTRAINT [PK_CourierAlias] PRIMARY KEY CLUSTERED ([Alias] ASC)
);


GO
PRINT N'Creating [tms].[_CourierNbrPool]...';


GO
CREATE TABLE [tms].[_CourierNbrPool] (
    [CourierID]   [dbo].[I32]    NOT NULL,
    [TrackingNbr] [loc].[RefNbr] NOT NULL,
    CONSTRAINT [PK_CourierNbrPool] PRIMARY KEY CLUSTERED ([CourierID] ASC, [TrackingNbr] ASC)
);


GO
PRINT N'Creating [tms].[_Flight]...';


GO
CREATE TABLE [tms].[_Flight] (
    [ID]        [dbo].[I64]  NOT NULL,
    [POD]       CHAR (3)     NOT NULL,
    [ETD]       [dbo].[DT]   NOT NULL,
    [POA]       CHAR (3)     NOT NULL,
    [ETA]       [dbo].[DT]   NOT NULL,
    [FlightNbr] VARCHAR (30) NOT NULL,
    [AirlineID] [dbo].[I32]  NOT NULL,
    CONSTRAINT [PK_Flight] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [tms].[_Route]...';


GO
CREATE TABLE [tms].[_Route] (
    [ID]          [dbo].[I32]  NOT NULL,
    [BrokerID]    [dbo].[I32]  NOT NULL,
    [CourierID]   [dbo].[I32]  NOT NULL,
    [ClrMethodID] [dbo].[I32]  NOT NULL,
    [CmdyRootID]  [dbo].[I32]  NOT NULL,
    [MaxWeight]   REAL         NOT NULL,
    [MaxSkuCnt]   TINYINT      NOT NULL,
    [MftGroup]    VARCHAR (10) NOT NULL,
    [RouteCode]   VARCHAR (20) NOT NULL,
    CONSTRAINT [PK_Route] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [UK_Route] UNIQUE NONCLUSTERED ([RouteCode] ASC)
);


GO
PRINT N'Creating [tms].[_RouteBranch]...';


GO
CREATE TABLE [tms].[_RouteBranch] (
    [RouteID]   [dbo].[I32] NOT NULL,
    [ActionID]  [dbo].[I32] NOT NULL,
    [AltRoleID] [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_RouteBranch] PRIMARY KEY CLUSTERED ([RouteID] ASC, [ActionID] ASC)
);


GO
PRINT N'Creating [tms].[_SvcClass]...';


GO
CREATE TABLE [tms].[_SvcClass] (
    [ID]        [dbo].[E8]  NOT NULL,
    [ClassCode] CHAR (3)    NOT NULL,
    [ClassAbbr] CHAR (2)    NOT NULL,
    [CourierID] [dbo].[I32] NOT NULL,
    [MaxWeight] REAL        NOT NULL,
    CONSTRAINT [PK_SvcClass] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [tms].[_SvcContract]...';


GO
CREATE TABLE [tms].[_SvcContract] (
    [ContractID] [dbo].[I32] NOT NULL,
    [SvcType]    [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_SvcContract] PRIMARY KEY CLUSTERED ([ContractID] ASC, [SvcType] ASC)
);


GO
PRINT N'Creating [tms].[_SvcCost]...';


GO
CREATE TABLE [tms].[_SvcCost] (
    [SvcClass]  [dbo].[E8] NOT NULL,
    [SvcZone]   [dbo].[E8] NOT NULL,
    [SectionWt] REAL       NOT NULL,
    [SvcCost]   REAL       NOT NULL,
    CONSTRAINT [PK_SvcCost] PRIMARY KEY CLUSTERED ([SvcClass] ASC, [SvcZone] ASC, [SectionWt] ASC)
);


GO
PRINT N'Creating [tms].[_SvcFacility]...';


GO
CREATE TABLE [tms].[_SvcFacility] (
    [ID]             [dbo].[I32]   NOT NULL,
    [SourceID]       [dbo].[E8]    NOT NULL,
    [CourierID]      [dbo].[I32]   NOT NULL,
    [ImportZoneCode] CHAR (5)      NOT NULL,
    [POA]            CHAR (3)      NOT NULL,
    [MailerID]       CHAR (9)      NOT NULL,
    [FacilityInfo]   VARCHAR (100) NOT NULL,
    [ShprInfo]       VARCHAR (100) NOT NULL,
    [CneeInfo]       VARCHAR (100) NOT NULL,
    [ReturnInfo]     VARCHAR (100) NOT NULL,
    CONSTRAINT [PK_SvcFacility] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [tms].[_SvcFacility].[IC_SvcFacility_Vendor]...';


GO
CREATE NONCLUSTERED INDEX [IC_SvcFacility_Vendor]
    ON [tms].[_SvcFacility]([CourierID] ASC)
    INCLUDE([ImportZoneCode], [POA], [MailerID], [FacilityInfo], [SourceID], [ShprInfo], [CneeInfo], [ReturnInfo]);


GO
PRINT N'Creating [tms].[_SvcFactor]...';


GO
CREATE TABLE [tms].[_SvcFactor] (
    [SvcClass]           [dbo].[E8]  NOT NULL,
    [RcvHubID]           [dbo].[I32] NOT NULL,
    [OnZoneCode3]        CHAR (3)    NOT NULL,
    [ContractID]         [dbo].[I32] NOT NULL,
    [HandlingFeeOZ]      REAL        NOT NULL,
    [HandlingFeeLB]      REAL        NOT NULL,
    [FuelSurchargeRatio] REAL        NOT NULL,
    [Factor1]            REAL        NOT NULL,
    [Factor2]            REAL        NOT NULL,
    [Factor3]            REAL        NOT NULL,
    [Factor4]            REAL        NOT NULL,
    [Factor5]            REAL        NOT NULL,
    [Factor6]            REAL        NOT NULL,
    [Factor7]            REAL        NOT NULL,
    [Factor8]            REAL        NOT NULL,
    [Factor9]            REAL        NOT NULL,
    CONSTRAINT [PK_SvcFactor] PRIMARY KEY CLUSTERED ([SvcClass] ASC, [RcvHubID] ASC, [OnZoneCode3] ASC, [ContractID] ASC)
);


GO
PRINT N'Creating [tms].[_SvcFacZoneCode]...';


GO
CREATE TABLE [tms].[_SvcFacZoneCode] (
    [CourierID]  [dbo].[I32] NOT NULL,
    [ZoneCode]   CHAR (3)    NOT NULL,
    [FacilityID] [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_SvcFacZoneCode] PRIMARY KEY CLUSTERED ([CourierID] ASC, [ZoneCode] ASC, [FacilityID] ASC)
);


GO
PRINT N'Creating [tms].[_SvcRate]...';


GO
CREATE TABLE [tms].[_SvcRate] (
    [SvcType]   [dbo].[I32] NOT NULL,
    [RcvHubID]  [dbo].[I32] NOT NULL,
    [SvcClass]  [dbo].[E8]  NOT NULL,
    [SvcZone]   [dbo].[E8]  NOT NULL,
    [SectionWt] REAL        NOT NULL,
    [SvcRate]   REAL        NOT NULL,
    CONSTRAINT [PK_SvcRate] PRIMARY KEY CLUSTERED ([SvcType] ASC, [RcvHubID] ASC, [SectionWt] ASC)
);


GO
PRINT N'Creating [tms].[_SvcRoute]...';


GO
CREATE TABLE [tms].[_SvcRoute] (
    [SvcType]  [dbo].[I32] NOT NULL,
    [POA]      CHAR (3)    NOT NULL,
    [Priority] CHAR (1)    NOT NULL,
    [RouteID]  [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_SvcRoute] PRIMARY KEY CLUSTERED ([SvcType] ASC, [POA] ASC, [Priority] ASC)
);


GO
PRINT N'Creating [tms].[_SvcType]...';


GO
CREATE TABLE [tms].[_SvcType] (
    [ID]             [dbo].[I32]  NOT NULL,
    [TenantID]       [dbo].[I32]  NOT NULL,
    [CurrencyID]     [dbo].[E8]   NOT NULL,
    [DutyCurrencyID] [dbo].[E8]   NOT NULL,
    [FallbackPOA]    CHAR (3)     NOT NULL,
    [InitStateID]    [dbo].[I32]  NOT NULL,
    [InitQueue]      VARCHAR (20) NOT NULL,
    [ClrMethodID]    [dbo].[I32]  NOT NULL,
    [CmdyRootID]     [dbo].[I32]  NOT NULL,
    [UseFactor]      BIT          NOT NULL,
    [UsePreCheck]    BIT          NOT NULL,
    CONSTRAINT [PK_SvcType] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [tms].[_SvcType].[IC_SvcType_Tenant]...';


GO
CREATE NONCLUSTERED INDEX [IC_SvcType_Tenant]
    ON [tms].[_SvcType]([TenantID] ASC)
    INCLUDE([InitStateID], [ClrMethodID], [FallbackPOA]);


GO
PRINT N'Creating [tms].[_SvcZone]...';


GO
CREATE TABLE [tms].[_SvcZone] (
    [CourierID]   [dbo].[I32] NOT NULL,
    [OnZoneCode3] CHAR (3)    NOT NULL,
    [ToZoneCode3] CHAR (3)    NOT NULL,
    [Zone]        TINYINT     NOT NULL,
    CONSTRAINT [PK_SvcZone] PRIMARY KEY CLUSTERED ([CourierID] ASC, [OnZoneCode3] ASC, [ToZoneCode3] ASC)
);


GO
PRINT N'Creating [tms].[_SvcZoneCode]...';


GO
CREATE TABLE [tms].[_SvcZoneCode] (
    [CourierID] [dbo].[I32] NOT NULL,
    [ZoneCode3] CHAR (3)    NOT NULL,
    CONSTRAINT [PK__SvcZoneCode] PRIMARY KEY CLUSTERED ([CourierID] ASC, [ZoneCode3] ASC)
);


GO
PRINT N'Creating [tms].[_Trucker]...';


GO
CREATE TABLE [tms].[_Trucker] (
    [ID]    [dbo].[I32]   NOT NULL,
    [Alias] [loc].[Alias] NOT NULL,
    CONSTRAINT [PK_Trucker] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [UK_Trucker_Alias] UNIQUE NONCLUSTERED ([Alias] ASC)
);


GO
PRINT N'Creating [whse].[_Rack]...';


GO
CREATE TABLE [whse].[_Rack] (
    [ID]    [dbo].[I32]  IDENTITY (10000, 1) NOT NULL,
    [HubID] [dbo].[I32]  NOT NULL,
    [Code]  VARCHAR (20) NOT NULL,
    CONSTRAINT [PK_Rack] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [UK_Rack] UNIQUE NONCLUSTERED ([Code] ASC)
);


GO
PRINT N'Creating [whse].[_Rack].[IC_Rack_Hub]...';


GO
CREATE NONCLUSTERED INDEX [IC_Rack_Hub]
    ON [whse].[_Rack]([HubID] ASC)
    INCLUDE([Code]);


GO
PRINT N'Creating [whse].[_RackOrder]...';


GO
CREATE TABLE [whse].[_RackOrder] (
    [ID]          [dbo].[I32] IDENTITY (10000, 1) NOT NULL,
    [RackerID]    [dbo].[I32] NOT NULL,
    [OrderType]   [dbo].[E8]  NOT NULL,
    [CreatedOn]   [dbo].[DT]  NOT NULL,
    [CompletedOn] [dbo].[DT]  NOT NULL,
    CONSTRAINT [PK_RackOrder] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [whse].[_StockInOrder]...';


GO
CREATE TABLE [whse].[_StockInOrder] (
    [ID]          [dbo].[I64] NOT NULL,
    [RcvHubID]    [dbo].[I32] NOT NULL,
    [ContractID]  [dbo].[I32] NOT NULL,
    [TotalSkuQty] [dbo].[I32] NOT NULL,
    CONSTRAINT [PK_StockInOrder] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [whse].[_StorageRate]...';


GO
CREATE TABLE [whse].[_StorageRate] (
    [RcvHubID]           [dbo].[I32] NOT NULL,
    [TenantID]           [dbo].[I32] NOT NULL,
    [CurrencyID]         [dbo].[E8]  NOT NULL,
    [RcvSkuFee]          REAL        NOT NULL,
    [RcvBoxFee]          REAL        NOT NULL,
    [RcvPltFee]          REAL        NOT NULL,
    [OutPkgFee]          REAL        NOT NULL,
    [OverWeightFee]      REAL        NOT NULL,
    [ExcessItemsFee]     REAL        NOT NULL,
    [WeightLimit]        REAL        NOT NULL,
    [ItemsQtyLimit]      REAL        NOT NULL,
    [StorageCbmFee30Day] REAL        NOT NULL,
    [StorageCbmFee60Day] REAL        NOT NULL,
    [StorageCbmFeeOther] REAL        NOT NULL,
    CONSTRAINT [PK_StorageRate] PRIMARY KEY CLUSTERED ([RcvHubID] ASC, [TenantID] ASC)
);


GO
PRINT N'Creating [dbo].[_Calendar]...';


GO
CREATE TABLE [dbo].[_Calendar] (
    [Value]   DATE    NOT NULL,
    [Year]    INT     NOT NULL,
    [Quarter] TINYINT NOT NULL,
    [Month]   TINYINT NOT NULL,
    [Week]    TINYINT NOT NULL,
    [Day]     TINYINT NOT NULL,
    [Dow]     TINYINT NOT NULL,
    [YOffset] INT     NOT NULL,
    [QOffset] INT     NOT NULL,
    [MOffset] INT     NOT NULL,
    [WOffset] INT     NOT NULL,
    [DOffset] INT     NOT NULL,
    CONSTRAINT [PK_Calendar] PRIMARY KEY CLUSTERED ([Value] ASC),
    CONSTRAINT [UK_Calendar] UNIQUE NONCLUSTERED ([Year] ASC, [Month] ASC, [Day] ASC)
);


GO
PRINT N'Creating [dbo].[_Calendar].[IC_Calendar_DOffset]...';


GO
CREATE NONCLUSTERED INDEX [IC_Calendar_DOffset]
    ON [dbo].[_Calendar]([DOffset] ASC)
    INCLUDE([Year], [Month], [Day]);


GO
PRINT N'Creating [dbo].[_Calendar].[IC_Calendar_MOffset]...';


GO
CREATE NONCLUSTERED INDEX [IC_Calendar_MOffset]
    ON [dbo].[_Calendar]([MOffset] ASC)
    INCLUDE([Year], [Month]);


GO
PRINT N'Creating [dbo].[_Calendar].[IC_Calendar_QOffset]...';


GO
CREATE NONCLUSTERED INDEX [IC_Calendar_QOffset]
    ON [dbo].[_Calendar]([QOffset] ASC)
    INCLUDE([Year], [Quarter]);


GO
PRINT N'Creating [dbo].[_Calendar].[IC_Calendar_WOffset]...';


GO
CREATE NONCLUSTERED INDEX [IC_Calendar_WOffset]
    ON [dbo].[_Calendar]([WOffset] ASC)
    INCLUDE([Year], [Week]);


GO
PRINT N'Creating [dbo].[_Calendar].[IC_Calendar_YOffset]...';


GO
CREATE NONCLUSTERED INDEX [IC_Calendar_YOffset]
    ON [dbo].[_Calendar]([YOffset] ASC)
    INCLUDE([Year]);


GO
PRINT N'Creating [acct].[DF_Charge_APCoa]...';


GO
ALTER TABLE [acct].[_Charge]
    ADD CONSTRAINT [DF_Charge_APCoa] DEFAULT ('') FOR [APCoa];


GO
PRINT N'Creating [acct].[DF_Charge_ARCoa]...';


GO
ALTER TABLE [acct].[_Charge]
    ADD CONSTRAINT [DF_Charge_ARCoa] DEFAULT ('') FOR [ARCoa];


GO
PRINT N'Creating [acct].[DF_Charge_VaultTag]...';


GO
ALTER TABLE [acct].[_Charge]
    ADD CONSTRAINT [DF_Charge_VaultTag] DEFAULT (0) FOR [VaultTag];


GO
PRINT N'Creating [acct].[DF_Commission_Percentage]...';


GO
ALTER TABLE [acct].[_Commission]
    ADD CONSTRAINT [DF_Commission_Percentage] DEFAULT (0) FOR [Percentage];


GO
PRINT N'Creating [acct].[DF_Contract_BillingCycle]...';


GO
ALTER TABLE [acct].[_Contract]
    ADD CONSTRAINT [DF_Contract_BillingCycle] DEFAULT (7) FOR [BillingCycle];


GO
PRINT N'Creating [acct].[DF_Contract_BizUnitID]...';


GO
ALTER TABLE [acct].[_Contract]
    ADD CONSTRAINT [DF_Contract_BizUnitID] DEFAULT (0) FOR [BizUnitID];


GO
PRINT N'Creating [acct].[DF_Contract_DutyTerms]...';


GO
ALTER TABLE [acct].[_Contract]
    ADD CONSTRAINT [DF_Contract_DutyTerms] DEFAULT (0) FOR [DutyTerms];


GO
PRINT N'Creating [acct].[DF_Contract_NonDutyTerms]...';


GO
ALTER TABLE [acct].[_Contract]
    ADD CONSTRAINT [DF_Contract_NonDutyTerms] DEFAULT (0) FOR [NonDutyTerms];


GO
PRINT N'Creating [acct].[DF_Invoice_ContractID]...';


GO
ALTER TABLE [acct].[_Invoice]
    ADD CONSTRAINT [DF_Invoice_ContractID] DEFAULT (0) FOR [ContractID];


GO
PRINT N'Creating [acct].[DF_Invoice_DueBalance]...';


GO
ALTER TABLE [acct].[_Invoice]
    ADD CONSTRAINT [DF_Invoice_DueBalance] DEFAULT (0) FOR [DueBalance];


GO
PRINT N'Creating [acct].[DF_Invoice_DueDate]...';


GO
ALTER TABLE [acct].[_Invoice]
    ADD CONSTRAINT [DF_Invoice_DueDate] DEFAULT (getutcdate()) FOR [DueDate];


GO
PRINT N'Creating [acct].[DF_Invoice_InvoicedOn]...';


GO
ALTER TABLE [acct].[_Invoice]
    ADD CONSTRAINT [DF_Invoice_InvoicedOn] DEFAULT (getutcdate()) FOR [InvoicedOn];


GO
PRINT N'Creating [acct].[DF_Invoice_IssueDate]...';


GO
ALTER TABLE [acct].[_Invoice]
    ADD CONSTRAINT [DF_Invoice_IssueDate] DEFAULT (getutcdate()) FOR [IssueDate];


GO
PRINT N'Creating [acct].[DF_Invoice_VaultTag]...';


GO
ALTER TABLE [acct].[_Invoice]
    ADD CONSTRAINT [DF_Invoice_VaultTag] DEFAULT (0) FOR [VaultTag];


GO
PRINT N'Creating [acct].[DF_Ledger_InvoiceID]...';


GO
ALTER TABLE [acct].[_Ledger]
    ADD CONSTRAINT [DF_Ledger_InvoiceID] DEFAULT ((0)) FOR [InvoiceID];


GO
PRINT N'Creating [acct].[DF_Ledger_PartyID]...';


GO
ALTER TABLE [acct].[_Ledger]
    ADD CONSTRAINT [DF_Ledger_PartyID] DEFAULT ((0)) FOR [PartyID];


GO
PRINT N'Creating [acct].[DF_Ledger_TalliedOn]...';


GO
ALTER TABLE [acct].[_Ledger]
    ADD CONSTRAINT [DF_Ledger_TalliedOn] DEFAULT (getutcdate()) FOR [TalliedOn];


GO
PRINT N'Creating [acct].[DF_Payment_PaidOn]...';


GO
ALTER TABLE [acct].[_Payment]
    ADD CONSTRAINT [DF_Payment_PaidOn] DEFAULT (getutcdate()) FOR [PaidOn];


GO
PRINT N'Creating [acct].[DF_Payment_PayMethod]...';


GO
ALTER TABLE [acct].[_Payment]
    ADD CONSTRAINT [DF_Payment_PayMethod] DEFAULT ((0)) FOR [PayMethod];


GO
PRINT N'Creating [acct].[DF_Payment_XID]...';


GO
ALTER TABLE [acct].[_Payment]
    ADD CONSTRAINT [DF_Payment_XID] DEFAULT ((0)) FOR [XID];


GO
PRINT N'Creating [acct].[DF_Vault_CreditLimit]...';


GO
ALTER TABLE [acct].[_Vault]
    ADD CONSTRAINT [DF_Vault_CreditLimit] DEFAULT (0) FOR [CreditLimit];


GO
PRINT N'Creating [acct].[DF_Vault_InvoicedAmt]...';


GO
ALTER TABLE [acct].[_Vault]
    ADD CONSTRAINT [DF_Vault_InvoicedAmt] DEFAULT (0) FOR [InvoicedAmt];


GO
PRINT N'Creating [acct].[DF_Vault_SourceID]...';


GO
ALTER TABLE [acct].[_Vault]
    ADD CONSTRAINT [DF_Vault_SourceID] DEFAULT (0) FOR [SourceID];


GO
PRINT N'Creating [acct].[DF_Vault_TalliedOn]...';


GO
ALTER TABLE [acct].[_Vault]
    ADD CONSTRAINT [DF_Vault_TalliedOn] DEFAULT (getutcdate()) FOR [TalliedOn];


GO
PRINT N'Creating [acct].[DF_Vault_UninvoicedAmt]...';


GO
ALTER TABLE [acct].[_Vault]
    ADD CONSTRAINT [DF_Vault_UninvoicedAmt] DEFAULT (0) FOR [UninvoicedAmt];


GO
PRINT N'Creating [acct].[DF_VaultXact_InvoiceID]...';


GO
ALTER TABLE [acct].[_VaultXact]
    ADD CONSTRAINT [DF_VaultXact_InvoiceID] DEFAULT ((0)) FOR [InvoiceID];


GO
PRINT N'Creating [acct].[DF_VaultXact_PaymentID]...';


GO
ALTER TABLE [acct].[_VaultXact]
    ADD CONSTRAINT [DF_VaultXact_PaymentID] DEFAULT ((0)) FOR [PaymentID];


GO
PRINT N'Creating [acct].[DF_VaultXact_XactedOn]...';


GO
ALTER TABLE [acct].[_VaultXact]
    ADD CONSTRAINT [DF_VaultXact_XactedOn] DEFAULT (getutcdate()) FOR [XactedOn];


GO
PRINT N'Creating [brkg].[DF_Broker_ApiToken]...';


GO
ALTER TABLE [brkg].[_Broker]
    ADD CONSTRAINT [DF_Broker_ApiToken] DEFAULT ('') FOR [ApiToken];


GO
PRINT N'Creating [brkg].[DF_Broker_ApiUrl]...';


GO
ALTER TABLE [brkg].[_Broker]
    ADD CONSTRAINT [DF_Broker_ApiUrl] DEFAULT ('') FOR [ApiUrl];


GO
PRINT N'Creating [brkg].[DF_Broker_FlatRate]...';


GO
ALTER TABLE [brkg].[_Broker]
    ADD CONSTRAINT [DF_Broker_FlatRate] DEFAULT (0) FOR [FlatRate];


GO
PRINT N'Creating [brkg].[DF_Broker_PercentRate]...';


GO
ALTER TABLE [brkg].[_Broker]
    ADD CONSTRAINT [DF_Broker_PercentRate] DEFAULT (0) FOR [PercentRate];


GO
PRINT N'Creating [brkg].[DF_ClrMethod_Exemption]...';


GO
ALTER TABLE [brkg].[_ClrMethod]
    ADD CONSTRAINT [DF_ClrMethod_Exemption] DEFAULT (0) FOR [Exemption];


GO
PRINT N'Creating [brkg].[DF_ClrMethod_IDRequirement]...';


GO
ALTER TABLE [brkg].[_ClrMethod]
    ADD CONSTRAINT [DF_ClrMethod_IDRequirement] DEFAULT (0) FOR [IDRequirement];


GO
PRINT N'Creating [brkg].[DF_ClrMethod_FlatRate]...';


GO
ALTER TABLE [brkg].[_ClrMethodRate]
    ADD CONSTRAINT [DF_ClrMethod_FlatRate] DEFAULT (0) FOR [FlatRate];


GO
PRINT N'Creating [brkg].[DF_ClrMethod_PercentRate]...';


GO
ALTER TABLE [brkg].[_ClrMethodRate]
    ADD CONSTRAINT [DF_ClrMethod_PercentRate] DEFAULT (0) FOR [PercentRate];


GO
PRINT N'Creating [brkg].[DF_Commodity_Surcharge]...';


GO
ALTER TABLE [brkg].[_Commodity]
    ADD CONSTRAINT [DF_Commodity_Surcharge] DEFAULT (0) FOR [Surcharge];


GO
PRINT N'Creating [brkg].[DF_Duty_CommodityUoM]...';


GO
ALTER TABLE [brkg].[_Duty]
    ADD CONSTRAINT [DF_Duty_CommodityUoM] DEFAULT (0) FOR [CommodityUoM];


GO
PRINT N'Creating [brkg].[DF_Duty_CustomsValue]...';


GO
ALTER TABLE [brkg].[_Duty]
    ADD CONSTRAINT [DF_Duty_CustomsValue] DEFAULT (0) FOR [CustomsValue];


GO
PRINT N'Creating [core].[DF_Action_LoopEntryID]...';


GO
ALTER TABLE [core].[_Action]
    ADD CONSTRAINT [DF_Action_LoopEntryID] DEFAULT (0) FOR [LoopEntryID];


GO
PRINT N'Creating [core].[DF_Activity_ActionID]...';


GO
ALTER TABLE [core].[_Activity]
    ADD CONSTRAINT [DF_Activity_ActionID] DEFAULT (0) FOR [ActionID];


GO
PRINT N'Creating [core].[DF_Activity_TalliedOn]...';


GO
ALTER TABLE [core].[_Activity]
    ADD CONSTRAINT [DF_Activity_TalliedOn] DEFAULT (getutcdate()) FOR [TalliedOn];


GO
PRINT N'Creating [core].[DF_Activity_UserID]...';


GO
ALTER TABLE [core].[_Activity]
    ADD CONSTRAINT [DF_Activity_UserID] DEFAULT (0) FOR [UserID];


GO
PRINT N'Creating [core].[DF_AddOnSvc_OperatorID]...';


GO
ALTER TABLE [core].[_AddOnSvc]
    ADD CONSTRAINT [DF_AddOnSvc_OperatorID] DEFAULT (0) FOR [OperatorID];


GO
PRINT N'Creating [core].[DF_Attachment_AuxID]...';


GO
ALTER TABLE [core].[_Attachment]
    ADD CONSTRAINT [DF_Attachment_AuxID] DEFAULT (0) FOR [AuxID];


GO
PRINT N'Creating [core].[DF_Attachment_PostedOn]...';


GO
ALTER TABLE [core].[_Attachment]
    ADD CONSTRAINT [DF_Attachment_PostedOn] DEFAULT (getutcdate()) FOR [PostedOn];


GO
PRINT N'Creating [core].[DF_Attachment_PosterID]...';


GO
ALTER TABLE [core].[_Attachment]
    ADD CONSTRAINT [DF_Attachment_PosterID] DEFAULT (0) FOR [PosterID];


GO
PRINT N'Creating [core].[DF_ChangedBy]...';


GO
ALTER TABLE [core].[_ChangeLog]
    ADD CONSTRAINT [DF_ChangedBy] DEFAULT (0) FOR [ChangedBy];


GO
PRINT N'Creating [core].[DF_ChangedOn]...';


GO
ALTER TABLE [core].[_ChangeLog]
    ADD CONSTRAINT [DF_ChangedOn] DEFAULT (getutcdate()) FOR [ChangedOn];


GO
PRINT N'Creating [core].[DF_Contact_District]...';


GO
ALTER TABLE [core].[_Contact]
    ADD CONSTRAINT [DF_Contact_District] DEFAULT (N'') FOR [District];


GO
PRINT N'Creating [core].[DF_Contact_IsDefault]...';


GO
ALTER TABLE [core].[_Contact]
    ADD CONSTRAINT [DF_Contact_IsDefault] DEFAULT (0) FOR [IsDefault];


GO
PRINT N'Creating [core].[DF_Contact_Street3]...';


GO
ALTER TABLE [core].[_Contact]
    ADD CONSTRAINT [DF_Contact_Street3] DEFAULT (N'') FOR [Street3];


GO
PRINT N'Creating [core].[DF_Matter_AID]...';


GO
ALTER TABLE [core].[_Matter]
    ADD CONSTRAINT [DF_Matter_AID] DEFAULT (0) FOR [AID];


GO
PRINT N'Creating [core].[DF_Matter_HandlerID]...';


GO
ALTER TABLE [core].[_Matter]
    ADD CONSTRAINT [DF_Matter_HandlerID] DEFAULT (0) FOR [HandlerID];


GO
PRINT N'Creating [core].[DF_Matter_LockCnt]...';


GO
ALTER TABLE [core].[_Matter]
    ADD CONSTRAINT [DF_Matter_LockCnt] DEFAULT (0) FOR [LockCnt];


GO
PRINT N'Creating [core].[DF_Matter_PID]...';


GO
ALTER TABLE [core].[_Matter]
    ADD CONSTRAINT [DF_Matter_PID] DEFAULT (0) FOR [PID];


GO
PRINT N'Creating [core].[DF_Matter_PostedOn]...';


GO
ALTER TABLE [core].[_Matter]
    ADD CONSTRAINT [DF_Matter_PostedOn] DEFAULT (getutcdate()) FOR [PostedOn];


GO
PRINT N'Creating [core].[DF_Matter_RejoinID]...';


GO
ALTER TABLE [core].[_Matter]
    ADD CONSTRAINT [DF_Matter_RejoinID] DEFAULT (0) FOR [RejoinID];


GO
PRINT N'Creating [core].[DF_Matter_StatedOn]...';


GO
ALTER TABLE [core].[_Matter]
    ADD CONSTRAINT [DF_Matter_StatedOn] DEFAULT (getutcdate()) FOR [StatedOn];


GO
PRINT N'Creating [core].[DF_Message_AuxID]...';


GO
ALTER TABLE [core].[_Message]
    ADD CONSTRAINT [DF_Message_AuxID] DEFAULT (0) FOR [AuxID];


GO
PRINT N'Creating [core].[DF_Message_Message]...';


GO
ALTER TABLE [core].[_Message]
    ADD CONSTRAINT [DF_Message_Message] DEFAULT (N'') FOR [Body];


GO
PRINT N'Creating [core].[DF_Message_PostedOn]...';


GO
ALTER TABLE [core].[_Message]
    ADD CONSTRAINT [DF_Message_PostedOn] DEFAULT (getutcdate()) FOR [PostedOn];


GO
PRINT N'Creating [core].[DF_Message_PosterID]...';


GO
ALTER TABLE [core].[_Message]
    ADD CONSTRAINT [DF_Message_PosterID] DEFAULT (0) FOR [PosterID];


GO
PRINT N'Creating [core].[DF_Outbound_QueuedOn]...';


GO
ALTER TABLE [core].[_OutboundQ]
    ADD CONSTRAINT [DF_Outbound_QueuedOn] DEFAULT (getutcdate()) FOR [QueuedOn];


GO
PRINT N'Creating [core].[DF_Party_AID]...';


GO
ALTER TABLE [core].[_Party]
    ADD CONSTRAINT [DF_Party_AID] DEFAULT ((0)) FOR [AID];


GO
PRINT N'Creating [core].[DF_Party_PID]...';


GO
ALTER TABLE [core].[_Party]
    ADD CONSTRAINT [DF_Party_PID] DEFAULT ((0)) FOR [PID];


GO
PRINT N'Creating [core].[DF_RefStamp_UtcPlaceID]...';


GO
ALTER TABLE [core].[_RefStamp]
    ADD CONSTRAINT [DF_RefStamp_UtcPlaceID] DEFAULT (0) FOR [UtcPlaceID];


GO
PRINT N'Creating [core].[DF_Role_Name]...';


GO
ALTER TABLE [core].[_Role]
    ADD CONSTRAINT [DF_Role_Name] DEFAULT ('') FOR [Name];


GO
PRINT N'Creating unnamed constraint on [core].[_Setting]...';


GO
ALTER TABLE [core].[_Setting]
    ADD DEFAULT '' FOR [Description];


GO
PRINT N'Creating [core].[DF_State_IsInternal]...';


GO
ALTER TABLE [core].[_State]
    ADD CONSTRAINT [DF_State_IsInternal] DEFAULT (0) FOR [IsInternal];


GO
PRINT N'Creating [core].[DF_Tenant_NoLogo]...';


GO
ALTER TABLE [core].[_Tenant]
    ADD CONSTRAINT [DF_Tenant_NoLogo] DEFAULT (0) FOR [NoLogo];


GO
PRINT N'Creating [core].[DF_Tenant_SalesRepID]...';


GO
ALTER TABLE [core].[_Tenant]
    ADD CONSTRAINT [DF_Tenant_SalesRepID] DEFAULT (0) FOR [SalesRepID];


GO
PRINT N'Creating [core].[DF_Tenant_Source]...';


GO
ALTER TABLE [core].[_Tenant]
    ADD CONSTRAINT [DF_Tenant_Source] DEFAULT (0) FOR [Source];


GO
PRINT N'Creating [core].[DF_Transition_OutboundQ]...';


GO
ALTER TABLE [core].[_Transition]
    ADD CONSTRAINT [DF_Transition_OutboundQ] DEFAULT ('') FOR [OutboundQ];


GO
PRINT N'Creating [core].[DF_Transition_TodoHours]...';


GO
ALTER TABLE [core].[_Transition]
    ADD CONSTRAINT [DF_Transition_TodoHours] DEFAULT (0) FOR [TodoHours];


GO
PRINT N'Creating [core].[DF_User_RC]...';


GO
ALTER TABLE [core].[_User]
    ADD CONSTRAINT [DF_User_RC] DEFAULT ((0)) FOR [RC];


GO
PRINT N'Creating unnamed constraint on [shpt].[_Appointment]...';


GO
ALTER TABLE [shpt].[_Appointment]
    ADD DEFAULT (0) FOR [EstWeight];


GO
PRINT N'Creating [shpt].[DF_Batch_BatchedOn]...';


GO
ALTER TABLE [shpt].[_Batch]
    ADD CONSTRAINT [DF_Batch_BatchedOn] DEFAULT (getutcdate()) FOR [BatchedOn];


GO
PRINT N'Creating [shpt].[DF_Batch_ErrorCnt]...';


GO
ALTER TABLE [shpt].[_Batch]
    ADD CONSTRAINT [DF_Batch_ErrorCnt] DEFAULT (0) FOR [ErrorCnt];


GO
PRINT N'Creating unnamed constraint on [shpt].[_Parcel]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD DEFAULT (N'') FOR [ZoneCode];


GO
PRINT N'Creating [shpt].[DF_Parcel_ContractID]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [DF_Parcel_ContractID] DEFAULT (0) FOR [ContractID];


GO
PRINT N'Creating [shpt].[DF_Parcel_DeclaredWt]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [DF_Parcel_DeclaredWt] DEFAULT (0) FOR [DeclaredWt];


GO
PRINT N'Creating [shpt].[DF_Parcel_Height]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [DF_Parcel_Height] DEFAULT (0) FOR [Height];


GO
PRINT N'Creating [shpt].[DF_Parcel_LastMilerID]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [DF_Parcel_LastMilerID] DEFAULT (0) FOR [LastMilerID];


GO
PRINT N'Creating [shpt].[DF_Parcel_Length]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [DF_Parcel_Length] DEFAULT (0) FOR [Length];


GO
PRINT N'Creating [shpt].[DF_Parcel_RcvHubID]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [DF_Parcel_RcvHubID] DEFAULT (0) FOR [RcvHubID];


GO
PRINT N'Creating [shpt].[DF_Parcel_SvcClass]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [DF_Parcel_SvcClass] DEFAULT (1) FOR [SvcClass];


GO
PRINT N'Creating [shpt].[DF_Parcel_SvcZone]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [DF_Parcel_SvcZone] DEFAULT (1) FOR [SvcZone];


GO
PRINT N'Creating [shpt].[DF_Parcel_Weight]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [DF_Parcel_Weight] DEFAULT (0) FOR [Weight];


GO
PRINT N'Creating [shpt].[DF_Parcel_Width]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [DF_Parcel_Width] DEFAULT (0) FOR [Width];


GO
PRINT N'Creating [shpt].[DF_RackXact_OrderInID]...';


GO
ALTER TABLE [shpt].[_RackXact]
    ADD CONSTRAINT [DF_RackXact_OrderInID] DEFAULT (0) FOR [OrderInID];


GO
PRINT N'Creating [shpt].[DF_RackXact_OrderOutID]...';


GO
ALTER TABLE [shpt].[_RackXact]
    ADD CONSTRAINT [DF_RackXact_OrderOutID] DEFAULT (0) FOR [OrderOutID];


GO
PRINT N'Creating [shpt].[DF_RackXact_RackID]...';


GO
ALTER TABLE [shpt].[_RackXact]
    ADD CONSTRAINT [DF_RackXact_RackID] DEFAULT (0) FOR [RackID];


GO
PRINT N'Creating [shpt].[DF_SackLoad_TruckerID]...';


GO
ALTER TABLE [shpt].[_SackLoad]
    ADD CONSTRAINT [DF_SackLoad_TruckerID] DEFAULT (0) FOR [TruckerID];


GO
PRINT N'Creating [shpt].[DF_SackMft_BrokerID]...';


GO
ALTER TABLE [shpt].[_SackMft]
    ADD CONSTRAINT [DF_SackMft_BrokerID] DEFAULT (0) FOR [BrokerID];


GO
PRINT N'Creating [tms].[DF_Flight_AirlineID]...';


GO
ALTER TABLE [tms].[_Flight]
    ADD CONSTRAINT [DF_Flight_AirlineID] DEFAULT (0) FOR [AirlineID];


GO
PRINT N'Creating [tms].[DF_Route_CmdyRootID]...';


GO
ALTER TABLE [tms].[_Route]
    ADD CONSTRAINT [DF_Route_CmdyRootID] DEFAULT (2) FOR [CmdyRootID];


GO
PRINT N'Creating [tms].[DF_Route_MaxSkuCnt]...';


GO
ALTER TABLE [tms].[_Route]
    ADD CONSTRAINT [DF_Route_MaxSkuCnt] DEFAULT (0) FOR [MaxSkuCnt];


GO
PRINT N'Creating [tms].[DF_Route_MaxWeight]...';


GO
ALTER TABLE [tms].[_Route]
    ADD CONSTRAINT [DF_Route_MaxWeight] DEFAULT (0) FOR [MaxWeight];


GO
PRINT N'Creating [tms].[DF_Route_MftGroup]...';


GO
ALTER TABLE [tms].[_Route]
    ADD CONSTRAINT [DF_Route_MftGroup] DEFAULT ('CC') FOR [MftGroup];


GO
PRINT N'Creating [tms].[DF_SvcClass_CourierID]...';


GO
ALTER TABLE [tms].[_SvcClass]
    ADD CONSTRAINT [DF_SvcClass_CourierID] DEFAULT (0) FOR [CourierID];


GO
PRINT N'Creating [tms].[DF_SvcClass_MaxWeight]...';


GO
ALTER TABLE [tms].[_SvcClass]
    ADD CONSTRAINT [DF_SvcClass_MaxWeight] DEFAULT (0) FOR [MaxWeight];


GO
PRINT N'Creating [tms].[DF_SvcFacility_SourceID]...';


GO
ALTER TABLE [tms].[_SvcFacility]
    ADD CONSTRAINT [DF_SvcFacility_SourceID] DEFAULT ((0)) FOR [SourceID];


GO
PRINT N'Creating unnamed constraint on [tms].[_SvcFactor]...';


GO
ALTER TABLE [tms].[_SvcFactor]
    ADD DEFAULT 0 FOR [HandlingFeeOZ];


GO
PRINT N'Creating unnamed constraint on [tms].[_SvcFactor]...';


GO
ALTER TABLE [tms].[_SvcFactor]
    ADD DEFAULT 0 FOR [HandlingFeeLB];


GO
PRINT N'Creating unnamed constraint on [tms].[_SvcFactor]...';


GO
ALTER TABLE [tms].[_SvcFactor]
    ADD DEFAULT 0 FOR [FuelSurchargeRatio];


GO
PRINT N'Creating unnamed constraint on [tms].[_SvcRate]...';


GO
ALTER TABLE [tms].[_SvcRate]
    ADD DEFAULT (0) FOR [SvcClass];


GO
PRINT N'Creating unnamed constraint on [tms].[_SvcRate]...';


GO
ALTER TABLE [tms].[_SvcRate]
    ADD DEFAULT (255) FOR [SvcZone];


GO
PRINT N'Creating [tms].[DF_SvcType_CmdyRootID]...';


GO
ALTER TABLE [tms].[_SvcType]
    ADD CONSTRAINT [DF_SvcType_CmdyRootID] DEFAULT (2) FOR [CmdyRootID];


GO
PRINT N'Creating [tms].[DF_SvcType_DutyCurrencyID]...';


GO
ALTER TABLE [tms].[_SvcType]
    ADD CONSTRAINT [DF_SvcType_DutyCurrencyID] DEFAULT (1) FOR [DutyCurrencyID];


GO
PRINT N'Creating [tms].[DF_SvcType_InitQueue]...';


GO
ALTER TABLE [tms].[_SvcType]
    ADD CONSTRAINT [DF_SvcType_InitQueue] DEFAULT ('') FOR [InitQueue];


GO
PRINT N'Creating [tms].[DF_SvcType_UseFactor]...';


GO
ALTER TABLE [tms].[_SvcType]
    ADD CONSTRAINT [DF_SvcType_UseFactor] DEFAULT (0) FOR [UseFactor];


GO
PRINT N'Creating [tms].[DF_SvcType_UsePreCheck]...';


GO
ALTER TABLE [tms].[_SvcType]
    ADD CONSTRAINT [DF_SvcType_UsePreCheck] DEFAULT (0) FOR [UsePreCheck];


GO
PRINT N'Creating [whse].[PK_RackOrder_CreatedOn]...';


GO
ALTER TABLE [whse].[_RackOrder]
    ADD CONSTRAINT [PK_RackOrder_CreatedOn] DEFAULT (getutcdate()) FOR [CreatedOn];


GO
PRINT N'Creating [whse].[DF_StockInOrder_ContractID]...';


GO
ALTER TABLE [whse].[_StockInOrder]
    ADD CONSTRAINT [DF_StockInOrder_ContractID] DEFAULT (0) FOR [ContractID];


GO
PRINT N'Creating [whse].[DF_StorageRate_ExcessItemsFee]...';


GO
ALTER TABLE [whse].[_StorageRate]
    ADD CONSTRAINT [DF_StorageRate_ExcessItemsFee] DEFAULT (0) FOR [ExcessItemsFee];


GO
PRINT N'Creating [whse].[DF_StorageRate_ItemsQtyLimit]...';


GO
ALTER TABLE [whse].[_StorageRate]
    ADD CONSTRAINT [DF_StorageRate_ItemsQtyLimit] DEFAULT (0) FOR [ItemsQtyLimit];


GO
PRINT N'Creating [whse].[DF_StorageRate_OutPkgFee]...';


GO
ALTER TABLE [whse].[_StorageRate]
    ADD CONSTRAINT [DF_StorageRate_OutPkgFee] DEFAULT (0) FOR [OutPkgFee];


GO
PRINT N'Creating [whse].[DF_StorageRate_OverWeightFee]...';


GO
ALTER TABLE [whse].[_StorageRate]
    ADD CONSTRAINT [DF_StorageRate_OverWeightFee] DEFAULT (0) FOR [OverWeightFee];


GO
PRINT N'Creating [whse].[DF_StorageRate_RcvBoxFee]...';


GO
ALTER TABLE [whse].[_StorageRate]
    ADD CONSTRAINT [DF_StorageRate_RcvBoxFee] DEFAULT (0) FOR [RcvBoxFee];


GO
PRINT N'Creating [whse].[DF_StorageRate_RcvPltFee]...';


GO
ALTER TABLE [whse].[_StorageRate]
    ADD CONSTRAINT [DF_StorageRate_RcvPltFee] DEFAULT (0) FOR [RcvPltFee];


GO
PRINT N'Creating [whse].[DF_StorageRate_StorageCbmFee30Day]...';


GO
ALTER TABLE [whse].[_StorageRate]
    ADD CONSTRAINT [DF_StorageRate_StorageCbmFee30Day] DEFAULT (0) FOR [StorageCbmFee30Day];


GO
PRINT N'Creating [whse].[DF_StorageRate_StorageCbmFee60Day]...';


GO
ALTER TABLE [whse].[_StorageRate]
    ADD CONSTRAINT [DF_StorageRate_StorageCbmFee60Day] DEFAULT (0) FOR [StorageCbmFee60Day];


GO
PRINT N'Creating [whse].[DF_StorageRate_StorageCbmFeeOther]...';


GO
ALTER TABLE [whse].[_StorageRate]
    ADD CONSTRAINT [DF_StorageRate_StorageCbmFeeOther] DEFAULT (0) FOR [StorageCbmFeeOther];


GO
PRINT N'Creating [whse].[DF_StorageRate_WeightLimit]...';


GO
ALTER TABLE [whse].[_StorageRate]
    ADD CONSTRAINT [DF_StorageRate_WeightLimit] DEFAULT (0) FOR [WeightLimit];


GO
PRINT N'Creating [core].[MatterSeq]...';


GO
CREATE SEQUENCE [core].[MatterSeq]
    AS BIGINT
    INCREMENT BY 1
    MINVALUE 10000
    NO CACHE;


GO
PRINT N'Creating [core].[PartySeq]...';


GO
CREATE SEQUENCE [core].[PartySeq]
    AS BIGINT
    INCREMENT BY 1
    MINVALUE 10000
    NO CACHE;


GO
PRINT N'Creating [tms].[JFK901607]...';


GO
CREATE SEQUENCE [tms].[JFK901607]
    AS INT
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 9999999
    CYCLE
    NO CACHE;


GO
PRINT N'Creating [tms].[JFK901608]...';


GO
CREATE SEQUENCE [tms].[JFK901608]
    AS INT
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 9999999
    CYCLE
    NO CACHE;


GO
PRINT N'Creating [tms].[LAX901607]...';


GO
CREATE SEQUENCE [tms].[LAX901607]
    AS INT
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 9999999
    CYCLE
    NO CACHE;


GO
PRINT N'Creating [tms].[LAX901608]...';


GO
CREATE SEQUENCE [tms].[LAX901608]
    AS INT
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 9999999
    CYCLE
    NO CACHE;


GO
PRINT N'Creating [whse].[AsnNbrSeq]...';


GO
CREATE SEQUENCE [whse].[AsnNbrSeq]
    AS BIGINT
    INCREMENT BY 1
    MINVALUE 1
    NO CACHE;


GO
PRINT N'Creating [acct].[FK_Commission_Contract]...';


GO
ALTER TABLE [acct].[_Commission]
    ADD CONSTRAINT [FK_Commission_Contract] FOREIGN KEY ([ContractID]) REFERENCES [acct].[_Contract] ([ID]);


GO
PRINT N'Creating [acct].[FK_Commission_SalesRep]...';


GO
ALTER TABLE [acct].[_Commission]
    ADD CONSTRAINT [FK_Commission_SalesRep] FOREIGN KEY ([SalesRepID]) REFERENCES [core].[_Party] ([ID]);


GO
PRINT N'Creating [acct].[FK_Contract_BizUnit]...';


GO
ALTER TABLE [acct].[_Contract]
    ADD CONSTRAINT [FK_Contract_BizUnit] FOREIGN KEY ([BizUnitID]) REFERENCES [core].[_Party] ([ID]);


GO
PRINT N'Creating [acct].[FK_Contract_Source]...';


GO
ALTER TABLE [acct].[_Contract]
    ADD CONSTRAINT [FK_Contract_Source] FOREIGN KEY ([SourceID]) REFERENCES [core].[_Source] ([ID]);


GO
PRINT N'Creating [acct].[FK_Contract_Tenant]...';


GO
ALTER TABLE [acct].[_Contract]
    ADD CONSTRAINT [FK_Contract_Tenant] FOREIGN KEY ([TenantID]) REFERENCES [core].[_Tenant] ([ID]);


GO
PRINT N'Creating [acct].[FK_CurrencyRate_Fm]...';


GO
ALTER TABLE [acct].[_CurrencyRate]
    ADD CONSTRAINT [FK_CurrencyRate_Fm] FOREIGN KEY ([FmCurrencyID]) REFERENCES [acct].[_Currency] ([ID]);


GO
PRINT N'Creating [acct].[FK_CurrencyRate_Fo]...';


GO
ALTER TABLE [acct].[_CurrencyRate]
    ADD CONSTRAINT [FK_CurrencyRate_Fo] FOREIGN KEY ([ToCurrencyID]) REFERENCES [acct].[_Currency] ([ID]);


GO
PRINT N'Creating [acct].[FK_Invoice_Contract]...';


GO
ALTER TABLE [acct].[_Invoice]
    ADD CONSTRAINT [FK_Invoice_Contract] FOREIGN KEY ([ContractID]) REFERENCES [acct].[_Contract] ([ID]);


GO
PRINT N'Creating [acct].[FK_Invoice_Currency]...';


GO
ALTER TABLE [acct].[_Invoice]
    ADD CONSTRAINT [FK_Invoice_Currency] FOREIGN KEY ([CurrencyID]) REFERENCES [acct].[_Currency] ([ID]);


GO
PRINT N'Creating [acct].[FK_Invoice_Party]...';


GO
ALTER TABLE [acct].[_Invoice]
    ADD CONSTRAINT [FK_Invoice_Party] FOREIGN KEY ([PartyID]) REFERENCES [core].[_Party] ([ID]);


GO
PRINT N'Creating [acct].[FK_Ledger_Charge]...';


GO
ALTER TABLE [acct].[_Ledger]
    ADD CONSTRAINT [FK_Ledger_Charge] FOREIGN KEY ([ChargeID]) REFERENCES [acct].[_Charge] ([ID]);


GO
PRINT N'Creating [acct].[FK_Ledger_Currency]...';


GO
ALTER TABLE [acct].[_Ledger]
    ADD CONSTRAINT [FK_Ledger_Currency] FOREIGN KEY ([CurrencyID]) REFERENCES [acct].[_Currency] ([ID]);


GO
PRINT N'Creating [acct].[FK_Ledger_Invoice]...';


GO
ALTER TABLE [acct].[_Ledger]
    ADD CONSTRAINT [FK_Ledger_Invoice] FOREIGN KEY ([InvoiceID]) REFERENCES [acct].[_Invoice] ([ID]) ON DELETE SET DEFAULT;


GO
PRINT N'Creating [acct].[FK_Ledger_Matter]...';


GO
ALTER TABLE [acct].[_Ledger]
    ADD CONSTRAINT [FK_Ledger_Matter] FOREIGN KEY ([MatterID]) REFERENCES [core].[_Matter] ([ID]);


GO
PRINT N'Creating [acct].[FK_Ledger_Party]...';


GO
ALTER TABLE [acct].[_Ledger]
    ADD CONSTRAINT [FK_Ledger_Party] FOREIGN KEY ([PartyID]) REFERENCES [core].[_Party] ([ID]);


GO
PRINT N'Creating [acct].[FK_Payment_Cross]...';


GO
ALTER TABLE [acct].[_Payment]
    ADD CONSTRAINT [FK_Payment_Cross] FOREIGN KEY ([XID]) REFERENCES [acct].[_Payment] ([ID]);


GO
PRINT N'Creating [acct].[FK_Payment_Currency]...';


GO
ALTER TABLE [acct].[_Payment]
    ADD CONSTRAINT [FK_Payment_Currency] FOREIGN KEY ([CurrencyID]) REFERENCES [acct].[_Currency] ([ID]);


GO
PRINT N'Creating [acct].[FK_Payment_Party]...';


GO
ALTER TABLE [acct].[_Payment]
    ADD CONSTRAINT [FK_Payment_Party] FOREIGN KEY ([PartyID]) REFERENCES [core].[_Party] ([ID]);


GO
PRINT N'Creating [acct].[FK_Terms_Party]...';


GO
ALTER TABLE [acct].[_Terms]
    ADD CONSTRAINT [FK_Terms_Party] FOREIGN KEY ([PartyID]) REFERENCES [core].[_Party] ([ID]);


GO
PRINT N'Creating [acct].[FK_Vault_Currency]...';


GO
ALTER TABLE [acct].[_Vault]
    ADD CONSTRAINT [FK_Vault_Currency] FOREIGN KEY ([CurrencyID]) REFERENCES [acct].[_Currency] ([ID]);


GO
PRINT N'Creating [acct].[FK_Vault_Party]...';


GO
ALTER TABLE [acct].[_Vault]
    ADD CONSTRAINT [FK_Vault_Party] FOREIGN KEY ([PartyID]) REFERENCES [core].[_Party] ([ID]);


GO
PRINT N'Creating [acct].[FK_Vault_Source]...';


GO
ALTER TABLE [acct].[_Vault]
    ADD CONSTRAINT [FK_Vault_Source] FOREIGN KEY ([SourceID]) REFERENCES [core].[_Source] ([ID]);


GO
PRINT N'Creating [acct].[FK_VaultXact_Invoice]...';


GO
ALTER TABLE [acct].[_VaultXact]
    ADD CONSTRAINT [FK_VaultXact_Invoice] FOREIGN KEY ([InvoiceID]) REFERENCES [acct].[_Invoice] ([ID]);


GO
PRINT N'Creating [acct].[FK_VaultXact_Payment]...';


GO
ALTER TABLE [acct].[_VaultXact]
    ADD CONSTRAINT [FK_VaultXact_Payment] FOREIGN KEY ([PaymentID]) REFERENCES [acct].[_Payment] ([ID]);


GO
PRINT N'Creating [acct].[FK_VaultXact_Vault]...';


GO
ALTER TABLE [acct].[_VaultXact]
    ADD CONSTRAINT [FK_VaultXact_Vault] FOREIGN KEY ([VaultID]) REFERENCES [acct].[_Vault] ([ID]);


GO
PRINT N'Creating [brkg].[FK_Broker_Party]...';


GO
ALTER TABLE [brkg].[_Broker]
    ADD CONSTRAINT [FK_Broker_Party] FOREIGN KEY ([ID]) REFERENCES [core].[_Party] ([ID]);


GO
PRINT N'Creating [brkg].[FK_ClrMethod_Country]...';


GO
ALTER TABLE [brkg].[_ClrMethod]
    ADD CONSTRAINT [FK_ClrMethod_Country] FOREIGN KEY ([CountryCode]) REFERENCES [loc].[_Country] ([Code]);


GO
PRINT N'Creating [brkg].[FK_ClrMethodRate_Method]...';


GO
ALTER TABLE [brkg].[_ClrMethodRate]
    ADD CONSTRAINT [FK_ClrMethodRate_Method] FOREIGN KEY ([ClrMethodID]) REFERENCES [brkg].[_ClrMethod] ([ID]);


GO
PRINT N'Creating [brkg].[FK_ClrMethodRate_Tenant]...';


GO
ALTER TABLE [brkg].[_ClrMethodRate]
    ADD CONSTRAINT [FK_ClrMethodRate_Tenant] FOREIGN KEY ([TenantID]) REFERENCES [core].[_Tenant] ([ID]);


GO
PRINT N'Creating [brkg].[FK_Commodity_Duty]...';


GO
ALTER TABLE [brkg].[_Commodity]
    ADD CONSTRAINT [FK_Commodity_Duty] FOREIGN KEY ([DutyID]) REFERENCES [brkg].[_Duty] ([ID]);


GO
PRINT N'Creating [brkg].[FK_Commodity_PID]...';


GO
ALTER TABLE [brkg].[_Commodity]
    ADD CONSTRAINT [FK_Commodity_PID] FOREIGN KEY ([ID]) REFERENCES [brkg].[_Commodity] ([ID]);


GO
PRINT N'Creating [brkg].[FK_Duty_Country]...';


GO
ALTER TABLE [brkg].[_Duty]
    ADD CONSTRAINT [FK_Duty_Country] FOREIGN KEY ([CountryCode]) REFERENCES [loc].[_Country] ([Code]);


GO
PRINT N'Creating [core].[FK_Action_State]...';


GO
ALTER TABLE [core].[_Action]
    ADD CONSTRAINT [FK_Action_State] FOREIGN KEY ([LoopEntryID]) REFERENCES [core].[_State] ([ID]);


GO
PRINT N'Creating [core].[FK_Activity_Action]...';


GO
ALTER TABLE [core].[_Activity]
    ADD CONSTRAINT [FK_Activity_Action] FOREIGN KEY ([ActionID]) REFERENCES [core].[_Action] ([ID]);


GO
PRINT N'Creating [core].[FK_Activity_Matter]...';


GO
ALTER TABLE [core].[_Activity]
    ADD CONSTRAINT [FK_Activity_Matter] FOREIGN KEY ([MatterID]) REFERENCES [core].[_Matter] ([ID]);


GO
PRINT N'Creating [core].[FK_Activity_State]...';


GO
ALTER TABLE [core].[_Activity]
    ADD CONSTRAINT [FK_Activity_State] FOREIGN KEY ([StateID]) REFERENCES [core].[_State] ([ID]);


GO
PRINT N'Creating [core].[FK_Activity_User]...';


GO
ALTER TABLE [core].[_Activity]
    ADD CONSTRAINT [FK_Activity_User] FOREIGN KEY ([UserID]) REFERENCES [core].[_User] ([ID]);


GO
PRINT N'Creating [core].[FK_AddOnSvc_Matter]...';


GO
ALTER TABLE [core].[_AddOnSvc]
    ADD CONSTRAINT [FK_AddOnSvc_Matter] FOREIGN KEY ([MatterID]) REFERENCES [core].[_Matter] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [core].[FK_AddOnSvc_User]...';


GO
ALTER TABLE [core].[_AddOnSvc]
    ADD CONSTRAINT [FK_AddOnSvc_User] FOREIGN KEY ([OperatorID]) REFERENCES [core].[_User] ([ID]);


GO
PRINT N'Creating [core].[FK_Announcement_Source]...';


GO
ALTER TABLE [core].[_Announcement]
    ADD CONSTRAINT [FK_Announcement_Source] FOREIGN KEY ([SourceID]) REFERENCES [core].[_Source] ([ID]);


GO
PRINT N'Creating [core].[FK_Attachment_Poster]...';


GO
ALTER TABLE [core].[_Attachment]
    ADD CONSTRAINT [FK_Attachment_Poster] FOREIGN KEY ([PosterID]) REFERENCES [core].[_User] ([ID]);


GO
PRINT N'Creating [core].[FK_Challenge_Matter]...';


GO
ALTER TABLE [core].[_Challenge]
    ADD CONSTRAINT [FK_Challenge_Matter] FOREIGN KEY ([MatterID]) REFERENCES [core].[_Matter] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [core].[FK_ChangeLog_User]...';


GO
ALTER TABLE [core].[_ChangeLog]
    ADD CONSTRAINT [FK_ChangeLog_User] FOREIGN KEY ([ChangedBy]) REFERENCES [core].[_User] ([ID]);


GO
PRINT N'Creating [core].[FK_Concern_Matter]...';


GO
ALTER TABLE [core].[_Concern]
    ADD CONSTRAINT [FK_Concern_Matter] FOREIGN KEY ([MatterID]) REFERENCES [core].[_Matter] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [core].[FK_Contact_Country]...';


GO
ALTER TABLE [core].[_Contact]
    ADD CONSTRAINT [FK_Contact_Country] FOREIGN KEY ([CountryCode]) REFERENCES [loc].[_Country] ([Code]);


GO
PRINT N'Creating [core].[FK_Contact_Party]...';


GO
ALTER TABLE [core].[_Contact]
    ADD CONSTRAINT [FK_Contact_Party] FOREIGN KEY ([PartyID]) REFERENCES [core].[_Party] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [core].[FK_LoopStack_Matter]...';


GO
ALTER TABLE [core].[_LoopStack]
    ADD CONSTRAINT [FK_LoopStack_Matter] FOREIGN KEY ([MatterID]) REFERENCES [core].[_Matter] ([ID]);


GO
PRINT N'Creating [core].[FK_LoopStack_Return]...';


GO
ALTER TABLE [core].[_LoopStack]
    ADD CONSTRAINT [FK_LoopStack_Return] FOREIGN KEY ([ReturnID]) REFERENCES [core].[_Transition] ([ID]);


GO
PRINT N'Creating [core].[FK_Matter_AID]...';


GO
ALTER TABLE [core].[_Matter]
    ADD CONSTRAINT [FK_Matter_AID] FOREIGN KEY ([AID]) REFERENCES [core].[_Matter] ([ID]);


GO
PRINT N'Creating [core].[FK_Matter_Handler]...';


GO
ALTER TABLE [core].[_Matter]
    ADD CONSTRAINT [FK_Matter_Handler] FOREIGN KEY ([HandlerID]) REFERENCES [core].[_User] ([ID]);


GO
PRINT N'Creating [core].[FK_Matter_PID]...';


GO
ALTER TABLE [core].[_Matter]
    ADD CONSTRAINT [FK_Matter_PID] FOREIGN KEY ([PID]) REFERENCES [core].[_Matter] ([ID]);


GO
PRINT N'Creating [core].[FK_Matter_Poster]...';


GO
ALTER TABLE [core].[_Matter]
    ADD CONSTRAINT [FK_Matter_Poster] FOREIGN KEY ([PosterID]) REFERENCES [core].[_Tenant] ([ID]);


GO
PRINT N'Creating [core].[FK_Matter_State]...';


GO
ALTER TABLE [core].[_Matter]
    ADD CONSTRAINT [FK_Matter_State] FOREIGN KEY ([StateID]) REFERENCES [core].[_State] ([ID]);


GO
PRINT N'Creating [core].[FK_Message_Poster]...';


GO
ALTER TABLE [core].[_Message]
    ADD CONSTRAINT [FK_Message_Poster] FOREIGN KEY ([PosterID]) REFERENCES [core].[_User] ([ID]);


GO
PRINT N'Creating [core].[FK_Party_AID]...';


GO
ALTER TABLE [core].[_Party]
    ADD CONSTRAINT [FK_Party_AID] FOREIGN KEY ([AID]) REFERENCES [core].[_Party] ([ID]);


GO
PRINT N'Creating [core].[FK_Party_PID]...';


GO
ALTER TABLE [core].[_Party]
    ADD CONSTRAINT [FK_Party_PID] FOREIGN KEY ([PID]) REFERENCES [core].[_Party] ([ID]);


GO
PRINT N'Creating [core].[FK_Party_SRC]...';


GO
ALTER TABLE [core].[_Party]
    ADD CONSTRAINT [FK_Party_SRC] FOREIGN KEY ([Source]) REFERENCES [core].[_Source] ([ID]);


GO
PRINT N'Creating [core].[FK_Port_Country]...';


GO
ALTER TABLE [core].[_Port]
    ADD CONSTRAINT [FK_Port_Country] FOREIGN KEY ([Country]) REFERENCES [loc].[_Country] ([Code]);


GO
PRINT N'Creating [core].[FK_Port_Tenant]...';


GO
ALTER TABLE [core].[_Port]
    ADD CONSTRAINT [FK_Port_Tenant] FOREIGN KEY ([UtcPlaceID]) REFERENCES [core].[_Tenant] ([ID]);


GO
PRINT N'Creating [core].[FK_RefInfo_Matter]...';


GO
ALTER TABLE [core].[_RefInfo]
    ADD CONSTRAINT [FK_RefInfo_Matter] FOREIGN KEY ([MatterID]) REFERENCES [core].[_Matter] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [core].[FK_RefNbr_Matter]...';


GO
ALTER TABLE [core].[_RefNbr]
    ADD CONSTRAINT [FK_RefNbr_Matter] FOREIGN KEY ([MatterID]) REFERENCES [core].[_Matter] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [core].[FK_RefParty_Matter]...';


GO
ALTER TABLE [core].[_RefParty]
    ADD CONSTRAINT [FK_RefParty_Matter] FOREIGN KEY ([MatterID]) REFERENCES [core].[_Matter] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [core].[FK_RefParty_Party]...';


GO
ALTER TABLE [core].[_RefParty]
    ADD CONSTRAINT [FK_RefParty_Party] FOREIGN KEY ([PartyID]) REFERENCES [core].[_Party] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [core].[FK_RefStamp_Matter]...';


GO
ALTER TABLE [core].[_RefStamp]
    ADD CONSTRAINT [FK_RefStamp_Matter] FOREIGN KEY ([MatterID]) REFERENCES [core].[_Matter] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [core].[FK_RefStamp_State]...';


GO
ALTER TABLE [core].[_RefStamp]
    ADD CONSTRAINT [FK_RefStamp_State] FOREIGN KEY ([StateID]) REFERENCES [core].[_State] ([ID]);


GO
PRINT N'Creating [core].[FK_RefStamp_Tenant]...';


GO
ALTER TABLE [core].[_RefStamp]
    ADD CONSTRAINT [FK_RefStamp_Tenant] FOREIGN KEY ([UtcPlaceID]) REFERENCES [core].[_Tenant] ([ID]);


GO
PRINT N'Creating [core].[FK_Tenant]...';


GO
ALTER TABLE [core].[_Tenant]
    ADD CONSTRAINT [FK_Tenant] FOREIGN KEY ([ID]) REFERENCES [core].[_Party] ([ID]);


GO
PRINT N'Creating [core].[FK_Tenant_SRC]...';


GO
ALTER TABLE [core].[_Tenant]
    ADD CONSTRAINT [FK_Tenant_SRC] FOREIGN KEY ([Source]) REFERENCES [core].[_Source] ([ID]);


GO
PRINT N'Creating [core].[FK_Transition_Action]...';


GO
ALTER TABLE [core].[_Transition]
    ADD CONSTRAINT [FK_Transition_Action] FOREIGN KEY ([ActionID]) REFERENCES [core].[_Action] ([ID]);


GO
PRINT N'Creating [core].[FK_Transition_OnState]...';


GO
ALTER TABLE [core].[_Transition]
    ADD CONSTRAINT [FK_Transition_OnState] FOREIGN KEY ([OnStateID]) REFERENCES [core].[_State] ([ID]);


GO
PRINT N'Creating [core].[FK_Transition_Role]...';


GO
ALTER TABLE [core].[_Transition]
    ADD CONSTRAINT [FK_Transition_Role] FOREIGN KEY ([RoleID]) REFERENCES [core].[_Role] ([ID]);


GO
PRINT N'Creating [core].[FK_Transition_ToState]...';


GO
ALTER TABLE [core].[_Transition]
    ADD CONSTRAINT [FK_Transition_ToState] FOREIGN KEY ([ToStateID]) REFERENCES [core].[_State] ([ID]);


GO
PRINT N'Creating [core].[FK_User]...';


GO
ALTER TABLE [core].[_User]
    ADD CONSTRAINT [FK_User] FOREIGN KEY ([ID]) REFERENCES [core].[_Party] ([ID]);


GO
PRINT N'Creating [core].[FK_UserRole_Role]...';


GO
ALTER TABLE [core].[_UserRole]
    ADD CONSTRAINT [FK_UserRole_Role] FOREIGN KEY ([RoleID]) REFERENCES [core].[_Role] ([ID]);


GO
PRINT N'Creating [core].[FK_UserRole_User]...';


GO
ALTER TABLE [core].[_UserRole]
    ADD CONSTRAINT [FK_UserRole_User] FOREIGN KEY ([UserID]) REFERENCES [core].[_User] ([ID]);


GO
PRINT N'Creating [invt].[FK_Sku_Tenant]...';


GO
ALTER TABLE [invt].[_Sku]
    ADD CONSTRAINT [FK_Sku_Tenant] FOREIGN KEY ([TenantID]) REFERENCES [core].[_Tenant] ([ID]);


GO
PRINT N'Creating [invt].[FK_SkuBrokerage_Brkg]...';


GO
ALTER TABLE [invt].[_SkuBrokerage]
    ADD CONSTRAINT [FK_SkuBrokerage_Brkg] FOREIGN KEY ([BrokerID]) REFERENCES [brkg].[_Broker] ([ID]);


GO
PRINT N'Creating [invt].[FK_SkuBrokerage_Clr]...';


GO
ALTER TABLE [invt].[_SkuBrokerage]
    ADD CONSTRAINT [FK_SkuBrokerage_Clr] FOREIGN KEY ([ClrMethodID]) REFERENCES [brkg].[_ClrMethod] ([ID]);


GO
PRINT N'Creating [invt].[FK_SkuBrokerage_Duty]...';


GO
ALTER TABLE [invt].[_SkuBrokerage]
    ADD CONSTRAINT [FK_SkuBrokerage_Duty] FOREIGN KEY ([DutyID]) REFERENCES [brkg].[_Duty] ([ID]);


GO
PRINT N'Creating [invt].[FK_SkuBrokerage_Sku]...';


GO
ALTER TABLE [invt].[_SkuBrokerage]
    ADD CONSTRAINT [FK_SkuBrokerage_Sku] FOREIGN KEY ([SkuID]) REFERENCES [invt].[_Sku] ([ID]);


GO
PRINT N'Creating [shpt].[FK_Appointment_Matter]...';


GO
ALTER TABLE [shpt].[_Appointment]
    ADD CONSTRAINT [FK_Appointment_Matter] FOREIGN KEY ([ID]) REFERENCES [core].[_Matter] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [shpt].[FK_Batch_Site]...';


GO
ALTER TABLE [shpt].[_Batch]
    ADD CONSTRAINT [FK_Batch_Site] FOREIGN KEY ([SiteID]) REFERENCES [core].[_Tenant] ([ID]);


GO
PRINT N'Creating [shpt].[FK_Parcel_Batch]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [FK_Parcel_Batch] FOREIGN KEY ([BatchID]) REFERENCES [shpt].[_Batch] ([ID]);


GO
PRINT N'Creating [shpt].[FK_Parcel_Contract]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [FK_Parcel_Contract] FOREIGN KEY ([ContractID]) REFERENCES [acct].[_Contract] ([ID]);


GO
PRINT N'Creating [shpt].[FK_Parcel_LastMiler]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [FK_Parcel_LastMiler] FOREIGN KEY ([LastMilerID]) REFERENCES [tms].[_Courier] ([ID]);


GO
PRINT N'Creating [shpt].[FK_Parcel_Matter]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [FK_Parcel_Matter] FOREIGN KEY ([ID]) REFERENCES [core].[_Matter] ([ID]);


GO
PRINT N'Creating [shpt].[FK_Parcel_POA]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [FK_Parcel_POA] FOREIGN KEY ([POA]) REFERENCES [core].[_Port] ([Code]);


GO
PRINT N'Creating [shpt].[FK_Parcel_RcvHub]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [FK_Parcel_RcvHub] FOREIGN KEY ([RcvHubID]) REFERENCES [core].[_Tenant] ([ID]);


GO
PRINT N'Creating [shpt].[FK_Parcel_Route]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [FK_Parcel_Route] FOREIGN KEY ([RouteID]) REFERENCES [tms].[_Route] ([ID]);


GO
PRINT N'Creating [shpt].[FK_Parcel_SvcClass]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [FK_Parcel_SvcClass] FOREIGN KEY ([SvcClass]) REFERENCES [tms].[_SvcClass] ([ID]);


GO
PRINT N'Creating [shpt].[FK_Parcel_SvcType]...';


GO
ALTER TABLE [shpt].[_Parcel]
    ADD CONSTRAINT [FK_Parcel_SvcType] FOREIGN KEY ([SvcType]) REFERENCES [tms].[_SvcType] ([ID]);


GO
PRINT N'Creating [shpt].[FK_RackXact_OrderIn]...';


GO
ALTER TABLE [shpt].[_RackXact]
    ADD CONSTRAINT [FK_RackXact_OrderIn] FOREIGN KEY ([OrderInID]) REFERENCES [whse].[_RackOrder] ([ID]);


GO
PRINT N'Creating [shpt].[FK_RackXact_OrderOut]...';


GO
ALTER TABLE [shpt].[_RackXact]
    ADD CONSTRAINT [FK_RackXact_OrderOut] FOREIGN KEY ([OrderOutID]) REFERENCES [whse].[_RackOrder] ([ID]);


GO
PRINT N'Creating [shpt].[FK_RackXact_Parcel]...';


GO
ALTER TABLE [shpt].[_RackXact]
    ADD CONSTRAINT [FK_RackXact_Parcel] FOREIGN KEY ([ParcelID]) REFERENCES [shpt].[_Parcel] ([ID]);


GO
PRINT N'Creating [shpt].[FK_RackXact_Rack]...';


GO
ALTER TABLE [shpt].[_RackXact]
    ADD CONSTRAINT [FK_RackXact_Rack] FOREIGN KEY ([RackID]) REFERENCES [whse].[_Rack] ([ID]);


GO
PRINT N'Creating [shpt].[FK_Sack_Broker]...';


GO
ALTER TABLE [shpt].[_Sack]
    ADD CONSTRAINT [FK_Sack_Broker] FOREIGN KEY ([BrokerID]) REFERENCES [brkg].[_Broker] ([ID]);


GO
PRINT N'Creating [shpt].[FK_Sack_ClrMethod]...';


GO
ALTER TABLE [shpt].[_Sack]
    ADD CONSTRAINT [FK_Sack_ClrMethod] FOREIGN KEY ([ClrMethodID]) REFERENCES [brkg].[_ClrMethod] ([ID]);


GO
PRINT N'Creating [shpt].[FK_Sack_ID]...';


GO
ALTER TABLE [shpt].[_Sack]
    ADD CONSTRAINT [FK_Sack_ID] FOREIGN KEY ([ID]) REFERENCES [core].[_Matter] ([ID]);


GO
PRINT N'Creating [shpt].[FK_Sack_POA]...';


GO
ALTER TABLE [shpt].[_Sack]
    ADD CONSTRAINT [FK_Sack_POA] FOREIGN KEY ([POA]) REFERENCES [core].[_Port] ([Code]);


GO
PRINT N'Creating [shpt].[FK_SackLoad_ID]...';


GO
ALTER TABLE [shpt].[_SackLoad]
    ADD CONSTRAINT [FK_SackLoad_ID] FOREIGN KEY ([ID]) REFERENCES [core].[_Matter] ([ID]);


GO
PRINT N'Creating [shpt].[FK_SackLoad_Trucker]...';


GO
ALTER TABLE [shpt].[_SackLoad]
    ADD CONSTRAINT [FK_SackLoad_Trucker] FOREIGN KEY ([TruckerID]) REFERENCES [tms].[_Trucker] ([ID]);


GO
PRINT N'Creating [shpt].[FK_SackMft_BRK]...';


GO
ALTER TABLE [shpt].[_SackMft]
    ADD CONSTRAINT [FK_SackMft_BRK] FOREIGN KEY ([BrokerID]) REFERENCES [brkg].[_Broker] ([ID]);


GO
PRINT N'Creating [shpt].[FK_SackMft_ID]...';


GO
ALTER TABLE [shpt].[_SackMft]
    ADD CONSTRAINT [FK_SackMft_ID] FOREIGN KEY ([ID]) REFERENCES [core].[_Matter] ([ID]);


GO
PRINT N'Creating [shpt].[FK_SackMft_POA]...';


GO
ALTER TABLE [shpt].[_SackMft]
    ADD CONSTRAINT [FK_SackMft_POA] FOREIGN KEY ([POA]) REFERENCES [core].[_Port] ([Code]);


GO
PRINT N'Creating [shpt].[FK_SackMft_POD]...';


GO
ALTER TABLE [shpt].[_SackMft]
    ADD CONSTRAINT [FK_SackMft_POD] FOREIGN KEY ([POD]) REFERENCES [core].[_Port] ([Code]);


GO
PRINT N'Creating [tms].[FK_Airline_Party]...';


GO
ALTER TABLE [tms].[_Airline]
    ADD CONSTRAINT [FK_Airline_Party] FOREIGN KEY ([ID]) REFERENCES [core].[_Party] ([ID]);


GO
PRINT N'Creating [tms].[FK_Courier_Party]...';


GO
ALTER TABLE [tms].[_Courier]
    ADD CONSTRAINT [FK_Courier_Party] FOREIGN KEY ([ID]) REFERENCES [core].[_Party] ([ID]);


GO
PRINT N'Creating [tms].[FK_CourierAlias_Courier]...';


GO
ALTER TABLE [tms].[_CourierAlias]
    ADD CONSTRAINT [FK_CourierAlias_Courier] FOREIGN KEY ([CourierID]) REFERENCES [tms].[_Courier] ([ID]);


GO
PRINT N'Creating [tms].[FK_CourierNbrPool_Courier]...';


GO
ALTER TABLE [tms].[_CourierNbrPool]
    ADD CONSTRAINT [FK_CourierNbrPool_Courier] FOREIGN KEY ([CourierID]) REFERENCES [tms].[_Courier] ([ID]);


GO
PRINT N'Creating [tms].[FK_Flight_ID]...';


GO
ALTER TABLE [tms].[_Flight]
    ADD CONSTRAINT [FK_Flight_ID] FOREIGN KEY ([ID]) REFERENCES [core].[_Matter] ([ID]);


GO
PRINT N'Creating [tms].[FK_Flight_POA]...';


GO
ALTER TABLE [tms].[_Flight]
    ADD CONSTRAINT [FK_Flight_POA] FOREIGN KEY ([POA]) REFERENCES [core].[_Port] ([Code]);


GO
PRINT N'Creating [tms].[FK_Flight_POD]...';


GO
ALTER TABLE [tms].[_Flight]
    ADD CONSTRAINT [FK_Flight_POD] FOREIGN KEY ([POD]) REFERENCES [core].[_Port] ([Code]);


GO
PRINT N'Creating [tms].[FK_Route_Broker]...';


GO
ALTER TABLE [tms].[_Route]
    ADD CONSTRAINT [FK_Route_Broker] FOREIGN KEY ([BrokerID]) REFERENCES [brkg].[_Broker] ([ID]);


GO
PRINT N'Creating [tms].[FK_Route_ClrMethod]...';


GO
ALTER TABLE [tms].[_Route]
    ADD CONSTRAINT [FK_Route_ClrMethod] FOREIGN KEY ([ClrMethodID]) REFERENCES [brkg].[_ClrMethod] ([ID]);


GO
PRINT N'Creating [tms].[FK_Route_Commodity]...';


GO
ALTER TABLE [tms].[_Route]
    ADD CONSTRAINT [FK_Route_Commodity] FOREIGN KEY ([CmdyRootID]) REFERENCES [brkg].[_Commodity] ([ID]);


GO
PRINT N'Creating [tms].[FK_Route_Courier]...';


GO
ALTER TABLE [tms].[_Route]
    ADD CONSTRAINT [FK_Route_Courier] FOREIGN KEY ([CourierID]) REFERENCES [tms].[_Courier] ([ID]);


GO
PRINT N'Creating [tms].[FK_RouteBranch_Action]...';


GO
ALTER TABLE [tms].[_RouteBranch]
    ADD CONSTRAINT [FK_RouteBranch_Action] FOREIGN KEY ([ActionID]) REFERENCES [core].[_Action] ([ID]);


GO
PRINT N'Creating [tms].[FK_RouteBranch_Role]...';


GO
ALTER TABLE [tms].[_RouteBranch]
    ADD CONSTRAINT [FK_RouteBranch_Role] FOREIGN KEY ([AltRoleID]) REFERENCES [core].[_Role] ([ID]);


GO
PRINT N'Creating [tms].[FK_RouteBranch_Route]...';


GO
ALTER TABLE [tms].[_RouteBranch]
    ADD CONSTRAINT [FK_RouteBranch_Route] FOREIGN KEY ([RouteID]) REFERENCES [tms].[_Route] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcClass_Courier]...';


GO
ALTER TABLE [tms].[_SvcClass]
    ADD CONSTRAINT [FK_SvcClass_Courier] FOREIGN KEY ([CourierID]) REFERENCES [tms].[_Courier] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcContract_Contract]...';


GO
ALTER TABLE [tms].[_SvcContract]
    ADD CONSTRAINT [FK_SvcContract_Contract] FOREIGN KEY ([ContractID]) REFERENCES [acct].[_Contract] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcContract_SvcType]...';


GO
ALTER TABLE [tms].[_SvcContract]
    ADD CONSTRAINT [FK_SvcContract_SvcType] FOREIGN KEY ([SvcType]) REFERENCES [tms].[_SvcType] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcCost_SvcClass]...';


GO
ALTER TABLE [tms].[_SvcCost]
    ADD CONSTRAINT [FK_SvcCost_SvcClass] FOREIGN KEY ([SvcClass]) REFERENCES [tms].[_SvcClass] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcFacility_Airport]...';


GO
ALTER TABLE [tms].[_SvcFacility]
    ADD CONSTRAINT [FK_SvcFacility_Airport] FOREIGN KEY ([POA]) REFERENCES [core].[_Port] ([Code]);


GO
PRINT N'Creating [tms].[FK_SvcFacility_Courier]...';


GO
ALTER TABLE [tms].[_SvcFacility]
    ADD CONSTRAINT [FK_SvcFacility_Courier] FOREIGN KEY ([CourierID]) REFERENCES [tms].[_Courier] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcFacility_Source]...';


GO
ALTER TABLE [tms].[_SvcFacility]
    ADD CONSTRAINT [FK_SvcFacility_Source] FOREIGN KEY ([SourceID]) REFERENCES [core].[_Source] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcFactor_Contract]...';


GO
ALTER TABLE [tms].[_SvcFactor]
    ADD CONSTRAINT [FK_SvcFactor_Contract] FOREIGN KEY ([ContractID]) REFERENCES [acct].[_Contract] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcFactor_RcvHub]...';


GO
ALTER TABLE [tms].[_SvcFactor]
    ADD CONSTRAINT [FK_SvcFactor_RcvHub] FOREIGN KEY ([RcvHubID]) REFERENCES [core].[_Tenant] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcFactor_SvcClass]...';


GO
ALTER TABLE [tms].[_SvcFactor]
    ADD CONSTRAINT [FK_SvcFactor_SvcClass] FOREIGN KEY ([SvcClass]) REFERENCES [tms].[_SvcClass] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcFacZoneCode_Courier]...';


GO
ALTER TABLE [tms].[_SvcFacZoneCode]
    ADD CONSTRAINT [FK_SvcFacZoneCode_Courier] FOREIGN KEY ([CourierID]) REFERENCES [tms].[_Courier] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcFacZoneCode_Facility]...';


GO
ALTER TABLE [tms].[_SvcFacZoneCode]
    ADD CONSTRAINT [FK_SvcFacZoneCode_Facility] FOREIGN KEY ([FacilityID]) REFERENCES [tms].[_SvcFacility] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcFacZoneCode_ZoneCode]...';


GO
ALTER TABLE [tms].[_SvcFacZoneCode]
    ADD CONSTRAINT [FK_SvcFacZoneCode_ZoneCode] FOREIGN KEY ([CourierID], [ZoneCode]) REFERENCES [tms].[_SvcZoneCode] ([CourierID], [ZoneCode3]);


GO
PRINT N'Creating [tms].[FK_SvcRate_RcvHub]...';


GO
ALTER TABLE [tms].[_SvcRate]
    ADD CONSTRAINT [FK_SvcRate_RcvHub] FOREIGN KEY ([RcvHubID]) REFERENCES [core].[_Tenant] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcRate_SvcClass]...';


GO
ALTER TABLE [tms].[_SvcRate]
    ADD CONSTRAINT [FK_SvcRate_SvcClass] FOREIGN KEY ([SvcClass]) REFERENCES [tms].[_SvcClass] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcRate_SvcType]...';


GO
ALTER TABLE [tms].[_SvcRate]
    ADD CONSTRAINT [FK_SvcRate_SvcType] FOREIGN KEY ([SvcType]) REFERENCES [tms].[_SvcType] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcRoute_Port]...';


GO
ALTER TABLE [tms].[_SvcRoute]
    ADD CONSTRAINT [FK_SvcRoute_Port] FOREIGN KEY ([POA]) REFERENCES [core].[_Port] ([Code]);


GO
PRINT N'Creating [tms].[FK_SvcRoute_Route]...';


GO
ALTER TABLE [tms].[_SvcRoute]
    ADD CONSTRAINT [FK_SvcRoute_Route] FOREIGN KEY ([RouteID]) REFERENCES [tms].[_Route] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcRoute_SvcType]...';


GO
ALTER TABLE [tms].[_SvcRoute]
    ADD CONSTRAINT [FK_SvcRoute_SvcType] FOREIGN KEY ([SvcType]) REFERENCES [tms].[_SvcType] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcType_ClrMethod]...';


GO
ALTER TABLE [tms].[_SvcType]
    ADD CONSTRAINT [FK_SvcType_ClrMethod] FOREIGN KEY ([ClrMethodID]) REFERENCES [brkg].[_ClrMethod] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcType_Commodity]...';


GO
ALTER TABLE [tms].[_SvcType]
    ADD CONSTRAINT [FK_SvcType_Commodity] FOREIGN KEY ([CmdyRootID]) REFERENCES [brkg].[_Commodity] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcType_Currency]...';


GO
ALTER TABLE [tms].[_SvcType]
    ADD CONSTRAINT [FK_SvcType_Currency] FOREIGN KEY ([CurrencyID]) REFERENCES [acct].[_Currency] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcType_InitState]...';


GO
ALTER TABLE [tms].[_SvcType]
    ADD CONSTRAINT [FK_SvcType_InitState] FOREIGN KEY ([InitStateID]) REFERENCES [core].[_State] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcType_Tenant]...';


GO
ALTER TABLE [tms].[_SvcType]
    ADD CONSTRAINT [FK_SvcType_Tenant] FOREIGN KEY ([TenantID]) REFERENCES [core].[_Tenant] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcZone_Courier]...';


GO
ALTER TABLE [tms].[_SvcZone]
    ADD CONSTRAINT [FK_SvcZone_Courier] FOREIGN KEY ([CourierID]) REFERENCES [tms].[_Courier] ([ID]);


GO
PRINT N'Creating [tms].[FK_SvcZone_OnZoneCode3]...';


GO
ALTER TABLE [tms].[_SvcZone]
    ADD CONSTRAINT [FK_SvcZone_OnZoneCode3] FOREIGN KEY ([CourierID], [OnZoneCode3]) REFERENCES [tms].[_SvcZoneCode] ([CourierID], [ZoneCode3]);


GO
PRINT N'Creating [tms].[FK_SvcZone_ToZoneCode3]...';


GO
ALTER TABLE [tms].[_SvcZone]
    ADD CONSTRAINT [FK_SvcZone_ToZoneCode3] FOREIGN KEY ([CourierID], [ToZoneCode3]) REFERENCES [tms].[_SvcZoneCode] ([CourierID], [ZoneCode3]);


GO
PRINT N'Creating [tms].[FK_Trucker_Party]...';


GO
ALTER TABLE [tms].[_Trucker]
    ADD CONSTRAINT [FK_Trucker_Party] FOREIGN KEY ([ID]) REFERENCES [core].[_Party] ([ID]);


GO
PRINT N'Creating [whse].[FK_Rack_Hub]...';


GO
ALTER TABLE [whse].[_Rack]
    ADD CONSTRAINT [FK_Rack_Hub] FOREIGN KEY ([HubID]) REFERENCES [core].[_Tenant] ([ID]);


GO
PRINT N'Creating [whse].[FK_RackOrder_User]...';


GO
ALTER TABLE [whse].[_RackOrder]
    ADD CONSTRAINT [FK_RackOrder_User] FOREIGN KEY ([RackerID]) REFERENCES [core].[_User] ([ID]);


GO
PRINT N'Creating [whse].[FK_StockInOrder_Contract]...';


GO
ALTER TABLE [whse].[_StockInOrder]
    ADD CONSTRAINT [FK_StockInOrder_Contract] FOREIGN KEY ([ContractID]) REFERENCES [acct].[_Contract] ([ID]);


GO
PRINT N'Creating [whse].[FK_StockInOrder_ID]...';


GO
ALTER TABLE [whse].[_StockInOrder]
    ADD CONSTRAINT [FK_StockInOrder_ID] FOREIGN KEY ([ID]) REFERENCES [core].[_Matter] ([ID]);


GO
PRINT N'Creating [whse].[FK_StockInOrder_RcvHub]...';


GO
ALTER TABLE [whse].[_StockInOrder]
    ADD CONSTRAINT [FK_StockInOrder_RcvHub] FOREIGN KEY ([RcvHubID]) REFERENCES [core].[_Tenant] ([ID]);


GO
PRINT N'Creating [whse].[FK_StorageRate_Currency]...';


GO
ALTER TABLE [whse].[_StorageRate]
    ADD CONSTRAINT [FK_StorageRate_Currency] FOREIGN KEY ([CurrencyID]) REFERENCES [acct].[_Currency] ([ID]);


GO
PRINT N'Creating [whse].[FK_StorageRate_RcvHub]...';


GO
ALTER TABLE [whse].[_StorageRate]
    ADD CONSTRAINT [FK_StorageRate_RcvHub] FOREIGN KEY ([RcvHubID]) REFERENCES [core].[_Tenant] ([ID]);


GO
PRINT N'Creating [whse].[FK_StorageRate_Tenant]...';


GO
ALTER TABLE [whse].[_StorageRate]
    ADD CONSTRAINT [FK_StorageRate_Tenant] FOREIGN KEY ([TenantID]) REFERENCES [core].[_Tenant] ([ID]);


GO
PRINT N'Creating [acct].[CK_Currency]...';


GO
ALTER TABLE [acct].[_Currency]
    ADD CONSTRAINT [CK_Currency] CHECK ([ID]<100);


GO
PRINT N'Creating [core].[CK_Matter_Source]...';


GO
ALTER TABLE [core].[_Matter]
    ADD CONSTRAINT [CK_Matter_Source] CHECK (Source<100);


GO
PRINT N'Creating [core].[CK_Matter_Type]...';


GO
ALTER TABLE [core].[_Matter]
    ADD CONSTRAINT [CK_Matter_Type] CHECK (Type  <100);


GO
PRINT N'Creating [core].[CK_Source]...';


GO
ALTER TABLE [core].[_Source]
    ADD CONSTRAINT [CK_Source] CHECK (ID<100);


GO
PRINT N'Creating [core].[CK_State]...';


GO
ALTER TABLE [core].[_State]
    ADD CONSTRAINT [CK_State] CHECK (ID<10 or ID between 10000 and 999999);


GO
PRINT N'Creating [tms].[CK_SvcRoute]...';


GO
ALTER TABLE [tms].[_SvcRoute]
    ADD CONSTRAINT [CK_SvcRoute] CHECK ((SvcType%10000)=0);


GO
PRINT N'Creating [tms].[CK_SvcType]...';


GO
ALTER TABLE [tms].[_SvcType]
    ADD CONSTRAINT [CK_SvcType] CHECK (ID between 0 and 99999999);


GO
PRINT N'Creating [tvp].[Bag@Count]...';


GO
-- PeterHo
create FUNCTION [tvp].[Bag@Count](@src nvarchar(max))
RETURNS bigint
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return	iif(@src is null, 0
	,		((datalength(@src) - datalength(replace(@src, N'	{	', N''))) / 6) + 1);
END
GO
PRINT N'Creating [tvp].[Comma@Count]...';


GO
-- PeterHo
create FUNCTION [tvp].[Comma@Count](@src nvarchar(max))
RETURNS bigint
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return iif(@src is null, 0
	,		((datalength(@src) - datalength(replace(@src, N',', N''))) / 2) + 1);
END
GO
PRINT N'Creating [tvp].[Entry@Count]...';


GO
-- PeterHo
create FUNCTION [tvp].[Entry@Count](@src nvarchar(max))
RETURNS bigint
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return	iif(@src is null, 0
	,		((datalength(@src) - datalength(replace(@src, N'	;	', N''))) / 6) + 1);
END
GO
PRINT N'Creating [tvp].[Many@Count]...';


GO
-- PeterHo
create FUNCTION [tvp].[Many@Count](@src nvarchar(max))
RETURNS bigint
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return	iif(@src is null, 0
	,		((datalength(@src) - datalength(replace(@src, N'	,	', N''))) / 6) + 1);
END
GO
PRINT N'Creating [tvp].[Mucho@Count]...';


GO
-- PeterHo
create FUNCTION [tvp].[Mucho@Count](@src nvarchar(max))
RETURNS bigint
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return	iif(@src is null, 0
	,		((datalength(@src) - datalength(replace(@src, N'	[	', N''))) / 6) + 1);
END
GO
PRINT N'Creating [tvp].[Pcs@Count]...';


GO
-- PeterHo
create FUNCTION [tvp].[Pcs@Count](@src nvarchar(max), @spr nvarchar(255)=N'	;	')
RETURNS bigint
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return	iif(@src is null, 0, iif(datalength(@spr) > 0
	,		((datalength(@src) - datalength(replace(@src, @spr, N'')))  / datalength(@spr)) + 1, 1));
END
GO
PRINT N'Creating [tvp].[Spr@Count]...';


GO
-- PeterHo
create FUNCTION [tvp].[Spr@Count](@src nvarchar(max), @spr nvarchar(255)=N'	;	')
RETURNS bigint
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return	iif(@src is null, 0, iif(datalength(@spr)>0
	,		(datalength(@src) - datalength(replace(@src, @spr, N'')))  / datalength(@spr),	0));
END
GO
PRINT N'Creating [dbo].[Bit@IsSingle]...';


GO
-- PeterHo
create FUNCTION [dbo].[Bit@IsSingle](@value bigint)
RETURNS bit
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return iif(@value > 0 and (@value & (@value - 1)) = 0, 1, 0);
END
GO
PRINT N'Creating [dbo].[Currency@Check]...';


GO
-- PeterHo
create FUNCTION [dbo].[Currency@Check](@amt bigint, @currencyID tinyint)
RETURNS bit
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return iif(@amt=0 or abs(@amt)%100=@currencyID, 1, 0)
END
GO
PRINT N'Creating [dbo].[Currency@Equal]...';


GO
-- PeterHo
create FUNCTION [dbo].[Currency@Equal](@amtA bigint, @amtB bigint)
RETURNS bit
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return iif(@amtA=0 or @amtB=0, 1, iif(abs(@amtA)%100=abs(@amtB)%100, 1, 0))
END
GO
PRINT N'Creating [acct].[CK_Invoice_DueBalance]...';


GO
ALTER TABLE [acct].[_Invoice]
    ADD CONSTRAINT [CK_Invoice_DueBalance] CHECK (dbo.Currency@Check(DueBalance, CurrencyID)=1);


GO
PRINT N'Creating [acct].[CK_Invoice_InvoiceAmt]...';


GO
ALTER TABLE [acct].[_Invoice]
    ADD CONSTRAINT [CK_Invoice_InvoiceAmt] CHECK (dbo.Currency@Check(InvoiceAmt, CurrencyID)=1);


GO
PRINT N'Creating [acct].[CK_Ledger_ChargeAmt]...';


GO
ALTER TABLE [acct].[_Ledger]
    ADD CONSTRAINT [CK_Ledger_ChargeAmt] CHECK (dbo.Currency@Check(ChargeAmt, CurrencyID)=1);


GO
PRINT N'Creating [acct].[CK_Payment_PaidAmt]...';


GO
ALTER TABLE [acct].[_Payment]
    ADD CONSTRAINT [CK_Payment_PaidAmt] CHECK (dbo.Currency@Check(PaidAmt, CurrencyID)=1);


GO
PRINT N'Creating [acct].[CK_Vault_Uninvoiced]...';


GO
ALTER TABLE [acct].[_Vault]
    ADD CONSTRAINT [CK_Vault_Uninvoiced] CHECK (dbo.Currency@Check(UninvoicedAmt, CurrencyID)=1);


GO
PRINT N'Creating [acct].[CK_Vault_VaultBal]...';


GO
ALTER TABLE [acct].[_Vault]
    ADD CONSTRAINT [CK_Vault_VaultBal] CHECK (dbo.Currency@Check(VaultBal,      CurrencyID)=1);


GO
PRINT N'Creating [acct].[CK_VaultXact_XactAmt]...';


GO
ALTER TABLE [acct].[_VaultXact]
    ADD CONSTRAINT [CK_VaultXact_XactAmt] CHECK (dbo.Currency@Equal(PrevBal, XactAmt)=1);


GO
PRINT N'Creating [acct].[@-----------------#acct]...';


GO
-- PeterHo
CREATE FUNCTION [acct].[@-----------------#acct]()
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN (select null as [Nil])
/*
	...
*/
GO
PRINT N'Creating [acct].[Charge#ID]...';


GO
--Smile
CREATE FUNCTION [acct].[Charge#ID] ()
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN
(
	select	2  as Deduct
	,		3  as Deposit	         	
	,		10 as Insurance	         	      
	,		11 as Freight	         	         	
	,		12 as Commission	
	,		13 as Operation	
	,		14 as Tax	
	,		15 as Duty	
	,		16 as OutPkgFee
	,		17 as BrokerageFee
	,		20 as RcvSkuFee
	,		21 as StorageCbmFee30Day
	,		22 as StorageCbmFee60Day
	,		23 as StorageCbmOther
	,		24 as OverWeightFee
	,		25 as ExcessItemsFee
)
GO
PRINT N'Creating [acct].[Charge#Raw]...';


GO
-- PeterHo
CREATE FUNCTION [acct].[Charge#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Code, APCoa, ARCoa, VaultTag, VaultType
	from	[acct].[_Charge]
)
GO
PRINT N'Creating [acct].[Contract#Raw]...';


GO
-- Smile
CREATE FUNCTION [acct].[Contract#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, TenantID, SourceID,  BizUnitID,    SalesDeptID=BizUnitID--ToBeDropped
	,		BillingCycle, DutyTerms, NonDutyTerms, EffectiveOn, ExpiredOn   
	from	[acct].[_Contract]
)
GO
PRINT N'Creating [acct].[Currency#Raw]...';


GO
-- PeterHo: For Integrity Only.
CREATE FUNCTION [acct].[Currency#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Code
	from	[acct].[_Currency]
)
GO
PRINT N'Creating [acct].[CurrencyRate#Raw]...';


GO
-- PeterHo: For Integrity Only.
CREATE FUNCTION [acct].[CurrencyRate#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	FmCurrencyID, ToCurrencyID, EffectiveOn, ForPayment, ForDeclaration
	from	[acct].[_CurrencyRate]
)
GO
PRINT N'Creating [acct].[Ledger#Side]...';


GO
-- PeterHo
CREATE FUNCTION [acct].[Ledger#Side] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1 as [AP]
	,		2 as [AR]
	,		3 as [XP] -- Void AP
	,		4 as [XR] -- Void AR
)
GO
PRINT N'Creating [acct].[Payment#Method]...';


GO
-- PeterHo
CREATE FUNCTION [acct].[Payment#Method] ()
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN
(
	select	1	as [Cash]
	,		2	as [Check]
	---------------------------
	,		11	as [AliPay]
	,		12	as [PayPal]
	,		13	as [WeChat]
	---------------------------
	,		21	as [CreditCard]
	,		22	as [DebitCard]
	---------------------------
	,		99	as [Others]
	---------------------------
	,		101	as [Withdraw]
)
GO
PRINT N'Creating [acct].[Payment#Raw]...';


GO
-- PeterHo
CREATE FUNCTION [acct].[Payment#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, XID, LedgerSide, CurrencyID, PartyID, PayMethod, PaidAmt, PaidOn
	,		PaymentNbr=isnull(cast(ID as varchar(15)), 0)
	from	[acct].[_Payment]
)
GO
PRINT N'Creating [acct].[Terms#Raw]...';


GO
-- Smile
CREATE FUNCTION [acct].[Terms#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	PartyID, VaultTag, NetDays
	from	[acct].[_Terms] 
)
GO
PRINT N'Creating [acct].[Vault#Tag]...';


GO
-- PeterHo
CREATE FUNCTION [acct].[Vault#Tag] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [Duty]
	,		2	as [NotDuty]
)
GO
PRINT N'Creating [acct].[Vault#Type]...';


GO
-- PeterHo
CREATE FUNCTION [acct].[Vault#Type] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [Fund]
	,		2	as [Cash]
	,		3	as [Bonus]
	,		4	as [Reward]
	,		5	as [Credit]
	,		6	as [CreditMemo]
	---------------------------
	,		11	as [Freight]
	,		12	as [Commission]
	,		13	as [Operation]
	,		14	as [Tax]
	,		15	as [Duty]
	---------------------------
)
GO
PRINT N'Creating [api].[@------------------#api]...';


GO
--PeterHo
CREATE FUNCTION [api].[@------------------#api]()
RETURNS TABLE
AS RETURN (select null as [Nil])
/*
	Document comes here.
*/
GO
PRINT N'Creating [api].[ActivitySubscription#Raw]...';


GO
-- AaronLiu
CREATE FUNCTION [api].[ActivitySubscription#Raw]()
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, RefNbr
	from	api._ActivitySubscription
)
GO
PRINT N'Creating [bo].[@------------------#svc]...';


GO
--Smile
CREATE FUNCTION [bo].[@------------------#svc]()
RETURNS TABLE
AS RETURN (select null as [Nil])
/*
	Document comes here.
*/
GO
PRINT N'Creating [brkg].[@-----------------#brkg]...';


GO
-- PeterHo
CREATE FUNCTION [brkg].[@-----------------#brkg]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN (select null as [Nil])
GO
PRINT N'Creating [brkg].[Broker#Raw]...';


GO
--PeterHo
CREATE FUNCTION [brkg].[Broker#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, FlatRate, PercentRate, ApiToken, ApiUrl, BrokerAlias=Alias
	from	brkg._Broker
)
GO
PRINT N'Creating [brkg].[BrokerRate#For]...';


GO
--Smile
CREATE FUNCTION [brkg].[BrokerRate#For](@brokerID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with	brokerRate as
	(
		select	top(1)	FlatRate, PercentRate
		from	brkg.Broker#Raw()
		where	ID=@brokerID
		union	all
		select	0, 0
	)
	select	top(1)	FlatRate, PercentRate
	from	brokerRate
)
GO
PRINT N'Creating [brkg].[ClrMethodRate#Raw]...';


GO
--PeterHo
CREATE FUNCTION [brkg].[ClrMethodRate#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	TenantID, ClrMethodID, FlatRate, PercentRate
	from	brkg._ClrMethodRate
)
GO
PRINT N'Creating [brkg].[Commodity#Raw]...';


GO
--PeterHo
CREATE FUNCTION [brkg].[Commodity#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, PID, DutyID, Name, Surcharge
	from	brkg._Commodity
)
GO
PRINT N'Creating [brkg].[Duty#Raw]...';


GO
--PeterHo
CREATE FUNCTION [brkg].[Duty#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, CountryCode, DutyCode, DutyRate, CustomsValue, CommodityUoM
	from	brkg._Duty
)
GO
PRINT N'Creating [co].[@------------------#co]...';


GO
--Smile
CREATE FUNCTION [co].[@------------------#co]()
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN (select null as [Nil])
/*
	Document comes here.
*/
GO
PRINT N'Creating [co].[Payment$Verify]...';


GO
-- Ken
CREATE FUNCTION [co].[Payment$Verify](@paymentID bigint)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	select	XID 
	from	acct.Payment#Raw()
	where	ID=@paymentID
)
GO
PRINT N'Creating [core].[@-----------------#core]...';


GO
--PeterHo
CREATE FUNCTION [core].[@-----------------#core]()
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN (select null as [Nil])
/*
	...
*/
GO
PRINT N'Creating [core].[Action#ID]...';


GO
--PeterHo
CREATE FUNCTION [core].[Action#ID]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	11100	as HubCheckIn
	,		11200	as HubMeasure
	,		11202	as HubMeasureMPS    
	,		11203	as HubMeasureCPS    
	,		11204	as HubMeasureOrphan  
	,		11210	as HubRemeasure
	,		11220	as ImportAsn
	,		11230	as CfmAsnHubVerified
	,		11240	as CfmAsnRacked
	,		11245	as VoidAsn
	,		11310	as QueueRakedIn
	,		11320	as Cart
	,		11330	as Rack
	,		11340	as QueueRackOut
	,		11355	as RackingMissing
	,		11410	as Unify
	,		17106	as TranslateForBrokerage
	,		17099	as CompleteParcelInfo
--	,		11500	as HubVerify
	,		11505	as HubVerifyWithTappingRed
	,		11510	as HubVerifyWithTappingGreen
	,		11560	as ComplyWithShippingPlan
	,		11860	as CloseSack
	,		11865	as VoidSack
	,		11866	as AddParcelToSack
	,		11867	as RemoveParcelFromSack
	,		11868	as AddToSackMft
	,		11872	as AddToSackLoad
	,		11873	as RemoveFromSackLoad
	,		11900	as ImportHubManifest
	,		11950	as CfmTransload
	,		11951	as ImportOutgateManifest
	--------------------------------------------
	,		16005	as Adopt 
	--------------------------------------------
	,		17000	as InitParcel
	,		17005	as VoidParcel
	,		17015	as FlagForReturn
	,		17098	as ConfirmIDInfo
	,		17500	as FallbackShipping
	,		17102	as UpdateIDNumber
	,		17103	as RequestIDPicture
	,		17104	as UpdateIDPicture
	,		17105   as DetermineCmdy
	,		17100	as UpdateParcelInfo
	,		17155	as ReportOverThreshold
	,		17180	as RouteToUSPS
	,		17200	as ConfirmRoute
	,		17203	as ReportSvcRateNotFound
	,		17204	as ReportCreditLimitExceeded
	,		17206	as CfmPayment
	,		17207	as ImportSvcRate
	,		17210	as SourceConfirm
	,		17211	as SourceConcur
	,		17220	as ReceiveBrkgAcceptance
	,		17221	as RequeueBrkgApi
	,		17225	as ReceiveBrkgRejection
	,		17270	as VoidPickup
	,		17275	as CallOffDriver
	,		17276	as DriverStartOff
	,		17277	as CancelStartOff
	,		17284	as Dispatch
	,		17299	as CfmPickedup
	,		17300	as ICManifest
	,		17605	as Bounce
	--------------------------------------------
	,		17170	as PromoteToShippingPlan
	,		17176	as ComposeShippingPlan
	--------------------------------------------
	,		18845	as CfmFlightDepartureDelayed	
	,		18855	as CfmFlightArrivalDelayed	 
	,		18865	as CfmCustomsHeld
	,		18870	as CfmCustomsCleared
	,		18895	as CfmCustomsSeized
	,		18897	as CfmSurrenderByImport
	,		18899	as CfmSurrendered

	--------------------------------------------
	,		58540	as WMSProvideOutgoingWeight
)
GO
PRINT N'Creating [core].[Action#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[Action#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, ActionName=Name, LoopEntryID
	from	core._Action
)
GO
PRINT N'Creating [core].[Activity#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[Activity#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, MatterID, StateID, ActionID, UserID, TalliedOn
	from	core._Activity
)
GO
PRINT N'Creating [core].[AddOnSvc#Raw]...';


GO
--Eason
CREATE FUNCTION [core].[AddOnSvc#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[ID], [MatterID], [Type], [OperatorID], [StartedOn], [EndedOn]
	from	[core].[_AddOnSvc]
)
GO
PRINT N'Creating [core].[AddOnSvc#Type]...';


GO
--Eason
CREATE FUNCTION [core].[AddOnSvc#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
		select
		10  as TakePhoto,           -- 内件拍照
		11  as Inventory,           -- 内件数量核对
		51  as [Return],            -- 退货
		101 as ChangeLabel,         -- 换单
		102 as ReinforcePackaging,  -- 内件加固
		103 as Consolidation,       -- 合并包裹
		104 as RemoveInvoice,       -- 取出单证
		105 as AdditionalPackaging, -- 加运输包装操作费（PAK袋）
		200 as CustomizedService
)
GO
PRINT N'Creating [core].[Attachment#Raw]...';


GO
--HeBaiDong
CREATE	FUNCTION [core].[Attachment#Raw]()
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, RegID, RowID, AuxID, PostedOn, PosterID, FileBankID
	from	core._Attachment
)
GO
PRINT N'Creating [core].[Attachment#Type]...';


GO
--Smile
CREATE FUNCTION [core].[Attachment#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	31	as Mawb
	----------------------------
	,		101	as SalesContract
	,		102	as SvcRate
	----------------------------
	,		255	as Other
)
GO
PRINT N'Creating [core].[Challenge#Borderline]...';


GO
--PeterHo, Smile
CREATE FUNCTION [core].[Challenge#Borderline](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	MinStage=cast(min(BoundStage) as int)
		from	core._Challenge where MatterID=@matterID
	)
	select	Borderline=isnull(MinStage, 30000) from cte
)
GO
PRINT N'Creating [core].[Challenge#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[Challenge#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, Type, BoundStage
	from	core._Challenge
)
GO
PRINT N'Creating [core].[Challenge#Type]...';


GO
--PeterHo
CREATE FUNCTION [core].[Challenge#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as VaultBalance
	----------------------------
	,		101	as Instruction
	,		102	as Audition
	----------------------------
	,		201	as TobeHeld
	,		202	as TobeReturned
	,		203	as TobeDisposed
)
GO
PRINT N'Creating [core].[Concern#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[Concern#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, Type
	from	core._Concern
)
GO
PRINT N'Creating [core].[Concern#Type]...';


GO
--Smile, PeterHo
CREATE FUNCTION [core].[Concern#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as NameAbnormal
	,		2	as PhoneAbnormal
	,		3	as BalanceInsufficient
	,		4	as AddressIncomplete
	,		5	as ValueTransfinite
	,		11	as PreCouierDuplicate
	,		15	as PreCheckIncomplete
)
GO
PRINT N'Creating [core].[Contact#Raw]...';


GO
-- PeterHo
CREATE FUNCTION [core].[Contact#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID,      PartyID,  Type,       IsDefault
	,		Name,    Phone,    Email,      Company
	,		Street1, Street2,  Street3,    District
	,		City,    Province, PostalCode, CountryCode
	from	core._Contact
)
GO
PRINT N'Creating [core].[Contact#Type]...';


GO
--PeterHo, Aaron
CREATE FUNCTION [core].[Contact#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as Billing
	,		2	as Shipping
	,		3	as Cnee
	,		4	as Returning
)
GO
PRINT N'Creating [core].[LoopStack#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[LoopStack#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, MatterID, ReturnID
	,		Marker=lead(ID) over (partition by MatterID order by ID)
	from	core._LoopStack
)
GO
PRINT N'Creating [core].[Matter#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[Matter#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID,    PID,     AID,      Source,   Type,     LockCnt
	,		Stage, StateID, StatedOn, PosterID, PostedOn, HandlerID
	,		RejoinID -- ToBeDropped --
	from	core._Matter
)
GO
PRINT N'Creating [core].[Matter#Type]...';


GO
--PeterHo
CREATE FUNCTION [core].[Matter#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [Parcel]
	------------------------------------
	,		2	as [Zack]
	,		3	as [Sack]
	,		4	as [ZackMft]
	,		5	as [SackMft]
	,		6	as [ZackLoad]
	,		7	as [SackLoad]
	,		8	as [Flight]
	,		9	as [Vessel]
	------------------------------------
	,		11	as [ShippingPlan]
	,		12	as [MasterParcel] -- MPS
	,		13	as [HouseParcel]  -- MPS
	,		14	as [UnityParcel]  -- CPS
	,		15	as [MediumParcel] -- CPS
	,		16	as [OrphanParcel]
	,		17	as [PIP]
	,		18	as [Appointment]
	------------------------------------
	,		21	as [StockInOrder]
	,		22	as [StorageFee]
	,		25	as [AssortedFees]
	------------------------------------
	--  AppType start from 51 ~ 99    --
	------------------------------------
)
GO
PRINT N'Creating [core].[Message#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[Message#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	RegID, RowID, AuxID, PostedOn, PosterID, Body
	from	core._Message
)
GO
PRINT N'Creating [core].[Party#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[Party#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, PID, AID, Type, Source, Alias
	from	core._Party
)
GO
PRINT N'Creating [core].[Party#Role]...';


GO
--PeterHo
CREATE FUNCTION [core].[Party#Role]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	8	as [PreCourier]
	,		9	as [PostCourier]
	------------------------------
	,		20	as [Client]
	,		21	as [ClientAgent]
	,		22	as [ClientSite]
	------------------------------
	,		10	as [InfoCenter]
	,		11	as [ReceivingHub]
	,		12	as [TransitingHub]
	,		13	as [CollectingHub]
	,		19	as [BackOffice]
	------------------------------

	,		101	as [Ramper]
	--,		91	as [ExportBroker]
	--,		92	as [ImportBroker]
	--,		93	as [ExportCustoms]
	--,		94	as [ImportCustoms]
	-- App roles use 100+ --------
)
GO
PRINT N'Creating [core].[Party#Type]...';


GO
--PeterHo
CREATE FUNCTION [core].[Party#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [Staff]
	,		2	as [Member]
	,		3	as [Operator]
	,		4	as [Associate]
	,		5	as [Ramper]
	,		9	as [SalesRep]
	---------------------------
	,		10	as [ZebraRegion]
	,		11	as [ZebraHub]
	,		12	as [ZebraStore]
	,		15	as [ZebraIC]
	,		17	as [ZebraDiv]
	,		19	as [ZebraDept]
	---------------------------
	,		21	as [AgentStore]
	,		22	as [TenantSite]
	,		80	as [Port]
	,		99	as [Platform]
	---------------------------
	,		100	as [Customer]
	,		101	as [Tenant]
	---------------------------
	,		200	as [Vendor]
	,		201	as [Broker]
	,		202	as [Trucker]
	,		203	as [Courier]
	,		204	as [Customs]
)
GO
PRINT N'Creating [core].[Port#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[Port#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Code, Type, Country, UtcOffset, UtcPlaceID
	from	core._Port
)
GO
PRINT N'Creating [core].[Port#Type]...';


GO
--PeterHo
CREATE FUNCTION [core].[Port#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [Airport]
	,		2	as [Seaport]
	,		4	as [Landport]
)
GO
PRINT N'Creating [core].[Queue#OutboundQ]...';


GO
--PeterHo
CREATE FUNCTION [core].[Queue#OutboundQ]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ToSource, QueueType, QueuedOn, MatterID, StateID
	from	core._OutboundQ
)
GO
PRINT N'Creating [core].[Queue#OutboundX]...';


GO
--PeterHo
CREATE FUNCTION [core].[Queue#OutboundX]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	QueuedOn, ToSource, QueueType, MatterID, StateID
	from	core._OutboundX
)
GO
PRINT N'Creating [core].[Queue#Type]...';


GO
--PeterHo
CREATE FUNCTION [core].[Queue#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as StateChanged
	,		2	as Challenge
	,		3	as Reminder
	,		11	as SubscribeCallback
	,		12	as PolyCallback
	,		13	as ReadyForRelease

	--[App]----------------------
	,		101	as MeasureReady
	,		102 as ShippingPlanReady
	,		103 as ShippingPlanComplied

	--[Api: for InfoPath only]---
	,		201	as BrokerApi
	,		202	as PreCourierApi
	,		203	as PostCourierApi
	,		205 as IDInfoRequired 
	,		206 as IDInfoReview
)
GO
PRINT N'Creating [core].[RefInfo#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefInfo#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, Type, Info
	from	core._RefInfo
)
GO
PRINT N'Creating [core].[RefInfo#Type]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefInfo#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [ShprInfo]
	,		2	as [CneeInfo]
	,		3	as [DeclaredInfo]
	,		4	as [VerifiedInfo]
	,		5	as [IDInfo]
	------------------------------
--	,		6	as []
	,		7	as [BrokerageInfo]
	,		8	as [ShippingLabelInfo]
	,		9	as [ShippingPlanInfo]
	,		10	as [ConcurredInfo]
	------------------------------
	,		11	as [ReturnInfo]
	,		12	as [RemarkInfo]
	,		13	as [PickupInfo]
	,		15  as [VoidInfo]
	,		20	as [AddOnSvcInfo]
	,		25	as [HandWrittenOrderImgInfo]
	,		30	as [SnapshotInfo]
)
GO
PRINT N'Creating [core].[RefNbr#Decode]...';


GO
--Aaron
CREATE FUNCTION [core].[RefNbr#Decode](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteDecoded as
	(
		select	Number=right(@number, 22)
		where	len(@number)=30 and left(@number, 3)='420'  -- USPS & FedEx SmartPost
		union	all
		select	Number=right(@number, 12)
		where	len(@number)=34 and left(@number, 1)='9'    -- FedEx Ground
	)
	select	top(1) Number from cteDecoded
)
GO
PRINT N'Creating [core].[RefNbr#DecodeOne]...';


GO
--Aaron
CREATE FUNCTION [core].[RefNbr#DecodeOne](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteDecoded as
	(
		select	Number=right(@number, 22)
		where	len(@number)=30 and left(@number, 3)='420'  -- FedEx SmartPost / USPS
		union	all
		select	Number=right(@number, 12)
		where	len(@number)=34 and left(@number, 1)='9'    -- FedEx Ground
	)
	select	top(1) Number
	from	cteDecoded
)
GO
PRINT N'Creating [core].[RefNbr#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefNbr#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, Type, Number
	from	core._RefNbr
)
GO
PRINT N'Creating [core].[RefNbr#Type]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefNbr#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [MIT] -- DO NOT CHANGE!!
--	,		2	as [ZEB]
	,		8	as [PreCourier]
	,		9	as [PostCourier]
	----------------------------
	,		10	as [BookingNbr]
	,		11	as [VenderRef]
	,		21	as [MawbNbr]
	,		31	as [MblNbr]
	----------------------------
	,		101	as [ClientRef]
	,		114	as [RackLabel]

	----------------------------
	,		201	as [AsnNbr]
)
GO
PRINT N'Creating [core].[RefParty#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefParty#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, PartyRole, PartyID
	from	core._RefParty
)
GO
PRINT N'Creating [core].[RefStamp#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefStamp#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, StateID, UtcTime, UtcOffset, UtcPlaceID
	from	core._RefStamp
)
GO
PRINT N'Creating [core].[Registry#ID]...';


GO
--PeterHo
CREATE FUNCTION [core].[Registry#ID]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	1	as Matter
	,		2	as Party
	,		3	as Contract
	--------------------------
	,		11	as Activity
	,		12	as AddOnSvc
	--------------------------
	,		21	as Ledger
	,		22	as Invoice
	,		23	as Payment
	,		24	as PaymentPlan
	,		25	as AssortedFees
	--------------------------
	,		101	as ParcelBatch
	,		102 as SvcContract
	,		103 as SvcRate
)
GO
PRINT N'Creating [core].[Role#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[Role#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Name--, PID
	from	core._Role
)
GO
PRINT N'Creating [core].[Setting#Raw]...';


GO
--Eason
CREATE FUNCTION [core].[Setting#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Name, Value, Description
	from	core._Setting
)
GO
PRINT N'Creating [core].[Source#ID]...';


GO
--PeterHo
CREATE FUNCTION [core].[Source#ID]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [InfoPath]
	,		2	as [ZEB]
	,		3	as [eShip]
	,		4	as [eForward]
	,		5	as [eVMI_Legacy]
	,		6	as [ZPD]
	,		7	as [XPD]
	,		8	as [USD]
	,		9	as [AAE]
	,		11	as [eVMI]
)
GO
PRINT N'Creating [core].[Source#Rectify]...';


GO
--PeterHo
CREATE FUNCTION [core].[Source#Rectify](@source tinyint, @queueType tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Source=iif(@queueType>=t.BrokerApi, s.InfoPath, @source)
	from	core.Source#ID() s, core.Queue#Type() t
)
GO
PRINT N'Creating [core].[Stage#Boundary]...';


GO
--PeterHo
CREATE FUNCTION [core].[Stage#Boundary]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	0	as [Nil]
	---------------------------
	,		100		as [PreMin]
	,		9999	as [PreMax]
	---------------------------
	,		10000	as [CurMin]
	,		19999	as [CurMax]
	---------------------------
	,		20000	as [PostMin]
	,		25499	as [PostMax]
	---------------------------
	,		25500	as [Ended]
)
GO
PRINT N'Creating [core].[Stage#ID]...';


GO
--PeterHo
CREATE FUNCTION [core].[Stage#ID]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	100		as InfoImported
	-----------------------------------------
	,		500		as PreInterventionNeeded
	-----------------------------------------
	,		1000	as ParcelCreated
	,		1001	as PreScreenParcelCreated
	-----------------------------------------
	,		10101	as HubAccepted -- Marker
	,		10500	as InterventionNeeded
	,		11000	as HubCheckedIn
	,		11300	as HubMeasured
	,		11400	as Racking
	,		11600	as ContentVerified
	,		12000	as RouteAssigned
	,		13000	as RouteCfmed
	,		14000	as LoadBalanced
	,		18000	as Sacked
	,		19000	as SackManifested
	,		19300	as SackLoaded
	-----------------------------------------
	,		20000	as Outgated
	,		20500	as PostInterventionNeeded
	,		21000	as Transloaded
	,		22000	as Onboarded
	,		22300	as Departed
	,		22600	as Arrived
	,		23000	as CustomsHeld
	,		23600	as CustomsCleared
	,		24500	as Surrendered
	-----------------------------------------
	,		25100	as DoorDelivered
	,		25200	as Undeliverable
	,		25300	as CustomsSeized
	,		25500	as Ended
)
GO
PRINT N'Creating [core].[Stage#Of]...';


GO
--PeterHo
CREATE FUNCTION [core].[Stage#Of](@stateID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Stage from core._State where ID=@stateID
)
GO
PRINT N'Creating [core].[State#ID]...';


GO
--PeterHo
CREATE FUNCTION [core].[State#ID]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	10101	as HubAccepted -- Marker
	---------------------------------------- 
	,		11210	as AsnNbrGenerated
	,		11310	as TobeRackedIn
	,		11320	as Carted
	,		11330	as RackingRackedIn
	,		11340	as TobeRackedOut
	---------------------------------------- 
	,		16100	as OrphanCreated 
	,		17061	as ParcelRetired
	,		17150	as CreditLimitExceeded
	,		17271	as PickupRequested
	,		17281	as ThirdPtyPickupRequested
	,		18710	as FlightBooked
--	,		18781	as SackClosed
	,		18771	as SackCreated
	,		18773	as SackManifested
	,		18779	as SackTransloaded
	,		18791	as SackLoadCreated
	,		18800	as SackMftCreated
	,		18830	as SackMftTransloaded
	,		18840	as SackMftOnboarded
	,		18850	as SackMftDeparted
	,		18860	as SackMftArrived
	,		18870	as SackMftCustomsCleared
	,		18899	as SackMftSurrendered
	----------------------------------------
	,		38070	as InfoPictureReceived
	--,		38700	as Outgated
	,		38010	as CustomsSeized
	,		38855	as CustomsHeld
	,		38870	as CustomsCleared
	,		58500	as HubManifested
	,		58540	as AwaitingMeasurement
)
GO
PRINT N'Creating [core].[State#IdOfVoid]...';


GO
--PeterHo
CREATE FUNCTION [core].[State#IdOfVoid](@onStateID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	VoidID=(@onStateID/1000)*1000
)
GO
PRINT N'Creating [core].[State#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[State#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Stage, Name, IsInternal
	from	core._State
)
GO
PRINT N'Creating [core].[Supplement#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[Supplement#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	RegID, RowID, Supplement
	from	core._Supplement
)
GO
PRINT N'Creating [core].[Tenant#IdOf]...';


GO
--PeterHo
CREATE FUNCTION [core].[Tenant#IdOf](@source tinyint, @alias nvarchar(40))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID
	from	core._Tenant
	where	Source=@source and Alias=@alias
)
GO
PRINT N'Creating [core].[Tenant#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[Tenant#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Source, Alias, UtcPlace, UtcOffset, SalesRepID, NoLogo
	from	core._Tenant
)
GO
PRINT N'Creating [core].[Todo#Raw]...';


GO
-- PeterHo
CREATE FUNCTION [core].[Todo#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, RoleID, ActionID, ToSource, DueOn
	from	core._Todo
)
GO
PRINT N'Creating [core].[Transition#Raw]...';


GO
-- PeterHo
CREATE FUNCTION [core].[Transition#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, OnStateID, RoleID, ActionID, ToStateID, TodoHours, OutboundQ
	from	core._Transition
)
GO
PRINT N'Creating [core].[Transition#Tobe]...';


GO
-- PeterHo
CREATE FUNCTION [core].[Transition#Tobe](@onStateID int, @roleID int, @actionID int, @rejoinID int=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteTransition as
	(
		select	ToStateID=iif(ToStateID=-1, @rejoinID, ToStateID), TodoHours, OutboundQ
		from	core.Transition#Raw()
		where	(OnStateID=@onStateID and RoleID=@roleID and ActionID=@actionID)
	)
	select	ToStage=s.Stage, ToStateID, TodoHours, OutboundQ
	from	cteTransition x join core.State#Raw() s on s.ID=x.ToStateID
/*
	select	ToStage=s.Stage, ToStateID, TodoHours, OutboundQ
	from	core.Transition#Raw() x
	join	core.State#Raw() s on s.ID=x.ToStateID
	where	(OnStateID=@onStateID and RoleID=@roleID and ActionID=@actionID)
*/
)
GO
PRINT N'Creating [core].[User#Raw]...';


GO
--PeterHo
CREATE FUNCTION [core].[User#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Alias
	from	core._User
)
GO
PRINT N'Creating [core].[User#Role]...';


GO
--PeterHo
CREATE FUNCTION [core].[User#Role]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	100 as [ClientAdmin]
	,		101	as [ClientOP]
	,		102 as [ClientMgr]
	----------------------------
	,		110 as [HubAdmin]
	,		111 as [HubOP]
	,		112 as [HubMgr]
	,		115 as [HubDriver]
	----------------------------
	,		120 as [ICAdmin]
	,		121	as [ICOP]
	,		122	as [ICMgr]
	----------------------------
	,		130 as [BOAdmin]
	,		131	as [BOOP]
	,		132	as [BOMgr]
	----------------------------
	,		140	as [StoreAdmin]
	,		141 as [StoreOP]
	,		142	as [StoreMgr]
	----------------------------
	,		150	as [AcctAdmin]
	,		151 as [AcctOP]
	,		152	as [AcctMgr]
)
GO
PRINT N'Creating [core].[UserRole#Raw]...';


GO
--Smile
CREATE FUNCTION [core].[UserRole#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	UserID, RoleID
	from	core._UserRole
)
GO
PRINT N'Creating [hub].[@------------------#svc]...';


GO
--Smile
CREATE FUNCTION [hub].[@------------------#svc]()
RETURNS TABLE
AS RETURN (select null as [Nil])
/*
	Document comes here.
*/
GO
PRINT N'Creating [ic].[@--------------------#ic]...';


GO
--Daxia
CREATE FUNCTION [ic].[@--------------------#ic]()
RETURNS TABLE
AS RETURN (select null as [Nil])
/*
	Document comes here.
*/
GO
PRINT N'Creating [invt].[@-----------------#invt]...';


GO
--PeterHo
CREATE FUNCTION [invt].[@-----------------#invt]()
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN (select null as [Nil])
/*
	Document comes here.
*/
GO
PRINT N'Creating [invt].[Sku#Raw]...';


GO
--PeterHo
CREATE FUNCTION [invt].[Sku#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, TenantID, SkuNbr, FiledInfo
	from	invt._Sku
)
GO
PRINT N'Creating [invt].[SkuBrokerage#Raw]...';


GO
--PeterHo
CREATE FUNCTION [invt].[SkuBrokerage#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	SkuID, ClrMethodID, BrokerID, DutyID, Endorsement
	from	invt._SkuBrokerage
)
GO
PRINT N'Creating [loc].[TenantAlias#Encode]...';


GO
--Smile.Wang
CREATE FUNCTION [loc].[TenantAlias#Encode](@alias varchar(40) )
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	TenantAlias=concat(@alias, ' (Admin)')
)
GO
PRINT N'Creating [loc].[@------------------#loc]...';


GO
-- PeterHo
CREATE FUNCTION [loc].[@------------------#loc]()
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN (select null as [Nil])
/*
	...
*/
GO
PRINT N'Creating [loc].[Country#Raw]...';


GO
--PeterHo
CREATE FUNCTION [loc].[Country#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Code, Code3, CodeN
	from	[loc]._Country
)
GO
PRINT N'Creating [loc].[RefNbr#Cast]...';


GO
--PeterHo
CREATE FUNCTION [loc].[RefNbr#Cast](@number nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Number=cast(@number as varchar(40))
)
GO
PRINT N'Creating [loc].[SkuNbr#Cast]...';


GO
--PeterHo
CREATE FUNCTION [loc].[SkuNbr#Cast](@skuNbr nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	SkuNbr=cast(@skuNbr as varchar(40))
)
GO
PRINT N'Creating [loc].[TenantAlias#Rectify]...';


GO
--Smile
CREATE FUNCTION [loc].[TenantAlias#Rectify](@alias varchar(40))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	TenantAlias=replace(@alias, ' (Admin)', '')
)
GO
PRINT N'Creating [rpt].[Dashboard$StageSummary]...';


GO
-- Eason
CREATE FUNCTION [rpt].[Dashboard$StageSummary](@siteID bigint)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	select	isnull(sum(case when x.Stage between 100   and 24999 then 1 else 0 end),0) as ParcelTotal
	,		isnull(sum(case when x.Stage between 100   and  9999 then 1 else 0 end),0) as ParcelAwaiting
	,		isnull(sum(case when x.Stage between 10000 and 19999 then 1 else 0 end),0) as ParcelProcessing
	,		isnull(sum(case when x.Stage between 20000 and 24999 then 1 else 0 end),0) as ParcelShipped
	,		isnull(sum(case when x.Stage in (500,10500,20500)    then 1 else 0 end),0) as ExcptionTotal
	,		isnull(sum(case when x.Stage = 500                   then 1 else 0 end),0) as ExcptionAwaiting
	,		isnull(sum(case when x.Stage = 10500                 then 1 else 0 end),0) as ExcptionProcessing
	,		isnull(sum(case when x.Stage = 20500                 then 1 else 0 end),0) as ExcptionShipped
	from	core.Matter#Raw()        x
	cross	apply core.Matter#Type() t
	where	x.Type=t.Parcel and x.PosterID=@siteID
)
GO
PRINT N'Creating [rpt].[@------------------#rpt]...';


GO
--PeterHo
CREATE FUNCTION [rpt].[@------------------#rpt]()
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN (select null as [Nil])
/*
	Document comes here.
*/
GO
PRINT N'Creating [shpt].[Siblings#Cnt]...';


GO
-- AaronLiu
CREATE FUNCTION [shpt].[Siblings#Cnt](@parcelID I64)
RETURNS TABLE
-- WITH ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	Cnt=count(1)
		from	core.Matter#Raw()  x, core.Matter#Raw() m
		where	x.ID=@parcelID and x.AID=m.AID and m.AID>0
	)
	select	Cnt
	from	cte
)
GO
PRINT N'Creating [shpt].[@-----------------#shpt]...';


GO
--PeterHo
CREATE FUNCTION [shpt].[@-----------------#shpt]()
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN (select null as [Nil])
/*
	Document comes here.
*/
GO
PRINT N'Creating [shpt].[Appointment#Raw]...';


GO
-- AaronLiu
CREATE FUNCTION [shpt].[Appointment#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, PickupOn, EstWeight
	from	shpt._Appointment
)
GO
PRINT N'Creating [shpt].[Batch#Raw]...';


GO
--PeterHo
CREATE FUNCTION [shpt].[Batch#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, SiteID, BatchedOn, ErrorCnt
	from	shpt._Batch
)
GO
PRINT N'Creating [shpt].[Parcel#Raw]...';


GO
--PeterHo
CREATE FUNCTION [shpt].[Parcel#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, BatchID, RcvHubID, RouteID, LastMilerID
	,		ContractID,  SvcType,  SvcZone, SvcClass, POA
	,		Length,   Width,   Height, DeclaredWt, ZoneCode
	,		Weight=iif(nullif(Weight, 0) is null, DeclaredWt, Weight)
	from	shpt._Parcel
)
GO
PRINT N'Creating [shpt].[RackXact#Raw]...';


GO
--Smile
CREATE FUNCTION [shpt].[RackXact#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ParcelID, RackID, OrderInID, OrderOutID
	from	shpt._RackXact
)
GO
PRINT N'Creating [shpt].[Sack#Raw]...';


GO
--PeterHo
CREATE FUNCTION [shpt].[Sack#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, POA, SackWt, BrokerID, ClrMethodID
	from	shpt._Sack
)
GO
PRINT N'Creating [shpt].[Sack#SeqNbrOf]...';


GO
--PeterHo
CREATE FUNCTION [shpt].[Sack#SeqNbrOf](@sackID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteSack as
	(
		select	SeqDate=cast(cast(PostedOn as date) as datetime2(2))
		from	core.Matter#Raw()
		where	ID=@sackID
	)
	select	SeqNbr=count(*)%10000
	from	cteSack            x
	,		core.Matter#Type() t
	,		core.Matter#Raw()  m
	where	m.Type=t.Sack and m.ID<=@sackID
	and		m.PostedOn>=x.SeqDate and m.PostedOn<DATEADD(day, 1, x.SeqDate)
)
GO
PRINT N'Creating [shpt].[SackLoad#Raw]...';


GO
-- AaronLiu
CREATE FUNCTION [shpt].[SackLoad#Raw]()
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, TruckerID
	from	shpt._SackLoad
)
GO
PRINT N'Creating [shpt].[SackMft#Raw]...';


GO
--PeterHo
CREATE FUNCTION [shpt].[SackMft#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, POD, POA, MawbNbr, FlightNbr, BrokerID
	from	shpt._SackMft
)
GO
PRINT N'Creating [svc].[Batch$ExportError]...';


GO
--Smile, PeterHo
CREATE FUNCTION [svc].[Batch$ExportError](@batchID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) [Errors]=s.Supplement
	from	core.Registry#ID() r, core.Supplement#Raw() s
	where	s.RegID=r.ParcelBatch and s.RowID=@batchID
)
GO
PRINT N'Creating [svc].[@------------------#svc]...';


GO
--PeterHo
CREATE FUNCTION [svc].[@------------------#svc]()
RETURNS TABLE
AS RETURN (select null as [Nil])
/*
	Document comes here.
*/
GO
PRINT N'Creating [svc].[Port$List]...';


GO
--Smile
CREATE	FUNCTION [svc].[Port$List]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	Code, UtcOffset, UtcPlaceID
	from	core.Port#Raw()
)
GO
PRINT N'Creating [svc].[Commodity$Node]...';


GO
--PeterHo
CREATE FUNCTION [svc].[Commodity$Node](@parentID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with cteCmdy as
	(
		select	x.ID, x.PID, x.DutyID, x.Surcharge
		,		Path=cast(x.Name as nvarchar(max))
		from	brkg.Commodity#Raw()   x
		where	PID=@parentID and @parentID>0
		UNION	ALL
		select	x.ID, x.PID, x.DutyID, x.Surcharge
		,		Path=p.Path + N'	/	' + x.Name
		from	cteCmdy p join brkg.Commodity#Raw() x
		on		p.ID=x.PID
	)
	select	ID    =isnull(x.ID,     0), PID      =isnull(x.PID,       0)
	,		Path  =isnull(x.Path, N''), Surcharge=isnull(x.Surcharge, 0)
	,		DutyID=isnull(x.DutyID, 0), d.DutyRate,      d.DutyCode
	from	cteCmdy  x join brkg.Duty#Raw() d on d.ID=x.DutyID
	where	d.DutyRate>=0
)
GO
PRINT N'Creating [svc].[Challenge$BoundStage]...';


GO
--PeterHo
CREATE FUNCTION [svc].[Challenge$BoundStage]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	b.ID
	from	core.Stage#ID() k cross apply
	(
		select	ID=k.RouteAssigned
		--UNION	ALL
		--select	k.SackMfted
	) b
)
GO
PRINT N'Creating [svc].[Account$Lookup]...';


GO
-- Smile, PeterHo
CREATE FUNCTION [svc].[Account$Lookup]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	AID from core.Party#Raw()
		where	AID>1 group by AID
	)
	select	ID, Source, Type, Alias
	from	cte x join core.Party#Raw() p on p.ID=x.AID
	where	p.AID>1    -- eliminate Zebra's Hubs
	and		p.Source>0 -- eliminate Virtuals (Port, ...)
	
/*
	select	ID=p.AID, y.Alias
	from	core.Party#Raw()  p
	join	core.Party#Raw()  y on y.ID=p.AID
	cross	apply core.Party#Boundary() b
	where	p.AID>0 and p.Type between 	b.UserMin and b.Tenant
*/
)
GO
PRINT N'Creating [svc].[Tenancy$TenantLookup]...';


GO
--Sam
CREATE FUNCTION [svc].[Tenancy$TenantLookup]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	p.ID, p.PID, p.AID, p.Type, p.Source, p.Alias 
	from	core.Party#Raw() p, core.Party#Type() t
	where	p.Type=t.Tenant
)
GO
PRINT N'Creating [svc].[Sku$ForEndorsement]...';


GO
--SmileWang, PeterHo
CREATE FUNCTION [svc].[Sku$ForEndorsement](@clrMethodID int, @brokerID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, TenantID, Alias, SkuNbr, FiledInfo
	,		IsEndorsed=iif(d.DutyID is null, 0, 1)
	from	invt.Sku#Raw()    x
	join	core.Tenant#Raw() t on t.ID=x.TenantID
	left	join invt.SkuBrokerage#Raw() d
	on		d.SkuID=x.ID and d.ClrMethodID=@clrMethodID and d.BrokerID=@brokerID
)
GO
PRINT N'Creating [svc].[Tenancy$ZebraHubLookup]...';


GO
--Smile
CREATE FUNCTION [svc].[Tenancy$ZebraHubLookup]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	p.ID, p.PID, p.AID, p.Type, p.Source, p.Alias 
	from	core.Party#Raw() p, core.Party#Type() t
	where	p.Type=t.ZebraHub
)
GO
PRINT N'Creating [svc].[Broker$Lookup]...';


GO
--Smile
CREATE FUNCTION [svc].[Broker$Lookup]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, BrokerAlias
	from	brkg.Broker#Raw()
	where	ID>0
)
GO
PRINT N'Creating [svc].[Tenancy$Subtype]...';


GO
-- Smile
CREATE FUNCTION [svc].[Tenancy$Subtype]
(
	@parentID bigint, @typeToMatch int=0, @levelToBreak int=0
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteParty as
	(
		select	Level=0, x.ID, x.PID, x.Type, x.Alias, x.Source
		from	core.Party#Raw() x
		where	x.ID=@parentID
		UNION	ALL
		select	Level+1, c.ID, c.PID, c.Type, c.Alias, c.Source
		from	cteParty p join core.Party#Raw() c on c.PID=p.ID
		where	(@typeToMatch =0 or c.Type=@typeToMatch)
		and		(@levelToBreak=0 or Level<=@levelToBreak)
	)
	select	ID    =isnull(ID, 0),    Alias=isnull(Alias, ''), PID=isnull(PID, 0)
	,		Type  =isnull(Type, 0),  Level=isnull(Level, 0)
	,		Source=isnull(Source, 0)
	from	cteParty where ID<>@parentID
)
GO
PRINT N'Creating [svc].[Announcement$For]...';


GO
--PeterHo
CREATE	FUNCTION [svc].[Announcement$For](@source tinyint)
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, SourceID, Body
	from	core._Announcement
	where	SourceID=0
	and		EffectiveOn>=GETUTCDATE() and ExpiredOn<GETUTCDATE()
	UNION	ALL
	select	ID, SourceID, Body
	from	core._Announcement
	where	SourceID>0 and SourceID=@source
	and		EffectiveOn>=GETUTCDATE() and ExpiredOn<GETUTCDATE()
)
GO
PRINT N'Creating [svc].[RefNbr$SearchFor]...';


GO
-- Daxia, AaronLiu
CREATE FUNCTION [svc].[RefNbr$SearchFor](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with cteMatched as
	(
		select	MatterID, Type, Number
		from	core.RefNbr#Raw()
		where	Number=@number
	)
	, cteStaged as
	(
		select	x.MatterID, x.Type, x.Number, m.Stage
		from	cteMatched        x
		join	core.Matter#Raw() m on m.ID=x.MatterID
	)
	select	ID=MatterID, RefNbr=Number, Type, Stage
	from	cteStaged

	/*
	select	ID=MatterID, RefNbr=Number, Type, Stage
	from	core.RefNbr#ScanOne(@number, default, default)
	*/
)
GO
PRINT N'Creating [svc].[CurrencyRate$Summary]...';


GO
--Smile
CREATE FUNCTION [svc].[CurrencyRate$Summary]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with	cteCurrencyRate as
	(
		select	FmCurrencyID, ToCurrencyID, EffectiveOn, ForPayment, ForDeclaration
		,		Marker=Lead(FmCurrencyID) over (partition by FmCurrencyID, ToCurrencyID order by (select 0))
		from	acct.CurrencyRate#Raw()
	)
	select	FmCurrencyID, ToCurrencyID, EffectiveOn, ForPayment, ForDeclaration
	from	cteCurrencyRate
	where	Marker is null
)
GO
PRINT N'Creating [svc].[CustomerCode$Vefity]...';


GO
--Smile
CREATE	FUNCTION [svc].[CustomerCode$Vefity](@userID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID=isnull(p.ID,0), p.Alias
	from	core.Party#Raw()        x
	cross	apply core.Party#Type() k
	join	core.Party#Raw()        p on p.Source=x.Source and p.Type=k.TenantSite
	where	x.ID=@userID
)
GO
PRINT N'Creating [svc].[Tenancy$SiteVerify]...';


GO
--Aimee, Smile, Irene
CREATE FUNCTION [svc].[Tenancy$SiteVerify](@siteID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	SiteID=isnull(ID, 0)
	from	core.Party#Type() k, core.Party#Raw() x
	where	x.Type=k.TenantSite and x.ID=@siteID
)
GO
PRINT N'Creating [svc].[Setting$ByName]...';


GO
--Eason
CREATE FUNCTION [svc].[Setting$ByName](@name tvp)
RETURNS TABLE
--WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	Value
	from	core.Setting#Raw()
	where	Name=@name
)
GO
PRINT N'Creating [svc].[User$ContactName]...';


GO
--Daxia
CREATE FUNCTION [svc].[User$ContactName](@userID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, Name=isnull(Name, N''),  Handler=concat('(', x.ID, ') ', Name)
	from	core.User#Raw()           x 
	cross	apply core.Contact#Type() k
	left	join core.Contact#Raw()   c on c.PartyID=x.ID and c.Type=k.Billing
	where	x.ID=@userID
)
GO
PRINT N'Creating [svc].[User$List]...';


GO
--Simile
CREATE FUNCTION [svc].[User$List]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, RoleID, Name, Email
	from	core.User#Raw()           x
	join	core.UserRole#Raw()       u on u.UserID=x.ID
	cross	apply core.Contact#Type() k
	left	join core.Contact#Raw()   c on c.PartyID=x.ID and c.Type=k.Billing
)
GO
PRINT N'Creating [svc].[Tenancy$ZebraStoreLookup]...';


GO
--Aimee
CREATE FUNCTION [svc].[Tenancy$ZebraStoreLookup]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	p.ID, p.PID, p.AID, p.Type, p.Source, p.Alias 
	from	core.Party#Raw() p, core.Party#Type() t
	where	p.Type=t.ZebraStore
)
GO
PRINT N'Creating [svc].[Ramper$List]...';


GO
--AaronLiu
CREATE FUNCTION [svc].[Ramper$List]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, x.Alias
	from	core.Party#Type() t, core.User#Raw() x
	join	core.Party#Raw()  p on x.ID=p.ID
	where	p.Type=t.Ramper
)
GO
PRINT N'Creating [tms].[@------------------#tms]...';


GO
--PeterHo
CREATE FUNCTION [tms].[@------------------#tms]()
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN (select null as [Nil])
/*
	Document comes here.
*/
GO
PRINT N'Creating [tms].[Airline#Raw]...';


GO
-- AaronLiu
CREATE FUNCTION [tms].[Airline#Raw]()
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Alias
	from	tms._Airline
)
GO
PRINT N'Creating [tms].[BarcodeNbr#Make]...';


GO
-- PeterHo
CREATE FUNCTION [tms].[BarcodeNbr#Make](@zip5 char(5), @trackingNbr char(22))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	BarcodeNbr=concat('420', @zip5, @trackingNbr)
)
GO
PRINT N'Creating [tms].[Courier#IdOfAlias]...';


GO
--PeterHo
CREATE FUNCTION [tms].[Courier#IdOfAlias](@alias nvarchar(30))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	CourierID from tms._CourierAlias where Alias=@alias
		UNION	ALL
		select	ID from tms._Courier where Alias=@alias
		UNION	ALL
		select	0
	)
	select	top(1) CourierID from cte
)
GO
PRINT N'Creating [tms].[Courier#Raw]...';


GO
--PeterHo
CREATE FUNCTION [tms].[Courier#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, CourierCode=Code, CourierAlias=Alias
	from	tms._Courier
)
GO
PRINT N'Creating [tms].[Flight#Raw]...';


GO
-- AaronLiu
CREATE FUNCTION [tms].[Flight#Raw]()
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, POD, ETD, POA, ETA, FlightNbr, AirlineID
	from	tms._Flight
)
GO
PRINT N'Creating [tms].[Route#Raw]...';


GO
--PeterHo
CREATE FUNCTION [tms].[Route#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID,       MftGroup,  RouteCode
	,		BrokerID, CourierID, ClrMethodID, CmdyRootID, MaxSkuCnt, MaxWeight
	from	tms._Route
)
GO
PRINT N'Creating [tms].[RouteRole#For]...';


GO
--PeterHo
CREATE FUNCTION [tms].[RouteRole#For](@routeID int, @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteBranch as
	(
		select	RoleID=AltRoleID from tms._RouteBranch
		where	RouteID=@routeID and  ActionID=@actionID
		UNION	ALL
		select	@roleID
	)
	select	top(1) RoleID from cteBranch
)
GO
PRINT N'Creating [tms].[SvcClass#Raw]...';


GO
--PeterHo
CREATE FUNCTION [tms].[SvcClass#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, ClassCode, ClassAbbr, CourierID, MaxWeight
	from	tms._SvcClass
)
GO
PRINT N'Creating [tms].[SvcContract#Raw]...';


GO
--KEN
CREATE FUNCTION [tms].[SvcContract#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ContractID, SvcType 
	from	[tms].[_SvcContract]
)
GO
PRINT N'Creating [tms].[SvcFacility#Raw]...';


GO
-- Daxia
CREATE FUNCTION [tms].[SvcFacility#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, CourierID,  MailerID
	,		ImportZoneCode, POA,     SourceID
	,		[ImportZip3]=cast(LEFT(ImportZoneCode, 3) as char(3))
	,		FacilityInfo,  ShprInfo, CneeInfo, ReturnInfo
	,		[TokenID]=concat(POA, cast(CourierID as varchar(20)), cast(right('00'+cast(SourceID as varchar(2)), 2) as varchar(2)))
	from	[tms].[_SvcFacility]
)
GO
PRINT N'Creating [tms].[SvcFacZoneCode#Raw]...';


GO
-- Daxia
CREATE FUNCTION [tms].[SvcFacZoneCode#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	CourierID, FacilityID, ZoneCode
	from	tms._SvcFacZoneCode
)
GO
PRINT N'Creating [tms].[SvcRate#For]...';


GO
--PeterHo
CREATE FUNCTION [tms].[SvcRate#For](@svcType int, @rcvHubID bigint, @measuredWt real)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) SvcRate, SectionWt from tms._SvcRate
	where	(SvcType=@svcType and RcvHubID=@rcvHubID and SectionWt>=@measuredWt)
)
GO
PRINT N'Creating [tms].[SvcRoute#Raw]...';


GO
--PeterHo
CREATE FUNCTION [tms].[SvcRoute#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	SvcType, POA, Priority, RouteID
	from	tms._SvcRoute
)
GO
PRINT N'Creating [tms].[SvcToken#ID]...';


GO
-- PeterHo
create FUNCTION [tms].[SvcToken#ID] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[LAX901607]='LAX901607'
	,		[LAX901608]='LAX901608'
	,		[JFK901607]='JFK901607'
	,		[JFK901608]='JFK901608'
)
GO
PRINT N'Creating [tms].[SvcType#Major]...';


GO
--PeterHo
CREATE FUNCTION [tms].[SvcType#Major](@svcType int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteMajor as
	(
		select	Major=iif(@svcType<10000, @svcType, @svcType/10000)*10000
	)
	select	Major, Upto=Major+9999 from cteMajor
)
GO
PRINT N'Creating [tms].[SvcType#Raw]...';


GO
--PeterHo
CREATE FUNCTION [tms].[SvcType#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, TenantID, CurrencyID, DutyCurrencyID, FallbackPOA, InitStateID, InitQueue, ClrMethodID, CmdyRootID, UseFactor, UsePreCheck
	from	tms._SvcType
)
GO
PRINT N'Creating [tms].[TrackingNbr#Cast]...';


GO
-- PeterHo
CREATE FUNCTION [tms].[TrackingNbr#Cast](@number varchar(30))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	TrackingNbr=cast(right(rtrim(@number), 22) as char(22))
)
GO
PRINT N'Creating [tms].[Trucker#Raw]...';


GO
-- AaronLiu
CREATE FUNCTION [tms].[Trucker#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Alias
	from	tms._Trucker
)
GO
PRINT N'Creating [tvp].[@------------------#tvp]...';


GO
--PeterHo
CREATE FUNCTION [tvp].[@------------------#tvp]()
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN (select null as [Nil])
/*
	...
*/
GO
PRINT N'Creating [tvp].[Duad#Of]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Duad#Of](@value nvarchar(max),  @spr nvarchar(255)=N'	^	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	with	cteTally as (select [idx]=nullif(charindex(@spr, @value, 1), 0))
	select	[v1]=isnull(substring(@value, 1, idx-1),  isnull(@value,   N''))
	,		[v2]=isnull(substring(@value, idx+len(@spr), len(@value)), N'')
	from	cteTally
)
GO
PRINT N'Creating [tvp].[Newline#OfDuad]...';


GO
-- PeterHo
CREATE FUNCTION [tvp].[Newline#OfDuad](@value nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	v1, v2
	from	tvp.Duad#Of(@value, cast(char(13)+char(10) as nvarchar(255)))
)
GO
PRINT N'Creating [tvp].[Pcs#TallyR]...';


GO
-- PeterHo
CREATE FUNCTION [tvp].[Pcs#TallyR](@source nvarchar(max), @spr nvarchar(255)=N'	;	', @upto int=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteTally as
	(
		select	[Seq]=case when datalength(@source)<>0 then 1 else 0 end
		,		[Start]=1
		,		[Stop] =cast(charindex(isnull(@spr, N''), @source, 1) as int)
		UNION	ALL
		select	Seq+1
		,		[Start]=Stop + (datalength(@spr)/2)
		,		[Stop] =cast(charindex(@spr, @source, Stop+1) as int)
		from	cteTally
		where	(Stop > 0 and Stop < datalength(@source)/2) and (@upto=0 or @upto>Seq)
	)
	select	Seq, Start
	,		[Stop] =isnull(nullif(Stop, 0), isnull(cast((datalength(@source)/2)+1 as int), 0))
	from	cteTally where Seq<>0
--	option	(maxrecursion 0)
)
GO
PRINT N'Creating [tvp].[Referring#Make]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Referring#Make](@id bigint, @text nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[Tvp]=concat(@id, N'	@	', @text)
)
GO
PRINT N'Creating [tvp].[Referring#Of]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Referring#Of](@tvp nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[ID]=cast(v1 as bigint), [Text]=v2 from tvp.Duad#Of(@tvp, N'	@	')
)
GO
PRINT N'Creating [tvp].[Spr#Const]...';


GO
-- PeterHo: Keep sync with at.Spr.Xxx
CREATE FUNCTION [tvp].[Spr#Const]()
RETURNS TABLE 
WITH SCHEMABINDING
AS RETURN
(
	--(Outer and Ordered)-------------------------------------------------------------------
	select	N'	;	'	as [Entry]		-- "\t;\t"			
	,		N'	%	'	as [Block]	    -- "\t%\t"			
	,		N'	$	'	as [Field]		-- "\t&\t"  (upto 99)

	--(Inner Unbound)-----------------------------------------------------------------------
	,		N'	{	'	as [Bag]		-- "\t{\t"	(Collection)
	,		N'	/	'	as [Path]		-- "\t/\t"  (Ordered-Seq)
	,		N'	,	'	as [Many]		-- "\t,\t"  (Collection)
	,		N'	[	'	as [Mucho]		-- "\t[\t"	(Collection)
	,		N'	?	'	as [Change]		-- "\t?\t"  (Reserved)
	
	--(Inner Generic)-----------------------------------------------------------------------
	,		N'	#	'	as [Quire]	    -- "\t#\t"  (upto 24)
	,		N'	+	'	as [Dozen]	    -- "\t+\t"  (upto 12)
	,		N'	*	'	as [Tuplet]		-- "\t*\t"  (upto  9)
	,		N'	-	'	as [Quad]		-- "\t-\t"  (upto  4)
	,		N'	|	'	as [Triad]		-- "\t|\t"  (upto  3)
	,		N'	^	'	as [Duad]		-- "\t^\t"  (upto  2)
	
	--(Inner Specialized)-------------------------------------------------------------------
	,		N'	\	'	as [Log]		-- "\t\\\t" (Reserved)
	,		N'	]	'	as [Duo]		-- "\t]\t"  [Left ] Right]
	,		N'	}	'	as [Trio]		-- "\t}\t"  [Left } Mid } Right]
	,		N'	=	'	as [Pair]		-- "\t=\t"  [Left = Right]
	,		N'	~	'	as [Range]		-- "\t~\t"  [Min ~ Max]
	,		N'	!	'	as [Privacy]	-- "\t!\t"  [Public ! Proteced ! Internal ! Private]
	,		N'	:	'	as [Property]	-- "\t:\t"  [Name : Value]
	,		N'	@	'	as [Referring]	-- "\t@\t"  [ID @ Text]
)
GO
PRINT N'Creating [tvp].[Spr#Purify]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Spr#Purify] (@tvp nvarchar(max), @sprLength tinyint=3)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Tvp=isnull(stuff(@tvp, 1, @sprLength, N''), cast(N'' as nvarchar(max)))
)
GO
PRINT N'Creating [tvp].[Triad#Make]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Triad#Make](@v1 nvarchar(max), @v2 nvarchar(max), @v3 nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[Tvp]=concat(@v1, N'	|	', @v2, N'	|	', @v3)
)
GO
PRINT N'Creating [tvp].[Triad#Of]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Triad#Of](@value nvarchar(max),  @spr nvarchar(255)=N'	|	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.v1, [v2]=p.v1, [v3]=p.v2
	from	tvp.Duad#Of(@value, @spr) x
	cross	apply tvp.Duad#Of(x.v2, @spr) p
)
GO
PRINT N'Creating [tvp].[Trio#Make]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Trio#Make](@v1 nvarchar(max), @v2 nvarchar(max), @v3 nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[Tvp]=concat(@v1, k.Trio, @v2, k.Trio, @v3)
	from	tvp.Spr#Const() k
)
GO
PRINT N'Creating [tvp].[Trio#Of]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Trio#Of](@value nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.v1, [v2]=p.v1, [v3]=p.v2
	from	tvp.Spr#Const() k
	cross	apply tvp.Duad#Of(@value,k.Trio) x
	cross	apply tvp.Duad#Of(x.v2, k.Trio)  p
)
GO
PRINT N'Creating [vmi].[@------------------#vmi]...';


GO
--Smile
CREATE FUNCTION [vmi].[@------------------#vmi]()
RETURNS TABLE
AS RETURN (select null as [Nil])
/*
	Document comes here.
*/
GO
PRINT N'Creating [vmi].[Parcel$SummaryByStage]...';


GO
-- Smile
CREATE FUNCTION [vmi].[Parcel$SummaryByStage](@siteID bigint)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	select	isnull(sum(case when x.Stage >=10000 and x.Stage<12600 then 1  end),0) as AwaitingAudit
	,		isnull(sum(case when x.Stage >=12600 and x.Stage<20000 then 1  end),0) as AwaitingOutgate
	,		isnull(sum(case when x.Stage >=20000 and x.Stage<25000 then 1  end),0) as AwaitingDoorDelivery
	from	core.Matter#Raw()        x
	cross	apply core.Matter#Type() t
	cross	apply core.Source#ID()   k
	where	x.Type=t.Parcel and x.PosterID=@siteID and x.Source=k.eVMI
)
GO
PRINT N'Creating [whse].[Ramp#Routing]...';


GO
--AaronLiu
CREATE FUNCTION [whse].[Ramp#Routing] ()
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN
(
	--EX------------------------------
	select	10  as NotFound
	,		99	as UndefinedEX
	--HR------------------------------
	,		110	as HasConcern
	--OP------------------------------
	,		220	as HasChallenge
	,		221	as HasAddOnSvc
	,		230	as HasOverthrehold
	,		231	as HasFlaggedForReturn
	,		232	as HasMeasured
	,		233 as HasShippingPlan
	,		234	as ShouldRackIn
	,		250	as HasOutgated
	,		251	as HasOutboundLocked
	,		299	as UndefinedHR
	--CD------------------------------
	,		310	as ShouldOutbound	
)
GO
PRINT N'Creating [whse].[@-----------------#whse]...';


GO
--Smile
CREATE FUNCTION [whse].[@-----------------#whse]()
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN (select null as [Nil])
/*
	Document comes here.
*/
GO
PRINT N'Creating [whse].[Order#Type]...';


GO
--Smile
CREATE FUNCTION [whse].[Order#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [RackIn]
	,		2	as [RackOut]
)
GO
PRINT N'Creating [whse].[Rack#Raw]...';


GO
--Smile
CREATE FUNCTION [whse].[Rack#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, HubID, Code
	from	whse._Rack
)
GO
PRINT N'Creating [whse].[RackOrder#Raw]...';


GO
--Smile
CREATE FUNCTION [whse].[RackOrder#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, RackerID, OrderType, CreatedOn, CompletedOn
	from	whse._RackOrder
)
GO
PRINT N'Creating [whse].[StockInOrder#Raw]...';


GO
--Smile
CREATE FUNCTION [whse].[StockInOrder#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, RcvHubID, TotalSkuQty, ContractID
	from	whse._StockInOrder
)
GO
PRINT N'Creating [whse].[StorageRate#Raw]...';


GO
--Smile
CREATE FUNCTION [whse].[StorageRate#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	RcvHubID, TenantID, CurrencyID, RcvSkuFee, OutPkgFee
	,		OverWeightFee, WeightLimit, ExcessItemsFee, ItemsQtyLimit
	,		StorageCbmFee30Day, StorageCbmFee60Day, StorageCbmFeeOther
	from	whse._StorageRate
)
GO
PRINT N'Creating [xpd].[SackMft$Verify]...';


GO
--	Aimee
CREATE	FUNCTION [xpd].[SackMft$Verify](@mawbNbr char(11), @siteID int)
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	top(1) s.ID, MawbNbr 
	from	shpt.SackMft#Raw() s
	join	core.Matter#Raw()  m on m.PID=s.ID
	where	s.MawbNbr=@mawbNbr and  m.PosterID=@siteID
	order	by s.ID desc
)
GO
PRINT N'Creating [zeb].[RefNbr$Of]...';


GO
--Eva
CREATE FUNCTION [zeb].[RefNbr$Of](@matterID I64, @type E8)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Number
	from	core.RefNbr#Raw()
	where	MatterID=@matterID and Type=@type
)
GO
PRINT N'Creating [zeb].[Matter$Raw]...';


GO
-- Eva
CREATE FUNCTION [zeb].[Matter$Raw]()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	m.*
	from	core.Matter#Raw() m
)
GO
PRINT N'Creating [zeb].[Contact$Type]...';


GO
-- Eva
CREATE FUNCTION [zeb].[Contact$Type] ()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Billing
	,		Shipping
	,		Returning
	from	core.Contact#Type()
)
GO
PRINT N'Creating [zeb].[User$Role]...';


GO
-- Eva
CREATE FUNCTION [zeb].[User$Role] ()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	AcctAdmin
	,		AcctMgr
	,		AcctOP
	,		BOAdmin
	,		BOMgr
	,		BOOP
	,		ClientAdmin
	,		ClientMgr
	,		ClientOP
	,		HubAdmin
	,		HubDriver
	,		HubMgr
	,		HubOP
	,		ICAdmin
	,		ICMgr
	,		ICOP
	,		StoreAdmin
	,		StoreMgr
	,		StoreOP
	from	core.User#Role() r
)
GO
PRINT N'Creating [zeb].[RefInfo$Type]...';


GO
--Eva
CREATE FUNCTION [zeb].[RefInfo$Type]()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ShprInfo
	,		CneeInfo
	,		ReturnInfo
	,		IDInfo
	,		DeclaredInfo
	,		VerifiedInfo
	,		BrokerageInfo
	,		ShippingLabelInfo
	,		ShippingPlanInfo
	,		ConcurredInfo
	from	core.RefInfo#Type()
)
GO
PRINT N'Creating [zeb].[Queue$Type]...';


GO
-- Eva
CREATE FUNCTION [zeb].[Queue$Type]()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	StateChanged
	,		MeasureReady
	,		ShippingPlanReady
	,		ShippingPlanComplied
	,		BrokerApi
	,		Challenge
	,		PostCourierApi
	,		PreCourierApi
	,		Reminder
	from	core.Queue#Type()
)
GO
PRINT N'Creating [zeb].[Party$Type]...';


GO
-- Eva
CREATE FUNCTION [zeb].[Party$Type] ()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Staff
	,		Member
	,		Operator
	,		Facility=ZebraDiv
	,		AgentStore
	,		Associate
	,		Broker
	,		Courier
	,		Customer
	,		Customs
	,		Port
	,		Tenant
	,		TenantSite
	,		Trucker
	,		ZebraStore
	from	core.Party#Type()
)
GO
PRINT N'Creating [zeb].[RefNbr$Type]...';


GO
-- Eva
CREATE FUNCTION [zeb].[RefNbr$Type] ()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	MIT
	,		ClientRef
	,		PreCourier
	,		PostCourier
	,		MawbNbr
	,		MblNbr
	,		VenderRef
	from	core.RefNbr#Type()
)
GO
PRINT N'Creating [zeb].[Matter$Type]...';


GO
-- Eva
CREATE FUNCTION [zeb].[Matter$Type] ()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Parcel
	,		Sack
	,		SackMft
	,		Zack
	,		ZackMft
	,		ShippingPlan
	from	core.Matter#Type()
)
GO
PRINT N'Creating [zeb].[@------------------#zeb]...';


GO
--PeterHo
CREATE FUNCTION [zeb].[@------------------#zeb]()
RETURNS TABLE
AS RETURN (select null as [Nil])
/*
	Document comes here.
*/
GO
PRINT N'Creating [zeb].[Stage$ID]...';


GO
-- AaronLiu
CREATE FUNCTION [zeb].[Stage$ID]()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	HubCheckedIn
	from	core.Stage#ID()
)
GO
PRINT N'Creating [dbo].[@------------------#dbo]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[@------------------#dbo]()
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN (select null as [Nil])
/*
	...
*/
GO
PRINT N'Creating [dbo].[Bool#Const]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Bool#Const] ()
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select [true]=isnull(cast(1 as bit), 0), [false]=isnull(cast(0 as bit), 0)
)
GO
PRINT N'Creating [dbo].[Calendar#Raw]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Calendar#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Value
	,		Year,    Quarter, Month,   Week,    Day,Dow
	,		YOffset, QOffset, MOffset, WOffset, DOffset
	from	dbo._Calendar
)
GO
PRINT N'Creating [dbo].[Currency#Decode]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Currency#Decode](@amt bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[CurrencyID]=isnull(cast(abs(@amt)%100 as tinyint), 0)
)
GO
PRINT N'Creating [dbo].[Currency#ID]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Currency#ID]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	USD=1
	,		CNY=2
	,		EUR=3
	,		GBP=4
	,		JPY=5
	--------------
	,		TWD=11
	,		HKD=12
)
GO
PRINT N'Creating [dbo].[DT#Const]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[DT#Const] ()
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[Now]     = isnull(cast(getutcdate() as datetime2(2)), '')
	,		[Today]   = isnull(cast(getutcdate() as date), '')
	,		[Empty]   = isnull(cast('0001-01-01' as date), '')
	,		[Anchor]  = isnull(cast('2001-01-01' as date), '')
	,		[Infinity]= isnull(cast('9999-12-31' as date), '')
	,		[NilTick] = -2147483648
)
GO
PRINT N'Creating [dbo].[DT#Of]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[DT#Of](@value datetime2(2), @against datetime2(2)='')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	with cteArg  as
	(
		select	[Value]  =nullif(@value,   '1900-01-01')
		,		[Against]=nullif(@against, '1900-01-01')
	)
	, cteFact as
	(
		select	[Value]  =isnull(Value, Empty)
		,		[Date]   =isnull(cast(Value as date), Empty)
		,		[Time]   =isnull(cast(Value as time(0)), '')
		,		[Against]=isnull(Against, Now)
		,		Now, Today, Empty, Infinity, NilTick
		from	cteArg, dbo.DT#Const()
	)
	, ctePredicate as
	(
		select	Value, Date, Time
		,		[IsPM]      =iif(Time>'12:00:00', true, false)
		,		[IsEmpty]   =iif(Date=Empty,      true, false)
		,		[IsInfinity]=iif(Date=Infinity,   true, false)
		,		[IsTruthy]  =iif(Date=Empty or Date=Infinity, false, true)
		,		Now, Today, Empty, Infinity, NilTick, Against
		from	cteFact, dbo.Bool#Const()
	)
	, cteAged as
	(
		select	Value, Date, Time, IsPM, IsEmpty, IsInfinity, IsTruthy
		,		[DayAge] =isnull(iif(IsTruthy=0, 0, datediff(dd, Value, Against)), 0)
		,		[HourAge]=isnull(iif(IsTruthy=0, 0, datediff(hh, Value, Against)), 0)
		,		Now, Today, Empty, Infinity, NilTick, Against
		from	ctePredicate
	)
	select	Value, Date, Time, IsPM, IsEmpty, IsInfinity, IsTruthy, DayAge, HourAge
	,		[DaySpan] =isnull(HourAge / 24, 0)
	,		[HourSpan]=isnull(HourAge % 24, 0)
	,		[FallbackNow]     =iif(IsTruthy=0, Now,      Value)
	,		[FallbackToday]   =iif(IsTruthy=0, Today,    Value)
	,		[FallbackAgainst] =iif(IsTruthy=0, Against,  Value)
	,		[FallbackInfinity]=iif(IsTruthy=0, Infinity, Value)
	,		Now, Today, Empty, Infinity, NilTick
	from	cteAged
)
GO
PRINT N'Creating [dbo].[DT#ToLocal]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[DT#ToLocal](@utcTime datetime2(2), @utcOffset smallint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	LocalTime=isnull(dateadd(hour, @utcOffset, @utcTime), '0001')
)
GO
PRINT N'Creating [dbo].[Money#Of]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Money#Of](@amt bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	c.CurrencyID
	,		[RawAmt]=isnull((@amt/100)*100, 0)
	,		[DecAmt]=isnull(cast((@amt/100) as float)/100.0, 0.0)
	from	[dbo].Currency#Decode(@amt) c
)
GO
PRINT N'Creating [dbo].[Nbr#Emit]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Nbr#Emit] (@count int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with E1 (N) as
	(
		select	0 UNION ALL select 0 UNION ALL select 0 UNION ALL select 0
				  UNION ALL select 0 UNION ALL select 0 UNION ALL select 0
				  UNION ALL select 0 UNION ALL select 0 UNION ALL select 0
	)
	, E2 (N) as (select 0 from E1 a, E1 b) -- 10E+2
	, E4 (N) as (select 0 from E2 a, E2 b) -- 10E+4
	, E6 (N) as (select 0 from E4 a, E2 b) -- 10E+6
	, E8 (N) as (select 0 from E6 a, E2 b) -- 10E+8
	, EX (N) as (select 0 from E8 a, E2 b) -- 10E+10
	select	top(isnull(@count, 0))
			[Nbr]=isnull(row_number() over (order by (select 0)), 0) from EX
)
GO
PRINT N'Creating [dbo].[Nbr#Mod10]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Nbr#Mod10] (@numerics varchar(21))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteValue as
	(
		select	x.Nbr, Value=cast(substring(@numerics, x.Nbr, 1) as tinyint)
		from	dbo.Nbr#Emit(len(@numerics)) x
	)
	, cteSumToModTen as
	(
		select	ModTen=(sum(case when Nbr%2<>0 then Value end)  * 3
					   +sum(case when Nbr%2=0  then Value end)) % 10
		from	cteValue
	)
	, cteCheckDigit as
	(
		select	CheckDigit=char(iif(ModTen=0, 0, 10 - ModTen) + 48)
		from	cteSumToModTen
	)
	select	EncodedNbr=@numerics + CheckDigit, CheckDigit
	from	cteCheckDigit
)
GO
PRINT N'Creating [dbo].[Nbr#Yield]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Nbr#Yield] (@count int, @seed int, @step int=1)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[Nbr]=isnull(@seed + ((Nbr-1) * @step), 0)
	from	dbo.Nbr#Emit(@count)
)
GO
PRINT N'Creating [dbo].[DT@Anchor]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[DT@Anchor] ()
RETURNS date
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return (select Anchor from dbo.DT#Const());
END
GO
PRINT N'Creating [dbo].[DT@Empty]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[DT@Empty] ()
RETURNS date
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return (select Empty from dbo.DT#Const());
END
GO
PRINT N'Creating [dbo].[DT@Infinity]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[DT@Infinity] ()
RETURNS date
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return (select Infinity from dbo.DT#Const());
END
GO
PRINT N'Creating [acct].[Contract#For]...';


GO
--Peter, Smile
CREATE FUNCTION [acct].[Contract#For](@partyID bigint, @sourceID tinyint)
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN
(
	with cteContract as
	(
		select	c.ID, BillingCycle, DutyTerms, NonDutyTerms, BizUnitID, EffectiveOn, ExpiredOn
		,		Marker=Lead(c.ID) over(order by (select 0))
		from	core.Party#Raw()    x
		join	acct.Contract#Raw() c on c.TenantID=x.PID
		where	x.ID=@partyID and SourceID=@sourceID
		and		getutcdate() >= EffectiveOn 
		UNION	ALL
		select	ID, BillingCycle, DutyTerms, NonDutyTerms, BizUnitID, EffectiveOn, ExpiredOn
		,		Marker=Lead(x.ID) over(order by (select 0))
		from	acct.Contract#Raw() x 
		where	x.TenantID=@partyID and SourceID=@sourceID
		and		getutcdate() >= EffectiveOn 
		UNION	ALL
		select	0, 0, 0, 0, 0, '0001-01-01', '0001-01-01', null
	)
	select	top(1) ID, BillingCycle, DutyTerms, NonDutyTerms, BizUnitID, EffectiveOn, ExpiredOn
	from	cteContract     
	where	Marker is null
)
GO
PRINT N'Creating [acct].[Invoice#Raw]...';


GO
-- PeterHo
CREATE FUNCTION [acct].[Invoice#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, PartyID, VaultTag, LedgerSide, x.CurrencyID, DueDate, IssueDate, InvoicedOn
	,		DueBalance, DueBalanceRaw=m.RawAmt, DueBalanceDec=m.DecAmt
	,		InvoiceAmt, InvoiceRawAmt=i.RawAmt, InvoiceDecAmt=i.DecAmt
	,		InvoiceNbr=isnull(cast(ID as varchar(15)), 0), ContractID	
	from	[acct].[_Invoice]                x
	cross	apply dbo.Money#Of(x.DueBalance) m
	cross	apply dbo.Money#Of(x.InvoiceAmt) i
)
GO
PRINT N'Creating [acct].[Ledger#Raw]...';


GO
-- PeterHo
CREATE FUNCTION [acct].[Ledger#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID,  PartyID, MatterID,   ChargeID,  ChargeAmt
	,		x.CurrencyID,  LedgerSide, TalliedOn, InvoiceID
	,		ChargeRaw=m.RawAmt, ChargeDec=m.DecAmt
	from	[acct].[_Ledger]              x
	cross	apply dbo.Money#Of(x.ChargeAmt) m
)
GO
PRINT N'Creating [acct].[Ledger#Tvp]...';


GO
--PeterHo
CREATE FUNCTION [acct].[Ledger#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat
		(
			k.Many,	  PartyID,    k.Tuplet, ChargeID,   k.Tuplet, ChargeAmt,
			k.Tuplet, CurrencyID, k.Tuplet, LedgerSide, k.Tuplet, TalliedOn,
			k.Tuplet, InvoiceID
		)
		from	tvp.Spr#Const() k, acct.Ledger#Raw()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	Ledgers=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [brkg].[Commodity#Deep]...';


GO
--PeterHo
CREATE FUNCTION [brkg].[Commodity#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,          PID, Name,      Surcharge
	,		DutyID,        d.DutyCode,     d.DutyRate
	,		d.CountryCode, d.CommodityUoM, d.CustomsValue
	from	brkg.Commodity#Raw() x
	join	brkg.Duty#Raw() d on d.ID=x.DutyID
)
GO
PRINT N'Creating [co].[Parcel$SummaryByStage]...';


GO
-- Smile
CREATE FUNCTION [co].[Parcel$SummaryByStage](@tenantID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	select	isnull(sum(case when x.Stage between 100   and  9999 then 1 else 0 end),0) as ParcelAwaiting
	,		isnull(sum(case when x.Stage between 10000 and 19999 then 1 else 0 end),0) as ParcelProcessing
	,		isnull(sum(case when x.Stage between 20000 and 24999 then 1 else 0 end),0) as ParcelShipped	
	from	core.Matter#Raw()        x
	cross	apply core.Matter#Type() t
	where	x.Type=t.Parcel 
	and		x.PosterID in 
	(
		select	ID 
		from	core.Party#Raw()        p
		cross	apply core.Party#Type() k
		where	p.PID=@tenantID and     p.Type=k.TenantSite
	)	
)
GO
PRINT N'Creating [co].[Tenancy$UserList]...';


GO
-- Smile
CREATE FUNCTION [co].[Tenancy$UserList](@tenantID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	with	cteSubType as
	(
		select	t.ID, t.PID, Alias, t.Type, Name, Email
		from	svc.Tenancy$Subtype(@tenantID,default, default) t
		cross	apply core.Contact#Type() c
		left	join  core.Contact#Raw()  o on o.PartyID=t.ID and o.Type=c.Billing
	)
	select	x.ID, x.Alias, Name, Email, SiteID=isnull(p.ID, 0), SiteAlias=isnull(p.Alias, N'')
	from	cteSubType               x
	cross	apply core.Party#Type()  k
	left	join  core.Party#Raw()   p on p.ID=x.PID and p.Type=k.TenantSite
	where	x.Type=k.Operator and x.ID>0
)
GO
PRINT N'Creating [co].[Payment$DetailFor]...';


GO
-- Ken
CREATE FUNCTION [co].[Payment$DetailFor](@paymentID bigint,@toCurrencyID tinyint)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	select PaymentNbr, PaidAmt, ForPayment
	from   acct.Payment#Raw()         x
	join   svc.CurrencyRate$Summary() p on p.ToCurrencyID=@toCurrencyID and p.FmCurrencyID=x.CurrencyID
	where  ID= @paymentID
)
GO
PRINT N'Creating [core].[Matter#ANodeDn]...';


GO
-- AaronLiu
CREATE FUNCTION [core].[Matter#ANodeDn](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePNode as
	(
		select	Level=0,       x.ID, x.AID, x.Type, x.Source, x.Stage, x.StateID
		from	core.Matter#Raw() x
		where	x.ID=@matterID and @matterID>0
		UNION	ALL
		select	Level=Level+1, x.ID, x.AID, x.Type, x.Source, x.Stage, x.StateID
		from	ctePNode p join core.Matter#Raw() x
		on		x.AID=p.ID
	)
	select	Level, ID, AID, Type, Source, Stage, StateID from ctePNode
)
GO
PRINT N'Creating [core].[Matter#NodeDn]...';


GO
-- AaronLiu, PeterHo
CREATE FUNCTION [core].[Matter#NodeDn](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePNode as
	(
		select	Level=0,       x.ID, x.AID, x.PID, x.Type, x.Source, x.Stage, x.StateID, x.RejoinID
		from	core.Matter#Raw() x
		where	x.ID=@matterID and @matterID>0
		UNION	ALL
		select	Level=Level+1, x.ID, x.AID, x.PID, x.Type, x.Source, x.Stage, x.StateID, x.RejoinID
		from	ctePNode p join core.Matter#Raw() x
		on		x.AID=p.ID
		UNION	ALL
		select	Level=Level+1, x.ID, x.AID, x.PID, x.Type, x.Source, x.Stage, x.StateID, x.RejoinID
		from	ctePNode p join core.Matter#Raw() x
		on		x.PID=p.ID
	)
	select	Level, ID, AID, PID, Type, Source, Stage, StateID, RejoinID from ctePNode
)
GO
PRINT N'Creating [core].[UserRole#Tvp]...';


GO
-- Smile
CREATE FUNCTION [core].[UserRole#Tvp](@userID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteTvp(text) as
	(
		select	[text()]=concat( N',', x.RoleID)
		from	core.UserRole#Raw() x
		where	x.UserID=@userID
		for	xml path(N'')
	)
	select	Tvp from cteTvp cross apply tvp.Spr#Purify(text, 1)
)
GO
PRINT N'Creating [core].[RefNbr#Of]...';


GO
-- AaronLiu
CREATE FUNCTION [core].[RefNbr#Of](@matterID I64, @type E8)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Number
	from	core.RefNbr#Raw()
	where	MatterID=@matterID and Type=@type
)
GO
PRINT N'Creating [core].[AddOnSvc#Exists]...';


GO
--PeterHo
CREATE FUNCTION [core].[AddOnSvc#Exists](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	HasAddOnSvc=iif(exists(select 0 from core._AddOnSvc where MatterID=@matterID and OperatorID=0), true, false)
	from	dbo.Bool#Const()
)
GO
PRINT N'Creating [core].[AddOnSvc#Tvp]...';


GO
--EASON
CREATE FUNCTION [core].[AddOnSvc#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat
		(
			k.Many,  ID,        k.Dozen, Type, k.Dozen, OperatorID,  
			k.Dozen, StartedOn, k.Dozen, EndedOn
		)
		from	tvp.Spr#Const() k, core.AddOnSvc#Raw()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	AddOnServices=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [core].[Challenge#Exists]...';


GO
--PeterHo
CREATE FUNCTION [core].[Challenge#Exists](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	HasChallenge=iif(exists(select 0 from core._Concern where MatterID=@matterID), true, false)
	from	dbo.Bool#Const()
)
GO
PRINT N'Creating [core].[Challenge#Tvp]...';


GO
--PeterHo
CREATE FUNCTION [core].[Challenge#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
	/*
		select	[text()]=concat
		(
			k.Many, Type
		,	k.Duad,	BoundStage, k.Quad, Body, k.Quad, PostedOn
		,	k.Quad, PosterID,   k.Referring,  PosterAlias
		)
		from	tvp.Spr#Const() k, core.Challenge#Of(@matterID)
	*/
		select	[text()]=concat(k.Many, Type, k.Duad, BoundStage)
		from	tvp.Spr#Const() k, core.Challenge#Raw()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	Challenges=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [core].[Concern#Exists]...';


GO
--PeterHo
CREATE FUNCTION [core].[Concern#Exists](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	HasConcern=iif(exists(select 0 from core._Concern where MatterID=@matterID), true, false)
	from	dbo.Bool#Const()
)
GO
PRINT N'Creating [core].[Concern#Tvp]...';


GO
--PeterHo
CREATE FUNCTION [core].[Concern#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, Type, k.Duad)
		from	tvp.Spr#Const() k, core.Concern#Raw()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	Concerns=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [core].[Contact#Tvp]...';


GO
-- PeterHo
CREATE FUNCTION [core].[Contact#Tvp] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID,      PartyID, Type, IsDefault,   Name,    CountryCode, [Tvp]=concat
	(		Name,    k.Dozen, Phone,    k.Dozen, Email,       k.Dozen, Company,    k.Dozen
	,		Street1, k.Dozen, Street2,  k.Dozen, Street3,     k.Dozen, District,   k.Dozen
	,		City,    k.Dozen, Province, k.Dozen, PostalCode,  k.Dozen, CountryCode
	)from	core.Contact#Raw() cross apply tvp.Spr#Const() k
)
GO
PRINT N'Creating [core].[Contact#TvpFor]...';


GO
-- PeterHo
CREATE FUNCTION [core].[Contact#TvpFor](@partyID int, @contactType tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteContact as
	(
		select	Tvp from core.Contact#Tvp()
		where	PartyID=@partyID and Type=@contactType
		UNION	ALL
		select	Tvp from core.Contact#Tvp() cross apply core.Contact#Type() k
		where	PartyID=@partyID and Type=k.Billing
	)
	select	top(1) Tvp from cteContact
)
GO
PRINT N'Creating [core].[Contact#TvpForRefInfo]...';


GO
-- PeterHo
CREATE FUNCTION [core].[Contact#TvpForRefInfo](@partyID int, @refInfoType tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteType as
	(
		select	ContactType=case @refInfoType
				when i.ShprInfo   then c.Shipping
				when i.CneeInfo   then c.Shipping
				when i.ReturnInfo then c.Returning
				else c.Billing    end
		from	core.RefInfo#Type() i, core.Contact#Type() c
	)
	select	Tvp from cteType cross apply core.Contact#TvpFor(@partyID, ContactType)
)
GO
PRINT N'Creating [core].[Matter#ANodeUp]...';


GO
--PeterHo
CREATE FUNCTION [core].[Matter#ANodeUp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteNode as
	(
		select	Level=0, x.ID, x.AID, x.Type
		from	core.Matter#Raw() x
		where	x.ID=@matterID
		UNION	ALL
		select	Level=Level-1, x.ID, x.AID, x.Type
		from	cteNode c join core.Matter#Raw() x
		on		(c.AID>0 and c.AID=x.ID)
	)
	select	Level, ID, Type from cteNode
)
GO
PRINT N'Creating [core].[Matter#Maybe]...';


GO
-- PeterHo
CREATE FUNCTION [core].[Matter#Maybe](@matterID bigint, @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	core._Matter x
	cross	apply core.Transition#Tobe(x.StateID, @roleID, @actionID, x.RejoinID) t
	cross	apply core.Challenge#Borderline(x.ID) c
	where	x.ID=@matterID and x.LockCnt=0 and t.ToStage<=c.Borderline
)
GO
PRINT N'Creating [core].[Matter#PNodeDn]...';


GO
--PeterHo
CREATE FUNCTION [core].[Matter#PNodeDn](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePNode as
	(
		select	Level=0,       x.ID, x.PID, x.Type, x.Source, x.Stage, x.StateID, x.RejoinID
		from	core.Matter#Raw() x
		where	x.ID=@matterID and @matterID>0
		UNION	ALL
		select	Level=Level+1, x.ID, x.PID, x.Type, x.Source, x.Stage, x.StateID, x.RejoinID
		from	ctePNode p join core.Matter#Raw() x
		on		x.PID=p.ID
	)
	select	Level, ID, PID, Type, Source, Stage, StateID, RejoinID from ctePNode
)
GO
PRINT N'Creating [core].[Matter#PNodeUp]...';


GO
--PeterHo
CREATE FUNCTION [core].[Matter#PNodeUp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteNode as
	(
		select	Level=0, x.ID, x.PID, x.Type, x.Stage, x.StateID
		from	core.Matter#Raw() x
		where	x.ID=@matterID
		UNION	ALL
		select	Level=Level-1, x.ID, x.PID, x.Type, x.Stage, x.StateID
		from	cteNode c join core.Matter#Raw() x
		on		(c.PID>0 and c.PID=x.ID)
	)
	select	Level, ID, Type, Stage, StateID from cteNode
)
GO
PRINT N'Creating [core].[Matter#Tobe]...';


GO
-- PeterHo
CREATE FUNCTION [core].[Matter#Tobe](@matterID bigint, @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	core._Matter x cross apply core.Transition#Tobe(x.StateID, @roleID, @actionID, x.RejoinID) t
	where	x.ID=@matterID
)
GO
PRINT N'Creating [core].[Message#BodyOfLast]...';


GO
--Smile
CREATE FUNCTION [core].[Message#BodyOfLast](@regID int, @rowID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) Body=last_value(Body) over(order by (select 0)) 
	from	core.Message#Raw()
	where	RegID=@regID and RowID=@rowID
)
GO
PRINT N'Creating [core].[Message#Of]...';


GO
--PeterHo
CREATE FUNCTION [core].[Message#Of](@regID int, @rowID bigint, @auxID tinyint=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID=isnull(row_number() over (order by (select 0)), 0)
	,		RegID,    RowID,    AuxID,      Body
	,		PostedOn, PosterID, PosterAlias=u.Alias
	from	core.Message#Raw() x
	join	core.User#Raw()    u on u.ID=x.PosterID
	where	x.RegID=@regID and x.RowID=@rowID and (nullif(@auxID, 0) is null or x.AuxID=@auxID)
)
GO
PRINT N'Creating [core].[Party#PNodeDn]...';


GO
--PeterHo
CREATE FUNCTION [core].[Party#PNodeDn](@partyID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePNode as
	(
		select	Level=0,       x.ID, x.PID, x.Type, x.Source, Alias=cast(x.Alias as nvarchar(max))
		from	core.Party#Raw() x
		where	x.ID=@partyID and @partyID>0
		UNION	ALL
		select	Level=Level+1, x.ID, x.PID, x.Type, x.Source, p.Alias + N'	/	' + x.Alias
		from	ctePNode p join core.Party#Raw() x
		on		x.PID=p.ID
	)
	select	Level =isnull(Level,   0)
	,		ID    =isnull(ID,      0)
	,		PID   =isnull(PID,     0)
	,		Type  =isnull(Type,    0)
	,		Source=isnull(Source,  0)
	,		Alias =isnull(Alias, N'')
	from	ctePNode
)
GO
PRINT N'Creating [core].[Party#PNodeUp]...';


GO
--Smile
CREATE FUNCTION [core].[Party#PNodeUp](@partyID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePNode as
	(
		select	Level=0,       x.ID, x.PID, x.Type, x.Source, x.Alias 
		from	core.Party#Raw() x
		where	x.ID=@partyID and @partyID>0
		UNION	ALL
		select	Level=Level-1, x.ID, x.PID, x.Type, x.Source, x.Alias 
		from	ctePNode p join core.Party#Raw() x
		on		(p.PID>0 and x.ID=p.PID)
	)
	select	Level, ID, PID, Type, Source, Alias from ctePNode
)
GO
PRINT N'Creating [core].[RefInfo#Of]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefInfo#Of](@matterID bigint, @type tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) Info
	from	core.RefInfo#Raw()
	where	MatterID=@matterID and Type=@type
)
GO
PRINT N'Creating [core].[RefInfo#Tvp]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefInfo#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, Type, k.Duad, Info)
		from	tvp.Spr#Const() k, core.RefInfo#Raw()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	RefInfos=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [core].[RefInfo#VerifiedOrDeclared]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefInfo#VerifiedOrDeclared](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) x.Info
	from	core.RefInfo#Type() k
	cross	apply
	(
		select	Info from core.RefInfo#Of(@matterID, k.VerifiedInfo)
		UNION	ALL
		select	Info from core.RefInfo#Of(@matterID, k.DeclaredInfo)
	) x
)
GO
PRINT N'Creating [core].[RefNbr#IdOfFirst]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefNbr#IdOfFirst](@number varchar(40), @type tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) MatterID
	from	core.RefNbr#Raw()
	where	Number=@number and Type=@type
)
GO
PRINT N'Creating [core].[RefNbr#IdOfLast]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefNbr#IdOfLast](@number varchar(40), @type tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) MatterID=last_value(MatterID) over (order by (select 0))
	from	core.RefNbr#Raw()
	where	Number=@number and Type=@type
)
GO
PRINT N'Creating [core].[RefNbr#MatchOne]...';


GO
--PeterHo, Aaron
CREATE FUNCTION [core].[RefNbr#MatchOne]
(
	@number varchar(40), @minStage int=100, @maxStage int=25500
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteMatched as
	(
		select	MatterID, Type, Number
		,		Marker=row_number() over(partition by MatterID order by Type)
		from	core.RefNbr#Raw()
		where	Number=@number
	)
	, cteStaged as
	(
		select	x.MatterID, x.Type, x.Number, m.Stage
		from	cteMatched        x
		join	core.Matter#Raw() m on m.ID=x.MatterID
		where	Marker=1 and (m.Stage between @minStage and @maxStage)
	)
	select	top(1) MatchedCnt=count(*) over()
	,		MatterID, Type, Number, Stage
	from	cteStaged
)
GO
PRINT N'Creating [core].[RefNbr#ScanOne]...';


GO
--PeterHo, Aaron
CREATE FUNCTION [core].[RefNbr#ScanOne]
(
	@number varchar(40), @minStage int=100, @maxStage int=25500
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteScaned as
	(
		select	Number,   MatterID, Type, Stage
		from	core.RefNbr#MatchOne(@number, @minStage, @maxStage)
		where	MatchedCnt=1
		union	all
		select	n.Number, MatterID, Type, Stage
		from	core.RefNbr#DecodeOne(@number) x
		cross	apply core.RefNbr#MatchOne(x.Number, @minStage, @maxStage) n
		where	MatchedCnt=1
	)
	select	top(1) Number,   MatterID, Type, Stage
	from	cteScaned
/*
	select	top(1) Number, MatterID, Type, Stage
	from	core.RefNbr#MatchOne(@number, @minStage, @maxStage)
	where	MatchedCnt=1
*/
)
GO
PRINT N'Creating [core].[RefNbr#Tvp]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefNbr#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, Type, k.Duad, Number)
		from	tvp.Spr#Const() k, core.RefNbr#Raw()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	RefNbrs=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [core].[RefParty#Deep]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefParty#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.MatterID,     x.PartyRole,    x.PartyID,        PartyAlias=p.Alias
	,		PartyPID=p.PID, PartyAID=p.AID, PartyType=p.Type, PartySource=p.Source
	from	core.RefParty#Raw() x join core.Party#Raw() p on p.ID=x.PartyID
)
GO
PRINT N'Creating [core].[RefParty#Of]...';


GO
--AaronLiu
CREATE FUNCTION [core].[RefParty#Of](@matterID bigint, @partyRole tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) PartyID
	from	core.RefParty#Raw()
	where	MatterID=@matterID and PartyRole=@partyRole
)
GO
PRINT N'Creating [core].[RefParty#Tvp]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefParty#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, PartyRole, k.Triad, PartyID, k.Triad, PartyAlias)
		from	tvp.Spr#Const() k, core.RefParty#Deep()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	RefParties=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [core].[RefStamp#Deep]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefStamp#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID,   StateID
	,		UtcTime,    x.UtcOffset
	,		UtcPlaceID, t.UtcPlace
	from	core.RefStamp#Raw() x
	join	core.Tenant#Raw()   t on t.ID=x.UtcPlaceID
)
GO
PRINT N'Creating [core].[RefStamp#Of]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefStamp#Of](@matterID bigint, @stateID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) UtcTime, UtcOffset, UtcPlaceID, UtcPlace
	from	core.RefStamp#Deep()
	where	MatterID=@matterID and StateID=@stateID
)
GO
PRINT N'Creating [core].[RefStamp#Tvp]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefStamp#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, StateID, k.Duad
		,		UtcTime, k.Trio, UtcOffset, k.Trio, UtcPlaceID, k.Duo, UtcPlace)
		from	tvp.Spr#Const() k, core.RefStamp#Deep()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	RefStamps=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [core].[RoleID#Tvp]...';


GO
-- Eva, PeterHo
CREATE FUNCTION [core].[RoleID#Tvp](@userID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte (text) as
	(
		select	[text()]=concat(N',', RoleID)
		from	core._UserRole
		where	UserID=@userID
		for		xml path(N'')
	)
	select	RoleIDs=Tvp from cte cross apply tvp.Spr#Purify(text, 1)
)
GO
PRINT N'Creating [core].[Todo#For]...';


GO
-- PeterHo
CREATE FUNCTION [core].[Todo#For](@userID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	t.RoleID, ActionID, ToSource
	,		FirstDue=min(DueOn)
	,		TotalCnt=isnull(count(distinct MatterID), 0)
	from	core._UserRole  x
	join	core.Todo#Raw() t on t.RoleID=x.RoleID
	where	x.UserID=@userID
	group	by t.RoleID, ActionID, ToSource
)
GO
PRINT N'Creating [core].[Transition#Debug]...';


GO
-- PeterHo
CREATE FUNCTION [core].[Transition#Debug]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	OnStateID, OnState=o.Name
	,		RoleID,    Role   =r.Name
	,		ActionID,  Action =a.Name, LoopEntryID
	,		ToStateID, ToState=t.Name
	,		OutboundQ, TodoHours
	from	core.Transition#Raw() x
	join	core._State  o on o.ID=x.OnStateID
	join	core._State  t on t.ID=x.ToStateID
	join	core._Action a on a.ID=x.ActionID
	join	core._Role   r on r.ID=x.RoleID
)
GO
PRINT N'Creating [core].[Transition#Todo]...';


GO
-- PeterHo
CREATE FUNCTION [core].[Transition#Todo](@onStateID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, RoleID, k.Duad, ActionID)
		from	tvp.Spr#Const() k, core.Transition#Raw()
		where	OnStateID=@onStateID and RoleID>0
		for		xml path(N'')
	)
	select	RoledActions=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [hub].[Parcel$ShippingPlanVia]...';


GO
-- Eva
CREATE FUNCTION [hub].[Parcel$ShippingPlanVia](@number varchar(40))
RETURNS TABLE
--, ENCRYPTION
WITH SCHEMABINDING
AS RETURN 
(
	select	ID=x.MatterID, x.Number, ShippingPlan=i.Info
	from	core.RefNbr#ScanOne(@number, default, default)        x
	cross	apply core.RefInfo#Type()                             t
	cross	apply core.RefInfo#Of(x.MatterID, t.ShippingPlanInfo) i
	cross	apply core.Matter#Type()                              mt
	where	x.Type=mt.Parcel
)
GO
PRINT N'Creating [hub].[Trucker$List]...';


GO
-- AaronLiu
CREATE FUNCTION [hub].[Trucker$List]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Alias
	from	tms.Trucker#Raw()
)
GO
PRINT N'Creating [hub].[RackOutOrder$ListFor]...';


GO
-- Smile
CREATE FUNCTION [hub].[RackOutOrder$ListFor](@userID int, @orderID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	ID=ParcelID, ParcelNbr=format(ParcelID %1000000, '000000')
	,		RackID,      RackCode=a.Code
	from	whse.RackOrder#Raw() x
	join	shpt.RackXact#Raw()  r on x.ID=r.OrderOutID
	join	whse.Rack#Raw()      a on a.ID=r.RackID
	where	x.RackerID=@userID and x.ID=@orderID

)
GO
PRINT N'Creating [hub].[Parcel$CheckForRackOut]...';


GO
-- Smile
CREATE FUNCTION [hub].[Parcel$CheckForRackOut](@number varchar(40), @orderID int, @userID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	d.ID
	from	whse.RackOrder#Raw()    x
	cross	apply core.RefNbr#ScanOne(@number, default, default) m
	join	core.Matter#Raw()       d on d.ID=m.MatterID
	join	shpt.RackXact#Raw()     r on r.OrderOutID=x.ID and r.ParcelID=m.MatterID
	cross	apply core.State#ID()   k
	where	x.ID=@orderID and x.RackerID=@userID and d.StateID=k.TobeRackedOut
	
)
GO
PRINT N'Creating [hub].[Sack#Parcels]...';


GO
-- Eva
CREATE FUNCTION [hub].[Sack#Parcels](@sackID I64)
RETURNS	TABLE
--WITH ENCRYPTION
AS RETURN
(
	select	ParcelCnt = isnull(sum(case when m.Type in (t.Parcel, t.HouseParcel, t.MasterParcel, t.MediumParcel, t.OrphanParcel, t.UnityParcel) then 1 else 0 end),0)
	from	core.Matter#PNodeDn(@sackID) m
	cross	apply core.Matter#Type()     t
)
GO
PRINT N'Creating [hub].[Parcel$ScanOneForTearOff]...';


GO
-- AaronLiu
CREATE FUNCTION [hub].[Parcel$ScanOneForTearOff](@number varchar(40))
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ID=MatterID, Type, Stage
	from	core.RefNbr#ScanOne(@number, default, default)
)
GO
PRINT N'Creating [shpt].[Siblings#CntInRack]...';


GO
-- AaronLiu
CREATE FUNCTION [shpt].[Siblings#CntInRack](@parcelID I64)
RETURNS TABLE
-- WITH ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	x.ParcelID, m.AID
		from	shpt.RackXact#Raw()	x, core.Matter#Raw() m
		where	x.ParcelID=m.ID and m.AID>0
	), cteP as
	(
		select	Cnt=count(1)	
		from	cte x, cte m
		where	x.ParcelID=@parcelID and x.AID=m.AID
	)
	select	Cnt
	from	cteP
)
GO
PRINT N'Creating [shpt].[Parcel#PreSorting]...';


GO
--AaronLiu
CREATE FUNCTION [shpt].[Parcel#PreSorting](@pracelID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with	cteScaned as
	(
		select	x.ID,		  x.Stage
		,		r.HasConcern, r.HasChallenge, r.HasAddOnSvc
		from	whse.Ramp#Routing() r, core.Matter#Raw() x
		where	x.ID=@pracelID
	),	cteSorting as
	(
		select	Code=NotFound
		from	whse.Ramp#Routing()
		where	@pracelID is null
		union	all
		select	Code=x.HasConcern
		from	cteScaned x
		cross	apply core.Concern#Exists(x.ID) c
		where	c.HasConcern=1
		union	all
		select	Code=x.HasChallenge
		from	cteScaned x
		cross	apply core.Challenge#Exists(x.ID) c
		where	c.HasChallenge=1
		union	all
		select	Code=x.HasAddOnSvc
		from	cteScaned x
		cross	apply core.AddOnSvc#Exists(x.ID) a
		where	a.HasAddOnSvc=1
	)
	select	top(1) Code from cteSorting
)
GO
PRINT N'Creating [shpt].[Parcel#Sorting]...';


GO
--AaronLiu
CREATE FUNCTION [shpt].[Parcel#Sorting](@pracelID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with	cteScaned as
	(
		select	x.ID,				  x.Stage
		,		r.HasOverthrehold,	  r.HasFlaggedForReturn,  r.HasMeasured,			 r.HasShippingPlan
		,		r.ShouldRackIn,		  r.HasOutgated,		  r.HasOutboundLocked,		 r.ShouldOutbound
		,		r.UndefinedEX,		  r.UndefinedHR
		,		s.HubMeasured,		  s.Racking,			  b.PostMin,				 b.CurMin
--------------------------------------------------------------------------------------------------------------------HACK Add below to Stage#ID()
		,		Overthreshold=10545,  FlaggedForReturn=10550, ShippingPlanCocured=11900, ToRacking=11410
		,		OutboundLocked=18000, OutboundStart=14000
--------------------------------------------------------------------------------------------------------------------HACK Add above to Stage#ID()
		from	core.Matter#Raw()			x
		cross	apply core.Stage#ID()		s
		cross	apply whse.Ramp#Routing()	r
		cross	apply core.Stage#Boundary() b
		where	x.ID=@pracelID
	),	cteSorting as
	(
		select	Code					 from shpt.Parcel#PreSorting(@pracelID)
		union	all
		select	Code=HasOverthrehold	 from cteScaned where Stage=Overthreshold
		union	all						 
		select	Code=HasFlaggedForReturn from cteScaned where Stage=FlaggedForReturn
		union	all						 
		select	Code=HasMeasured		 from cteScaned where Stage=HubMeasured
		union	all						 
		select	Code=HasShippingPlan	 from cteScaned where Stage=ShippingPlanCocured
		union	all						 
		select	Code=ShouldRackIn		 from cteScaned where Stage=ToRacking
		union	all						 
		select	Code=HasOutgated		 from cteScaned where Stage>PostMin
		union	all						 
		select	Code=HasOutboundLocked	 from cteScaned where Stage>OutboundLocked
		union	all						 
		select	Code=ShouldOutbound		 from cteScaned where Stage>OutboundStart
		union	all						 
		select	Code=UndefinedHR		 from cteScaned where Stage>CurMin
		union	all						 
		select	Code=UndefinedEX		 from cteScaned
	)
	select	top(1) Code from cteSorting
)
GO
PRINT N'Creating [shpt].[Parcel#Maybe]...';


GO
--PeterHo
CREATE FUNCTION [shpt].[Parcel#Maybe](@id bigint, @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID, ActionID, OnStateID, ToStateID, ToStage, Source, OutboundQ, TodoHours
	from	shpt.Parcel#Raw() p
	cross	apply tms.RouteRole#For(p.RouteID, @roleID, @actionID) r
	cross	apply core.Matter#Maybe(p.ID,     r.RoleID, @actionID) t
	where	p.ID=@id
)
GO
PRINT N'Creating [shpt].[Parcel#Tobe]...';


GO
--PeterHo
CREATE FUNCTION [shpt].[Parcel#Tobe](@id bigint, @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID, ActionID, OnStateID, ToStateID, ToStage, Source, OutboundQ, TodoHours
	from	shpt.Parcel#Raw() p
	cross	apply tms.RouteRole#For(p.RouteID, @roleID, @actionID) r
	cross	apply core.Matter#Tobe (p.ID,     r.RoleID, @actionID) t
	where	p.ID=@id
)
GO
PRINT N'Creating [svc].[Commodity$Root]...';


GO
--PeterHo
CREATE FUNCTION [svc].[Commodity$Root](@cmdyRootID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	c.ID, c.PID, [Path]=c.Name
	,		c.Surcharge, c.DutyID, c.DutyRate, c.DutyCode
	from	brkg.Commodity#Raw()   x
	join	brkg.Commodity#Deep()  c on c.PID=x.ID
	where	x.PID=0 and x.ID=@cmdyRootID
)
GO
PRINT N'Creating [svc].[Commodity$Fuzzy]...';


GO
--PeterHo
CREATE FUNCTION [svc].[Commodity$Fuzzy](@countryCode char(2))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	c.ID, c.PID, [Path]=c.Name
	,		c.Surcharge, c.DutyID, c.DutyRate, c.DutyCode
	from	brkg.Commodity#Raw()   x
	join	brkg.Commodity#Deep()  c on c.PID=x.ID
	where	x.PID=0 and x.Name=cast(@countryCode + N'F' as nvarchar(50))
)
GO
PRINT N'Creating [svc].[Batch$Summary]...';


GO
--PeterHo
CREATE FUNCTION [svc].[Batch$Summary](@siteID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with cteSummary as
	(
		select	x.ID, x.BatchedOn, x.ErrorCnt, t.UtcOffset
		,		FailureCnt=isnull(count(case when p.SvcZone=0 then 1        end), 0)
	--	,		FailureWt =isnull(sum  (case when p.SvcZone=0 then p.Weight end), 0)
		,		SuccessCnt=isnull(count(case when p.SvcZone>0 then 1        end), 0)
	--	,		SuccessWt =isnull(sum  (case when p.SvcZone>0 then p.Weight end), 0)
		from	shpt.Batch#Raw()  x
		join	core.Tenant#Raw() t on t.ID=x.SiteID
		join	shpt.Parcel#Raw() p on p.BatchID=x.ID
		where	x.SiteID=@siteID
		group	by x.ID, x.ErrorCnt, x.BatchedOn, t.UtcOffset
	)
	select	ID, ErrorCnt, FailureCnt, SuccessCnt, BatchedOn=l.LocalTime
	from	cteSummary cross apply dbo.DT#ToLocal(BatchedOn, UtcOffset) l
)
GO
PRINT N'Creating [svc].[Tenancy$For]...';


GO
--Eva, PeterHo
CREATE FUNCTION [svc].[Tenancy$For](@userID int)
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	Tvp=concat(p.ID, k.Quad, p.PID, k.Quad, p.AID, k.Quad, x.Alias, k.Duad, r.RoleIDs)
	from	tvp.Spr#Const()  k, core.User#Raw() x
	join	core.Party#Raw() p  on p.ID=x.ID
	cross	apply core.RoleID#Tvp(x.ID) r
	where	x.ID=@userID
)
GO
PRINT N'Creating [svc].[Account$InvoiceSummary]...';


GO
-- Smile
CREATE FUNCTION [svc].[Account$InvoiceSummary]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, PartyID, PartyAlias=Alias, InvoiceNbr, CurrencyID, VaultTag
	,		InvoiceAmt=isnull(InvoiceAmt,0), DueBalance=isnull(DueBalance,0)
	,		InvoicedOn=isnull(InvoicedOn, '0001-01-01')
	from	acct.Invoice#Raw()  x
	join	core.Party#Raw()    p on x.PartyID=p.ID
	join	acct.Contract#Raw() c on c.ID=x.ContractID
	where	x.ID>0	and x.DueBalance>0 and c.BillingCycle>0
)
GO
PRINT N'Creating [svc].[Account$InvoiceList]...';


GO
--Ken, PeterHo, Smile
CREATE FUNCTION [svc].[Account$InvoiceList]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID,	    CurrencyID, DueBalance,  InvoiceAmt
	,		InvoicedOn, InvoiceNbr, x.VaultTag, x.PartyID, Alias
	,		DueDate, RemainingDays=datediff(day, getutcdate(), DueDate)
	from	acct.Invoice#Raw()       x
	join	core.Party#Raw()         p  on p.ID = x.PartyID
	join	acct.Contract#Raw()      c on c.ID=x.ContractID
	where	x.DueBalance>0  and c.BillingCycle>0
)
GO
PRINT N'Creating [svc].[Commodity$FuzzyRoot]...';


GO
--Daxia
CREATE FUNCTION [svc].[Commodity$FuzzyRoot](@svcType int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	c.ID, c.PID, Path
	,		Surcharge,   DutyID, DutyRate, DutyCode
	from	tms.SvcType#Raw()    x
	cross	apply svc.Commodity$Root(x.CmdyRootID) c
	where	x.ID=@svcType
)
GO
PRINT N'Creating [svc].[Parcel$ScanOne]...';


GO
-- Eason
CREATE FUNCTION [svc].[Parcel$ScanOne](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	r.Number
	from	core.RefNbr#MatchOne(@number, 1, 25500) x 
	cross	apply core.RefNbr#Type()              t
	join	core.RefNbr#Raw()                     r on r.MatterID=x.MatterID and r.Type=t.MIT
	where	MatchedCnt=1
)
GO
PRINT N'Creating [svc].[MftGroup$Lookup]...';


GO
--Ken
CREATE FUNCTION [svc].[MftGroup$Lookup]()
RETURNS TABLE
WITH SCHEMABINDING--,ENCRYPTION
AS RETURN
(
	select	MftGroup from tms.Route#Raw() r
	where	r.ID>0   group by MftGroup
)
GO
PRINT N'Creating [svc].[Tenancy$UserInfoList]...';


GO
--Smile
CREATE FUNCTION [svc].[Tenancy$UserInfoList]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, x.Alias, x.Source, Name, Email, TenantID=a.ID, TenantAlias=a.Alias
	,		SiteID=iif(x.AID=x.PID, 0, p.ID), SiteAlias=iif(x.AID=x.PID, N'', p.Alias)
	,		BizUnitID, BizUnit=d.Alias
	from	core.Party#Raw()          x 
	join	core.Party#Raw()          p on p.ID=x.PID
	join	core.Party#Raw()          a on a.ID=x.AID
	cross	apply acct.Contract#For(a.ID, a.Source) o
	join	core.Party#Raw()          d on d.ID=o.BizUnitID
	cross	apply core.Party#Type()   k
	cross	apply core.Contact#Type() t
	left	join core.Contact#Raw()   c on c.PartyID=x.ID and c.Type=t.Billing
	where	x.Type=k.Operator
)
GO
PRINT N'Creating [svc].[Tenancy$TenantInfoList]...';


GO
--Smile
CREATE FUNCTION [svc].[Tenancy$TenantInfoList]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, x.Alias, x.Source, UtcPlace, UtcOffset, Contact=c.Tvp
	,		BizUnitID, BizUnit=b.Alias, BillingCycle, DutyTerms, NonDutyTerms
	,		EffectiveOn=isnull(EffectiveOn, ''), ExpiredOn=isnull(ExpiredOn, '')
	from	core.Party#Raw()           x 
	join	core.Tenant#Raw()          p on p.ID=x.ID
	cross	apply acct.Contract#For(p.ID, p.Source) r
	join	core.Party#Raw()           b on b.ID=r.BizUnitID
	cross	apply core.Contact#Type()  k
	outer	apply core.Contact#TvpFor( x.ID, k.Billing) c 
	cross	apply core.Party#Type()    t
	where	x.ID>0 and x.Type=t.Tenant
)
GO
PRINT N'Creating [svc].[Tenancy$SiteInfoList]...';


GO
--Smile
CREATE FUNCTION [svc].[Tenancy$SiteInfoList]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, x.Alias, x.Source, TenantID=x.PID, TenantAlias=d.Alias
	,		UtcPlace, UtcOffset, Shipping=s.Tvp, Returning=r.Tvp
	from	core.Party#Raw()           x 
	join	core.Party#Raw()           d on d.ID=x.PID
	join	core.Tenant#Raw()          t on x.ID=t.ID
	cross	apply core.Contact#Type()  k
	outer	apply core.Contact#TvpFor(x.ID, k.Shipping)  s
	outer	apply core.Contact#TvpFor(x.ID, k.Returning) r 
	cross	apply core.Party#Type()    p
	where	x.Type=p.TenantSite and x.ID>0
)
GO
PRINT N'Creating [svc].[Tenancy$SiteList]...';


GO
--Smile
CREATE FUNCTION [svc].[Tenancy$SiteList]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, x.Alias, TenantID=x.PID, TenantAlias=d.Alias, x.Source, t.UtcPlace, t.UtcOffset
	,		BizUnitID, BizUnit=b.Alias
	from	core.Party#Raw()         x
	join	core.Party#Raw()         d on d.ID=x.PID
	join	core.Tenant#Raw()        t on x.ID=t.ID
	cross	apply acct.Contract#For(d.ID, d.Source) c 
	join	core.Party#Raw()         b on b.ID=c.BizUnitID
	cross	apply core.Party#Type()  k
	where	x.Type=k.TenantSite
)
GO
PRINT N'Creating [svc].[SalesRep$Lookup]...';


GO
--PeterHo
CREATE FUNCTION [svc].[SalesRep$Lookup]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Level, ID, PID, Type,  Source, Alias
	from	core.Party#Type()      k
	,		core.Party#PNodeDn(1)  x -- 1: Zebra HQ
	where	x.Type=k.SalesRep
)
GO
PRINT N'Creating [svc].[BizUnit$Lookup]...';


GO
--PeterHo
CREATE FUNCTION [svc].[BizUnit$Lookup]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Level, ID, PID, Type,  Source, Alias
	from	core.Party#Type()      k
	,		core.Party#PNodeDn(1)  x -- 1: Zebra HQ
	where	x.Type in (k.ZebraDiv, k.ZebraDept)
)
GO
PRINT N'Creating [svc].[Payment$Summary]...';


GO
-- Smile
CREATE FUNCTION [svc].[Payment$Summary]()
RETURNS TABLE
--WITH ENCRYPTION
AS RETURN
(
	select	x.ID, TenantID=x.PartyID, TenantAlias=t.Alias, CurrencyID, PayMethod, PaidAmt, PaidOn
	,		BizUnitID, BizUnit=p.Alias, Supplement	
	from	acct.Payment#Raw() x
	join	core.Party#Raw()   t on t.ID=x.PartyID
	cross	apply acct.Contract#For(x.PartyID, t.Source) c
	join	core.Party#Raw()   p on p.ID=c.BizUnitID
	cross	apply core.Registry#ID()   k
	left	join core.Supplement#Raw() s on s.RegID=k.Payment and s.RowID=x.ID
	where	x.ID>1 and XID<1
)
GO
PRINT N'Creating [svc].[SvcContract$For]...';


GO
--Ken, Smile
CREATE FUNCTION [svc].[SvcContract$For](@partyID int)
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	SvcType
	from	core.Party#Raw()                        p
	cross	apply acct.Contract#For(P.ID, p.Source) x
	join	tms.SvcContract#Raw()                   s on s.ContractID=x.ID
	where	p.ID=@partyID and x.ID>0

)
GO
PRINT N'Creating [svc].[User$Summary]...';


GO
--Smile
CREATE FUNCTION [svc].[User$Summary]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, Alias, RoleTvps=r.Tvp, Name, Email
	from	core.User#Raw()           x
	cross	apply core.Contact#Type() k
	left	join core.Contact#Raw()   c on c.PartyID=x.ID and c.Type=k.Billing
	cross	apply core.UserRole#Tvp(x.ID) r 
)
GO
PRINT N'Creating [svc].[Contact$List]...';


GO
--AaronLiu
CREATE FUNCTION [svc].[Contact$List]()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ID, PartyID, Type, IsDefault, Tvp
	from	core.Contact#Tvp()
)
GO
PRINT N'Creating [svc].[Account$StorageFees]...';


GO
-- Ken
CREATE FUNCTION [svc].[Account$StorageFees]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, m.Source, TenantID=p.ID, PartyAlias=Alias
	,		Supplement, TalliedOn, ChargeAmt, CurrencyID, ChargeID 
	from	acct.Ledger#Raw()          x
	cross	apply core.Matter#Type()   k
	join	core.Matter#Raw()          m on m.ID=x.MatterID and m.Type=k.StorageFee
	join	core.Tenant#Raw()          p on p.ID=x.PartyID
	cross	apply core.Registry#ID()   r 
	join	core.Supplement#Raw() s on s.RegID=r.Ledger and s.RowID=x.ID

)
GO
PRINT N'Creating [svc].[Parcel$DetailForSubscribe]...';


GO
-- AaronLiu
CREATE FUNCTION [svc].[Parcel$DetailForSubscribe](@mic varchar(40))
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	ID=x.MatterID, SubscribeNbr=a.RefNbr
	from	api.ActivitySubscription#Raw() a, core.RefNbr#ScanOne(@mic, default, default) x
	where	x.MatterID=a.MatterID
)
GO
PRINT N'Creating [svc].[Account$AssortedFees]...';


GO
-- Ken
CREATE FUNCTION [svc].[Account$AssortedFees]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, TenantID=p.ID, Alias, m.Source, Supplement
	,		ChargeAmt, TalliedOn, ChargeID, CurrencyID, ClientRefNbr=b.Number 
	from	acct.Ledger#Raw()          x
	cross	apply core.Matter#Type()   k
	join	core.Matter#Raw()          m on m.ID=x.MatterID and m.Type=k.AssortedFees
	join	core.Tenant#Raw()          p on p.ID=x.PartyID
	cross	apply core.RefNbr#Type()   t
	join	core.RefNbr#Raw()          b on b.MatterID=m.ID and b.Type=t.ClientRef
	cross	apply core.Registry#ID()   r 
	join	core.Supplement#Raw()      s on s.RegID=r.AssortedFees and s.RowID=m.ID

)
GO
PRINT N'Creating [tms].[CheckDigit#For]...';


GO
-- PeterHo
CREATE FUNCTION [tms].[CheckDigit#For](@pic char(21))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteValue as
	(
		select	x.Nbr, Value=cast(substring(@pic, x.Nbr, 1) as tinyint)
		from	dbo.Nbr#Emit(len(@pic)) x
	)
	, cteSumToModTen as
	(
		select	ModTen=(sum(case when Nbr%2<>0 then Value end)  * 3
					   +sum(case when Nbr%2=0  then Value end)) % 10
		from	cteValue
	)
	select	CheckDigit=char(iif(ModTen=0, 0, 10 - ModTen) + 48)
	from	cteSumToModTen
)
GO
PRINT N'Creating [tms].[SvcClass#For]...';


GO
-- Eason, Smile
CREATE FUNCTION [tms].[SvcClass#For](@svcType int, @weight real)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	SvcType, SvcClass=c.ID
		from	tms.SvcType#Raw()  x
		join	tms.SvcRoute#Raw() s on s.SvcType=x.ID
		join	tms.Route#Raw()    r on r.ID=s.RouteID
		join	tms.SvcClass#Raw() c on c.CourierID=r.CourierID
		where	SvcType=@svcType and @weight<c.MaxWeight and UseFactor=1
		UNION	ALL
		select	isnull(@svcType, 0), 0
	)
	select	top(1) SvcType, SvcClass from cte	
)
GO
PRINT N'Creating [tms].[SvcFacility#ZoneCode]...';


GO
-- Daxia
CREATE FUNCTION [tms].[SvcFacility#ZoneCode] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ZoneCode,       x.FacilityID,   f.CourierID, f.SourceID
	,		f.ImportZoneCode, f.ImportZip3,   f.POA
	,		f.MailerID,       f.FacilityInfo, f.TokenID
	,		f.ShprInfo,       f.CneeInfo,     f.ReturnInfo
	from	tms.SvcFacZoneCode#Raw() x
	join	tms.SvcFacility#Raw()   f on f.ID=x.FacilityID
)
GO
PRINT N'Creating [tms].[SvcRoute#For]...';


GO
--PeterHo
CREATE FUNCTION [tms].[SvcRoute#For](@svcType int, @poa char(3))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) POA, Priority, RouteID, r.CourierID
	from	tms.SvcType#Major(@svcType) m
	,		tms.SvcRoute#Raw() s
	join	tms.Route#Raw()    r on r.ID=s.RouteID
	where	SvcType=m.Major and POA=@poa
)
GO
PRINT N'Creating [tms].[SvcType#For]...';


GO
--PeterHo
CREATE FUNCTION [tms].[SvcType#For](@svcType int, @siteID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteMajor as
	(
		select	Major, Upto from tms.SvcType#Major(@svcType)
	)
	, cteCandidate as
	(
		select	t.ID, InitStateID, InitQueue, ClrMethodID, FallbackPOA
		from	cteMajor k, core.Party#Raw() x
		join	tms.SvcType#Raw() t on t.TenantID=x.PID
		where	x.ID=@siteID
		and		t.ID between k.Major and k.Upto
		UNION	ALL
		select	ID, InitStateID, InitQueue, ClrMethodID, FallbackPOA
		from	cteMajor k, tms.SvcType#Raw()
		where	ID=k.Major
	)
	select	top(1) ID, InitStateID, InitQueue, ClrMethodID, FallbackPOA from cteCandidate
)
/*
CREATE FUNCTION [tms].[SvcType#For](@svcType int, @tenantID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteMajor as
	(
		select	Major, Upto from tms.SvcType#Major(@svcType)
	)
	, cteCandidate as
	(
		select	ID, InitStateID, ClrMethodID, FallbackPOA
		from	cteMajor k, tms.SvcType#Raw()
		where	ID=@tenantID and ID between k.Major and k.Upto
		UNION	ALL
		select	ID, InitStateID, ClrMethodID, FallbackPOA
		from	cteMajor k, tms.SvcType#Raw()
		where	ID=k.Major
	)
	select	top(1) ID, InitStateID, ClrMethodID, FallbackPOA from cteCandidate
)
*/
GO
PRINT N'Creating [tms].[SvcZone#For]...';


GO
-- Daxia
CREATE FUNCTION [tms].[SvcZone#For](@source tinyint, @svcClass tinyint, @onZip3 char(3), @toZip3 char(3))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	z.CourierID, z.OnZoneCode3, z.ToZoneCode3, z.Zone
	from	tms.SvcClass#Raw() c
	join	tms.SvcFacility#ZoneCode() f on f.CourierID=c.CourierID
	join	tms._SvcZone z on z.CourierID=c.CourierID and z.OnZoneCode3=@onZip3 and z.ToZoneCode3=@toZip3
	where	c.ID=@svcClass and f.ZoneCode=@onZip3 and f.SourceID=@source
)
GO
PRINT N'Creating [tms].[TrackingNbr#Make]...';


GO
-- PeterHo
CREATE FUNCTION [tms].[TrackingNbr#Make]
(
	@svcCode char(3), @mailerID char(9), @mailerSeq int, @errorSeq bigint
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePic as
	(
		select	Pic=iif(@mailerSeq=0
		,		format(@errorSeq, '0000000000000000000000')
		,		concat('92', @svcCode, @mailerID, cast(format(@mailerSeq, '0000000') as char(7))))
	)
	select	TrackingNbr=isnull(cast(x.Pic+c.CheckDigit as char(22)), '')
	from	ctePic x cross apply tms.CheckDigit#For(x.Pic) c
)
GO
PRINT N'Creating [tvp].[Duad#Make]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Duad#Make](@v1 nvarchar(max), @v2 nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[Tvp]=concat(@v1, k.Duad, @v2) from tvp.Spr#Const() k
)
GO
PRINT N'Creating [tvp].[Duo#Make]...';


GO
-- PeterHo
CREATE FUNCTION [tvp].[Duo#Make](@v1 nvarchar(max), @v2 nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[Tvp]=concat(@v1, k.Duo, @v2) from tvp.Spr#Const() k
)
GO
PRINT N'Creating [tvp].[Duo#Of]...';


GO
-- PeterHo
CREATE FUNCTION [tvp].[Duo#Of](@value nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	d.v1, d.v2
	from	tvp.Spr#Const() k
	cross	apply tvp.Duad#Of(@value, k.Duo) d
)
GO
PRINT N'Creating [tvp].[I32#Join]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[I32#Join] (@array dbo.I32Array readonly)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(N',', ID) from @array for xml path(N'')
	)
	select	Tvp from cte cross apply tvp.Spr#Purify(text, 1)
)
GO
PRINT N'Creating [tvp].[I64#Join]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[I64#Join] (@array dbo.I64Array readonly)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(N',', ID) from @array for xml path(N'')
	)
	select	Tvp from cte cross apply tvp.Spr#Purify(text, 1)
)
GO
PRINT N'Creating [tvp].[I64Seqs#Join]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[I64Seqs#Join] (@idSeqs dbo.I64Seqs readonly)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, Seq, k.Duad, ID)
		from	tvp.Spr#Const() k, @idSeqs
		for xml path(N'')
	)
	select	Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [tvp].[Newline#OfTriad]...';


GO
-- PeterHo
CREATE FUNCTION [tvp].[Newline#OfTriad](@value nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	v1, v2, v3
	from	tvp.Triad#Of(@value, cast(char(13)+char(10) as nvarchar(255)))
)
GO
PRINT N'Creating [tvp].[Pair#Make]...';


GO
-- PeterHo
CREATE FUNCTION [tvp].[Pair#Make](@v1 nvarchar(max), @v2 nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[Tvp]=concat(@v1, k.Pair, @v2) from tvp.Spr#Const() k
)
GO
PRINT N'Creating [tvp].[Pair#Of]...';


GO
-- PeterHo
CREATE FUNCTION [tvp].[Pair#Of](@value nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	d.v1, d.v2
	from	tvp.Spr#Const() k
	cross	apply tvp.Duad#Of(@value, k.Pair) d
)
GO
PRINT N'Creating [tvp].[Pcs#SliceR]...';


GO
-- PeterHo
CREATE FUNCTION [tvp].[Pcs#SliceR](@source nvarchar(max), @spr nvarchar(255)=N'	;	', @upto int=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Seq, Start, Stop
	,		[Length]=isnull(Stop-Start, 0) 
	,		[Piece] =isnull(substring(@source, Start, Stop-Start), cast(N'' as nvarchar(max)))
	from	tvp.Pcs#TallyR(@source, @spr, @upto)
--	option	(maxrecursion 0)
)
GO
PRINT N'Creating [tvp].[Pcs#Tally]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Pcs#Tally](@source nvarchar(max), @spr nvarchar(255)=N'	;	')
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteTally (Start) as
	(
		select	1 UNION ALL select Nbr+(datalength(@spr)/2)
		from	dbo.Nbr#Emit(datalength(@source)/2)
		where	datalength(@spr)>0 and substring(@source, Nbr, datalength(@spr)/2)=@spr
	)
	, cteBoundary (Start, Stop) as
	(
		select	Start, isnull(nullif(charindex(@spr, @source, Start), 0), (datalength(@source)/2)+1)
		from	cteTally
	)
	select	[Seq]=row_number() over (order by (select 0)), Start, Stop
	from	cteBoundary where datalength(@source)>0
)
GO
PRINT N'Creating [tvp].[Quad#Make]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Quad#Make]
(
	@v1 nvarchar(max), @v2 nvarchar(max), @v3 nvarchar(max), @v4 nvarchar(max)
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[Tvp]=concat(@v1, k.Quad, @v2, k.Quad, @v3, k.Quad, @v4)
	from	tvp.Spr#Const() k
)
GO
PRINT N'Creating [tvp].[Quad#Of]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Quad#Of](@value nvarchar(max),  @spr nvarchar(255)=N'	-	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.v1, x.v2, [v3]=p.v1, [v4]=p.v2
	from	tvp.Triad#Of(@value, @spr) x
	cross	apply tvp.Duad#Of(x.v3, @spr) p
)
GO
PRINT N'Creating [vmi].[Tenancy$For]...';


GO
--Smile
CREATE FUNCTION [vmi].[Tenancy$For](@userID int)
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	Tvp=concat(p.ID, k.Quad, p.PID, k.Quad, p.AID, k.Quad, t.Alias, k.Duad, r.RoleIDs)
	from	tvp.Spr#Const()  k, core.User#Raw() x
	join	core.Party#Raw() p  on p.ID=x.ID
	join	core.Party#Raw() t  on t.ID=p.AID
	cross	apply core.RoleID#Tvp(x.ID) r
	where	x.ID=@userID
)
GO
PRINT N'Creating [vmi].[SvcContract$For]...';


GO
--Smile
CREATE FUNCTION [vmi].[SvcContract$For](@partyID int)
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	SvcType
	from	core.Party#Raw()                        p
	cross	apply acct.Contract#For(P.ID, p.Source) x
	join	tms.SvcContract#Raw()                   s on s.ContractID=x.ID
	where	p.ID=@partyID and x.ID>0

)
GO
PRINT N'Creating [whse].[StorageRate#For]...';


GO
--Smile
CREATE FUNCTION [whse].[StorageRate#For](@rcvHubID int, @siteID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	RcvHubID, TenantID, CurrencyID, RcvSkuFee, OutPkgFee
		,		OverWeightFee, WeightLimit, ExcessItemsFee, ItemsQtyLimit
		,		StorageCbmFee30Day, StorageCbmFee60Day, StorageCbmFeeOther
		from	core.Party#Raw()       x
		join	whse.StorageRate#Raw() t on t.TenantID=x.PID
		where	x.ID=@siteID
		UNION ALL
		select	RcvHubID, TenantID, CurrencyID, RcvSkuFee, OutPkgFee
		,		OverWeightFee, WeightLimit, ExcessItemsFee, ItemsQtyLimit
		,		StorageCbmFee30Day, StorageCbmFee60Day, StorageCbmFeeOther
		from	whse.StorageRate#Raw()
		where	RcvHubID=@rcvHubID 
	)
	select	top(1) RcvHubID, TenantID, CurrencyID, RcvSkuFee, OutPkgFee
	,		OverWeightFee, WeightLimit, ExcessItemsFee, ItemsQtyLimit
	,		StorageCbmFee30Day, StorageCbmFee60Day, StorageCbmFeeOther
	from	cte
)
GO
PRINT N'Creating [zeb].[RefNbr$Tvp]...';


GO
-- Eva
CREATE FUNCTION [zeb].[RefNbr$Tvp](@matterID bigint)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	RefNbrs from core.RefNbr#Tvp(@matterID)
)
GO
PRINT N'Creating [zeb].[RefInfo$Tvp]...';


GO
-- Eva
CREATE FUNCTION [zeb].[RefInfo$Tvp](@matterID bigint)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	RefInfos from core.RefInfo#Tvp(@matterID)
)
GO
PRINT N'Creating [zeb].[RefInfo$Of]...';


GO
-- Eva
CREATE FUNCTION [zeb].[RefInfo$Of](@matterID bigint, @type tinyint)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Info from core.RefInfo#Of(@matterID, @type)
)
GO
PRINT N'Creating [zeb].[Challenge$Tvp]...';


GO
-- Eva
CREATE FUNCTION [zeb].[Challenge$Tvp](@matterID bigint)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Challenges from core.Challenge#Tvp(@matterID)
)
GO
PRINT N'Creating [zeb].[Parcel$ScanOne]...';


GO
-- AaronLiu
CREATE FUNCTION [zeb].[Parcel$ScanOne](@number varchar(40))
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Number, MatterID, Type, Stage
	from	core.RefNbr#ScanOne(@number, default, default)
)
GO
PRINT N'Creating [zeb].[Matter$LatestStage]...';


GO
/*
	TODO: refine this, with offset cannot use calendar offset
*/
-- AaronLiu
CREATE FUNCTION [zeb].[Matter$LatestStage](@matterID I64, @startDate DT, @endDate DT)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	LatestStage=isnull(max(s.Stage),0)
	from	core.Matter#PNodeUp(@matterID) x
	join	core.Activity#Raw() a on a.MatterID=x.ID
	join	core.State#Raw()    s on s.ID=a.StateID
--	join	dbo.Calendar#Raw()  d on d.Value=cast(a.TalliedOn as Date)
--	cross   apply dbo.Calendar#Of(@startDate) sd
--	cross   apply dbo.Calendar#Of(@endDate  ) ed
--	where	d.DOffset   between sd.DOffset and  ed.DOffset
	where	a.TalliedOn between @startDate and @endDate
)
GO
PRINT N'Creating [dbo].[Bit#Wise]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Bit#Wise]()
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS
RETURN 
(
	select	[Bit]=isnull(cast(Nbr as tinyint), 0)
	,		[Val]=isnull(power(cast(2 as bigint), cast(Nbr-1 as float)), cast(0 as bigint))
	from	dbo.Nbr#Emit(63)
)
GO
PRINT N'Creating [dbo].[Calendar#Of]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Calendar#Of] (@value date)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
    with cteArg as (select [Value]=isnull(@value, Anchor), Anchor from dbo.DT#Const())
    , cteOffset as
    (
        select	Value,   Anchor
        ,		[Year]   =isnull(  datepart(yy, Value), 0)
        ,		[Quarter]=isnull(  datepart(qq, Value), 0)
        ,		[Month]  =isnull(  datepart(mm, Value), 0)
        ,       [Week]   =isnull(  datepart(ww, Value), 0)
        ,		[Day]    =isnull(  datepart(dd, Value), 0)
        ,		[Dow]    =isnull(((datepart(dw, Value)+5)%7)+1, 0)
        ,		[YOffset]=isnull(  datediff(yy, Anchor, Value), 0)
        ,		[QOffset]=isnull(  datediff(qq, Anchor, Value), 0)
        ,		[MOffset]=isnull(  datediff(mm, Anchor, Value), 0)
        ,		[WOffset]=isnull(  datediff(ww, Anchor, Value), 0)
        ,		[DOffset]=isnull(  datediff(dd, Anchor, Value), 0)
        from	cteArg
    )
    , cteRange as
    (
        select	Value
        ,		Year,    Quarter, Month,   Week,    Day,Dow
        ,		YOffset, QOffset, MOffset, WOffset, DOffset
        ,		[BOMonth]=isnull(dateadd(mm, MOffset, Anchor), '')
        ,		[BOWeek] =isnull(dateadd(ww, WOffset, Anchor), '')
        from	cteOffset
    )
    select	Value
    ,		Year,    Quarter, Month,   Week,    Day,Dow
    ,		YOffset, QOffset, MOffset, WOffset, DOffset
    ,		BOMonth, [EOMonth]=isnull(dateadd(dd, -1, dateadd(mm, 1, BOMonth)), '')
    ,		BOWeek,  [EOWeek] =isnull(dateadd(dd,  6, BOWeek), '')
    ,		[BONextMonth]=isnull(dateadd(mm, 1, BOMonth), '')
    ,		[BONextWeek] =isnull(dateadd(dd, 7, BOWeek),  '')
    from	cteRange
)
GO
PRINT N'Creating [dbo].[Calendar#Today]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Calendar#Today] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Value
	,		Year,    Quarter, Month,   Week,    Day,Dow
	,		YOffset, QOffset, MOffset, WOffset, DOffset
	from	dbo.Calendar#Of(getutcdate())
)
GO
PRINT N'Creating [dbo].[Currency#Encode]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Currency#Encode](@amt bigint, @currencyID tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[Amt]=isnull(isnull(nullif(sign(@amt), 0), 1) * (m.RawAmt + (@currencyID % 100)), 0)
	from	[dbo].Money#Of(abs(@amt)) m
)
GO
PRINT N'Creating [dbo].[Money#Make]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Money#Make](@decAmt float, @currency tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with	cteRaw as
	(
	--	select RawAmt=cast(round(@decAmt, 2)*100 as bigint)*100
		select RawAmt=cast(cast(@decAmt as numeric(27,9))*100 as bigint)*100
	)
	select	Amt, RawAmt from cteRaw
	cross	apply [dbo].Currency#Encode(RawAmt, @currency)
)
GO
PRINT N'Creating [dbo].[Money#Sum]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Money#Sum](@amtA bigint, @amtB bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	c.Amt
	from	[dbo].Money#Of(@amtA) a
	cross	apply [dbo].Money#Of(@amtB) b
	cross	apply [dbo].Currency#Encode(a.RawAmt+b.RawAmt, a.CurrencyID) c
)
GO
PRINT N'Creating [dbo].[Money#USD]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Money#USD](@decAmt float)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	CurrencyID=USD, Amt, RawAmt
	from	dbo.Currency#ID()
	cross	apply dbo.Money#Make(@decAmt, USD)
)
GO
PRINT N'Creating [dbo].[Nbr#Range]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Nbr#Range](@start int, @end int, @step int=1)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select Nbr from dbo.Nbr#Yield
	(
		(abs(@end - @start) + 1) / abs(@step), @start, iif(@end >= @start, abs(@step), -abs(@step))
	)
)
GO
PRINT N'Creating [core].[DF_AddOnSvc_EndedOn]...';


GO
ALTER TABLE [core].[_AddOnSvc]
    ADD CONSTRAINT [DF_AddOnSvc_EndedOn] DEFAULT (dbo.DT@Empty()) FOR [EndedOn];


GO
PRINT N'Creating [core].[DF_AddOnSvc_StartedOn]...';


GO
ALTER TABLE [core].[_AddOnSvc]
    ADD CONSTRAINT [DF_AddOnSvc_StartedOn] DEFAULT (dbo.DT@Empty()) FOR [StartedOn];


GO
PRINT N'Creating [tms].[DF_Flight_ETA]...';


GO
ALTER TABLE [tms].[_Flight]
    ADD CONSTRAINT [DF_Flight_ETA] DEFAULT (dbo.DT@Empty()) FOR [ETA];


GO
PRINT N'Creating [tms].[DF_Flight_ETD]...';


GO
ALTER TABLE [tms].[_Flight]
    ADD CONSTRAINT [DF_Flight_ETD] DEFAULT (dbo.DT@Empty()) FOR [ETD];


GO
PRINT N'Creating [whse].[PK_RackOrder_CompletedOn]...';


GO
ALTER TABLE [whse].[_RackOrder]
    ADD CONSTRAINT [PK_RackOrder_CompletedOn] DEFAULT (dbo.DT@Empty()) FOR [CompletedOn];


GO
PRINT N'Creating [acct].[Vault#Raw]...';


GO
-- PeterHo, Smile
CREATE FUNCTION [acct].[Vault#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, PartyID,   x.SourceID, x.CurrencyID, VaultType,    TalliedOn
	,		VaultBal,      RawBal=v.RawAmt,          DecBal        =v.DecAmt
	,		CreditLimit,   CreditLimitRaw=c.RawAmt,  CreditLimitDec=c.DecAmt
	,		InvoicedAmt,   InvoicedRaw   =i.RawAmt,  InvoicedDec   =i.DecAmt
	,		UninvoicedAmt, UninvoicedRaw =u.RawAmt,  UninvoicedDec =u.DecAmt
	,		CurBalRaw=(v.RawAmt + c.RawAmt - u.RawAmt -i.RawAmt),  CurBal=b.Amt
	from	[acct].[_Vault]                    x 
	cross	apply dbo.Money#Of(VaultBal)       v
	cross	apply dbo.Money#Of(CreditLimit)    c
	cross	apply dbo.Money#Of(UninvoicedAmt)  u
	cross	apply dbo.Money#Of(InvoicedAmt)    i
	cross	apply dbo.Currency#Encode(v.RawAmt+c.RawAmt-u.RawAmt-i.RawAmt, x.CurrencyID) b
)
GO
PRINT N'Creating [acct].[Vault#Summary]...';


GO
-- PeterHo
CREATE FUNCTION [acct].[Vault#Summary] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteVault as
	(
		select	PartyID,   CurrencyID
		,		RawTotal   =sum  (RawBal)
		,		LastOn     =max  (TalliedOn)
		,		TypeCnt    =count(VaultType)
--		,		Outstanding=sum  (Outstanding)
		from	acct.Vault#Raw()
		group	by PartyID, CurrencyID
	)
	select	PartyID,  x.CurrencyID
	,		RawTotal, DecTotal=m.DecAmt, TypeCnt, LastOn
	from	cteVault x cross apply dbo.Money#Of(RawTotal) m
)
GO
PRINT N'Creating [acct].[VaultXact#Raw]...';


GO
-- PeterHo
CREATE FUNCTION [acct].[VaultXact#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, XactAmt, XactedOn,  PrevBal, [NextBal]=n.Amt
	,		PaymentID,   InvoiceID, VaultID
	from	[acct].[_VaultXact]
	cross	apply [dbo].Money#Sum(XactAmt, PrevBal) n
)
GO
PRINT N'Creating [brkg].[ClrMethod#Raw]...';


GO
--PeterHo
CREATE FUNCTION [brkg].[ClrMethod#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, ClrMethodCode, CountryCode, CurrencyID
	,		IDRequirement, Exemption, ExemptionRaw=m.RawAmt
	from	brkg._ClrMethod        x
	cross	apply dbo.Money#Make(x.Exemption, x.CurrencyID) m
)
GO
PRINT N'Creating [brkg].[ClrMethodRate#For]...';


GO
--Smile
CREATE FUNCTION [brkg].[ClrMethodRate#For](@tenantID int, @clrMethodID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(	
	with cteRate as
	(
		select	top(1)	CurrencyID, FlatRateRaw=m.RawAmt, PercentRate
		from	brkg.ClrMethodRate#Raw() x
		join	brkg.ClrMethod#Raw()     d on d.ID=@clrMethodID
		cross	apply dbo.Money#Make(x.FlatRate, d.CurrencyID) m
		where	TenantID=@tenantID and ClrMethodID=@clrMethodID	
		union all
		select	0, 0, 0
	)
	select	top(1) CurrencyID, FlatRateRaw, PercentRate
	from	cteRate
)
GO
PRINT N'Creating [core].[Message#Tvp]...';


GO
-- Aimee
CREATE FUNCTION core.Message#Tvp(@matterID bigint)
RETURNS TABLE
--, ENCRYPTION
WITH SCHEMABINDING
AS RETURN 
(
	with	cte(text) as
	(
		select	[text()] = concat(k.Many, x.AuxID, k.Quad, x.PosterAlias, k.Quad, x.PostedOn, k.Quad, x.Body)
		from	core.Registry#ID()    m
		cross	apply core.Message#Of(m.Matter, @matterID, default) x
		cross	apply tvp.Spr#Const() k
		for		xml path(N'')
	)
	select	Messages=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [core].[Activity#TrackSpecific]...';


GO
-- AaronLiu
CREATE FUNCTION [core].[Activity#TrackSpecific](@matterID I64, @stateID I32)
RETURNS TABLE
--WITH  ENCRYPTION
AS RETURN
(
	with cteBase as
	(
		select	a.ID,        a.MatterID
		,		a.StateID,   s.Stage
		,		a.UserID,    UserAlias =p.Alias
		,		a.TalliedOn, UtcPartyID=p.PID
		,		s.IsInternal
		from	core.Activity#Raw() a
		join	core.State#Raw()    s on s.ID=a.StateID
		join	core.Party#Raw()    p on p.ID=a.UserID
		where	a.MatterID=@matterID and a.StateID=@stateID
	)
	, cteMarked as
	(
		select	x.ID,     x.MatterID,  x.StateID, x.Stage,     x.TalliedOn
		,		x.UserID, x.UserAlias, z.UtcTime, z.UtcOffset, z.UtcPlace, z.UtcPlaceID
		from	cteBase   x 
		cross	apply
		(
			select	top(1) UtcTime,  UtcOffset, UtcPlace, UtcPlaceID from
			(
				select	UtcTime,     UtcOffset, UtcPlace, UtcPlaceID
				from	core.RefStamp#Of(x.MatterID, x.StateID)
				UNION	ALL
				select	x.TalliedOn, UtcOffset, UtcPlace, UtcPartyID
				from	core.Tenant#Raw() where ID=x.UtcPartyID
			) y
		) z
	)
	select	ID,     MatterID,  StateID, Stage,     TalliedOn
	,		UserID, UserAlias, UtcTime, UtcOffset, UtcPlace, UtcPlaceID
	from	cteMarked
)
GO
PRINT N'Creating [core].[Activity#Track]...';


GO
--PeterHo
CREATE FUNCTION [core].[Activity#Track](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteBase as
	(
		select	a.ID, x.Type, a.MatterID
		,		a.StateID,    s.Stage,  s.IsInternal
		,		a.UserID,     UserAlias=p.Alias
		,		a.TalliedOn,  UtcPartyID=p.PID
		from	core.Matter#PNodeUp(@matterID) x
		join	core.Activity#Raw() a on a.MatterID=x.ID
		join	core.State#Raw()    s on s.ID=a.StateID
		join	core.Party#Raw()    p on p.ID=a.UserID
	)
	, cteMarked as
	(
		select	x.ID,     x.Type,      x.MatterID, x.StateID,   x.Stage,    x.TalliedOn
		,		x.UserID, x.UserAlias, z.UtcTime,  z.UtcOffset, z.UtcPlace, z.UtcPlaceID
		,		Marker=lead(ID) over (partition by x.Stage order by z.UtcTime)
		from	cteBase x cross apply
		(
			select	top(1) UtcTime,  UtcOffset, UtcPlace, UtcPlaceID from
			(
				select	UtcTime,     UtcOffset, UtcPlace, UtcPlaceID
				from	core.RefStamp#Of(x.MatterID, x.StateID)
				UNION	ALL
				select	x.TalliedOn, UtcOffset, UtcPlace, UtcPartyID
				from	core.Tenant#Raw() where ID=x.UtcPartyID
			) y
		) z
		where	x.IsInternal=0
	)
	select	ID,     Type,      MatterID, StateID,   Stage,    TalliedOn
	,		UserID, UserAlias, UtcTime,  UtcOffset, UtcPlace, UtcPlaceID--, Marker
	from	cteMarked where Marker is null
)
GO
PRINT N'Creating [core].[Challenge#Of]...';


GO
--PeterHo
CREATE FUNCTION [core].[Challenge#Of](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	Marker=lead(m.RegID) over (partition by m.RegID, m.RowID, m.AuxID order by (select 0))
		,		x.Type, x.BoundStage, m.Body, m.PostedOn, m.PosterID, m.PosterAlias
		from	core.Challenge#Raw()     x
		cross	apply core.Registry#ID() r
		cross	apply core.Message#Of(r.Matter, MatterID, Type) m
		where	x.MatterID=@matterID
	)
	select	Type, BoundStage, Body, PostedOn, PosterID, PosterAlias
	from	cte where Marker is null
)
GO
PRINT N'Creating [core].[Matter#Deep]...';


GO
--PeterHo
CREATE FUNCTION [core].[Matter#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,      PID, AID,   x.Source,    Type, LockCnt,       Stage, StateID, StatedOn,  HandlerID
	,		PosterID,  PosterAlias=t.Alias,     PostedAt=t.UtcPlace, PostedOn,       t.UtcOffset
	,		n.RefNbrs, i.RefInfos, s.RefStamps, p.RefParties,        o.RoledActions, c.Challenges, a.AddOnServices
	from	core.Matter#Raw() x
	join	core.Tenant#Raw() t on t.ID=x.PosterID
	outer	apply core.Transition#Todo(x.StateID) o
	outer	apply core.RefNbr#Tvp   (x.ID) n
	outer	apply core.RefInfo#Tvp  (x.ID) i
	outer	apply core.RefStamp#Tvp (x.ID) s
	outer	apply core.RefParty#Tvp (x.ID) p
	outer	apply core.Challenge#Tvp(x.ID) c
	outer	apply core.AddOnSvc#Tvp (x.ID) a
)
GO
PRINT N'Creating [core].[MIC#Emit]...';


GO
--PeterHo
CREATE FUNCTION [core].[MIC#Emit](@matterID bigint, @source tinyint, @type tinyint, @postedOn date)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePic as
	(
		select	nbr=concat('36'
				,   format(@source  %100,      '00')
				,   format(@type    %100,      '00')
				,   format(DOffset  %100000,   '00000')
				,	format(@matterID%10000000, '0000000'))
		from	dbo.Calendar#Of(@postedOn)
	)
	select	MIC=n.EncodedNbr
	from	ctePic cross apply dbo.Nbr#Mod10(nbr) n
)
GO
PRINT N'Creating [core].[MIC#IdOf]...';


GO
--PeterHo
CREATE FUNCTION [core].[MIC#IdOf](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID from core.RefNbr#Type() k
	cross	apply core.RefNbr#IdOfFirst(@number, k.MIT)
)
GO
PRINT N'Creating [hub].[Challenge$List]...';


GO
-- Aimee
CREATE FUNCTION hub.Challenge$List(@number varchar(40))
RETURNS TABLE
--, ENCRYPTION
WITH SCHEMABINDING
AS RETURN 
(
	select	ID=x.MatterID, Messages, Challenges
	from	core.MIC#IdOf(@number) x
	cross	apply core.Message#Tvp(x.MatterID)
	cross	apply core.Challenge#Tvp(x.MatterID)
)
GO
PRINT N'Creating [invt].[SkuDuty#Tvp]...';


GO
--PeterHo, Smile
CREATE FUNCTION [invt].[SkuDuty#Tvp](@skuID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteDuty(text) AS
	(
		select	[text()]=concat(k.Many, c.ClrMethodCode, k.Triad, d.DutyRate, k.Triad, d.DutyCode)
		from	tvp.Spr#Const()      k, invt.SkuBrokerage#Raw() x
		join	brkg.Duty#Raw()      d on d.ID=x.DutyID
		join	brkg.ClrMethod#Raw() c on c.ID=x.ClrMethodID
		where	x.SkuID=@skuID
		for		xml path(N'')
	)
	select	DutyTvp=Tvp from cteDuty cross apply tvp.Spr#Purify(text, default) 
/*
	with cteSkuDuty(text) as
	(
		select	[text()]=concat(k.Many, m.ClrMethodCode, k.Triad, x.DutyRate, k.Triad, x.CmdyCode)
		from	tvp.Spr#Const() k,   invt.TenantSku#Duty() x
		join	brkg.ClrMethod#Raw() m on m.ID=x.ClrMethodID
		where	x.TenantSkuID=@tenantSkuID
		for xml path(N'')
	)
	select	DutyTvp=Tvp from cteSkuDuty cross apply tvp.Spr#Purify(text, default)
*/
)
GO
PRINT N'Creating [loc].[CmdyInfo#Of]...';


GO
-- PeterHo
CREATE FUNCTION [loc].[CmdyInfo#Of](@info nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	CmdyHeadID=cast(v1 as int)
	,		CmdyTailID=cast(v2 as int)
	,		DutyCode  =v3
	,		DutyRate  =cast(v4 as real)
	from	tvp.Quad#Of(@info, default)
)
GO
PRINT N'Creating [loc].[LineInfo#Of]...';


GO
-- PeterHo
CREATE FUNCTION [loc].[LineInfo#Of](@info nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	GoodsInfo=v1
	,		LineQty  =cast(v2 as int)
	,		CmdyID   =cast(v4 as int)
	,		LineTotal=cast(v3 as bigint)
	,		LineRawTotal=m.RawAmt
	,		LineDecTotal=m.DecAmt
	,		m.CurrencyID
	from	tvp.Quad#Of(@info, default)
	cross	apply dbo.Money#Of(cast(v3 as bigint)) m
)
GO
PRINT N'Creating [loc].[Tenancy#Of]...';


GO
-- PeterHo
CREATE FUNCTION [loc].[Tenancy#Of](@slip nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteFact as
	(
		select	[PID]   =cast(v1 as int)
		,		[AID]   =cast(v2 as int)
		,		[UserID]=cast(v3 as int)
		,		[RoleID]=cast(v4 as int)
		from	tvp.Quad#Of(@slip, default)
	)
	select	PID,  AID, UserID,     RoleID
	,		HubID=PID, SiteID=PID, AcctID=AID
	from	cteFact
)
GO
PRINT N'Creating [shpt].[Appointment#Base]...';


GO
--AaronLiu
CREATE FUNCTION [shpt].[Appointment#Base]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, PID, AID, Source,  Type,	   LockCnt,	 Stage, StateID, StatedOn,	SiteID=m.PosterID
	,		SiteAlias=m.PosterAlias, PostedAt, PostedOn, SiteUtcOffset=m.UtcOffset, PickupOn
	,		EstWeight,  HandlerID,	 RefNbrs,  RefInfos, RefStamps, RefParties,		RoledActions
	,		Challenges, AddOnServices
	from	shpt.Appointment#Raw() x
	join	core.Matter#Deep()	   m on m.ID=x.ID
)
GO
PRINT N'Creating [shpt].[Parcel#Base]...';


GO
--PeterHo
CREATE FUNCTION [shpt].[Parcel#Base]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, PID, AID,    Source, Type, LockCnt,    Stage,    StateID,  StatedOn, BatchID
	,		SiteID=m.PosterID, SiteAlias=m.PosterAlias,  PostedAt, PostedOn, SiteUtcOffset=m.UtcOffset
	,		RcvHubID, RouteID, LastMilerID,  ContractID, POA, HandlerID
	,		SvcType, SvcZone,  SvcClass,     Weight,     Length, Width, Height,     ZoneCode
	,		RefNbrs,  RefInfos, RefStamps,   RefParties, RoledActions,  Challenges, AddOnServices
	from	shpt.Parcel#Raw()  x
	join	core.Matter#Deep() m on m.ID=x.ID
)
GO
PRINT N'Creating [shpt].[Sack#Base]...';


GO
-- AaronLiu
CREATE FUNCTION [shpt].[Sack#Base]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, m.PID, m.AID, m.Source,    m.Type,      m.LockCnt,   m.HandlerID
	,		m.Stage, m.StateID, m.StatedOn,  x.BrokerID,  ClrMethodID, SackWt
	,		HubID=m.PosterID,   HubAlias=m.PosterAlias,   PostedAt
	,		m.PostedOn,         HubUtcOffset=m.UtcOffset
	,		POD=isnull(s.POD, ''), POA=isnull(x.POA, '')
	,		RefNbrs, RefStamps, RefParties
	,		RoledActions,       Challenges,  FlightID=isnull(f.PID, 0)
	from	shpt.Sack#Raw()    x
	join	core.Matter#Deep() m on x.ID=m.ID
	left	join shpt.SackMft#Raw() s on s.ID=m.PID
	left	join core.Matter#Raw()  f on s.ID=f.ID
)
GO
PRINT N'Creating [shpt].[SackLoad#Base]...';


GO
-- AaronLiu
CREATE FUNCTION [shpt].[SackLoad#Base]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,	   PID, AID, Source,   Type,    LockCnt,    Stage,        StateID
	,		StatedOn,  PostedAt, PostedOn, RefNbrs, RefParties, RoledActions, Challenges
	,		TruckerID, Trucker=t.Alias,    HubID= m.PosterID
	from	shpt.SackLoad#Raw() x
	join	core.Matter#Deep()  m on m.ID=x.ID
	join	tms.Trucker#Raw()   t on x.TruckerID=t.ID
)
GO
PRINT N'Creating [shpt].[SackMft#Base]...';


GO
--PeterHo
CREATE FUNCTION [shpt].[SackMft#Base]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,   PID, AID,  Source,  Type, LockCnt, Stage,     StateID,    StatedOn,    BrokerID
	,		HubID=m.PosterID,  HubAlias=m.PosterAlias, PostedAt,  PostedOn,   HubUtcOffset=m.UtcOffset
	,		POD, POA, MawbNbr, FlightNbr, RefNbrs,     RefStamps, RefParties, RoledActions, Challenges
	from	shpt.SackMft#Raw() x
	join	core.Matter#Deep() m on m.ID=x.ID
)
GO
PRINT N'Creating [shpt].[SackMft#Deep]...';


GO
--PeterHo, AaronLiu, Smile
CREATE FUNCTION [shpt].[SackMft#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,    PID, AID,  Source,   Type,     LockCnt,        Stage, StateID, StatedOn
	,		HubID,   HubAlias,  PostedAt, PostedOn, HubUtcOffset,   POD=isnull(f.POD, x.POD)
	,		POA=isnull(f.POA, x.POA),   MawbNbr,   FlightNbr=isnull(f.FlightNbr, x.FlightNbr), BrokerID
	,		RefNbrs, RefStamps, RoledActions, Challenges, a.Ledgers, ETA, ETD
	from	shpt.SackMft#Base()   x
	left	join tms.Flight#Raw() f  on x.PID=f.ID
	outer	apply acct.Ledger#Tvp(x.ID) a
)
GO
PRINT N'Creating [svc].[Batch$ExportSuccess]...';


GO
--Simile, PeterHo
CREATE FUNCTION [svc].[Batch$ExportSuccess](@batchID bigint)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	n.RefNbrs, CneeInfo=i.Info, PostedOn=l.LocalTime
	from	shpt.Parcel#Base()          x
	cross	apply core.RefInfo#Type()   t
	join	core.RefInfo#Raw()          i on i.MatterID=x.ID and i.Type=t.CneeInfo
	cross	apply core.RefNbr#Tvp(x.ID) n
	cross	apply dbo.DT#ToLocal(x.PostedOn, x.SiteUtcOffset) l
	where	x.BatchID=@batchID
)
GO
PRINT N'Creating [svc].[SackMft$MawbInfo]...';


GO
--	Smile
CREATE	FUNCTION [svc].[SackMft$MawbInfo]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	SELECT	ID, MawbNbr, POA, p.UtcOffset, p.UtcPlaceID
	FROM 	shpt.SackMft#Base()   x
	join	core.Port#Raw()       p on p.Code=x.POA
	cross	apply core.Stage#ID() k
	where	x.Stage=k.Arrived
)
GO
PRINT N'Creating [svc].[SackMft$List]...';


GO
--Aimee, Smile, AaronLiu, hbd
CREATE	FUNCTION [svc].[SackMft$List]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID,	      MawbNbr, FlightID=x.PID, FlightNbr,    PostedOn,  Stage, StateID
	,		StatedOn,   HubID, HubAlias,       HubUtcOffset, RefStamps, RoledActions
	,		UnSackedParcelCnt, UnTransloadedSackCnt, Source
	,		POA, [POAUtcOffset]=a.UtcOffset, [POAUtcPlaceID]=a.UtcPlaceID
	,		POD, [PODUtcOffset]=d.UtcOffset, [PODUtcPlaceID]=d.UtcPlaceID
	from	shpt.SackMft#Deep()	  x
	join	core.Port#Raw() a on  x.POA=a.Code
	join	core.Port#Raw() d on  x.POD=d.Code
	cross	apply (
		select	UnSackedParcelCnt   =isnull(sum(case when m.Type=t.Parcel and m.Level=1             then 1 else 0 end),0)
		,		UnTransloadedSackCnt=isnull(sum(case when m.Type=t.Sack   and m.Stage<s.Transloaded then 1 else 0 end),0)
		from	core.Matter#PNodeDn(x.ID) m
		cross	apply core.Matter#Type()  t
		cross	apply core.Stage#ID()     s
	) n
)
GO
PRINT N'Creating [svc].[Parcel$Track]...';


GO
--PeterHo
CREATE FUNCTION [svc].[Parcel$Track](@parcelID bigint)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with cteTvp(text) as
	(
		select	[text()]=concat(k.Many
		,		ID,       k.Tuplet, Stage,     k.Tuplet
		,		UserID,   k.Tuplet, UserAlias, k.Tuplet
		,		UtcPlace, k.Tuplet, UtcTime,   k.Tuplet, UtcOffset)
		from	core.Activity#Track(@parcelID)
		,		tvp.Spr#Const() k for xml path(N'')
	)
	select	Tracks=Tvp, l.CourierCode, CourierNbr=isnull(c.Number, N'')
	from	cteTvp cross apply tvp.Spr#Purify(text, default)
	join	shpt.Parcel#Raw() p on p.ID=@parcelID
	join	tms.Courier#Raw() l on l.ID=p.LastMilerID
--	join	tms.Route#Deep()  r on r.ID=p.RouteID -- dropped on 2017-08-19
	outer	apply
	(
		select	Number from	core.RefNbr#Raw() n
		cross	apply  core.RefNbr#Type()     t
		where	n.MatterID=@parcelID and n.Type=t.PostCourier
	) c
)
GO
PRINT N'Creating [svc].[Message$List]...';


GO
--PeterHo: HACK!!， Aimee
CREATE	FUNCTION [svc].[Message$List](@matterID bigint)
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	m.ID, m.AuxID, m.Body, m.PostedOn, m.PosterID, m.PosterAlias, BoundStage=isnull(cast(c.BoundStage as int), 0)
	from	core.Registry#ID() k
	cross	apply core.Message#Of(k.Matter, @matterID, default) m
	left	join core.Challenge#Of(@matterID) c on c.Type=m.AuxID and c.Body=m.Body and c.PostedOn=m.PostedOn
)
GO
PRINT N'Creating [svc].[ClrMethod$Lookup]...';


GO
--Sam
CREATE FUNCTION [svc].[ClrMethod$Lookup]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, ClrMethodCode, CountryCode
	from	brkg.ClrMethod#Raw()
)
GO
PRINT N'Creating [svc].[ClrMethod$BrokerLookup]...';


GO
--Sam
CREATE FUNCTION [svc].[ClrMethod$BrokerLookup]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	c.CountryCode	as CountryCode
		,	b.ID			as BrokerID
		,	b.BrokerAlias	
		,	c.ID			as ClrMethodID
		,	c.ClrMethodCode 
	from	tms.Route#Raw()      r
	join	brkg.Broker#Raw()    b	on b.ID = r.BrokerID
	join	brkg.ClrMethod#Raw() c	on c.ID = r.ClrMethodID
	Where	b.ID > 0 and c.ID > 0
)
GO
PRINT N'Creating [svc].[Account$Ledger]...';


GO
-- Smile, PeterHo, FJJ, PeterHo, Smile
CREATE FUNCTION [svc].[Account$Ledger]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,      d.Source,    ChargeAmt, CurrencyID
	,		TalliedOn, x.PartyID,   PartyAlias=p.Alias
	,		Weight,    SvcType,     RefInfos,  RefNbrs
	,		SectionWt, g.VaultTag,  NetDays=isnull(BillingCycle, 0)
	,		BizUnitID, BizUnit=n.Alias, ChargeID, x.MatterID
	from	acct.Ledger#Raw()        x
	join	core.Party#Raw()         p on p.ID=x.PartyID
	join	shpt.Parcel#Base()       d on d.ID=x.MatterID
	join	acct.Charge#Raw()        g on g.ID=x.ChargeID
	join	acct.Contract#Raw()      t on t.ID=d.ContractID
	join	core.Party#Raw()         n on n.ID=t.BizUnitID
	cross	apply acct.Ledger#Side() s 
	cross	apply tms.SvcRate#For(d.SvcType, d.RcvHubID, d.Weight) a
	where	x.LedgerSide=s.AR
)
GO
PRINT N'Creating [svc].[VaultXact$Summary]...';


GO
-- Smile
CREATE FUNCTION [svc].[VaultXact$Summary]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,      PartyID=p.ID, PartyAlias=p.Alias, BizUnitID, BizUnit=b.Alias
	,		PaymentID, v.CurrencyID,   XactAmt, PrevBal, NextBal, XactedOn,  Supplement
	from	acct.Vault#Raw()           v	
	join	acct.VaultXact#Raw()       x on x.VaultID=v.ID
	join	core.Party#Raw()           p on p.ID=v.PartyID
	cross	apply acct.Contract#For(p.ID, p.Source) c
	join	core.Party#Raw()           b on b.ID=c.BizUnitID
	cross	apply core.Registry#ID()   k
	left	join acct.Payment#Raw()    m on m.ID=x.PaymentID
	left	join core.Supplement#Raw() s on s.RegID =k.Payment and s.RowID=m.ID
)
GO
PRINT N'Creating [svc].[Sku$DutyList]...';


GO
--PeterHo, Aimee
CREATE FUNCTION [svc].[Sku$DutyList]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, x.TenantID, TenantAlias=p.Alias, x.SkuNbr, t.DutyTvp
	from	invt.Sku#Raw()    x
	join	core.Tenant#Raw() p on p.ID= x.TenantID
	cross	apply invt.SkuDuty#Tvp(x.ID) t
)
GO
PRINT N'Creating [svc].[Account$VaultBalFor]...';


GO
-- Smile
CREATE FUNCTION [svc].[Account$VaultBalFor](@partyID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID=PartyID, VaultBal, InvoicedAmt, UninvoicedAmt, CurrencyID, VaultType, CurBal, CreditLimit
	from	acct.Vault#Raw()  x
	where	x.PartyID=@partyID 
)
GO
PRINT N'Creating [svc].[Parcel$RefInfoFor]...';


GO
--Aimee, Smile
CREATE FUNCTION [svc].[Parcel$RefInfoFor](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, m.Stage, SiteAlias, RefInfos, RefNbrs
	from	core.RefNbr#ScanOne(@number, default, default) x
	join	shpt.Parcel#Base() m on m.ID = x.MatterID
)
GO
PRINT N'Creating [svc].[Parcel$ListForRef]...';


GO
-- Daxia
Create FUNCTION [svc].[Parcel$ListForRef](@siteID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, RefNbrs, RefInfos, Stage
	from	shpt.Parcel#Base()
	where	SiteID=@siteID
)
GO
PRINT N'Creating [svc].[Parcel$ForPlatform]...';


GO
--Ken
CREATE FUNCTION [svc].[Parcel$ForPlatform]()
RETURNS TABLE 
WITH SCHEMABINDING --,ENCRYPTION
AS RETURN 
(
	select	x.ID,  SiteAlias, x.Source, RefNbrs
	,		Stage, PostedOn, StatedOn, CourierAlias
	from   shpt.Parcel#Base()  x
	join   tms.Courier#Raw()   c	ON  c.ID=x.LastMilerID
)
GO
PRINT N'Creating [svc].[Invoice$ProcessingList]...';


GO
--Smile
CREATE FUNCTION [svc].[Invoice$ProcessingList](@source tinyint, @vaultTag tinyint, @partyID int, @bizUnitID int, @issueDate datetime2(2))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with	cteLedgerGroup as
	(
		select	l.PartyID, x.SourceID, p.ContractID, l.CurrencyID, g.VaultTag
		,		IssueDate=iif(BillingCycle%7=0, cd.BOWeek, cd.BOMonth)
		,		l.ChargeRaw, LastInvoiceDate=isnull(i.LastInvoiceDate, dbo.DT@Empty()),	l.TalliedOn, BillingCycle
		from	acct.Contract#Raw()               x
		cross	apply dbo.Calendar#Of(@issueDate) cd
		join	shpt.Parcel#Raw()                 p on p.ContractID=x.ID
		join	acct.Ledger#Raw()                 l on l.MatterID=p.ID
		join	acct.Charge#Raw()                 g on l.ChargeID=g.ID
		cross	apply acct.Vault#Tag()            a
		cross	apply acct.Ledger#Side()          d
		outer	apply (
						select  LastInvoiceDate=max(IssueDate)
						from	acct.Invoice#Raw()
						where	PartyID=x.TenantID
						and		ContractID=x.ID
						and		VaultTag=g.VaultTag
						and		CurrencyID=l.CurrencyID
					  )                           i           
		where	l.InvoiceID=0
		and		(nullif(@vaultTag,0) is null or g.VaultTag=@vaultTag)
		and		l.LedgerSide=d.AR
		and		(nullif(@bizUnitID,0) is null or x.BizUnitID=@bizUnitID)
		and		(nullif(@partyID, 0) is null or x.TenantID=@partyID)
		and		(nullif(@source,  0) is null or x.SourceID=@source)
		and		BillingCycle>0
		and	    l.TalliedOn<iif(BillingCycle%7=0, cd.BOWeek, cd.BOMonth)
	), cteInvoiceSummary as
	(
		select	PartyID, SourceID, ContractID, CurrencyID, VaultTag
		,		IssueDate, ChargeRaw
		,		InvoiceGroup=DateDiff(day, TalliedOn, dateadd(day, -1,IssueDate))/BillingCycle
		from	cteLedgerGroup               x
		where	(BillingCycle%7=0 and datediff(day, LastInvoiceDate, IssueDate)>=BillingCycle)
		or		(BillingCycle%7>0 and datediff(month, LastInvoiceDate, IssueDate)=1)
	), cteInvoice as
	(
		select	PartyID, VaultTag, CurrencyID, ContractID, InvoiceGroup, IssueDate, ChargeRawAmt=sum(ChargeRaw)
		from	cteInvoiceSummary  
		group	by PartyID, VaultTag, CurrencyID, ContractID, InvoiceGroup, IssueDate
	)
	select	ID=PartyID, PartyAlias=p.Alias, CurrencyID, VaultTag, ChargeAmt=c.Amt
	,		t.SourceID, IssueDate, ContractID, InvoiceGroup
	,		DueDate=dateadd(day, iif(VaultTag=k.Duty, DutyTerms, NonDutyTerms), IssueDate)
	from	cteInvoice             x
	join	core.Party#Raw()       p on p.ID=x.PartyID
	cross	apply dbo.Currency#Encode(ChargeRawAmt, CurrencyID)  c
	join	acct.Contract#Raw()    t on t.ID=x.ContractID
	cross	apply acct.Vault#Tag() k
)
GO
PRINT N'Creating [svc].[Parcel$CriteriaForLoadBalance]...';


GO
-- PeterHo ,Irene
CREATE FUNCTION svc.Parcel$CriteriaForLoadBalance()
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	with cteSummary as
	(
		select	x.RcvHubID, x.POA, r.BrokerID, r.MftGroup, x.RouteID
		,		TotalParcelCnt=isnull(count(*), 0)
		,		TotalParcelWt =isnull(sum(cast(x.Weight as float)), 0)
		from	shpt.Parcel#Base()       x
		join	tms.Route#Raw()          r on r.ID=x.RouteID
		cross	apply core.Stage#ID()    k
		cross	apply core.Matter#Type() m
		where	x.Stage=k.RouteCfmed and x.PID=0 and x.Type=m.Parcel
		group	by x.RcvHubID, x.POA, r.BrokerID, r.MftGroup, x.RouteID
	)
	select	RcvHubID, RcvHubAlias=t.Alias
	,		BrokerID, b.BrokerAlias,  POA
	,		MftGroup, TotalParcelCnt, RouteID
	,		TotalParcelWt
	from	cteSummary           x
	join	core.Tenant#Raw()    t on t.ID=x.RcvHubID
	join	brkg.Broker#Raw()    b on b.ID=x.BrokerID
)
GO
PRINT N'Creating [svc].[Parcel$ForMeasureNotice]...';


GO
-- Daxia
CREATE FUNCTION [svc].[Parcel$ForMeasureNotice]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, x.PID, x.AID, x.Source, x.Type, x.Stage, x.StateID, x.SvcType
	,		RcvHubID,  RcvHubAlias=t.Alias,   t.UtcOffset, t.UtcPlace
	,		Weight,    Length, Width, Height, RefNbrs, ClientRefNbr=isnull(r.Number, N'')
	from	shpt.Parcel#Base()       x
	left	join core.Matter#Raw()   m on m.ID=x.AID
	cross	apply core.RefNbr#Type() k
	left	join core.RefNbr#Raw()   r on r.MatterID=m.ID and r.Type=k.ClientRef
	join	core.Tenant#Raw()        t on t.ID=x.RcvHubID
)
GO
PRINT N'Creating [svc].[Parcel$ExceptionListFor]...';


GO
--Ken, Aimee
CREATE FUNCTION [svc].[Parcel$ExceptionListFor](@siteID int)
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	x.ID, x.RefInfos, RefNbrs, Stage, StateID, StatedOn
	from	shpt.Parcel#Base()    x
	cross	apply core.Stage#ID() s
	where	x.Stage in (s.PreInterventionNeeded, s.InterventionNeeded, s.PostInterventionNeeded)
	and		x.SiteID=@siteID 
)
GO
PRINT N'Creating [svc].[Account$VaultSummary]...';


GO
-- Smile
CREATE FUNCTION [svc].[Account$VaultSummary](@partyID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	select	CurrencyID, VaultBal, VaultType, LockCnt
	from	acct.Vault#Raw() x
	cross	apply(
					select	LockCnt=count(*)
					from	core.Matter#Raw()     m
					cross	apply core.State#ID() s
					where	m.StateID=s.CreditLimitExceeded
				 ) l
	cross	apply acct.Vault#Type() t
	where	x.VaultType=t.Fund and x.PartyID=@partyID
)
GO
PRINT N'Creating [svc].[Account$ForCreditLimitExceeded]...';


GO
-- Smile
CREATE FUNCTION [svc].[Account$ForCreditLimitExceeded]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteSummary as
	(
		select	a.ID, a.Alias, x.HandlerID, ParcelCnt=count(*), MinStatedOn=min(x.StatedOn)
		from	core.State#ID() k, shpt.Parcel#Base() x
		join	core.Party#Raw()   p on x.ID=p.ID
		join	core.Party#Raw()   a on a.ID=p.AID
		where	x.StateID=k.CreditLimitExceeded
		group	by a.ID, a.Alias, x.HandlerID
	)
	select	x.ID, TenantAlias=x.Alias, HandlerID, Handler=u.Alias, Name, Phone, Email
	,		ParcelCnt=isnull(ParcelCnt, 0), MinStatedOn
	from	cteSummary                x
	join	core.User#Raw()           u on u.ID=x.HandlerID
	cross	apply core.Contact#Type() t
	join	core.Contact#Raw()   c on c.PartyID=x.ID and c.Type=t.Billing

)
GO
PRINT N'Creating [svc].[Account$VaultBalance]...';


GO
-- Smile
CREATE FUNCTION [svc].[Account$VaultBalance]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID=PartyID, TenantAlias=a.Alias, VaultBal, InvoicedAmt, UninvoicedAmt, CurrencyID, VaultType, CurBal, CreditLimit
	,		BizUnitID=ISNULL(BizUnitID, 0), BizUnit=ISNULL(p.Alias, N''), BillingCycle
	from	acct.Vault#Raw()         x
	join	core.Party#Raw()         a on a.ID=x.PartyID
	cross	apply acct.Contract#For(x.PartyID, a.Source) c
	join	core.Party#Raw()         p on p.ID=c.BizUnitID
)
GO
PRINT N'Creating [svc].[Appointment$ListForRamper]...';


GO
-- AaronLiu
CREATE FUNCTION [svc].[Appointment$ListForRamper](@ramperID I64)
RETURNS TABLE
--WITH ENCRYPTION
AS RETURN
(
	select	x.ID,	    x.SiteID,   SiteType=c.Type, x.PostedOn, x.Stage, x.StateID
	,		x.StatedOn, x.PickupOn, x.RefNbrs,		 x.RefInfos
	from	shpt.Appointment#Base() x
	cross	apply core.Party#Role() r
	cross	apply core.RefParty#Of(x.ID, r.Ramper) p
	join	core.Party#Raw()  c on x.SiteID=c.ID
	where	p.PartyID=@ramperID
)
GO
PRINT N'Creating [svc].[Appointment$List]...';


GO
--AaronLiu
CREATE FUNCTION [svc].[Appointment$List]()
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	x.ID,		x.SiteID,	TenantID=t.ID, TenantAlias=t.Alias,		x.PostedOn, x.Stage, x.StateID
	,		x.StatedOn, x.PickupOn, x.EstWeight,   Weight=isnull(Weight,0), x.RefNbrs,  x.RefInfos
	from	shpt.Appointment#Base() x
	join	core.Party#Raw()  s on s.ID=x.SiteID
	join	core.Party#Raw()  t on t.ID=s.PID
	cross	apply (
		select	Weight=isnull(sum(p.Weight),0)
		from	core.Matter#Type() t, core.Matter#ANodeDn(x.ID) m
		join	shpt.Parcel#Raw()  p on m.ID=p.ID
		where	m.Type=t.Parcel
	) c
)
GO
PRINT N'Creating [svc].[Parcel$ScanOneForApp]...';


GO
-- AaronLiu
CREATE FUNCTION [svc].[Parcel$ScanOneForApp](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	p.ID, p.Stage
	from	core.RefNbr#ScanOne(@number, default, default) x
	join	shpt.Parcel#Base() p on p.ID=x.MatterID
)
GO
PRINT N'Creating [tms].[Flight#Base]...';


GO
-- AaronLiu
CREATE FUNCTION [tms].[Flight#Base]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,	    PID, AID,     Source, Type, LockCnt, Stage, StateID,   StatedOn
	,		PostedAt,   PostedOn,     POD,    ETD,  POA,	 ETA,   FlightNbr, RefStamps
	,		RefParties, RoledActions, Challenges
	from	tms.Flight#Raw()   x
	join	core.Matter#Deep() m on m.ID=x.ID
)
GO
PRINT N'Creating [tms].[Route#Deep]...';


GO
--PeterHo
CREATE FUNCTION [tms].[Route#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,        MftGroup,        RouteCode
	,		ClrMethodID, m.ClrMethodCode, m.CountryCode
	,		BrokerID,    b.FlatRate,      b.PercentRate, b.BrokerAlias, b.ApiToken, b.ApiUrl
	,		CourierID,   c.CourierAlias,  c.CourierCode, CmdyRootID,    MaxSkuCnt,  MaxWeight
	from	tms.Route#Raw()      x
	join	brkg.ClrMethod#Raw() m on m.ID=x.ClrMethodID
	join	brkg.Broker#Raw()    b on b.ID=BrokerID
	join	tms.Courier#Raw()    c on c.ID=CourierID
)
GO
PRINT N'Creating [tms].[SvcCost#ByFactor]...';


GO
--Daxia
CREATE FUNCTION [tms].[SvcCost#ByFactor]
(
	@contractID    int,
	@onZoneCode3   char(3), 
	@toZoneCode3   char(3), 
	@toPlus2       char(2), 
	@svcClass      tinyint, 
	@measuredWt    real
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
		with cteRate as
		(
			select	DecAmt=iif(@measuredWt>453.592, x.HandlingFeeLB, x.HandlingFeeOZ)
					+(c.Cost * (1 + x.FuelSurchargeRatio)
							 * (1 + choose(z.Zone
								, x.Factor1, x.Factor2, x.Factor3
								, x.Factor4, x.Factor5, x.Factor6
								, x.Factor7, x.Factor8, x.Factor9)))
					+(isnull(a.AreaSurcharge, 0) * (1 + x.FuelSurchargeRatio))
			from	tms._SvcFactor     x
			join	tms.SvcClass#Raw() s on s.ID=x.SvcClass
			join	tms._SvcZone       z on z.OnZoneCode3=x.OnZoneCode3 and z.ToZoneCode3=@toZoneCode3 and z.CourierID=s.CourierID
			cross	apply
			(
				select	top(1) Cost=SvcCost from tms._SvcCost
				where	SvcClass=@svcClass and Zone=z.Zone and SectionWt>=@measuredWt
			) c
			outer	apply
			(
				select	AreaSurcharge from tms._AreaSurcharge
				where	ZoneCode=cast(@toZoneCode3+@toPlus2 as char(5))
			) a
			where	x.ContractID=@contractID and SvcClass=@svcClass and x.OnZoneCode3=@onZoneCode3
		)
		select	m.CurrencyID, m.Amt, m.RawAmt, x.DecAmt
		from	cteRate x cross apply dbo.Money#USD(x.DecAmt) m
)
GO
PRINT N'Creating [tms].[SvcFacility#For]...';


GO
-- PeterHo
CREATE FUNCTION [tms].[SvcFacility#For](@source tinyint, @svcClass tinyint, @zip3 char(3))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	f.CourierID,    c.ClassCode, TokenID
	,		ImportZoneCode, POA,         MailerID
	,		ImportZip3,     FacilityID,  FacilityInfo
	,		ShprInfo,       CneeInfo,    ReturnInfo
	from	tms.SvcClass#Raw() c
	join	tms.SvcFacility#ZoneCode() f on f.CourierID=c.CourierID
	where	c.ID=@svcClass and f.ZoneCode=@zip3 and f.SourceID=@source
)
GO
PRINT N'Creating [tms].[SvcRoute#Deep]...';


GO
--PeterHo
CREATE FUNCTION [tms].[SvcRoute#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	SvcType, POA,  Priority, MaxSkuCnt, MaxWeight
	,		RouteID,       r.RouteCode
	,		r.ClrMethodID, r.ClrMethodCode, r.CountryCode
	,		r.BrokerID,    r.BrokerAlias
	,		r.CourierID,   r.CourierAlias,  r.CourierCode
	from	tms.SvcRoute#Raw() x
	join	tms.Route#Deep()   r on r.ID=x.RouteID
)
GO
PRINT N'Creating [tms].[SvcType#Deep]...';


GO
--PeterHo
CREATE FUNCTION [tms].[SvcType#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,         TenantID,         TenantAlias=t.Alias
	,		x.CurrencyID, x.DutyCurrencyID, x.CmdyRootID
	,		ClrMethodID,  m.ClrMethodCode,  m.CountryCode
	from	tms.SvcType#Raw()    x
	join	core.Tenant#Raw()    t on t.ID=x.TenantID
	join	brkg.ClrMethod#Raw() m on m.ID=x.ClrMethodID
)
GO
PRINT N'Creating [tvp].[Newline#OfQuad]...';


GO
-- PeterHo
CREATE FUNCTION [tvp].[Newline#OfQuad](@value nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	v1, v2, v3, v4
	from	tvp.Quad#Of(@value, cast(char(13)+char(10) as nvarchar(255)))
)
GO
PRINT N'Creating [tvp].[Pcs#Left]...';


GO
 --PeterHo: 4/1
CREATE FUNCTION [tvp].[Pcs#Left]
(
	@value           nvarchar(max)
,   @separator       nvarchar(255)
,   @sprIndex        int
,   @keepTrailingSpr bit
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select  [Piece]=isnull(substring(@value, 0,
			iif(@keepTrailingSpr=1, Stop+(datalength(@separator)/2), Stop)), N'')
	from    tvp.Pcs#Tally(@value, @separator)
	order	by (select null)
	offset	iif(@sprIndex>0, @sprIndex-1, 0) rows
	fetch	next 1 rows only
)
GO
PRINT N'Creating [tvp].[Pcs#Mid]...';


GO
 --PeterHo: 4/1
CREATE FUNCTION [tvp].[Pcs#Mid]
(
	@value              nvarchar(max)
,   @separator          nvarchar(255)
,   @pieceIndex         int
,   @keepSurroundingSpr bit
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[Piece]=isnull(substring(@value
			,		iif(@keepSurroundingSpr=1,    Start-(datalength(@separator)/2),      Start)
			,		iif(@keepSurroundingSpr=1, (Stop-Start)+datalength(@separator), Stop-Start)), N'')
	from	tvp.Pcs#Tally(@value, @separator)
	order	by (select null)
	offset	iif(@pieceIndex>0, @pieceIndex-1, 0) rows
	fetch	next 1 rows only
)
GO
PRINT N'Creating [tvp].[Pcs#Right]...';


GO
 --PeterHo: 4/1
CREATE FUNCTION [tvp].[Pcs#Right]
(
	@value          nvarchar(max)
,   @separator      nvarchar(255)
,   @sprIndex       int
,   @keepLeadingSpr bit
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[Piece]=isnull(substring(@value,
		    iif(@keepLeadingSpr=1, Stop, Stop+(datalength(@separator)/2)), datalength(@value)), N'')
	from	tvp.Pcs#Tally(@value, @separator)
	order	by (select null)
	offset	iif(@sprIndex>0, @sprIndex-1, 0) rows
	fetch	next 1 rows only
)
GO
PRINT N'Creating [vmi].[Parcel$Summary]...';


GO
--Smile
CREATE FUNCTION [vmi].[Parcel$Summary]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, Stage, x.Source, SvcType, RcvHubID, RcvHubAlias=h.Alias, TenantID=t.ID, TenantAlias=t.Alias
	,		RefNbrs, RefInfos
	from	shpt.Parcel#Base() x
	join	core.Party#Raw()   h on h.ID=x.RcvHubID
	join	core.Party#Raw()   p on p.ID=x.SiteID
	join	core.Party#Raw()   t on t.ID=p.PID
	cross	apply core.Source#ID() k
	where	x.Source=k.eVMI
)
GO
PRINT N'Creating [vmi].[AccountBal$Verify]...';


GO
--Smile
CREATE FUNCTION [vmi].[AccountBal$Verify](@acctID int, @svcType int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	v.ID, v.CurBal
	from	tms.SvcType#For(@svcType, @acctID) x
	join	tms.SvcType#Raw()                  e on e.ID=x.ID
	cross	apply acct.Vault#Type()            k
	join	acct.Vault#Raw()                   v on v.PartyID=@acctID 
												and v.CurrencyID=e.CurrencyID 
												and v.VaultType=k.Fund

)
GO
PRINT N'Creating [vmi].[Invoice$SummaryForSasa]...';


GO

--Smile
CREATE FUNCTION [vmi].[Invoice$SummaryForSasa]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with cte as
	(
			select	x.ID, x.PartyID, VaultBal=c.NextBal, x.CurrencyID, x.TalliedOn, ChargeID, ChargeAmt
			,		ClientRefNbr=N'', RefNbr=r.Number, Supplement=N'', c.XactedOn
			,		SectionWt=0, Weight=0
			from	acct.Ledger#Raw()        x
			join	acct.Vault#Raw()         v on x.PartyID=v.PartyID and x.CurrencyID=v.CurrencyID
			join	acct.VaultXact#Raw()     c on c.VaultID=v.ID and c.InvoiceID=x.InvoiceID
			cross	apply core.RefNbr#Type() k
			join	core.RefNbr#Raw()        r on r.MatterID=x.MatterID and r.Type=k.AsnNbr
			
			union all
			select	x.ID, x.PartyID, VaultBal=c.NextBal, x.CurrencyID, x.TalliedOn, ChargeID, ChargeAmt
			,		ClientRefNbr=N'', RefNbr=N'', Supplement, c.XactedOn
			,		SectionWt=0, Weight=0
			from	acct.Ledger#Raw()          x
			cross	apply core.Matter#Type()   k
			join	core.Matter#Raw()          m on m.ID=x.MatterID and m.Type =k.AssortedFees
			join	acct.Vault#Raw()           v on x.PartyID=v.PartyID and x.CurrencyID=v.CurrencyID
			join	acct.VaultXact#Raw()       c on c.VaultID=v.ID and c.InvoiceID=x.InvoiceID
			cross	apply core.Registry#ID()   r 
			join	core.Supplement#Raw()      s on s.RegID =r.AssortedFees and s.RowID=m.ID
			
			union all
			select	x.ID, x.PartyID, VaultBal=c.NextBal, x.CurrencyID, x.TalliedOn, ChargeID, ChargeAmt
			,		ClientRefNbr=N'', RefNbr=N'', Supplement, c.XactedOn
			,		SectionWt=0, Weight=0
			from	acct.Ledger#Raw()          x
			cross	apply core.Matter#Type()   k
			join	core.Matter#Raw()          m on m.ID=x.MatterID and m.Type =k.StorageFee
			join	acct.Vault#Raw()           v on x.PartyID=v.PartyID and x.CurrencyID=v.CurrencyID
			join	acct.VaultXact#Raw() c on c.VaultID=v.ID and c.InvoiceID=x.InvoiceID
			cross	apply core.Registry#ID()   r 
			join	core.Supplement#Raw()      s on s.RegID =r.Ledger and s.RowID=x.ID
			
			union all
			select	x.ID, x.PartyID, VaultBal=c.NextBal, x.CurrencyID, x.TalliedOn, ChargeID, ChargeAmt
			,		ClientRefNbr=r.Number, RefNbr=p.Number, Supplement=N'', c.XactedOn
			,		SectionWt=Weight, Weight
			from	acct.Ledger#Raw()          x					
			join	shpt.Parcel#Raw()          m on m.ID=x.MatterID 
			join	acct.Vault#Raw()           v on x.PartyID=v.PartyID and x.CurrencyID=v.CurrencyID
			join	acct.VaultXact#Raw()       c on c.VaultID=v.ID and c.InvoiceID=x.InvoiceID
			cross	apply core.RefNbr#Type()   t
			join	core.RefNbr#Raw()          r on r.MatterID=m.ID and r.Type=t.ClientRef
			left	join core.RefNbr#Raw()     p on p.MatterID=m.ID and p.Type=t.PostCourier
			
			union all
			select	x.ID, x.PartyID, VaultBal=c.NextBal, x.CurrencyID, x.PaidOn, ChargeID=iif(x.PaidAmt>0, g.Deposit, g.Deduct)
			,		ChargeAmt=x.PaidAmt
			,		ClientRefNbr=N'', RefNbr=N'', Supplement=N'', c.XactedOn
			,		SectionWt=0, Weight=0
			from	acct.Payment#Raw()   x
			join	acct.Vault#Raw()     v on x.PartyID=v.PartyID and x.CurrencyID=v.CurrencyID
			join	acct.VaultXact#Raw() c on c.VaultID=v.ID and c.PaymentID=x.ID
			cross	apply acct.Charge#ID() g
					
				
	)
	select	u.ID, PartyAlias=d.Alias, TalliedOn, ClientRefNbr, CurrencyID, XactedOn
	,		RefNbr, VaultBal, ChargeAmt, Weight, SectionWt,  ChargeID, Supplement	
	from	core.Party#Raw() d
	join	cte              u on d.ID=u.PartyID
	where	d.ID in (10983, 10987)


)
GO
PRINT N'Creating [vmi].[Account$VaultBalFor]...';


GO
-- Smile
CREATE FUNCTION [vmi].[Account$VaultBalFor](@partyID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID=PartyID, VaultBal, InvoicedAmt, UninvoicedAmt, CurrencyID, VaultType, CurBal, CreditLimit
	from	acct.Vault#Raw()  x
	where	x.PartyID=@partyID 
)
GO
PRINT N'Creating [whse].[StockInOrder#Base]...';


GO
--Smile
CREATE FUNCTION [whse].[StockInOrder#Base]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, PID, AID,     Source, Type, LockCnt,    Stage,    StateID,  StatedOn,	RcvHubID, ContractID
	,		SiteID=m.PosterID,  SiteAlias=m.PosterAlias,  PostedAt, PostedOn, SiteUtcOffset=m.UtcOffset
	,		RefNbrs,  RefInfos, RefStamps,   RefParties, RoledActions,  Challenges, AddOnServices, TotalSkuQty
	from	whse.StockInOrder#Raw() x
	join	core.Matter#Deep()      m on m.ID=x.ID
)
GO
PRINT N'Creating [zeb].[Parcel$RePacked]...';


GO
-- AaronLiu
CREATE FUNCTION [zeb].[Parcel$RePacked](@parcelID I64)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ID
	from	shpt.Parcel#Base()
	where	AID=@parcelID
)
GO
PRINT N'Creating [dbo].[Bit#On]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Bit#On](@value bigint, @size tinyint)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	top(@size%65) Bit, Val
	from	dbo.Bit#Wise()
	where	(Val&@value)<>cast(0 as bigint)
)
GO
PRINT N'Creating [dbo].[Calendar#Emit]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Calendar#Emit] (@dayCount int, @anchorOffset int=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteAnchor as
	(
		select	[Anchor]=dateadd(yy, isnull(@anchorOffset, 0), k.Anchor)
		from	dbo.DT#Const() k
	)
	select	Value
	,		Year,    Quarter, Month,   Week,    Day,Dow
	,		YOffset, QOffset, MOffset, WOffset, DOffset
	from	cteAnchor
	cross	apply dbo.Nbr#Emit(abs(@dayCount))
	cross	apply dbo.Calendar#Of(dateadd(dd, (Nbr-1)*sign(@dayCount), Anchor))
)
GO
PRINT N'Creating [dbo].[Money#CNY]...';


GO
-- PeterHo
CREATE FUNCTION [dbo].[Money#CNY](@decAmt float)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	CurrencyID=CNY, Amt, RawAmt
	from	dbo.Currency#ID()
	cross	apply dbo.Money#Make(@decAmt, CNY)
)
GO
PRINT N'Creating [acct].[VaultXact#LastBalFor]...';


GO
--Smile.Wang
CREATE FUNCTION [acct].[VaultXact#LastBalFor](@vaultID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, PrevBalRaw=x.RawAmt
	from	acct.VaultXact#Raw()                  v
	cross	apply dbo.Money#Sum(PrevBal, XactAmt) p	
	cross	apply dbo.Money#Of(p.Amt)             x
	where	ID=
	           (select	top(1) ID=last_value(ID) over (order by (select 0))	
				from	acct.VaultXact#Raw()		
				where	VaultID=@vaultID
			   )
	
)
GO
PRINT N'Creating [acct].[Vault#IdOf]...';


GO
-- PeterHo
CREATE FUNCTION [acct].[Vault#IdOf](@partyID bigint, @currencyID tinyint, @valutType tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID from acct.Vault#Raw()
	where	(PartyID=@partyID and CurrencyID=@currencyID and VaultType=@valutType)
)
GO
PRINT N'Creating [co].[Parcel$PendingFor]...';


GO
--Ken
CREATE FUNCTION [co].[Parcel$PendingFor](@days tinyint,@tenantID int)
RETURNS TABLE
WITH SCHEMABINDING,ENCRYPTION
AS RETURN
(
	select	ParcelCnt=count(ID), Date=x.Value 
	from	dbo.Calendar#Raw()            x
	cross	apply core.Stage#Boundary()   s
	left	join shpt.Parcel#Base()       p 
	on		x.Value=cast(StatedOn as date)  and p.Stage between s.PreMin and s.PreMax
	and		p.SiteID in 
	(
		select	ID 
		from	core.Party#Raw()         t
		cross	apply core.Party#Type()  k
		where	t.PID=@tenantID and      t.Type=k.TenantSite
	)	
	where  Value between dateadd(day, -@days+1, cast(getutcdate() as date)) and cast(getutcdate() as date) 
	group  by x.Value 
)
GO
PRINT N'Creating [hub].[Parcel$SortingInfoVia]...';


GO
-- Eva
CREATE FUNCTION [hub].[Parcel$SortingInfoVia](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING
--, ENCRYPTION
AS RETURN 
(
	select	ID, p.Stage, StateID, StatedOn, RefNbrs, Port=POA--?
	from	core.RefNbr#ScanOne(@number, default, default) x
	join	shpt.Parcel#Base() p on p.ID=x.MatterID
)
GO
PRINT N'Creating [hub].[Sack$InManifest]...';


GO
-- AaronLiu
CREATE	FUNCTION [hub].[Sack$InManifest](@sackMftID I64)
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ID,	 Stage,	   StateID,     StatedOn,      HubID,     ManifestID=PID
	,		POA, BrokerID, ClrMethodID, Weight=SackWt, ParcelCnt, PostedOn
	,		SackNbr=r.Number
	from	shpt.Sack#Base()	     x
	cross	apply core.RefNbr#Type() s
	join	core.Port#Raw()		     a on  x.POA=a.Code
	join	core.RefNbr#Raw()        r on r.MatterID=x.ID and r.Type=s.MIT
	cross	apply (
		select	ParcelCnt = isnull(sum(case when m.Type=t.Parcel then 1 else 0 end),0)
		from	core.Matter#PNodeDn(x.ID) m
		cross	apply core.Matter#Type()  t
	) n
	where	x.PID=@sackMftID
)
GO
PRINT N'Creating [hub].[SackMft$Summary]...';


GO
-- AaronLiu, Smile
CREATE	FUNCTION [hub].[SackMft$Summary]()
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ID,       Stage, StateID,   StatedOn,   HubID
	,		BrokerID, POA,   ParcelCnt, UnSackedParcelCnt
	,		SackCnt,  PostedOn
	from	shpt.SackMft#Base()	x
	cross	apply (
		select	SackCnt			  = isnull(sum(case when m.Type=t.Sack   then 1 else 0 end),0)
		,		ParcelCnt		  = isnull(sum(case when m.Type=t.Parcel then 1 else 0 end),0)
		,		UnSackedParcelCnt = isnull(sum(case when m.Type=t.Parcel and m.Level=1 then 1 else 0 end),0)
		from	core.Matter#PNodeDn(x.ID) m
		cross	apply core.Matter#Type()  t
	) n
)
GO
PRINT N'Creating [hub].[SackLoad$ScanOne]...';


GO
-- AaronLiu
CREATE FUNCTION [hub].[SackLoad$ScanOne](@number varchar(40))
RETURNS	TABLE
--WITH ENCRYPTION
AS RETURN
(
	select	ID,		   s.Stage, StateID, StatedOn, PostedOn, HubID, RefNbrs, SackCnt
	,		TruckerID, Trucker
	from	core.RefNbr#ScanOne(@number, default, default) x
	join	shpt.SackLoad#Base() s on s.ID=x.MatterID
	cross	apply
	(
		select	SackCnt=isnull(sum(case when m.Type=t.Sack then 1 else 0 end),0)
		from	core.Matter#ANodeDn(s.ID) m
		cross	apply core.Matter#Type()  t
	) n
)
GO
PRINT N'Creating [hub].[Sack$InLoad]...';


GO
-- Eva
CREATE	FUNCTION [hub].[Sack$InLoad](@sackloadID I64)
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ID,  Stage,   StateID, StatedOn,      HubID,    POD, POA
	,		BrokerID, ClrMethodID, Weight=SackWt, PostedOn, FlightID
	,		SackNbr=r.Number
	from	shpt.Sack#Base()         x
	cross	apply core.RefNbr#Type() s
	join	core.RefNbr#Raw()        r on r.MatterID=x.ID and r.Type=s.MIT
	where	x.AID=@sackloadID
)
GO
PRINT N'Creating [hub].[SackLoad$List]...';


GO
-- AaronLiu
CREATE FUNCTION [hub].[SackLoad$List]()
RETURNS	TABLE
--WITH ENCRYPTION
AS RETURN
(
	select	ID, Stage, StateID, StatedOn, PostedOn, HubID, RefNbrs, SackCnt
	,		TruckerID, Trucker
	from	shpt.SackLoad#Base() x
	cross	apply
	(
		select	SackCnt=isnull(sum(case when m.Type=t.Sack then 1 else 0 end),0)
		from	core.Matter#ANodeDn(x.ID) m
		cross	apply core.Matter#Type()  t
	) n
)
GO
PRINT N'Creating [hub].[Sack$ScanOne]...';


GO
-- AaronLiu, Eva
CREATE FUNCTION [hub].[Sack$ScanOne](@number varchar(40))
RETURNS	TABLE
--WITH ENCRYPTION
AS RETURN
(
	select	ID,  s.Stage, StateID, StatedOn,      HubID,    POD, POA
	,		BrokerID, ClrMethodID, Weight=SackWt, PostedOn, FlightID
	,		SackNbr=r.Number
	from	core.RefNbr#ScanOne(@number, default, default) x
	join	shpt.Sack#Base()         s on s.ID=x.MatterID
	cross	apply core.RefNbr#Type() t
	join	core.RefNbr#Raw()        r on r.MatterID=s.ID and r.Type=t.MIT
)
GO
PRINT N'Creating [hub].[Parcel$CheckForRackIn]...';


GO
-- Smile
CREATE FUNCTION [hub].[Parcel$CheckForRackIn](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	p.ID
	from	core.RefNbr#ScanOne(@number, default, default) x
	join	shpt.Parcel#Base() p on p.ID=x.MatterID
	cross	apply core.State#ID() k
	where	p.StateID=k.Carted
)
GO
PRINT N'Creating [hub].[Sack$DetailForPrint]...';


GO
-- Smile
CREATE FUNCTION [hub].[Sack$DetailForPrint](@sackID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	RouteID=t.ID, FmCountryCode=c.CountryCode, SackSeq=isnull(q.SeqNbr, 0)
	,		x.PostedOn
	from	shpt.Sack#Base()          x
	cross	apply core.Contact#Type() k
	join	core.Contact#Raw() c on x.HubID=c.PartyID and c.Type=k.Billing
	join	tms.Route#Raw()    t on t.ClrMethodID=x.ClrMethodID and t.BrokerID=x.BrokerID
	cross	apply shpt.Sack#SeqNbrOf(x.ID) q
	where	x.ID=@sackID
)
GO
PRINT N'Creating [hub].[Sack$ScanOneForMft]...';


GO
-- Eva
CREATE FUNCTION [hub].[Sack$ScanOneForMft](@number varchar(40))
RETURNS	TABLE
--WITH ENCRYPTION
AS RETURN
(
	select	s.ID, SackNbr=n.Number, s.Stage, StateID,  StatedOn, HubID, POD, POA
	,		RouteID=r.ID, PostedOn, ParcelCnt
	from	core.RefNbr#ScanOne(@number, default, default) x
	join	shpt.Sack#Base()             s on s.ID=x.MatterID
	join	tms.Route#Raw()              r on r.ClrMethodID=s.ClrMethodID and r.BrokerID=s.BrokerID
	cross	apply core.RefNbr#Type()     t
	join	core.RefNbr#Raw()            n on n.MatterID=s.ID and n.Type=t.MIT
	cross	apply hub.Sack#Parcels(s.ID) p
)
GO
PRINT N'Creating [hub].[Sack$List]...';


GO
-- Eva
CREATE	FUNCTION [hub].[Sack$List]()
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	x.ID, SackNbr=r.Number, Stage, StateID,  StatedOn, HubID, POD, POA
	,		RouteID=t.ID, PostedOn, ParcelCnt
	from	shpt.Sack#Base()             x
	cross	apply core.RefNbr#Type()     s
	join	core.RefNbr#Raw()            r on r.MatterID=x.ID and r.Type=s.MIT
	join	tms.Route#Raw()              t on t.ClrMethodID=x.ClrMethodID and t.BrokerID=x.BrokerID
	cross	apply hub.Sack#Parcels(x.ID) n
)
GO
PRINT N'Creating [hub].[Parcel$ListForMedium]...';


GO
-- Smile
CREATE FUNCTION [hub].[Parcel$ListForMedium](@unityID bigint)
RETURNS TABLE
--WITH ENCRYPTION
AS RETURN 
(
	select	ID, StateID, RefNbrs, RefInfos
	from	shpt.Parcel#Base() p
	where	p.AID=@unityID
)
GO
PRINT N'Creating [hub].[Parcel$UnityInfoVia]...';


GO
-- Smile
CREATE FUNCTION [hub].[Parcel$UnityInfoVia](@number varchar(40))
RETURNS TABLE
--WITH ENCRYPTION
AS RETURN 
(
	select	p.ID, RefNbrs, RefInfos
	from	core.RefNbr#ScanOne(@number, default, default) x
	cross	apply core.Matter#Type()                       k
	join	core.Matter#Raw()                              m on m.ID=x.MatterID and m.Type=k.MediumParcel
	join	shpt.Parcel#Base()                             p on p.ID=m.AID

)
GO
PRINT N'Creating [ic].[SackMft$ForOutgated]...';


GO
--Daxia
CREATE	FUNCTION [ic].[SackMft$ForOutgated]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, MawbNbr, FlightNbr, Stage,       StatedOn
	,		POA,  POD,     p.RouteID, t.RouteCode
	,		[TotalParcelCnt]=isnull(p.TotalParcelCnt, 0)
	from	shpt.SackMft#Deep()	  x
	cross	apply
	(
		select	TotalParcelCnt=count(*), RouteID
		from	core.Matter#Raw() m cross apply core.Matter#Type() k
		join	shpt.Parcel#Base()  t on t.PID=m.ID 
		where	m.PID=x.ID group by t.RouteID
	) p
	join	tms.Route#Raw() t on t.ID=p.RouteID
)
GO
PRINT N'Creating [ic].[Parcel$ForHandWrittenOrder]...';


GO
--Aimee, bd.he, Daxia
CREATE FUNCTION [ic].[Parcel$ForHandWrittenOrder]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID,    x.Source, Stage, StateID, StatedOn, PostedOn,  PostedAt
	,		RefNbrs, RefInfos, ShopID=SiteID,  ShopAlias=SiteAlias, HandlerID, u.Handler
	from	core.Source#ID()   k, shpt.Parcel#Base() x
	cross	apply svc.User$ContactName(x.HandlerID)  u
	where	x.Source=k.AAE and SvcType=0
)
GO
PRINT N'Creating [loc].[Tenancy#As]...';


GO
-- PeterHo
CREATE FUNCTION [loc].[Tenancy#As](@tenancy nvarchar(max), @tobeRole int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Tenancy=Tvp
	from	loc.Tenancy#Of(@tenancy)
	cross	apply tvp.Quad#Make(PID, AID, UserID, @tobeRole)
)
GO
PRINT N'Creating [shpt].[Parcel#Deep]...';


GO
--PeterHo
CREATE FUNCTION [shpt].[Parcel#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, PID,   AID, x.Source,  Type, LockCnt, Stage, StateID, StatedOn,      BatchID,  b.BatchedOn
	,		x.SiteID,    x.SiteAlias,    PostedAt,      PostedOn,       SiteUtcOffset, RcvHubID, RcvHubAlias=h.Alias
	,		RouteID,     r.RouteCode,    r.MftGroup,    r.BrokerID,     r.BrokerAlias, r.CmdyRootID, POA
	,		r.CourierID, r.CourierAlias, r.CourierCode  --<<-- TobeDropped
	,		LastMilerID, LastMilerAlias=c.CourierAlias, LastMilerCode=c.CourierCode
	,		ContractID
	,		SvcType,     SvcZone,  SvcClass,  Weight,     Length,       Width,      Height, ZoneCode
	,		RefNbrs,     RefInfos, RefStamps, RefParties, RoledActions, Challenges, a.Ledgers
	,		HandlerID,   AddOnServices
	from	shpt.Parcel#Base() x
	join	shpt.Batch#Raw()   b on b.ID=x.BatchID
	join	core.Tenant#Raw()  h on h.ID=x.RcvHubID
	join	tms.Courier#Raw()  c on c.ID=x.LastMilerID
	join	tms.Route#Deep()   r on r.ID=x.RouteID
	outer	apply acct.Ledger#Tvp  (x.ID) a
)
GO
PRINT N'Creating [shpt].[Parcel#LedgerByFactor]...';


GO
--Daxia
CREATE FUNCTION [shpt].[Parcel#LedgerByFactor](@parcelIDs dbo.I64Array readonly)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteLedger as
	(
		select	[MatterID]  =x.ID, x.ContractID, [LadgerPartyID]=p.AID, [ChargeAmt]=r.Amt, r.CurrencyID
		,		[LedgerPartyID]=iif(lag(p.AID) over (partition by p.AID order by (select 0)) is null, p.AID, 0)
		,		[LedgerDueAmt] =sum(r.RawAmt)  over (partition by p.AID)
		from	@parcelIDs i
		join	shpt.Parcel#Base() x on x.ID=i.ID
		join	core.Party#Raw()   p on p.ID=x.SiteID
		cross	apply tms.SvcFacility#For(x.SvcClass, left(x.ZoneCode, 3)) f
		cross	apply tms.SvcCost#ByFactor(x.ContractID, f.ImportZip3, left(x.ZoneCode, 3), substring(x.ZoneCode, 4, 2), x.SvcClass, x.MeasuredWt) r
	)
	select	MatterID, ContractID, LadgerPartyID, ChargeID=g.Freight, ChargeAmt, CurrencyID, LedgerPartyID, InvDueAmt=c.Amt
	from	cteLedger
	cross	apply dbo.Currency#Encode(LedgerDueAmt, CurrencyID) c
	cross	apply acct.Charge#ID() g
)
GO
PRINT N'Creating [svc].[Parcel$TrackOne]...';


GO
--PeterHo
CREATE FUNCTION [svc].[Parcel$TrackOne](@trackingNbr varchar(40))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	Tracks, CourierCode, CourierNbr
	from	core.RefNbr#ScanOne(@trackingNbr, default, default) x
	cross	apply svc.Parcel$Track(x.MatterID) a

/*
	select	ID, a.Stage, UserID,  UserAlias
	,		UtcPlace,    UtcTime, UtcOffset
	from	core.RefNbr#ScanOne(@trackingNbr, default, default) x
	cross	apply svc.Parcel$Track(x.MatterID) a
*/
)
GO
PRINT N'Creating [svc].[Parcel$ForLoadBalance]...';


GO
-- Smile, PeterHo, Aimee
CREATE FUNCTION [svc].[Parcel$ForLoadBalance] (@stage int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, RefNbrs, RcvHubID,  RcvHubAlias, POA, StateID, StatedOn, Source
	,		RouteID,     RouteCode, BrokerID,    BrokerAlias
	from	shpt.Parcel#Deep() 	
	where	Stage=@stage
)
GO
PRINT N'Creating [svc].[Parcel$Detail]...';


GO
-- Eason
CREATE FUNCTION svc.Parcel$Detail()
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	ID, PID, AID, Source, PostedOn,  Stage,        StateID,  StatedOn
	,		BatchID, BatchedOn,   RcvHubID,  RcvHubAlias,  SiteID,   SiteAlias
	,		RouteID, RouteCode,   CourierID, CourierAlias, BrokerID, BrokerAlias
	,		POA,     SvcType,     SvcZone,   SvcClass,     Weight,   Length,   Width, Height
	,		RefNbrs, RefInfos,    Ledgers,   Challenges,   AddOnServices, ZoneCode
	from	shpt.Parcel#Deep()
)
GO
PRINT N'Creating [svc].[Parcel$ExceptionList]...';


GO
-- Smile, Ken, bd.he, Daxia
CREATE FUNCTION [svc].[Parcel$ExceptionList]()
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	x.ID,    x.StateID, StatedOn, Stage,    Source, SvcType, POA, HandlerID, u.Handler
	,		RouteID, RouteCode, RefNbrs,  RefInfos, RoledActions,    LastMessage=m.Body
	from	shpt.Parcel#Deep() x cross apply core.Registry#ID() k
	cross	apply svc.User$ContactName(x.HandlerID)             u
	outer	apply core.Message#BodyOfLast(k.Matter, x.ID)       m
)
GO
PRINT N'Creating [svc].[Parcel$ShippingPlanList]...';


GO
-- Aimee, Smile
Create FUNCTION [svc].[Parcel$ShippingPlanList]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, Stage, x.Source, POA, Weight, RefNbrs, RouteID, RouteCode
	,		RcvHubID,  RcvHubAlias, RefInfos, HandlerID, Handler=u.Alias
	from	shpt.Parcel#Deep() x
	join	core.User#Raw()    u on x.HandlerID=u.ID
)
GO
PRINT N'Creating [svc].[Parcel$ForStage]...';


GO
--Aimee, Ken, bd.he
CREATE FUNCTION [svc].[Parcel$ForStage]()
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	x.ID, x.Source, Stage, RcvHubID, RcvHubAlias, RefNbrs, StatedOn
	,		TenantID=t.ID, TenantAlias=t.Alias,   RouteID, RouteCode
	,		Handler, HandlerID
	from	core.Party#Type() k, shpt.Parcel#Deep() x
	join	core.Party#Raw()  s on s.ID=x.SiteID
	join	core.Party#Raw()  t on t.ID=s.PID
	cross	apply svc.User$ContactName(x.HandlerID) u
)
GO
PRINT N'Creating [svc].[SackMft$Export]...';


GO
--Sam
CREATE	FUNCTION [svc].[SackMft$Export]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, p.RefNbrs, p.RefInfos,  p.Weight, p.RouteID, p.PostedOn
	from	shpt.SackMft#Raw()  x
	join    shpt.Parcel#Deep()  p on p.PID = x.ID
)
GO
PRINT N'Creating [svc].[Parcel$OutgatedList]...';


GO
--Smile, Aimee
CREATE FUNCTION [svc].[Parcel$OutgatedList]()
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	x.ID, x.Source, x.StatedOn,  x.StateID, SvcType, x.Stage, x.PostedOn, x.RefStamps, x.RefNbrs
	,		x.POA,  RcvHubID, RcvHubAlias, RouteID, RouteCode, LastMilerAlias,      MawbNbr,     FlightNbr
	,		[PosterAlias]=x.SiteAlias, [SackNbr]=s.RefNbrs,    RefInfos
	from	shpt.Parcel#Deep()       x	
	left	join shpt.Sack#Base()    s  on s.ID=x.PID
	left	join shpt.SackMft#Deep() sm on sm.ID=s.PID or sm.ID=x.PID
)
GO
PRINT N'Creating [svc].[Parcel$ForCreateSackMft]...';


GO
-- Smile
--TODO: clear old Parcel$ForLoadBalance
CREATE FUNCTION [svc].[Parcel$ForCreateSackMft] ()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID,      Source,   RefNbrs,   RcvHubID, RcvHubAlias, POA,      StateID, StatedOn
	,		RouteID, MftGroup, RouteCode, BrokerID, BrokerAlias, RefInfos, Weight
	from	shpt.Parcel#Deep()    x 
	cross	apply core.Stage#ID() k
	where	x.Stage=k.RouteCfmed
)
GO
PRINT N'Creating [svc].[Flight$List]...';


GO
-- AaronLiu
CREATE FUNCTION [svc].[Flight$List]()
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID,  FlightNbr, PostedOn, Stage, StateID, StatedOn, RefStamps, RoledActions
	,		POD, [PODUtcOffset]=d.UtcOffset, [PODUtcPlaceID]=d.UtcPlaceID, ETD
	,		POA, [POAUtcOffset]=a.UtcOffset, [POAUtcPlaceID]=a.UtcPlaceID, ETA
	from	tms.Flight#Base()	 x
	join	core.Port#Raw() a on x.POA=a.Code
	join	core.Port#Raw() d on x.POD=d.Code
)
GO
PRINT N'Creating [svc].[SackMft$ExportForOutgate]...';


GO
--Eva
CREATE	FUNCTION [svc].[SackMft$ExportForOutgate]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID,    x.FlightNbr, x.MawbNbr, MftPostedOn=x.PostedOn, x.BrokerID, x.POD, x.POA, x.HubAlias
	,		SackNbrs=s.RefNbrs
	,		p.RefNbrs, p.RefInfos, p.Weight, p.RouteID, p.PostedOn
	from	shpt.SackMft#Deep() x
	join	shpt.Sack#Base()    s on s.PID=x.ID
	join	shpt.Parcel#Deep()  p on p.PID=s.ID

	UNION

	select	x.ID,    x.FlightNbr, x.MawbNbr, MftPostedOn=x.PostedOn, x.BrokerID, x.POD, x.POA, x.HubAlias
	,		SackNbrs=N''
	,		p.RefNbrs, p.RefInfos, p.Weight, p.RouteID, p.PostedOn
	from	shpt.SackMft#Deep() x
	join	shpt.Parcel#Deep()  p on p.PID = x.ID
)
GO
PRINT N'Creating [svc].[Parcel$ListForCainiao]...';


GO
--Smile, AaronLiu
CREATE FUNCTION [svc].[Parcel$ListForCainiao]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID,		 x.RcvHubAlias, MIC=m.Number
	,		LastMilerID, LastMilerCode, x.RouteID
	,		PostCourier=isnull(c.Number,    N'')
	,		FlightNbr  =isnull(d.FlightNbr, N'')
	,		POA=isnull(d.POA, N'')
	,		POD=isnull(d.POD, N'')
	from	shpt.Parcel#Deep()       x
	cross	apply core.Matter#Type() mk
	cross	apply core.RefNbr#Type() k
	join	core.RefNbr#Raw()        m on m.MatterID=x.ID and m.Type=k.MIT
	left	join core.RefNbr#Raw()   c on c.MatterID=x.ID and c.Type=k.PostCourier
	outer	apply 
	(
		select	SackMftID=ID 
		from	core.Matter#PNodeUp(x.ID)
		where	Type=mk.SackMft
	) s
	left	join shpt.SackMft#Deep() d on d.ID=s.SackMftID 
)
GO
PRINT N'Creating [svc].[Parcel$ForOutgatedNotice]...';


GO
-- For eForward Notice
-- Daxia
CREATE FUNCTION [svc].[Parcel$ForOutgatedNotice]()
RETURNS TABLE
WITH  ENCRYPTION
AS RETURN
(
	select	x.ID, SvcType, Weight,          LastMilerAlias,      SiteAlias
	,		x.RefNbrs,     m.RefStamps,     m.MawbNbr,           FlightNbr
	,		HubCountryCode=c.CountryCode,   SackSeqNbr=isnull(n.SeqNbr, 0)
	,		SackPostedOn=isnull(p.PostedOn, N'0001-01-01'), x.StatedOn
	,		ETA=isnull(ETA, N'0001-01-01'), ETD=isnull(ETD, N'0001-01-01')
	,		HubUtcOffset=isnull(a.UtcOffset, 0), OutgatedOn=isnull(a.UtcTime, '')
	from	core.State#ID() i, shpt.Parcel#Deep()   x
	cross	apply core.Matter#Type() k
	outer	apply (
					select	SackMftID=ID 
					from	core.Matter#PNodeUp(x.ID) d
					where	Type=k.SackMft) s
	left	join  shpt.SackMft#Deep()       m on m.ID=s.SackMftID 
	left	join  shpt.Sack#Base()          p on p.ID=x.PID
	outer	apply core.Activity#TrackSpecific(x.ID, 48700) a--i.OutGated) a
	outer	apply shpt.Sack#SeqNbrOf(p.ID)  n
	outer	apply (
		select	top(1) CountryCode
		from	core.Contact#Type() k, core.Contact#Raw() c 
		where	c.PartyID=p.HubID and c.Type=k.Billing
	) c
)
GO
PRINT N'Creating [svc].[Parcel$WithChallenge]...';


GO
--wangtianqi, Smile
CREATE FUNCTION [svc].[Parcel$WithChallenge]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID,    x.StateID, StatedOn, Stage, Source, SvcType, POA 
	,		HandlerID, RouteID, RouteCode, RefNbrs,  RoledActions, ChallengeBody=c.Body, u.Handler
	from	shpt.Parcel#Deep()            x 
	cross	apply core.Challenge#Of(x.ID) c
	cross	apply svc.User$ContactName(x.HandlerID) u
)
GO
PRINT N'Creating [svc].[Parcel$Label]...';


GO
-- Daxia
CREATE FUNCTION svc.Parcel$Label()
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	ID, PID, AID, Source, PostedOn,    x.Stage,      StateID,  StatedOn
	,		BatchID, BatchedOn,   RcvHubID,    RcvHubAlias,  SiteID,   SiteAlias
	,		RouteID, RouteCode,   x.CourierID, CourierAlias, BrokerID, BrokerAlias
	,		x.POA,   SvcType,     SvcZone,     SvcClass,     Weight,   Length, Width, Height
	,		RefNbrs, RefInfos,    Ledgers,     Challenges,   AddOnServices,    ZoneCode
	,		FacilityID=isnull(FacilityID%100, 0), BarcodeNbr
	from	svc.Parcel$Detail() x
	cross	apply core.RefNbr#Type() k
	left	join core.RefNbr#Raw() r on r.MatterID=x.ID and r.Type=k.PostCourier
	outer	apply tms.SvcFacility#For(x.Source, x.SvcClass, left(x.ZoneCode, 3)) f
	outer	apply tms.BarcodeNbr#Make(x.ZoneCode, r.Number)      b
)
GO
PRINT N'Creating [svc].[Parcel$LabelVia]...';


GO
-- Daxia
CREATE FUNCTION svc.Parcel$LabelVia(@number varchar(40))
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	ID, PID, AID, Source, PostedOn,    p.Stage,      StateID,  StatedOn
	,		BatchID, BatchedOn,   RcvHubID,    RcvHubAlias,  SiteID,   SiteAlias
	,		RouteID, RouteCode,   p.CourierID, CourierAlias, BrokerID, BrokerAlias
	,		p.POA,   SvcType,     SvcZone,     SvcClass,     Weight,   Length, Width, Height
	,		RefNbrs, RefInfos,    Ledgers,     Challenges,   AddOnServices,    ZoneCode
	,		FacilityID=isnull(FacilityID%100, 0), BarcodeNbr
	from	core.RefNbr#ScanOne(@number, default, default) x
	cross	apply core.RefNbr#Type() k
	join	svc.Parcel$Detail() p on p.ID=x.MatterID
	left	join core.RefNbr#Raw() r on r.MatterID=x.MatterID and r.Type=k.PostCourier
	outer	apply tms.SvcFacility#For(p.Source, p.SvcClass, left(p.ZoneCode, 3)) f
	outer	apply tms.BarcodeNbr#Make(p.ZoneCode, r.Number)      b
)
GO
PRINT N'Creating [svc].[Account$StockInOrderLedger]...';


GO
-- Smile
CREATE FUNCTION [svc].[Account$StockInOrderLedger]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,      d.Source,    ChargeAmt, CurrencyID
	,		TalliedOn, x.PartyID,   PartyAlias=p.Alias	
	,		NetDays=isnull(BillingCycle, 0), ChargeID
	,		BizUnitID, BizUnit=n.Alias, AsnNbr=a.Number
	from	acct.Ledger#Raw()        x
	join	core.Party#Raw()         p on p.ID=x.PartyID
	join	whse.StockInOrder#Base() d on d.ID=x.MatterID
	join	acct.Contract#Raw()      t on t.ID=d.ContractID
	join	core.Party#Raw()         n on n.ID=t.BizUnitID
	cross	apply core.RefNbr#Type() r
	join	core.RefNbr#Raw()        a on a.MatterID=d.ID and a.Type=r.AsnNbr
	cross	apply acct.Ledger#Side() s 
	where	x.LedgerSide=s.AR
)
GO
PRINT N'Creating [tms].[Route#Check]...';


GO
--PeterHo
CREATE FUNCTION [tms].[Route#Check](@routeID bigint, @svcClass tinyint, @weight real, @length real, @tenancy nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteAction as
	(
		select	k.HubMeasure
		,		TobeActionID=iif(@weight>x.MaxWeight, k.ReportOverThreshold, k.HubMeasure)
		from	core.Action#ID() k, tms.Route#Raw() x
		where	x.ID=@routeID
	)
	select	TobeActionID
	,		TobeSvcClass=iif(TobeActionID=HubMeasure, @svcClass, cast(0 as tinyint))
	,		TobeTenancy =iif(TobeActionID=HubMeasure, @tenancy,  (select Tenancy from loc.Tenancy#As(@tenancy, 0)))
	from	cteAction
)
GO
PRINT N'Creating [vmi].[StockInOrder$Summary]...';


GO
-- Smile
CREATE FUNCTION [vmi].[StockInOrder$Summary]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, CreatedOn=PostedOn, Stage, r.Number, SiteID
	from	whse.StockInOrder#Base() x
	cross	apply core.RefNbr#Type() t
	join	core.RefNbr#Raw()        r on r.MatterID=x.ID and r.Type=t.AsnNbr
)
GO
PRINT N'Creating [vmi].[Parcel$Detail]...';


GO
--Smile
CREATE FUNCTION [vmi].[Parcel$Detail]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, Source, PostedOn,  Stage,  StateID, StatedOn,  OutgatedOn=isnull(OutgatedOn,'')
	,		RcvHubID, RcvHubAlias, SiteID, SiteAlias, RefNbrs, RefInfos
	,		SvcType,  t.CourierCode, t.CourierNbr, t.Tracks
	from	shpt.Parcel#Deep()           x
	cross	apply svc.Parcel$Track(x.ID) t
	outer	apply(
					select	top(1) OutgatedOn=TalliedOn
					from	core.Activity#Raw()   a
					join    core.State#Raw()      t on a.StateID=t.ID
					cross	apply core.Stage#ID() k
					where	Stage=k.Outgated and MatterID=x.ID
					
				) c
	cross	apply core.Source#ID() k
	where	x.Source=k.eVMI
)
GO
PRINT N'Creating [vmi].[Parcel$List]...';


GO
--Smile
CREATE FUNCTION [vmi].[Parcel$List](@trackingNbr varchar(40))
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, Weight, Source, PostedOn,  Stage,   StateID,  StatedOn
	,		SvcType,    SiteID, SiteAlias, RefNbrs, RefInfos, Ledgers
	from	shpt.Parcel#Deep()     x
	cross	apply core.Source#ID() k
	where	x.Source=k.eVMI
	and		(nullif(@trackingNbr, '') is null
	or		exists (
						select	MatterID from core.RefNbr#Raw()
						where	MatterID=x.ID and Number=@trackingNbr
					))
)
GO
PRINT N'Creating [vmi].[Parcel$ForExport]...';


GO
--Smile
CREATE FUNCTION [vmi].[Parcel$ForExport](@siteID int, @trackingNbr varchar(40))
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, Weight, PostedOn,  Stage, RcvHubAlias, CourierAlias
	,		SvcType,    RefNbrs,   RefInfos, Ledgers
	from	shpt.Parcel#Deep()     x
	cross	apply core.Source#ID() k
	where	x.Source=k.eVMI
	and		x.SiteID=@siteID
	and		(nullif(@trackingNbr, '') is null
	or		exists (
						select	MatterID from core.RefNbr#Raw()
						where	MatterID=x.ID and Number=@trackingNbr
					))
)
GO
PRINT N'Creating [core].[Measure#Todo]...';


GO
-- AaronLiu
CREATE FUNCTION [core].[Measure#Todo](@matterID I64, @tenancy tvp)
RETURNS TABLE
-- WITH ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	m.ID, m.Type,  Adopt, QueueRakedIn, HubMeasure, ReportOverThreshold
		,		HubMeasureMPS, HubMeasureCPS, HubMeasureOrphan
		from	core.Matter#Raw() m, core.Action#ID() a
		where	m.ID=@matterID
	), cteTodo as
	(
		select	ActionID=x.HubMeasureMPS, ExeActionID=x.QueueRakedIn, TobeTenancy=@tenancy
		from	cte x, core.Matter#Type() t
		where	x.Type=t.HouseParcel
		union	all
		select	ActionID=x.HubMeasureCPS, ExeActionID=x.QueueRakedIn, TobeTenancy=@tenancy
		from	cte x, core.Matter#Type() t
		where	x.Type=t.MediumParcel
		union	all
		select	ActionID=x.HubMeasureOrphan, ExeActionID=x.QueueRakedIn, TobeTenancy=@tenancy
		from	cte x, core.Matter#Type() t
		where	x.Type=t.OrphanParcel
		union	all
		select	ActionID=0, ExeActionID=x.ReportOverThreshold, TobeTenancy=t.Tenancy
		from	cte x
		cross	apply loc.Tenancy#As(@tenancy, 0) t
		join	shpt.Parcel#Raw() p on p.ID=x.ID
		join	tms.Route#Raw()	  r on r.ID=p.RouteID
		where	r.MaxWeight>0 and p.Weight>r.MaxWeight
		union	all
		select	ActionID=0, ExeActionID=x.HubMeasure, TobeTenancy=@tenancy
		from	cte x
	)
	select	top(1) ActionID, ExeActionID, TobeTenancy
	from	cteTodo
)
GO
PRINT N'Creating [hub].[Parcel$ScanOneForSacking]...';


GO
-- AaronLiu
CREATE	FUNCTION [hub].[Parcel$ScanOneForSacking](@number varchar(40))
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	x.ID, x.Stage, x.StateID, x.PID, x.POA, RouteID, x.BrokerID, r.ClrMethodID, x.Weight, x.RefNbrs
	from	shpt.Parcel#Deep()  x
	join	tms.Route#Raw()	    r on x.RouteID=r.ID
	join	core.RefNbr#ScanOne(@number, default, default) m on m.MatterID=x.ID
)
GO
PRINT N'Creating [hub].[Parcel$InSack]...';


GO
-- AaronLiu
CREATE	FUNCTION [hub].[Parcel$InSack](@sackID I64)
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	x.ID, x.Weight, x.RefNbrs
	from	shpt.Parcel#Deep() x
	where	x.PID=@sackID
)
GO
PRINT N'Creating [hub].[Parcel$InParcel]...';


GO
-- AaronLiu
CREATE	FUNCTION [hub].[Parcel$InParcel](@parcelID I64)
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ID, RefNbrs
	from	shpt.Parcel#Deep()
	where	PID=@parcelID
)
GO
PRINT N'Creating [ic].[Parcel$WithConcern]...';


GO
--ken, Smile
CREATE FUNCTION [ic].[Parcel$WithConcern](@concernType tinyint)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, Stage, SvcType,   Source, RouteID, RouteCode, StatedOn, RefNbrs, RefInfos
	,		Handler,  HandlerID,    Concerns
	from	shpt.Parcel#Deep()                      x 
	cross	apply core.Concern#Tvp(x.ID)            t
	cross	apply svc.User$ContactName(x.HandlerID) u
	where   exists (
						select	MatterID
						from	core.Concern#Raw() where x.ID=MatterID 
						and		(Type=@concernType or nullif(@concernType, 0) is null)
					)
	
)
GO
PRINT N'Creating [ic].[Parcel$ForExportActivityInfo]...';


GO
--Aimee Tan, Sean Rao
CREATE FUNCTION [ic].[Parcel$ForExportActivityInfo]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, Stage,    x.Source, RcvHubID, RcvHubAlias, RouteID,  RouteCode
	,		SiteAlias,      LastMilerAlias,     PostedOn,    StatedOn, RefNbrs
	,		Weight,			Length,				Height,		 Width
	,		TenantID=p.PID, Activities=e.Tvp
	from	shpt.Parcel#Deep() x
	join	core.Party#Raw()   p on p.ID=x.SiteID
	outer	apply
	(
		select	[text()]=concat(k.Many, Stage, k.Quad, TalliedOn, k.Quad, t.UtcOffset, k.Quad, p.UtcOffset)
		from	core.Activity#Raw()    a
		left	join core.Tenant#Raw() t on t.ID=x.RcvHubID
		left	join core.Port#Raw()   p on p.Code=x.POA
		cross	apply core.Stage#Of(a.StateID) s
		cross	apply tvp.Spr#Const()  k
		where	a.MatterID=x.ID for xml path(N'')
	) z (text)
	cross	apply tvp.Spr#Purify(z.text, default) e
)
GO
PRINT N'Creating [svc].[Parcel$DetailVia]...';


GO
-- Eason,Aimee
CREATE FUNCTION svc.Parcel$DetailVia(@number varchar(40))
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	ID, PID, AID, Source, PostedOn,  p.Stage,      StateID,  StatedOn
	,		BatchID, BatchedOn,   RcvHubID,  RcvHubAlias,  SiteID,   SiteAlias
	,		RouteID, RouteCode,   CourierID, CourierAlias, BrokerID, BrokerAlias
	,		POA,     SvcType,     SvcZone,   SvcClass,     Weight,   Length, Width, Height
	,		RefNbrs, RefInfos,    Ledgers,   Challenges,   AddOnServices,    ZoneCode
	from	core.RefNbr#ScanOne(@number, default, default) x
	join	svc.Parcel$Detail() p on p.ID=x.MatterID
)
GO
PRINT N'Creating [tvp].[N4K#Slice]...';


GO
CREATE FUNCTION [tvp].[N4K#Slice]
(@source NVARCHAR (MAX), @separator NVARCHAR (255))
RETURNS 
     TABLE (
        [Piece] NVARCHAR (4000) NULL)
AS
 EXTERNAL NAME [Zebra.DB].[SqlTvpFuncs].[N40SliceClr]


GO
PRINT N'Creating [tvp].[NAX#Slice]...';


GO
CREATE FUNCTION [tvp].[NAX#Slice]
(@source NVARCHAR (MAX), @separator NVARCHAR (255))
RETURNS 
     TABLE (
        [Piece] NVARCHAR (MAX) NULL)
AS
 EXTERNAL NAME [Zebra.DB].[SqlTvpFuncs].[TvpSliceClr]


GO
PRINT N'Creating [tvp].[Pcs#TallyT]...';


GO
-- PeterHo
CREATE FUNCTION [tvp].[Pcs#TallyT](@source nvarchar(max), @spr nvarchar(255)=N'	;	', @upto int=0)
RETURNS @result TABLE 
(
	[Seq] int not null, [Start] int not null, [Stop] int not null
	PRIMARY KEY CLUSTERED ([Seq] ASC, [Start] ASC, [Stop] ASC)
)
WITH SCHEMABINDING, ENCRYPTION
AS 
BEGIN
	insert	@result select [Seq],   [Start], [Stop]
	from	tvp.Pcs#TallyR(@source, @spr,    @upto)
	option	(maxrecursion 0)
	RETURN
END
GO
PRINT N'Creating [tvp].[Pcs#At]...';


GO
 --PeterHo: 4/1
CREATE FUNCTION [tvp].[Pcs#At]
(
	@index int, @source nvarchar(max), @spr nvarchar(255)=N'	;	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Piece
	from	tvp.NAX#Slice(@source, @spr)
	order	by (select null)
	offset	iif(@index>0, @index-1, 0) rows
	fetch	next 1 rows only
)
GO
PRINT N'Creating [tvp].[Pcs#Of]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Pcs#Of](@count int, @value nvarchar(max), @spr nvarchar(255))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	with ctePiece as
	(
		select	top(@count % 100) Seq=row_number() over (order by (select null)), Piece
		from	tvp.NAX#Slice(iif(datalength(@value)<>0, @value, @spr), @spr)
	)
	select	 top(1)
			 [v1]=isnull( [1], N''),  [v2]=isnull( [2], N''),  [v3]=isnull( [3], N''),  [v4]=isnull( [4], N''),
			 [v5]=isnull( [5], N''),  [v6]=isnull( [6], N''),  [v7]=isnull( [7], N''),  [v8]=isnull( [8], N''),
			 [v9]=isnull( [9], N''), [v10]=isnull([10], N''), [v11]=isnull([11], N''), [v12]=isnull([12], N''),
			[v13]=isnull([13], N''), [v14]=isnull([14], N''), [v15]=isnull([15], N''), [v16]=isnull([16], N''),
			[v17]=isnull([17], N''), [v18]=isnull([18], N''), [v19]=isnull([19], N''), [v20]=isnull([20], N''),
			[v21]=isnull([21], N''), [v22]=isnull([22], N''), [v23]=isnull([23], N''), [v24]=isnull([24], N''),
			[v25]=isnull([25], N''), [v26]=isnull([26], N''), [v27]=isnull([27], N''), [v28]=isnull([28], N''),
			[v29]=isnull([29], N''), [v30]=isnull([30], N''), [v31]=isnull([31], N''), [v32]=isnull([32], N''),
			[v33]=isnull([33], N''), [v34]=isnull([34], N''), [v35]=isnull([35], N''), [v36]=isnull([36], N''),
			[v37]=isnull([37], N''), [v38]=isnull([38], N''), [v39]=isnull([39], N''), [v40]=isnull([40], N''),
			[v41]=isnull([41], N''), [v42]=isnull([42], N''), [v43]=isnull([43], N''), [v44]=isnull([44], N''),
			[v45]=isnull([45], N''), [v46]=isnull([46], N''), [v47]=isnull([47], N''), [v48]=isnull([48], N''),
			[v49]=isnull([49], N''), [v50]=isnull([50], N''), [v51]=isnull([51], N''), [v52]=isnull([52], N''),
			[v53]=isnull([53], N''), [v54]=isnull([54], N''), [v55]=isnull([55], N''), [v56]=isnull([56], N''),
			[v57]=isnull([57], N''), [v58]=isnull([58], N''), [v59]=isnull([59], N''), [v60]=isnull([60], N''),
			[v61]=isnull([61], N''), [v62]=isnull([62], N''), [v63]=isnull([63], N''), [v64]=isnull([64], N''),
			[v65]=isnull([65], N''), [v66]=isnull([66], N''), [v67]=isnull([67], N''), [v68]=isnull([68], N''),
			[v69]=isnull([69], N''), [v70]=isnull([70], N''), [v71]=isnull([71], N''), [v72]=isnull([72], N''),
			[v73]=isnull([73], N''), [v74]=isnull([74], N''), [v75]=isnull([75], N''), [v76]=isnull([76], N''),
			[v77]=isnull([77], N''), [v78]=isnull([78], N''), [v79]=isnull([79], N''), [v80]=isnull([80], N''),
			[v81]=isnull([81], N''), [v82]=isnull([82], N''), [v83]=isnull([83], N''), [v84]=isnull([84], N''),
			[v85]=isnull([85], N''), [v86]=isnull([86], N''), [v87]=isnull([87], N''), [v88]=isnull([88], N''),
			[v89]=isnull([89], N''), [v90]=isnull([90], N''), [v91]=isnull([91], N''), [v92]=isnull([92], N''),
			[v93]=isnull([93], N''), [v94]=isnull([94], N''), [v95]=isnull([95], N''), [v96]=isnull([96], N''),
			[v97]=isnull([97], N''), [v98]=isnull([98], N''), [v99]=isnull([99], N'')
	from	(select Seq, Piece from ctePiece) raw pivot (max(Piece) for Seq in
	(
		 [1],  [2],  [3],  [4],  [5],  [6],  [7],  [8],  [9], [10], [11], [12], [13], [14], [15], [16],
		[17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32],
		[33], [34], [35], [36], [37], [38], [39], [40], [41], [42], [43], [44], [45], [46], [47], [48],
		[49], [50], [51], [52], [53], [54], [55], [56], [57], [58], [59], [60], [61], [62], [63], [64],
		[65], [66], [67], [68], [69], [70], [71], [72], [73], [74], [75], [76], [77], [78], [79], [80],
		[81], [82], [83], [84], [85], [86], [87], [88], [89], [90], [91], [92], [93], [94], [95], [96],
		[97], [98], [99]
	)) x
)
GO
PRINT N'Creating [tvp].[Pcs#Slice]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Pcs#Slice](@source nvarchar(max), @spr nvarchar(255)=N'	;	')
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select  top(tvp.Pcs@Count(@source, @spr))
			Seq=row_number() over (order by (select null)), Piece
	from    tvp.NAX#Slice(@source, @spr)

--	select  Seq=row_number() over (order by (select null)), Piece
--	from    tvp.NAX#Slice(@source, @spr)
)
GO
PRINT N'Creating [tvp].[Pcs#SliceT]...';


GO
-- PeterHo
CREATE FUNCTION [tvp].[Pcs#SliceT](@source nvarchar(max), @spr nvarchar(255)=N'	;	', @upto int=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Seq, Start, Stop
	,		[Length]=isnull(Stop-Start, 0)
	,		[Piece] =isnull(substring(@source, Start, Stop-Start), cast(N'' as nvarchar(max)))
	from	tvp.Pcs#TallyT(@source, @spr, @upto)
)
GO
PRINT N'Creating [tvp].[Pcs#SliceV]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Pcs#SliceV]
(
	@index		int,
	@source		nvarchar(max),
	@blockSpr	nvarchar(255)=N'	%	',
	@sourceSpr	nvarchar(255)=N'	;	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select  Seq, b.Piece
	from	tvp.Pcs#Slice(@source, @sourceSpr) s
	cross	apply tvp.Pcs#At(@index, s.Piece, @blockSpr) b

--	select  Seq=row_number() over (order by (select null)), b.Piece
--	from	tvp.NAX#Slice(@source, @sourceSpr) s
--	cross	apply tvp.Pcs#At(@index, s.Piece, @blockSpr) b
)
GO
PRINT N'Creating [tvp].[Quad#Slice]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Quad#Slice]
(
	@source nvarchar(max), @valueSpr nvarchar(255)=N'	-	', @sourceSpr nvarchar(255)=N'	,	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Seq, v1, v2, v3, v4
	from	tvp.Pcs#Slice(@source, @sourceSpr)
	cross	apply tvp.Quad#Of(Piece, @valueSpr)
)
GO
PRINT N'Creating [tvp].[Quire#Of]...';


GO
--PeterHo: 4/1
CREATE FUNCTION [tvp].[Quire#Of](@value nvarchar(max), @spr nvarchar(255)=N'	#	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select  v1,   v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9, v10, v11, v12,
			v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24
	from    tvp.Pcs#Of(24, @value, @spr)
)
GO
PRINT N'Creating [tvp].[Quire#Slice]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Quire#Slice]
(
	@source nvarchar(max), @valueSpr nvarchar(255)=N'	#	', @sourceSpr nvarchar(255)=N'	,	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq
	,		 v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9, v10, v11, v12
	,		v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24
	from	tvp.Pcs#Slice(@source, @sourceSpr)
	cross	apply tvp.Quire#Of(Piece, @valueSpr)
)
GO
PRINT N'Creating [tvp].[Triad#Slice]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Triad#Slice]
(
	@source nvarchar(max), @valueSpr nvarchar(255)=N'	|	', @sourceSpr nvarchar(255)=N'	,	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Seq, v1, v2, v3
	from	tvp.Pcs#Slice(@source, @sourceSpr)
	cross	apply tvp.Triad#Of(Piece, @valueSpr)
)
GO
PRINT N'Creating [tvp].[Tuplet#Of]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Tuplet#Of](@value nvarchar(max), @spr nvarchar(255)=N'	*	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select  v1, v2, v3, v4, v5, v6, v7, v8, v9
	from    tvp.Pcs#Of(9, @value, @spr)
)
GO
PRINT N'Creating [tvp].[Tuplet#Slice]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Tuplet#Slice]
(
	@source nvarchar(max), @valueSpr nvarchar(255)=N'	*	', @sourceSpr nvarchar(255)=N'	,	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, v1, v2, v3, v4, v5, v6, v7, v8, v9
	from	tvp.Pcs#Slice(@source, @sourceSpr)
	cross	apply tvp.Tuplet#Of(Piece, @valueSpr)
)
GO
PRINT N'Creating [brkg].[BrokerageFee#For]...';


GO
/*
brokerageInfo=Mucho[Triad<SkuID, CmdyInfo, LineInfo:Localized>]
CmdyInfo     =Quad<CmdyHeadID, CmdyTailID, DutyCode, DutyRate>
LineInfo     =Quad<GoodsInfo, LineQty, LineTotal, CmdyID>
*/
--Smile.Wang
CREATE FUNCTION [brkg].[BrokerageFee#For](@routeID int,  @brokerageInfo nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with creRate as
	(
		select	l.CurrencyID
		,		BrokerageFee=ceiling(sum(x.PercentRate*l.LineDecTotal)*100)/100
		from	tms.Route#Raw()       u
		join	brkg.Broker#Raw()     x on u.BrokerID=x.ID
		cross	apply tvp.Spr#Const() k
		cross	apply tvp.Triad#Slice(@brokerageInfo, default, k.Mucho) t
		cross	apply loc.CmdyInfo#Of(t.v2)                             c
		cross	apply loc.LineInfo#Of(t.v3)                             l	
		where	u.ID=@routeID
		group	by l.CurrencyID	
	)
		select	CurrencyID, DutyRate=m.Amt
		from	creRate x
		cross	apply dbo.Money#Make(x.BrokerageFee, x.CurrencyID) m
		where	m.Amt>x.CurrencyID
)
GO
PRINT N'Creating [brkg].[DutyRate#For]...';


GO
/*
brokerageInfo=Mucho[Triad<SkuID, CmdyInfo, LineInfo:Localized>]
CmdyInfo     =Quad<CmdyHeadID, CmdyTailID, DutyCode, DutyRate>
LineInfo     =Quad<GoodsInfo, LineQty, LineTotal, CmdyID>
*/
--Smile.Wang
CREATE FUNCTION [brkg].[DutyRate#For](@partyID int, @clrMethodID int, @brokerageInfo nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteDuty as
	(
		select	l.CurrencyID
		,		DutyRateRaw=sum(c.DutyRate*l.LineRawTotal)
		,		ClrRateRaw=sum(d.PercentRate*l.LineRawTotal)
		from	tvp.Spr#Const() k 
		cross	apply tvp.Triad#Slice(@brokerageInfo, default, k.Mucho) x
		cross	apply loc.CmdyInfo#Of(x.v2)       c
		cross	apply loc.LineInfo#Of(x.v3)       l	
		cross	apply brkg.ClrMethodRate#For(@partyID, @clrMethodID) d
		group	by l.CurrencyID		
	)
	, cteTotalDuty as
	(
		select	CurrencyID, DutyRaw=sum(DutyRaw)
		from	
		(
			select	x.CurrencyID, DutyRaw=iif(x.CurrencyID=d.CurrencyID,  iif(DutyRateRaw>d.ExemptionRaw, DutyRateRaw, 0), DutyRateRaw)+ClrRateRaw
			from	cteDuty x
			join	brkg.ClrMethod#Raw() d on d.ID=@clrMethodID
			union	all
			select	CurrencyID, FlatRateRaw
			from	brkg.ClrMethodRate#For(@partyID, @clrMethodID)
		) u
		group by u.CurrencyID
	)
		select	CurrencyID, DutyRate=m.Amt
		from	cteTotalDuty x
		cross	apply dbo.Currency#Encode(x.DutyRaw, CurrencyID) m
)
GO
PRINT N'Creating [loc].[GoodsInfo#Of]...';


GO
-- PeterHo
CREATE FUNCTION [loc].[GoodsInfo#Of](@info nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Name       =v1
	,		Brand      =v2
	,		Model      =v3
	,		Spec       =v4
	,		Sku        =v5 
	,		SkuBatch   =v6
	,		Condition  =v7, v8, v9
	from	tvp.Tuplet#Of(@info, default)
)
GO
PRINT N'Creating [rpt].[Dashboard$Summary]...';


GO
-- Eason
CREATE FUNCTION [rpt].[Dashboard$Summary](@siteID bigint, @timezoneOffset int=0)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	select	LastDayParcel   =isnull(SUM(case when cl.DOffset - c.DOffset <=1               then 1 else 0 end), 0)
	,		Last7DParcel    =isnull(SUM(case when cl.DOffset - c.DOffset <=7               then 1 else 0 end), 0)
	,		Pre7DParcel     =isnull(SUM(case when cl.DOffset - c.DOffset between 7 and 14  then 1 else 0 end), 0)
	,		Last30DParcel   =isnull(SUM(case when cl.DOffset - c.DOffset <=30              then 1 else 0 end), 0)
	,		Pre30DParcel    =isnull(SUM(case when cl.DOffset - c.DOffset between 30 and 60 then 1 else 0 end), 0)
	,		LastMonthParcel =isnull(SUM(case when cl.MOffset - c.MOffset =0                then 1 else 0 end), 0)
	,		PreMonthParcel  =isnull(SUM(case when cl.MOffset - c.MOffset =1                then 1 else 0 end), 0)

	,       LastDaySales    =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset <=1               , r.Sales, 0)),2), 0)
	,		Last7DSales     =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset <=7               , r.Sales, 0)),2), 0)
	,		Pre7DSales      =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset between 7 and 14  , r.Sales, 0)),2), 0)
	,		Last30DSales    =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset <=30              , r.Sales, 0)),2), 0)
	,		Pre30DSales     =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset between 30 and 60 , r.Sales, 0)),2), 0)
	,		LastMonthSales  =isnull(ROUND(SUM(iif(cl.MOffset - c.MOffset =0                , r.Sales, 0)),2), 0)
	,		PreMonthSales   =isnull(ROUND(SUM(iif(cl.MOffset - c.MOffset =1                , r.Sales, 0)),2), 0)

	,       LastDayFreight  =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset <=1               , f.Freight, 0)), 2), 0)
	,		Last7DFreight   =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset <=7               , f.Freight, 0)), 2), 0)
	,		Pre7DFreight    =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset between 7 and 14  , f.Freight, 0)), 2), 0)
	,		Last30DFreight  =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset <=30              , f.Freight, 0)), 2), 0)
	,		Pre30DFreight   =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset between 30 and 60 , f.Freight, 0)), 2), 0)
	,		LastMonthFreight=isnull(ROUND(SUM(iif(cl.MOffset - c.MOffset =0                , f.Freight, 0)), 2), 0)
	,		PreMonthFreight =isnull(ROUND(SUM(iif(cl.MOffset - c.MOffset =1                , f.Freight, 0)), 2), 0)

	from	core.Matter#Raw()         x
	cross	apply core.Matter#Type()  mt
	cross	apply core.RefInfo#Type() rt
	cross	apply tvp.Spr#Const()     sp
	cross   apply dbo.Calendar#Of(DATEADD(HOUR,  -@timezoneOffset, GETUTCDATE())) cl
	join	dbo.Calendar#Raw() c on cast(x.PostedOn as Date)=c.Value
	cross	apply
	(
			select	Sales=isnull(sum(m.DecAmt), 0)
			from	core.RefInfo#Of(x.ID,rt.DeclaredInfo)           x
			cross	apply tvp.Quad#Slice(x.Info, default, sp.Mucho) t 
			cross	apply dbo.Money#Of(t.v3) m
	) r
	cross	apply
	(
			select	Freight=isnull(sum(m.DecAmt), 0)
			from	acct.Ledger#Raw()               g
			cross	apply acct.Charge#ID()          c
			cross	apply dbo.Money#Of(g.ChargeAmt) m
			where	g.MatterID=x.ID and g.ChargeID=c.Freight
	) f
	where	c.DOffset between (cl.DOffset - 60) and cl.DOffset 
	and		x.Type=mt.Parcel
	and		x.PosterID=@siteID
)
GO
PRINT N'Creating [rpt].[Dashboard$ParcelSummary]...';


GO
-- Eason
CREATE FUNCTION [rpt].[Dashboard$ParcelSummary](@siteID bigint, @startDate datetime, @endDate datetime, @timezoneOffset int=0)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	c.Value as [Date]
	,		Parcel=isnull(count(*), 0)
	,		Sales =round(sum(isnull(s.Sales, 0)), 2)
	from	core.Matter#Raw()         x
	cross	apply core.Matter#Type()  mt
	cross	apply core.RefInfo#Type() rt
	cross	apply tvp.Spr#Const()     sp
	cross   apply dbo.Calendar#Of(DATEADD(HOUR, -@timezoneOffset, @startDate)) sd
	cross   apply dbo.Calendar#Of(DATEADD(HOUR, -@timezoneOffset, @endDate  )) ed
	join	dbo.Calendar#Raw() c on cast(x.PostedOn as Date)=c.Value
	cross	apply
	(
		select	Sales=isnull(sum(m.DecAmt), 0)
		from	core.RefInfo#Of(x.ID,rt.DeclaredInfo)           i
		cross	apply tvp.Quad#Slice(i.Info, default, sp.Mucho) t
		cross	apply dbo.Money#Of(t.v3)                        m
	) s
	where	c.DOffset between sd.DOffset and ed.DOffset
	and		x.Type=mt.Parcel
	and		x.PosterID=@siteID
	group	by c.Value
);
GO
PRINT N'Creating [shpt].[IDNbr#Exists]...';


GO
--Smile
CREATE FUNCTION [shpt].[IDNbr#Exists](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteIDInfo as
	(
		select	IDNbr=t.v1
		from	core.RefInfo#Type() k, core.RefInfo#Raw() i
		cross	apply tvp.Tuplet#Of(i.Info, default)      t
		where	i.MatterID=@matterID and i.Type=k.IDInfo
	)
	select	HasIDNbr=iif(exists(select 0 from cteIDInfo where nullif(IDNbr, N'') is not null), true, false)
	from	dbo.Bool#Const()
)
GO
PRINT N'Creating [svc].[Parcel$List]...';


GO
-- Eason, AaronLiu, Smile, Daxia, Aimee
CREATE FUNCTION [svc].[Parcel$List]()
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	x.ID,    x.Source,  PostedOn,  Stage,     StateID,  StatedOn, BatchID,  RcvHubID
	,		SiteID, RouteID, RouteCode, CourierID, BrokerID, SvcType,  SvcZone,  SvcClass, CmdyRootID
	,		Weight, Length,  Width,     Height,    POA,      RefNbrs,  RefInfos, Ledgers,  Challenges
	,		LastMilerCode, HandlerID,   u.Handler, AddOnServices, HasIDNbr, HasConcern,    ZoneCode
	from	shpt.Parcel#Deep()                      x 
	cross	apply svc.User$ContactName(x.HandlerID) u	
	cross	apply core.Concern#Exists(x.ID)         e
	cross	apply shpt.IDNbr#Exists(x.ID)           i
)
GO
PRINT N'Creating [svc].[Flight$Verify]...';


GO
/*
	@flights = Many[Traid<POD, POA, Airline>]
*/
-- AaronLiu
CREATE FUNCTION [svc].[Flight$Verify](@flights tvp)
RETURNS TABLE
--WITH ENCRYPTION
AS RETURN
(
	select	Seq=isnull(x.Seq,0), Airline=x.v3,    AirlineID=isnull(l.ID,0), POD=x.v1, POA=x.v2
	,		[PODUtcOffset]=isnull(d.UtcOffset,0), [PODUtcPlaceID]=isnull(d.UtcPlaceID,0)
	,		[POAUtcOffset]=isnull(a.UtcOffset,0), [POAUtcPlaceID]=isnull(a.UtcPlaceID,0)
	from	tvp.Triad#Slice(@flights, default, default) x
	left	join core.Port#Raw()   d on x.v1=d.Code
	left	join core.Port#Raw()   a on x.v2=a.Code
	left	join tms.Airline#Raw() l on x.v3=l.Alias
)
GO
PRINT N'Creating [svc].[FileBankID$Lookup]...';


GO
--hbd
CREATE FUNCTION [svc].[FileBankID$Lookup](@slip tvp)
RETURNS TABLE
AS RETURN
(		
	select	ID, FileBankID
	from	tvp.Triad#Slice(@slip, default, default) x
	join	core.Attachment#Raw() a 
	on		a.RowID=cast(x.v1 as bigint)
	and		a.RegID=cast(x.v2 as int) 
	and		a.AuxID=cast(x.v3 as int)
)
GO
PRINT N'Creating [svc].[Parcel$DutyEstimate]...';


GO
-- AaronLiu
CREATE FUNCTION [svc].[Parcel$DutyEstimate](@parcelID I64, @brokerageInfo tvp)
RETURNS TABLE
--WITH	ENCRYPTION
AS RETURN
(
	select	d.DutyRate
	from	shpt.Parcel#Base() x
	join	tms.SvcType#Raw()  t on t.ID=x.SvcType
	join	core.Party#Raw()   p on p.ID=x.SiteID
	cross	apply brkg.DutyRate#For(p.AID, t.ClrMethodID, @brokerageInfo) d
	where	x.ID=@parcelID
)
GO
PRINT N'Creating [tms].[Freight#For]...';


GO
/*
brokerageInfo=Mucho[Triad<SkuID, CmdyInfo, LineInfo:Localized>]
CmdyInfo     =Quad<CmdyHeadID, CmdyTailID, DutyCode, DutyRate>
LineInfo     =Quad<GoodsInfo, LineQty, LineTotal, CmdyID>
*/
--Smile.Wang
CREATE FUNCTION [tms].[Freight#For](@svcType int, @rcvHubID bigint, @measuredWt real, @brokerageInfo nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteFreight as
	(
	select	SvcRate=cast((SvcRate*10000) as float)/10000
	from	tms.SvcRate#For(@svcType, @rcvHubID, @measuredWt)
	UNION	ALL
	select	isnull(cast((c.Surcharge*10000) as float)/10000,0)
	from	tvp.Spr#Const()      k
	cross	apply tvp.Triad#Slice(@brokerageInfo, default, k.Mucho) x
	cross	apply loc.LineInfo#Of(x.v3) q
	join	brkg.Commodity#Raw()        c on c.ID=q.CmdyID
	)

	select Freight=sum(SvcRate) from cteFreight
)
GO
PRINT N'Creating [tvp].[Bag#Slice]...';


GO
--PeterHo:
CREATE FUNCTION [tvp].[Bag#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, Piece from tvp.Pcs#Slice(@source, N'	{	')
)
GO
PRINT N'Creating [tvp].[Block#At]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Block#At]
(
	@index     int,
	@source    nvarchar(max),
	@blockSpr  nvarchar(255)=N'	%	',
	@sourceSpr nvarchar(255)=N'	;	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select [Tvp]=stuff(
	(
		select	[text()]=@sourceSpr + v.Piece
		from	tvp.Pcs#SliceV(@index, @source, @blockSpr, @sourceSpr) v
		for     xml path(N'')
	), 1, datalength(@sourceSpr)/2, N'')
)
GO
PRINT N'Creating [tvp].[Block#Fold]...';


GO
 --PeterHo: 4/1
CREATE FUNCTION [tvp].[Block#Fold]
(
	@index     int          --=2
,	@master    nvarchar(max)--=N'1,2'
,	@house     nvarchar(max)--=N'T	%	A	,	B	;	U	%	C	,	D'
--------------------------------------------------------------------------
,	@masterSpr nvarchar(255)=N','
,	@houseSpr  nvarchar(255)=N'	;	'
,	@blockSpr  nvarchar(255)=N'	%	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.Seq, Master=x.Piece, House=v.Piece
	from	tvp.Pcs#Slice(@master, @masterSpr) x
	join	tvp.Pcs#SliceV(@index, @house, @blockSpr, @houseSpr) v on v.Seq=x.Seq
/*
	select	m.Seq, Master=m.Piece, House=h.Piece
	from	tvp.Pcs#Slice(@master, @masterSpr)           m
	cross	apply tvp.Pcs#At(m.Seq,   @house, @houseSpr) x
	cross	apply tvp.Pcs#At(@index, x.Piece, @blockSpr) h
*/
)
GO
PRINT N'Creating [tvp].[Block#FoldA]...';


GO
 --PeterHo: 4/1
CREATE FUNCTION [tvp].[Block#FoldA]
(
	@index     int
,	@master    dbo.I64AutoSeqs readonly
,	@house     nvarchar(max)
,	@houseSpr  nvarchar(255)=N'	;	'
,	@blockSpr  nvarchar(255)=N'	%	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	m.Seq, Master=m.ID, House=v.Piece
	from	tvp.Pcs#SliceV(@index, @house, @blockSpr, @houseSpr) v 
	join	@master m on m.Seq=v.Seq
/*
	select	m.Seq, Master=m.ID, House=h.Piece from @master m
	cross	apply tvp.Pcs#At(m.Seq,   @house, @houseSpr)   x
	cross	apply tvp.Pcs#At(@index, x.Piece, @blockSpr)   h
*/
)
GO
PRINT N'Creating [tvp].[Block#FoldT]...';


GO
 --PeterHo: 4/1
CREATE FUNCTION [tvp].[Block#FoldT]
(
	@index     int
,	@master    dbo.I64Seqs readonly
,	@house     nvarchar(max)
,	@houseSpr  nvarchar(255)=N'	;	'
,	@blockSpr  nvarchar(255)=N'	%	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	m.Seq, Master=m.ID, House=v.Piece
	from	tvp.Pcs#SliceV(@index, @house, @blockSpr, @houseSpr) v 
	join	@master m on m.Seq=v.Seq
/*
	select	m.Seq, Master=m.ID, House=h.Piece from @master m
	cross	apply tvp.Pcs#At(m.Seq,   @house, @houseSpr)   x
	cross	apply tvp.Pcs#At(@index, x.Piece, @blockSpr)   h
*/
)
GO
PRINT N'Creating [tvp].[Cell#Slice]...';


GO
-- PeterHo
CREATE FUNCTION [tvp].[Cell#Slice]
(
	@source nvarchar(max)
,	@colSpr nvarchar(255)=N'	%	'
,	@rowSpr nvarchar(255)=N'	;	'
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[Col]=c.Seq, [Row]=r.Seq, [Val]=c.Piece
	from	tvp.Pcs#Slice(@source, @rowSpr)       r
	cross	apply tvp.Pcs#Slice(r.Piece, @colSpr) c
)
GO
PRINT N'Creating [tvp].[Comma#Slice]...';


GO
--PeterHo: 4/1
CREATE FUNCTION [tvp].[Comma#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, Piece from tvp.Pcs#Slice(@source, N',')
)
GO
PRINT N'Creating [tvp].[Dozen#Of]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Dozen#Of] (@value nvarchar(max), @spr nvarchar(255)=N'	+	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select  v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
	from    tvp.Pcs#Of(12, @value, @spr)
)
GO
PRINT N'Creating [tvp].[Dozen#Slice]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Dozen#Slice]
(
	@source nvarchar(max), @valueSpr nvarchar(255)=N'	+	', @sourceSpr nvarchar(255)=N'	,	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
	from	tvp.Pcs#Slice(@source, @sourceSpr)
	cross   apply tvp.Dozen#Of(Piece, @valueSpr)
)
GO
PRINT N'Creating [tvp].[Duad#Slice]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Duad#Slice]
(
	@source nvarchar(max), @valueSpr nvarchar(255)=N'	^	', @sourceSpr nvarchar(255)=N'	,	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Seq, v1, v2
	from	tvp.Pcs#Slice(@source, @sourceSpr)
	cross	apply tvp.Duad#Of(Piece, @valueSpr)
)
GO
PRINT N'Creating [tvp].[Field#Of]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Field#Of](@value nvarchar(max), @spr nvarchar(255)=N'	$	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	 v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9, v10, v11, v12, v13, v14, v15, v16,
			v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32,
			v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48,
			v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64,
			v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80,
			v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95, v96,
			v97, v98, v99
	from    tvp.Pcs#Of(99, @value, @spr)
)
GO
PRINT N'Creating [tvp].[Field#Slice]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[Field#Slice]
(
	@source nvarchar(max), @valueSpr nvarchar(255)=N'	$	', @sourceSpr nvarchar(255)=N'	;	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq
	,		 v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9, v10, v11, v12, v13, v14, v15, v16
	,		v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32
	,		v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48
	,		v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64
	,		v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80
	,		v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95, v96
	,		v97, v98, v99
	from	tvp.Pcs#Slice(@source, @sourceSpr)
	cross	apply tvp.Field#Of(Piece, @valueSpr)
)
GO
PRINT N'Creating [tvp].[I32#Slice]...';


GO
--PeterHo: 4/1
CREATE FUNCTION [tvp].[I32#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, [ID]=cast(Piece as int)
	from	tvp.Pcs#Slice(@source, N',')
)
GO
PRINT N'Creating [tvp].[I64#Slice]...';


GO
-- PeterHo: 4/1
CREATE FUNCTION [tvp].[I64#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, ID=cast(Piece as bigint)
	from	tvp.Pcs#Slice(@source, N',')
)
GO
PRINT N'Creating [tvp].[Many#Slice]...';


GO
--PeterHo: 4/1
CREATE FUNCTION [tvp].[Many#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, Piece from tvp.Pcs#Slice(@source, N'	,	')
)
GO
PRINT N'Creating [tvp].[Mucho#Slice]...';


GO
--PeterHo:
CREATE FUNCTION [tvp].[Mucho#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, Piece from tvp.Pcs#Slice(@source, N'	[	')
)
GO
PRINT N'Creating [tvp].[Newline#Slice]...';


GO
--PeterHo: 4/1
CREATE FUNCTION [tvp].[Newline#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, Piece
	from	tvp.Pcs#Slice(@source, cast(char(13)+char(10) as nvarchar(255)))
)
GO
PRINT N'Creating [vmi].[AsnNbr$Verify]...';


GO
--Smile
CREATE FUNCTION [vmi].[AsnNbr$Verify](@siteID int, @asnNbrs nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID=iif(r.MatterID is null, -1, isnull(b.ID, 0)), AsnNbr=x.Piece
	from	tvp.Many#Slice(@asnNbrs)       x
	cross	apply loc.RefNbr#Cast(x.Piece) n
	cross	apply core.RefNbr#Type()       k
	cross	apply core.State#ID()          s
	left	join core.RefNbr#Raw()         r on r.Number=n.Number and r.Type=k.AsnNbr
	left	join whse.StockInOrder#Base()  b on b.ID=r.MatterID  and 
												b.StateID=s.AsnNbrGenerated and
												b.SiteID=@siteID

)
GO
PRINT N'Creating [vmi].[Parcel$SummaryVia]...';


GO
--Smile
CREATE FUNCTION [vmi].[Parcel$SummaryVia](@idsInCsv nvarchar(max))
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, Stage, x.Source, SvcType, RcvHubID, RcvHubAlias=h.Alias, TenantID=t.ID, TenantAlias=t.Alias
	,		RefNbrs, RefInfos, x.PostedOn
	from	tvp.I64#Slice(@idsInCsv) i
	join	shpt.Parcel#Base() x on x.ID=i.ID
	join	core.Party#Raw()   h on h.ID=x.RcvHubID
	join	core.Party#Raw()   p on p.ID=x.SiteID
	join	core.Party#Raw()   t on t.ID=p.PID
	cross	apply core.Source#ID() k
	where	x.Source=k.eVMI
)
GO
PRINT N'Creating [zeb].[Matter$TobeVia]...';


GO
-- AaronLiu
CREATE FUNCTION [zeb].[Matter$TobeVia](@idsInCsv nvarchar(max), @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	tvp.I64#Slice(@idsInCsv) i join core._Matter x on x.ID=i.ID
	cross	apply core.Transition#Tobe(x.StateID, @roleID, @actionID, x.RejoinID) t
)
GO
PRINT N'Creating [api].[MIC$VefityForPlatform]...';


GO
/*
@micsInCsv =Duad[Alias, MIC]
*/
--Smile, AaronLiu
CREATE	FUNCTION [api].[MIC$VefityForPlatform](@userID int, @micsInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID=isnull(b.ID, 0), ClientRefNbr=d.Number
	from	tvp.Duad#Slice(@micsInCsv, default, default) x
	cross	apply loc.RefNbr#Cast(x.v2)                  d
	cross	apply core.RefNbr#Type()                     k
	left	join  core.RefNbr#Raw()                      r on r.Number=d.Number and r.Type=k.MIT
	join	core.Party#Raw()                             n on n.ID=@userID
	left	join  core.Party#Raw()                       p on p.Source=n.Source and p.Alias=x.v1
	cross	apply core.Stage#ID()                        s
	left	join  core.Matter#Raw()                      b on r.MatterID=b.ID   and b.PosterID=p.ID
)
GO
PRINT N'Creating [core].[Matter#MaybeVia]...';


GO
-- PeterHo
CREATE FUNCTION [core].[Matter#MaybeVia](@idsInCsv nvarchar(max), @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	tvp.I64#Slice(@idsInCsv) i join core._Matter x on x.ID=i.ID
	cross	apply core.Transition#Tobe(x.StateID, @roleID, @actionID, x.RejoinID) t
	cross	apply core.Challenge#Borderline(x.ID) c
	where	x.LockCnt=0 and t.ToStage<=c.Borderline

/*
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	tvp.I64#Slice(@idsInCsv) i join core._Matter x on x.ID=i.ID
	cross	apply core.Transition#Tobe(x.StateID, @roleID, @actionID) t
*/
)
GO
PRINT N'Creating [core].[Matter#TobeVia]...';


GO
-- PeterHo
CREATE FUNCTION [core].[Matter#TobeVia](@idsInCsv nvarchar(max), @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	tvp.I64#Slice(@idsInCsv) i join core._Matter x on x.ID=i.ID
	cross	apply core.Transition#Tobe(x.StateID, @roleID, @actionID, x.RejoinID) t

/*	-- Cheated by Execution Plan.
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	core._Matter x
	cross	apply core.Transition#Tobe(x.StateID, @roleID, @actionID) t
	where	x.ID in (select ID from tvp.I64#Slice(@idsInCsv))
*/
)
GO
PRINT N'Creating [core].[RefInfo#ToShippingPlan]...';


GO
--PeterHo
CREATE FUNCTION [core].[RefInfo#ToShippingPlan](@matterID bigint, @spec nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteInfo as
	(
		select	m.Seq, i.GoodsInfo, UnitPrice=i.LineDecTotal/i.LineQty, i.CurrencyID, i.CmdyID
		from	core.RefInfo#VerifiedOrDeclared(@matterID) x
		cross	apply tvp.Mucho#Slice(x.Info)  m
		cross	apply loc.LineInfo#Of(m.Piece) i
	)
	, cteSpec as
	(
		select	Bag=x.Seq, m.Seq, Qty=cast(m.Piece as int)
		from	tvp.Pcs#Slice(@spec, default)  x
		cross	apply tvp.Mucho#Slice(x.Piece) m
	)
	, cteLine as
	(
		select	s.Bag,  Info=q.Tvp, Seq=row_number() over (partition by s.Bag order by i.Seq)
		from	cteInfo i join cteSpec s on s.Seq=i.Seq
		cross	apply dbo.Money#Make(i.UnitPrice*s.Qty, i.CurrencyID)    m
		cross	apply tvp.Quad#Make(i.GoodsInfo, s.Qty, m.Amt, i.CmdyID) q
		
	)
	, cteMixed as
	(
		select	idx=1, x.Bag, x.Seq, x.Info
		from	cteLine x where x.Seq=1
		UNION	ALL
		select	idx=idx+1, x.Bag, x.Seq, p.Info + k.Mucho + x.Info
		from	cteMixed p join cteLine x on x.Bag=p.Bag and x.Seq=idx+1
		cross	apply tvp.Spr#Const() k
	)
	, cteMarked as
	(
		select	Bag, Info, Mark=lead(Seq) over (partition by Bag order by (Seq))
		from	cteMixed 
	)
	, cte(text) as
	(
		select	[text()]=concat(k.Bag, x.Info)
		from	tvp.Spr#Const() k, cteMarked x
		where	x.Mark is null  order by x.Bag
		for xml path(N'')
	)
	select	MatterID=@matterID, Type=k.ShippingPlanInfo, Info=Tvp
	from	core.RefInfo#Type() k, cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [invt].[SkuInfo#ToBrokerage]...';


GO
/*
@skuInfos: Mucho[Triad<SkuID, LineQty,  LineTotal>]
@result:   Mucho[Triad<SkuID, CmdyInfo, LineInfo> ] : BrokerageInfo
*/
--PeterHo, AaronLiu
CREATE FUNCTION [invt].[SkuInfo#ToBrokerage]
(
	@skuInfos nvarchar(max), @brokerID bigint, @clrMethodID int
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat
		(
			k.Mucho,      t.v1, k.Triad
		,	/*CmdyHeadID*/N'0', k.Quad, /*CmdyTailID*/N'0', k.Quad,        d.DutyCode, k.Quad, d.DutyRate
		,	k.Triad,      e.v1, k.Quad, /*LineQty   */t.v2, k.Quad, /*LineTotal*/t.v3, k.Quad, /*CmdyID*/N'0'
		)
		from	tvp.Mucho#Slice(@skuInfos)           x
		cross	apply tvp.Triad#Of(x.Piece, default) t
		join	invt.SkuBrokerage#Raw() b on
		(
			b.SkuID=cast(t.v1 as int) and b.ClrMethodID=@clrMethodID and b.BrokerID=@brokerID
		)
		join	brkg.Duty#Raw()   d on d.ID=b.DutyID
		cross	apply tvp.Pair#Of(b.Endorsement) e
		cross	apply tvp.Spr#Const() k 
		order	by x.Seq for xml path (N'')
	)
	select Info=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [invt].[SkuInfo#ToDeclared]...';


GO
/*
@skuInfos: Mucho[Triad<SkuID, LineQty, LineTotal>]
*/
--PeterHo, AaronLiu
CREATE FUNCTION [invt].[SkuInfo#ToDeclared](@skuInfos nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat
		(
			k.Mucho, /*GoodsInfo*/ p.v1
		,	k.Quad,  /*LineQty  */ t.v2
		,	k.Quad,  /*LineTotal*/ t.v3
		,	k.Quad,  /*CmdyID   */ N'0'
		)
		from	tvp.Mucho#Slice(@skuInfos)           x
		cross	apply tvp.Triad#Of(x.Piece, default) t
		join	invt.Sku#Raw()						 s on s.ID=cast(t.v1 as int)
		cross	apply tvp.Pair#Of(s.FiledInfo)		 p
		cross	apply tvp.Spr#Const()				 k 
		order	by x.Seq for xml path (N'')
	)
	select Info=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [loc].[Declared$ToBrokerage]...';


GO
/*
	@declaredInfo = Mucho[LineInfo]
	@cmdyInfos	  = Mucho[CmdyInfo]
*/
-- AaronLiu
CREATE FUNCTION [loc].[Declared$ToBrokerage](@declaredInfo nvarchar(max), @cmdyInfos nvarchar(max)=N'')
RETURNS TABLE
--WITH ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Mucho, b.Tvp)
		from	tvp.Mucho#Slice(@declaredInfo)			    x
		left	join  tvp.Mucho#Slice(@cmdyInfos)			d on x.Seq=d.Seq
		cross	apply tvp.Quad#Make( N'0', N'0', N'', N'0') c
		cross	apply tvp.Triad#Make(N'0', isnull(d.Piece,  c.Tvp), x.Piece) b
		cross	apply tvp.Spr#Const() k 
		order	by x.Seq 
		for		xml path(N'')
	)
	select BrokerageInfo=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)

/*
--AaronLiu
CREATE FUNCTION [loc].[Declared$ToBrokerage](@declaredInfo nvarchar(max))
RETURNS TABLE
--WITH ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Mucho, b.Tvp)
		from	tvp.Mucho#Slice(@declaredInfo)			    x
		cross	apply tvp.Quad#Make( N'0', N'0', N'', N'0') c
		cross	apply tvp.Triad#Make(N'0', c.Tvp, x.Piece)  b
		cross	apply tvp.Spr#Const() k 
		order	by x.Seq for xml path (N'')
	)
	select BrokerageInfo=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
*/
GO
PRINT N'Creating [loc].[TotalSkuQty#For]...';


GO
CREATE FUNCTION [loc].[TotalSkuQty#For](@declaredInfo nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	TotalSkuQty=sum(l.LineQty)
	from	tvp.Mucho#Slice(@declaredInfo) x
	cross	apply loc.LineInfo#Of(x.Piece) l
)
GO
PRINT N'Creating [loc].[Contact#Of]...';


GO
-- PeterHo
CREATE FUNCTION [loc].[Contact#Of](@slip nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Name=v1,    Phone=v2,     Email=v3,       Company=v4
	,		Street1=v5, Street2=v6,   Street3=v7,     District=v8
	,		City=v9,    Province=v10, PostalCode=v11, CountryCode=v12
	from	tvp.Dozen#Of(@slip, default)
)
GO
PRINT N'Creating [loc].[RefNbr#Slice]...';


GO
--PeterHo
CREATE FUNCTION [loc].[RefNbr#Slice](@numbersInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.Seq, n.Number
	from	tvp.Comma#Slice(@numbersInCsv) x
	cross	apply loc.RefNbr#Cast(x.Piece) n
)
GO
PRINT N'Creating [shpt].[Parcel#LedgerForVmi]...';


GO
--Smile
CREATE FUNCTION [shpt].[Parcel#LedgerForVmi](@parcelIDs dbo.I64Array readonly)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID=x.ID, ContractID, [LedgerPartyID]=p.AID, u.ChargeID, u.ChargeAmt, u.CurrencyID
	from	shpt.Parcel#Base() x
	join	core.Party#Raw()   p on p.ID=x.SiteID
	cross	apply core.RefInfo#Type() k
	outer	apply core.RefInfo#Of(x.ID, k.BrokerageInfo) i
	cross	apply core.RefInfo#Of(x.ID, k.DeclaredInfo)  o
	join	tms.SvcType#Raw()  t on t.ID=x.SvcType
	cross	apply acct.Charge#ID()                                       g
	cross	apply
	(
		select	ChargeAmt=c.Amt,  ChargeID=g.Freight, t.CurrencyID		
		from	tms.Freight#For(x.SvcType, x.RcvHubID, x.Weight, i.Info) r
		cross	apply dbo.Money#Make(r.Freight, t.CurrencyID)            c		
		where	t.ID=x.SvcType
		UNION	ALL
		select	r.DutyRate, ChargeID=g.Duty, r.CurrencyID
		from	brkg.DutyRate#For(p.AID, t.ClrMethodID, i.Info)         r
		where	r.DutyRate>r.CurrencyID
		UNION	ALL
		select	m.Amt, CharegeID=g.OutPkgFee, s.CurrencyID
		from	whse.StorageRate#For(x.RcvHubID, x.SiteID)              s
		cross	apply dbo.Money#Make(s.OutPkgFee, s.CurrencyID)         m
		where	m.Amt>s.CurrencyID
		UNION	ALL
		select	m.Amt, CharegeID=g.OverWeightFee, s.CurrencyID
		from	whse.StorageRate#For(x.RcvHubID, x.SiteID)              s
		cross	apply dbo.Money#Make(s.OverWeightFee, s.CurrencyID)     m
		where	x.Weight>s.WeightLimit
		and		m.Amt>s.CurrencyID
		UNION	ALL
		select	m.Amt, CharegeID=g.ExcessItemsFee, s.CurrencyID
		from	whse.StorageRate#For(x.RcvHubID, x.SiteID)              s
		cross	apply dbo.Money#Make(s.ExcessItemsFee, s.CurrencyID)    m
		cross	apply loc.TotalSkuQty#For(o.Info)                       o
		where	o.TotalSkuQty>s.ItemsQtyLimit	
		and		m.Amt>s.CurrencyID
	) u
	where	x.ID in (select ID from @parcelIDs)	
)
GO
PRINT N'Creating [shpt].[Parcel#FreightAndDutyFor]...';


GO
--Smile
CREATE FUNCTION [shpt].[Parcel#FreightAndDutyFor](@parcelIDs dbo.I64Array readonly)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID=x.ID, ContractID, [LedgerPartyID]=p.AID, u.ChargeID, u.ChargeAmt, u.CurrencyID
	from	shpt.Parcel#Base() x
	join	core.Party#Raw()   p on p.ID=x.SiteID
	cross	apply core.RefInfo#Type() k
	outer	apply core.RefInfo#Of(x.ID, k.BrokerageInfo) i
	join	tms.SvcType#Raw()  t on t.ID=x.SvcType
	cross	apply acct.Charge#ID()                                       g
	cross	apply
	(
		select	ChargeAmt=c.Amt,  ChargeID=g.Freight, t.CurrencyID		
		from	tms.Freight#For(x.SvcType, x.RcvHubID, x.Weight, i.Info) r
		cross	apply dbo.Money#Make(r.Freight, t.CurrencyID)            c		
		where	t.ID=x.SvcType
		UNION	ALL
		select	r.DutyRate, ChargeID=g.Duty, r.CurrencyID
		from	brkg.DutyRate#For(p.AID, t.ClrMethodID, i.Info)          r
		UNION	ALL
		select	r.DutyRate, ChargeID=g.BrokerageFee, r.CurrencyID
		from	brkg.BrokerageFee#For(x.RouteID, i.Info)                 r
	) u
	where	x.ID in (select ID from @parcelIDs)	and u.ChargeAmt>0
)
GO
PRINT N'Creating [shpt].[Parcel#MaybeVia]...';


GO
--PeterHo
CREATE FUNCTION [shpt].[Parcel#MaybeVia](@idsInCsv nvarchar(max), @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID, ActionID, OnStateID, ToStateID, ToStage, Source, OutboundQ, TodoHours
	from	tvp.I64#Slice(@idsInCsv) x join shpt.Parcel#Raw()      p on p.ID=x.ID
	cross	apply tms.RouteRole#For(p.RouteID, @roleID, @actionID) r
	cross	apply core.Matter#Maybe(p.ID,     r.RoleID, @actionID) t
)
GO
PRINT N'Creating [shpt].[Parcel#TobeVia]...';


GO
--PeterHo
CREATE FUNCTION [shpt].[Parcel#TobeVia](@idsInCsv nvarchar(max), @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID, ActionID, OnStateID, ToStateID, ToStage, Source, OutboundQ, TodoHours
	from	shpt.Parcel#Raw() p
	cross	apply tms.RouteRole#For(p.RouteID, @roleID, @actionID) r
	cross	apply core.Matter#Tobe (p.ID,     r.RoleID, @actionID) t
	where	p.ID in (select ID from tvp.I64#Slice(@idsInCsv))
)
GO
PRINT N'Creating [svc].[Batch$ExportForAmazon]...';


GO
--Smile, PeterHo
CREATE FUNCTION [svc].[Batch$ExportForAmazon](@batchIDs nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID=BatchID, RefNbrs, RefInfos, CourierAlias, SvcType, PostedOn=l.LocalTime
	from	tvp.I64#Slice(@batchIDs) x
	join	shpt.Parcel#Deep()  p on p.BatchID=x.ID
	cross	apply dbo.DT#ToLocal(p.PostedOn, p.SiteUtcOffset) l
)
GO
PRINT N'Creating [svc].[ClientRefNbr$Vefity]...';


GO
--Smile, PeterHo
CREATE	FUNCTION [svc].[ClientRefNbr$Vefity](@siteID int, @numbersInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	

		select	ID=isnull(c.ID,0), ClientRefNbr=x.Number
		from	loc.RefNbr#Slice(@numbersInCsv) x
		cross	apply core.RefNbr#Type()        k
		cross	apply(
						select top(1) m.ID 
						from(
								select	p.ID from core.RefNbr#Raw()  r
								join	shpt.Parcel#Base()           p on r.MatterID=p.ID  and p.SiteID=@siteID 
								where	r.Number=x.Number and r.Type=k.ClientRef
								union all
								select	0
						) m
		) c
		
	
	
)
GO
PRINT N'Creating [svc].[Parcel$ForBrokerage]...';


GO
-- Eason
CREATE FUNCTION [svc].[Parcel$ForBrokerage]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, m.PID, AID, m.Source, Type, LockCnt, Stage, m.StateID, StatedOn, PostedOn
	,		RcvHubID,  RcvHubAlias=c.Alias
	,		RouteID,   RouteCode, BrokerID, CourierID       , ClrMethodID
	,		POA,       SvcType,   SvcZone,  SvcClass, Weight, Length, Width, Height
	,		RefNbrs,   RefInfos=i.RefInfos
	,		Endorsement=e.Tvp
	from	shpt.Parcel#Raw()            x
	join	core.Matter#Raw()            m on m.ID=x.ID
	join	tms.Route#Raw()              r on r.ID=x.RouteID
	join	core.Tenant#Raw()			 c on c.ID=x.RcvHubID
	cross	apply core.RefInfo#Tvp(x.ID) i
	cross	apply core.RefInfo#Type()    t
	cross	apply core.RefNbr#Tvp(x.ID)  rn
	cross	apply
	(
		select	Info=i.v2
		from	tvp.Duad#Slice(i.RefInfos, default, default)  i
		where	i.v1=t.BrokerageInfo
	) ri	
	cross	apply
	(
		select	[text()]=concat(k.Many, b.SkuID, k.Triad, mt.v3, k.Triad, e.v2)
		from	tvp.Spr#Const() k, tvp.Mucho#Slice(ri.Info) m
		cross	apply tvp.Triad#Of(m.Piece, default)        mt
		join	invt.SkuBrokerage#Raw()                     b
		on		b.SkuID=cast(mt.v1 as int) and b.BrokerID=r.BrokerID and b.ClrMethodID=r.ClrMethodID
		cross	apply tvp.Pair#Of(b.Endorsement)			e
		for	xml path(N'')
	) z (text)
	cross	apply tvp.Spr#Purify(z.text, default) e
)
GO
PRINT N'Creating [svc].[Sku$Verify]...';


GO
--PeterHo, Smile
CREATE FUNCTION [svc].[Sku$Verify](@siteID int, @svcType int, @skuNbrs nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	
	select	ID=isnull(cast(d.SkuID as bigint), 0), c.SkuNbr
	from	tvp.Many#Slice(@skuNbrs)       x
	cross	apply loc.SkuNbr#Cast(x.Piece) c
	join	core.Party#Raw()               p on p.ID=@siteID
	left	join invt.Sku#Raw()            t on t.TenantID=p.PID and t.SkuNbr=c.SkuNbr
	cross	apply tms.SvcType#For(@svcType, @siteID)    s
	cross	apply tms.SvcRoute#For(s.ID, s.FallbackPOA) r
	join	tms.Route#Raw()                             a on a.ID=r.RouteID
	outer	apply
	(
		select	top(1) SkuID from invt.SkuBrokerage#Raw()
		where	SkuID=t.ID 
		and		ClrMethodID=a.ClrMethodID
		and		BrokerID=a.BrokerID
	) d
)
GO
PRINT N'Creating [svc].[MIC$Vefity]...';


GO
--PeterHo
CREATE	FUNCTION [svc].[MIC$Vefity](@micsInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID=isnull(r.MatterID,0), MIC=x.Number
	from	loc.RefNbr#Slice(@micsInCsv) x
	cross	apply core.RefNbr#Type() k
	left	join  core.RefNbr#Raw()  r on r.Number=x.Number and r.Type=k.MIT
)
GO
PRINT N'Creating [svc].[Parcel$TrackManyForZPS]...';


GO
--Smile
CREATE FUNCTION [svc].[Parcel$TrackManyForZPS](@numbersInCsv nvarchar(max), @siteID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
		with cteMatter as
	(
		select	SeqID=row_number() over (order by (select null))
		,		TrackingID =n.MatterID
		,		TrackingNbr=n.Number
		from	loc.RefNbr#Slice(@numbersInCsv)                       x
		cross	apply core.RefNbr#ScanOne(x.Number, default, default) n
		cross	apply core.Matter#Type() m 
		join	core.Matter#Raw()        r on r.Type=m.Parcel and r.ID=n.MatterID 
		cross	apply core.RefNbr#Type() k
		where	(case when n.Type in (k.ClientRef, k.PreCourier) then @siteID else r.PosterID end)=r.PosterID
	)
	, cteMarked as
	(
		select	x.TrackingID,      x.TrackingNbr
		,		ID,		Type,      MatterID, StateID,   Stage,    TalliedOn
		,		UserID, UserAlias, UtcTime,  UtcOffset, UtcPlace, UtcPlaceID
		,		Marker=lead(ID) over (partition by x.SeqID order by Stage)
		from	cteMatter x
		cross	apply core.Activity#Track(x.TrackingID)
	)
	select	ID=TrackingID, TrackingNbr, Stage
	,		UtcTime,       UtcOffset,   UtcPlace
	from	cteMarked where Marker is null
)
GO
PRINT N'Creating [svc].[ClientRefNbr$VefityForPlatform]...';


GO
/*
@numbersInCSV =Duad[Alias, ClientRefNbr]
*/
--Smile
CREATE	FUNCTION [svc].[ClientRefNbr$VefityForPlatform](@userID int, @numbersInCSV nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	
	select	ID=isnull(c.ID, 0), ClientRefNbr=d.Number
	from	tvp.Duad#Slice(@numbersInCSV, default, default) x
	cross	apply loc.RefNbr#Cast(x.v2)                     d
	cross	apply core.RefNbr#Type()                        k
	join	core.Party#Raw()                                n on n.ID=@userID
	left	join  core.Party#Raw()                          p on p.Source=n.Source and p.Alias=x.v1
	cross	apply(
						select top(1) m.ID 
						from(
								select	b.ID from core.RefNbr#Raw()  r
								join	shpt.Parcel#Base()           b on r.MatterID=b.ID  and b.SiteID=p.ID 
								where	r.Number=d.Number and r.Type=k.ClientRef
								union all
								select	0
						) m
		) c
			
)
GO
PRINT N'Creating [svc].[Parcel$VerifyForSackMft]...';


GO
/*
	@numbers = Comma<MIC>
*/
-- AaronLiu
CREATE FUNCTION [svc].[Parcel$VerifyForSackMft](@numbers tvp, @tenancy tvp)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	p.ID,       MIC=x.Piece,   p.Stage, p.BrokerID, p.BrokerAlias, p.POA
	,		p.RcvHubID, p.RcvHubAlias, Transitable=iif(b.MatterID is null, 0, 1)
	from	tvp.Comma#Slice(@numbers)      x
	cross	apply core.MIC#IdOf(x.Piece)   m
	join	shpt.Parcel#Deep()			   p on m.MatterID=p.ID
	cross	apply core.Action#ID()         a
	cross	apply loc.Tenancy#Of(@tenancy) t
	outer	apply shpt.Parcel#Maybe(p.ID,  t.RoleID, a.ICManifest) b
)
GO
PRINT N'Creating [svc].[Sku$VerifyForEndorsement]...';


GO
/*
@skuIDs = string.Join(at.Spr.Comma, skuIDs);
*/
--Aimee
CREATE FUNCTION [svc].[Sku$VerifyForEndorsement](@skuIDs nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	SkuID=x.Piece, Result=isnull(cast(s.ID as bigint), 0)
	from	tvp.Comma#Slice(@skuIDs) x
	left	join invt.Sku#Raw()      s on s.ID=x.Piece
)
GO
PRINT N'Creating [svc].[Parcel$ForArrivedNotice]...';


GO
-- For eForward Notice
-- Daxia
CREATE FUNCTION [svc].[Parcel$ForArrivedNotice](@parcelIDS nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	p.ID,      SiteAlias
	,		p.RefNbrs, RefStamps=isnull(f.RefStamps, N'')
	from	shpt.Parcel#Base()      p 
	join	shpt.Sack#Base()        s on s.ID=p.PID	
	join	shpt.SackMft#Base()     m on m.ID=s.PID
	join	tms.Flight#Base()       f on f.ID=m.PID
	where	p.ID in (select ID from tvp.I64#Slice(@parcelIDS))
)
GO
PRINT N'Creating [svc].[Parcel$ForOnboardedNotice]...';


GO
-- For eForward Notice
-- Daxia
-- TODO: Must add new Onboarded LocalTime
CREATE FUNCTION [svc].[Parcel$ForOnboardedNotice](@idInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	p.ID,      SiteAlias
	,		p.RefNbrs, m.RefStamps
	from	tvp.I64#Slice(@idInCsv)   x
	join	shpt.SackMft#Base()       m on m.ID=x.ID
	left	join shpt.Sack#Base()     s on s.PID=x.ID
	join	shpt.Parcel#Base()        p on p.PID=s.ID or p.PID=x.ID
)
GO
PRINT N'Creating [svc].[Parcel$ForUploadIDPicture]...';


GO
-- Daxia
CREATE FUNCTION [svc].[Parcel$ForUploadIDPicture]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with cteCneeInfo as
	(
		select	MatterID, Name=c.v1, Phone=c.v2
		from	core.RefInfo#Type() k, core.RefInfo#Raw() x
		cross	apply tvp.Dozen#Of(x.Info, default) c
		where	x.Type=k.CneeInfo
	)
	select	p.ID, Name, Phone, p.RefInfos from cteCneeInfo x
	join	shpt.Parcel#Base() p on p.ID=x.MatterID and p.StateID in(38336, 17250)--USE State#ID
)
GO
PRINT N'Creating [svc].[Parcel$ExportByIDs]...';


GO
-- fangyi, Smile
CREATE FUNCTION [svc].[Parcel$ExportByIDs](@parcelIDs tvp)
RETURNS TABLE 
--WITH ENCRYPTION
AS RETURN 
(
	select	p.ID, HandlerID, Handler=Alias, Source, RouteCode
	,		POA, RefNbrs, RefInfos, Stage, StateID
	from	tvp.I64#Slice(@parcelIDs) x
	join	shpt.Parcel#Deep()        p on p.ID=x.ID
	join	core.User#Raw()           u on u.ID=p.HandlerID
)
GO
PRINT N'Creating [svc].[Parcel$VefityDutyCode]...';


GO
--Smile
CREATE	FUNCTION [svc].[Parcel$VefityDutyCode](@dutyCodes nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	p.ID, DutyCode=x.v2, DutyID=isnull(d.ID, 0), DutyRate=isnull(d.DutyRate, 0)
	from	tvp.Duad#Slice(@dutyCodes, default, default) x
	join	shpt.Parcel#Raw()                            p on p.ID=cast(x.v1 as bigint)
	join	tms.Route#Raw()                              t on t.ID=p.RouteID
	join	brkg.ClrMethod#Raw()                         c on c.ID=t.ClrMethodID
	left	join brkg.Duty#Raw()                         d on d.CountryCode=c.CountryCode and d.DutyCode=x.v2
)
GO
PRINT N'Creating [svc].[CourierAlias$Verify]...';


GO
--Smile
CREATE FUNCTION [svc].[CourierAlias$Verify](@aliasInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID=c.CourierID, CourierAlias=x.Piece
	from	tvp.Comma#Slice(@aliasInCsv)          x
	cross	apply tms.Courier#IdOfAlias(x.Piece)  c
)
GO
PRINT N'Creating [svc].[Parcel$ListVia]...';


GO
/*
  ToAaron:
	Should not use Parcel$List() any more, avoid 2100 parameters error for now.
	Don't use me, this will be dropped after brokerage dequeue refactoring.
*/
-- AaronLiu
CREATE FUNCTION [svc].[Parcel$ListVia](@idsInCsv nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING
AS RETURN 
(
	select	x.ID,	   Source,	  PostedOn,		 Stage,	   StateID,	   StatedOn, BatchID,  RcvHubID,   SiteID
	,		RouteID,   RouteCode, CourierID,	 BrokerID, SvcType,	   SvcZone,  SvcClass, CmdyRootID, Weight
	,		Length,	   Width,     Height,		 POA,      RefNbrs,	   RefInfos, Ledgers,  Challenges, LastMilerCode
	,		HandlerID, Handler,   AddOnServices, HasIDNbr, HasConcern, ZoneCode
	from	tvp.I64#Slice(@idsInCsv) i,	svc.Parcel$List() x
	where	i.ID=x.ID
)
GO
PRINT N'Creating [svc].[Sku$VerifyForPlatform]...';


GO
/*
@skus = Triad[Alias, Mucho<skus>, SvcType]
*/
--Smile
CREATE FUNCTION [svc].[Sku$VerifyForPlatform](@userID int, @skus nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID=isnull(cast(d.SkuID as bigint), 0), c.SkuNbr, SvcType=isnull(cast(x.v3 as int), 0)
	from	tvp.Triad#Slice(@skus, default, default)	x	
	cross	apply tvp.Mucho#Slice(x.v2)					m
	cross	apply loc.SkuNbr#Cast(m.Piece)				c
	join	core.Party#Raw()							n on n.ID=@userID
	left	join core.Party#Raw()						p on p.Alias=x.v1 and p.Source=n.Source
	left	join invt.Sku#Raw()							t on t.TenantID=p.PID and t.SkuNbr=c.SkuNbr
	cross	apply tms.SvcType#For(x.v3, p.ID)			s
	cross	apply tms.SvcRoute#For(s.ID, s.FallbackPOA) r
	join	tms.Route#Raw()                             a on a.ID=r.RouteID
	outer	apply
	(
		select	top(1) SkuID from invt.SkuBrokerage#Raw()
		where	SkuID=t.ID		 
		and		ClrMethodID=a.ClrMethodID
		and		BrokerID=a.BrokerID
	) d
)
GO
PRINT N'Creating [svc].[Parcel$ClearanceForXpd]...';


GO
--bd.he, Smile
CREATE FUNCTION [svc].[Parcel$ClearanceForXpd](@idsInCsv nvarchar(max))
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	p.ID, t.MawbNbr, f.FlightNbr, f.POA, f.POD, f.ETA, f.ETD, p.Weight
    ,		p.RefNbrs, p.RefInfos, r.BrokerID
	from	tvp.I64#Slice(@idsInCsv) x
	join	shpt.SackMft#Base()	     t on x.ID=t.ID
	join	tms.Flight#Raw()	     f on f.ID=t.PID
	join    shpt.Sack#Base()	     s on s.PID=x.ID
	join	shpt.Parcel#Base()	     p on p.PID=s.ID
	join	tms.Route#Raw()          r on r.ID=p.RouteID
	
)--HACK: should move to schema xpd
GO
PRINT N'Creating [tms].[TrackingNbr#Slice]...';


GO
-- PeterHo
CREATE FUNCTION [tms].[TrackingNbr#Slice](@slip nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	TrackingNbr
	from	tvp.Many#Slice(@slip)
	cross	apply tms.TrackingNbr#Cast(Piece)
)
GO
PRINT N'Creating [vmi].[Parcel$TrackMany]...';


GO
--Smile
CREATE FUNCTION [vmi].[Parcel$TrackMany](@numbersInCsv nvarchar(max), @siteID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
		with cteMatter as
	(
		select	SeqID=row_number() over (order by (select null))
		,		TrackingID =n.MatterID
		,		TrackingNbr=n.Number
		from	loc.RefNbr#Slice(@numbersInCsv)                       x
		cross	apply core.RefNbr#ScanOne(x.Number, default, default) n
		cross	apply core.Matter#Type() m 
		cross	apply core.Source#ID()   s
		join	core.Matter#Raw()        r on r.Type=m.Parcel and r.ID=n.MatterID and r.Source=s.eVMI
		cross	apply core.RefNbr#Type() k
		where	r.PosterID=r.PosterID
	)
	, cteMarked as
	(
		select	x.TrackingID,      x.TrackingNbr
		,		ID,		Type,      MatterID, StateID,   Stage,    TalliedOn
		,		UserID, UserAlias, UtcTime,  UtcOffset, UtcPlace, UtcPlaceID
		from	cteMatter x
		cross	apply core.Activity#Track(x.TrackingID)
	)
	select	ID=TrackingID, TrackingNbr, Stage
	,		UtcTime,       UtcOffset,   UtcPlace
	from	cteMarked
)
GO
PRINT N'Creating [vmi].[ClientRefNbr$Vefity]...';


GO
--Smile
CREATE	FUNCTION [vmi].[ClientRefNbr$Vefity](@siteID int, @numbersInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	

		select	ID=isnull(c.ID,0), ClientRefNbr=x.Number
		from	loc.RefNbr#Slice(@numbersInCsv) x
		cross	apply core.RefNbr#Type()        k
		cross	apply(
						select top(1) m.ID 
						from(
								select	p.ID from core.RefNbr#Raw()  r
								join	shpt.Parcel#Base()           p on r.MatterID=p.ID  and p.SiteID=@siteID 
								where	r.Number=x.Number and r.Type=k.ClientRef
								union all
								select	0
						) m
		) c
		
	
	
)
GO
PRINT N'Creating [xpd].[Parcel$Verify]...';


GO
--	Aimee
CREATE	FUNCTION [xpd].[Parcel$Verify](@micsInCsv nvarchar(max), @siteID int)
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID=m.MatterID, x.Number, Stage
	from	loc.RefNbr#Slice(@micsInCsv)  x
	cross	apply core.MIC#IdOf(x.Number) m
	join	core.Matter#Raw()             r on r.ID=m.MatterID
	where	r.PosterID=@siteID
)
GO
PRINT N'Creating [zeb].[Parcel$ViaBarcode]...';


GO
-- Eva, AaronLiu
CREATE FUNCTION [zeb].[Parcel$ViaBarcode](@barcodes tvp)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(N',', MatterID)
		from	loc.RefNbr#Slice(@barcodes) x
		cross	apply core.RefNbr#Type()    t
		cross	apply core.RefNbr#ScanOne(x.Number, default, default) m
		where	m.Type in (t.ClientRef, t.PreCourier)
		for		xml path(N'')
	)
	select IDs=Tvp from cte cross apply tvp.Spr#Purify(text, 1)
)
/*
	with cte(text) as
	(
		select	[text()]=concat(N',', MatterID)
		from	loc.RefNbr#Slice(@barcodes) x
		join	core.RefNbr#Raw()           n on n.Number=x.Number
		cross	apply core.RefNbr#Type()    t
		where	Type in (t.ClientRef, t.PreCourier)
		for xml path(N'')
	)
	select IDs=Tvp from cte cross apply tvp.Spr#Purify(text, 1)
*/
GO
PRINT N'Creating [acct].[Ledger#DutyTvpFor]...';


GO
--Smile.Wang
CREATE FUNCTION [acct].[Ledger#DutyTvpFor](@invoiceID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, row_number() over(order by (select 0)), k.Dozen, TalliedOn, k.Dozen, r.Number
						 , k.Dozen, m.Number, k.Dozen, concat(c.City, ', ', c.Province, ', ',c.CountryCode), k.Dozen, 
						 Source, k.Dozen, SvcType, k.Dozen, v.Info, k.Dozen, ChargeAmt)
		--Seq, LedgerDate, ClientRef, MIC, Destination, Source, SvcType, VerifiedInfo.FallBack(DeclaredInfo), Duty
		from	acct.Ledger#Raw()            x
		join	shpt.Parcel#Base()           p on p.ID=x.MatterID
		cross	apply core.RefNbr#Type()     rt 
		join	core.RefNbr#Raw()            r on r.MatterID=p.ID and r.Type=rt.ClientRef
		join	core.RefNbr#Raw()            m on m.MatterID=p.ID and m.Type=rt.MIT
		cross	apply core.RefInfo#Type()    ri
		join	core.RefInfo#Raw()           i  on i.MatterID=p.ID   and i.Type=ri.CneeInfo
		cross	apply core.RefInfo#VerifiedOrDeclared(p.ID) v
		cross	apply loc.Contact#Of(i.Info) c
		cross	apply tvp.Spr#Const()        k
		where   x.InvoiceID=@invoiceID  
		for		xml path(N'')
	)
	select DutyTvp=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [acct].[Ledger#FreightTvpFor]...';


GO
--Smile.Wang
CREATE FUNCTION [acct].[Ledger#FreightTvpFor](@invoiceID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, row_number() over(order by (select 0)), k.Dozen, TalliedOn, k.Dozen, r.Number, 
						 k.Dozen, m.Number, k.Dozen, concat(c.City, ', ', c.Province, ', ',c.CountryCode), k.Dozen, 
						 Source, k.Dozen, SvcType, k.Dozen, Weight, k.Dozen, SectionWt, k.Dozen, ChargeAmt)
		--Seq, LedgerDate, ClientRef, MIC, Destination, Source, SvcType, Weight, SectionWt, Duty
		from	acct.Ledger#Raw()            x
		join	shpt.Parcel#Base()           p on p.ID=x.MatterID
		cross	apply core.RefNbr#Type()     rt 
		join	core.RefNbr#Raw()            r on r.MatterID=p.ID and r.Type=rt.ClientRef
		join	core.RefNbr#Raw()            m on m.MatterID=p.ID and m.Type=rt.MIT
		cross	apply core.RefInfo#Type()    ri
		join	core.RefInfo#Raw()           i on i.MatterID=p.ID   and i.Type=ri.CneeInfo
		cross	apply loc.Contact#Of(i.Info) c
		cross	apply tms.SvcRate#For(p.SvcType, p.RcvHubID, p.Weight) a
		cross	apply tvp.Spr#Const()        k
		where   x.InvoiceID=@invoiceID  
		for		xml path(N'')
	)
	select FreightTvp=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Creating [bo].[Account$ExportForFreightInvoice]...';


GO
--Simile, PeterHo
CREATE FUNCTION [bo].[Account$ExportForFreightInvoice]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	InvoicedOn, InvoiceNbr, i.PartyID, NetDays=isnull(BillingCycle,0)
	,		DueDate, BillTo=c.Tvp, l.FreightTvp
	from	acct.Invoice#Raw()                    i
	join	core.Party#Raw()                      p  on p.ID = i.PartyID
	join	acct.Contract#Raw()                   t  on t.ID=i.ContractID
	cross	apply core.Contact#Type()             k
	outer	apply core.Contact#TvpFor(i.PartyID,  k.Billing) c
	cross	apply acct.Ledger#FreightTvpFor(i.ID) l
	cross	apply acct.Vault#Tag()                d
	cross	apply acct.Ledger#Side()              s
	where	i.DueBalance>0 and i.VaultTag=d.NotDuty and i.LedgerSide=s.AR and BillingCycle>0
)
GO
PRINT N'Creating [bo].[Account$ExportForDutyInvoice]...';


GO
--Simile, PeterHo
CREATE FUNCTION [bo].[Account$ExportForDutyInvoice]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	InvoicedOn, InvoiceNbr, i.PartyID, NetDays=isnull(t.BillingCycle,0)
	,		DueDate, BillTo=c.Tvp, l.DutyTvp
	from	acct.Invoice#Raw()                   i
	join	core.Party#Raw()                     p  on p.ID = i.PartyID
	join	acct.Contract#Raw()                  t  on t.ID=i.ContractID
	cross	apply core.Contact#Type()            k
	outer	apply core.Contact#TvpFor(i.PartyID, k.Billing) c
	cross	apply acct.Ledger#DutyTvpFor(i.ID)   l
	cross	apply acct.Vault#Tag()               d
	cross	apply acct.Ledger#Side()             s
	where	i.DueBalance>0 and i.VaultTag=d.Duty and i.LedgerSide=s.AR and BillingCycle>0
)
GO
PRINT N'Creating [core].[Activity#TrackMany]...';


GO
--PeterHo
CREATE FUNCTION [core].[Activity#TrackMany](@numbersInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteMatter as
	(
		select	SeqID=row_number() over (order by (select null))
		,		TrackingID =n.MatterID
		,		TrackingNbr=n.Number
		from	loc.RefNbr#Slice(@numbersInCsv) x
		cross	apply core.RefNbr#ScanOne(x.Number, default, default) n
	)
	, cteMarked as
	(
		select	x.TrackingID,      x.TrackingNbr
		,		ID,		Type,      MatterID, StateID,   Stage,    TalliedOn
		,		UserID, UserAlias, UtcTime,  UtcOffset, UtcPlace, UtcPlaceID
		,		Marker=lead(ID) over (partition by x.SeqID order by Stage)
		from	cteMatter x
		cross	apply core.Activity#Track(x.TrackingID)
	)
	select	TrackingID,        TrackingNbr
	,		ID,		Type,      MatterID, StateID,   Stage,    TalliedOn
	,		UserID, UserAlias, UtcTime,  UtcOffset, UtcPlace, UtcPlaceID--, Marker
	from	cteMarked where Marker is null
)
GO
PRINT N'Creating [core].[RefNbr#DecodeMulti]...';


GO
--Aaron
CREATE FUNCTION [core].[RefNbr#DecodeMulti](@numbersInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
    with cteDecoded(text) as
    (
        select  [text()]=concat(',', n.Number)
        from	loc.RefNbr#Slice(@numbersInCsv) x
        cross   apply core.RefNbr#DecodeOne(x.Number) n
        for     xml path('')
    )
    select Numbers=Tvp from cteDecoded cross apply tvp.Spr#Purify(text, 1)
)
GO
PRINT N'Creating [core].[RefNbr#MatchMulti]...';


GO
--PeterHo, Aaron
CREATE FUNCTION [core].[RefNbr#MatchMulti]
(
	@numbersInCsv nvarchar(max), @minStage int=100, @maxStage int=25500
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.Seq
	,		[Number]    =isnull(x.Number,    '')
	,		[MatchedCnt]=isnull(n.MatchedCnt, 0)
	,		[MatterID]  =isnull(n.MatterID,   0)
	,		[Type]      =isnull(n.Type,       0)
	,		[Stage]     =isnull(n.Stage,      0)
	from	loc.RefNbr#Slice(@numbersInCsv) x
	outer	apply core.RefNbr#MatchOne(x.Number, @minStage, @maxStage) n
)
GO
PRINT N'Creating [core].[RefNbr#ScanMulti]...';


GO
--PeterHo, Aaron
CREATE FUNCTION [core].[RefNbr#ScanMulti]
(
	@numbersInCsv nvarchar(max), @minStage int=100, @maxStage int=25500
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteScaned as
	(
		select	top(1) Seq, Number, MatterID, Type, Stage
		from	core.RefNbr#MatchMulti(@numbersInCsv, @minStage, @maxStage)
		where	MatchedCnt=1
		union	all
		select	top(1) Seq, Number, MatterID, Type, Stage
		from	core.RefNbr#DecodeMulti(@numbersInCsv) x
		cross	apply core.RefNbr#MatchMulti(x.Numbers, @minStage, @maxStage)
		where	MatchedCnt=1
	)
	select	top(1) Seq, Number, MatterID, Type, Stage
	from	cteScaned
)
GO
PRINT N'Creating [svc].[Parcel$TrackMany]...';


GO
--PeterHo
CREATE FUNCTION [svc].[Parcel$TrackMany](@numbersInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID=TrackingID, TrackingNbr, Stage
	,		UtcTime,       UtcOffset,   UtcPlace
	from	core.Activity#TrackMany(@numbersInCsv)
)
GO
PRINT N'Creating [svc].[Parcel$ScanMultiForAutomation]...';


GO
--Eason
CREATE FUNCTION [svc].[Parcel$ScanMultiForAutomation](@numbersInCsv tvp, @minStage E32=PreMin, @maxStage E32=PreMax)
RETURNS TABLE
--WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, RcvHubID,  Source, SvcType,  CourierID, RouteID
	,       s.Stage, StateID,  POA,    StatedOn, PostedOn
	,		RefNbrs, RefInfos, Number, AddOnServices
	from	core.RefNbr#ScanMulti(@numbersInCsv, @minStage, @maxStage) s
	join	shpt.Parcel#Deep() x on x.ID=s.MatterID 
)
GO
PRINT N'Creating [svc].[Parcel$TrackForXpd]...';


GO
-- Aimee
CREATE FUNCTION [svc].[Parcel$TrackForXpd](@numbersInCsv nvarchar(max), @siteID int)
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	Tracks, CourierCode, CourierNbr, TrackingNbr=x.Number
	from	core.RefNbr#MatchMulti(@numbersInCsv, default, default) x
	join	core.Matter#Raw() p on p.ID=x.MatterID
	cross	apply svc.Parcel$Track(p.ID)
	where	p.PosterID=@siteID
)
GO
PRINT N'Creating [zeb].[RefNbr$ExistedCnt]...';


GO
--Eva
CREATE FUNCTION [zeb].[RefNbr$ExistedCnt](@nbrsInCsv tvp, @minStage int=100, @maxStage int=25500)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Type, MatchedCnt
	from	core.RefNbr#MatchMulti(@nbrsInCsv, @minStage, @maxStage) x
)
GO
PRINT N'Creating [acct].[Vault#XactByInvoice]...';


GO
--Smile
CREATE PROCEDURE [acct].[Vault#XactByInvoice](@invoiceds I64Array readonly, @paymentID bigint =0, @vaultType tinyint)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
						
		-- 1	Upsert  Vault(s):
		with cteVaultGroup as
		(
			select	PartyID, i.CurrencyID, XactAmt=sum(-m.RawAmt)
			from	@invoiceds         x
			join	acct.Invoice#Raw() i on i.ID=x.ID
			cross	apply dbo.Money#Of(i.InvoiceAmt) m 
			group	by PartyID, i.CurrencyID
		), cteVault as
		(
			select	PartyID, CurrencyID, XactAmt=m.Amt
			from	cteVaultGroup                                    x
			cross	apply dbo.Currency#Encode(x.XactAmt, CurrencyID) m
		)
		merge	acct._Vault as o using cteVault as n
		on		(o.PartyID=n.PartyID and o.VaultType=@vaultType and o.CurrencyID=n.CurrencyID)
		when	matched  then update set VaultBal=(select Amt from dbo.Money#Sum(VaultBal, XactAmt))
										, TalliedOn=getutcdate()
										, InvoicedAmt=(select iif(Amt<o.CurrencyID, o.CurrencyID, Amt) 
										  from dbo.Money#Sum(o.InvoicedAmt, n.XactAmt))
		when	not matched then
				insert(  PartyID,   VaultBal,  VaultType,   CurrencyID)
				values(n.PartyID, n.XactAmt,  @vaultType, n.CurrencyID)
		;

		with cteInvoice as
		(
			select	x.PartyID, InvoiceID=x.ID, VaultID=v.ID, XactAmt=x.InvoiceAmt, XactAmtRaw=c.RawAmt, x.CurrencyID
			,		VaultBalRaw=isnull(PrevBalRaw, 0), Marker=lag(c.RawAmt) over(partition by v.ID order by x.ID)
			from	acct.Invoice#Raw()                    x
			join	 @invoiceds                           d on x.ID=d.ID
			cross	apply dbo.Money#Of(x.InvoiceAmt)      c
			join	acct.Vault#Raw() v on v.PartyID=x.PartyID and v.CurrencyID=x.CurrencyID and v.VaultType=@vaultType
			outer	apply acct.VaultXact#LastBalFor(v.ID) i
		),	cteCummulation as
		(
			select	PartyID, InvoiceID, VaultID, XactAmt, XactAmtRaw, CurrencyID
			,		Cummulation=sum(Marker) over (partition by VaultID  order by InvoiceID)
			,		VaultBalRaw, marker
			from	cteInvoice
		)
		, cteXact as
		(
			select	PartyID, InvoiceID, VaultID, XactAmt, CurrencyID, Cummulation, VaultBalRaw
			,		PrevBalRaw=iif(marker is null, VaultBalRaw, VaultBalRaw-Cummulation)
			from	cteCummulation
		)

		insert	acct._VaultXact
		(		PaymentID, InvoiceID, VaultID, PrevBal,  XactAmt)
		select	@paymentID,InvoiceID, VaultID, m.Amt,   -XactAmt
		from	cteXact                                           x
		cross	apply dbo.Currency#Encode(PrevBalRaw, CurrencyID) m;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [acct].[@------------------@acct]...';


GO
CREATE PROCEDURE [acct].[@------------------@acct]
AS
BEGIN
SET NOCOUNT ON;
/*
	
*/
END
GO
PRINT N'Creating [acct].[Vault#Upsert]...';


GO
/*
@partyAmts = Many[Duad<PartyID, XactAmt>]
RESULT     = I64PairAmts {PartyID=LID, VaultID=RID, PrevBal=Amt}
*/
--PeterHo
CREATE PROCEDURE [acct].[Vault#Upsert](@partyAmts tvp, @vaultType E8)
WITH ENCRYPTION--
AS
BEGIN
	SET NOCOUNT ON;

	declare	@idAmts I64PairAmts;
	with cteNew as
	(
		select	PartyID=cast(v1 as bigint), VaultType=@vaultType
		,		XactAmt=cast(v2 as bigint), c.CurrencyID
		from	tvp.Duad#Slice(@partyAmts, default, default)
		cross	apply dbo.Currency#Decode(cast(v2 as bigint)) c
	)
	merge	acct._Vault as o using cteNew as n
	on		(o.PartyID=n.PartyID and o.VaultType=n.VaultType and o.CurrencyID=n.CurrencyID)
	when	matched     then update set VaultBal =(select Amt from dbo.Money#Sum(VaultBal, XactAmt))
			                        ,   TalliedOn=getutcdate()
	when	not matched then insert(  PartyID,  VaultBal,   VaultType,   CurrencyID, TalliedOn)
			                 values(n.PartyID, n.XactAmt, n.VaultType, n.CurrencyID, getutcdate())
	output	inserted.PartyID, inserted.ID, isnull(deleted.VaultBal, inserted.CurrencyID) into @idAmts;

	select	/*PartyID*/LID, /*VaultID*/RID, /*PrevBal*/Amt from @idAmts;
END
GO
PRINT N'Creating [acct].[Vault#Xact]...';


GO
--PeterHo
CREATE PROCEDURE [acct].[Vault#Xact]
(
	@paymentID I64, @invoiceID I64, @partyID I32, @vaultType E8, @xactAmt amt
)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@partyAmts tvp=(select Tvp from tvp.Duad#Make(@partyID, @xactAmt));
		declare	@idAmts  I64PairAmts; insert @idAmts 
		(		LID,     RID,     Amt    )
	--	select	PartyID, VaultID, PrevBal)
		execute	acct.Vault#Upsert @partyAmts=@partyAmts, @vaultType=@vaultType;

		insert	acct._VaultXact
		(		 PaymentID,  InvoiceID, VaultID, PrevBal,  XactAmt)
		select	@paymentID, @invoiceID, RID,     Amt,     @xactAmt
		from	@idAmts;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[@-------------------@api]...';


GO
CREATE PROCEDURE [api].[@-------------------@api]
AS
BEGIN
SET NOCOUNT ON;
/*



*/
END
GO
PRINT N'Creating [api].[PostCourier$Dequeue]...';


GO
-- AaronLiu, Smile
CREATE PROCEDURE [api].[PostCourier$Dequeue](@result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;

	select	@result=N'';
	/*
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@source E8=(select InfoPath		  from core.Source#ID())
		,		@qtype	E8=(select PostCourierApi from core.Queue#Type());
		execute	core.OutboundQ#Dequeue @source=@source, @qtype=@qtype, @result=@result out;

		with cte(text) as
		(
			select	[text()]=concat
			(	
				k.Mucho,  x.ID,
				k.Tuplet, x.SvcType,
				k.Tuplet, x.RefNbrs,
				k.Tuplet, x.CourierCode,
				k.Tuplet, isnull(a.RefNbr,N'')
			)
			from	tvp.Spr#Const() k, tvp.Quad#Slice(@result, default, default) q
			join	shpt.Parcel#Deep()                  x on x.ID=cast(q.v1 as bigint)
			left	join api.ActivitySubscription#Raw() a on x.ID=a.MatterID			
			for		xml path(N'')
		)
		select	@result=Tvp from cte cross apply tvp.Spr#Purify(text, default);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
	*/
END
GO
PRINT N'Creating [app].[@-------------------@app]...';


GO
CREATE PROCEDURE [app].[@-------------------@app]
AS
BEGIN
SET NOCOUNT ON;
/*

@slip    = at.Tvp.Block.Join(RefNbr, CneeInfo, DeclaredInfo[Triad.Join(SkuID, LineQty, LineTotal).Over(at.Tvp.Mucho)])
             .Over(at.Tvp.Entry)
@context = at.Quad.Join(Source, SvcType, errorCnt, errors)

CREATE PROCEDURE [app].[Parcel$Init](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
;



*/
END
GO
PRINT N'Creating [auto].[@-------------------@auto]...';


GO
CREATE PROCEDURE [auto].[@-------------------@auto]
AS
BEGIN
SET NOCOUNT ON;
/*

*/
END
GO
PRINT N'Creating [bo].[CurrencyRate$Maintain]...';


GO
/*
@slip    tvp =Quad[FmCurencyID, ToCurrencyID, ForPayment, ForDeclaration]
*/
--Smile
CREATE PROCEDURE [bo].[CurrencyRate$Maintain](@slip tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	with	cteCurrencyRate as
	(
		select  FmCurrencyID=v1, ToCurrencyID=v2
		,		ForPayment=v3,   ForDeclaration=v4
		from	tvp.Quad#Slice(@slip, default, default) 
	)
	insert	acct._CurrencyRate( FmCurrencyID, ToCurrencyID, ForPayment, ForDeclaration, EffectiveOn)
	select						FmCurrencyID, ToCurrencyID, ForPayment, ForDeclaration, getutcdate()
	from	cteCurrencyRate;
END
GO
PRINT N'Creating [bo].[@-------------------@bo]...';


GO
CREATE PROCEDURE [bo].[@-------------------@bo]
AS
BEGIN
SET NOCOUNT ON;
/*

*/
END
GO
PRINT N'Creating [bo].[Account$UpdateContract]...';


GO
/*

@slip =Dozen<Source, DutyTerms, NoDutyTerms, BillingCycle, 
			 EffectiveOn, ExpiredOn, BIZUnitID, Many[SvcType]>
@context=TenantID

*/
--Smile
CREATE PROCEDURE [bo].[Account$UpdateContract](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;

		declare	@source tinyint, @dutyTerms tinyint,  @nondutyTerms tinyint, @billingCycle tinyint,
				@effectiveOn dbo.DT, @expiredOn dbo.DT, 
				@bizUnitID I32, @svcTypes tvp;

		select	@source=v1, @dutyTerms=v2, @nondutyTerms=v3, @billingCycle=v4,
				@effectiveOn=v5, @expiredOn=v6,
				@bizUnitID=v7,   @svcTypes=v8
		from	tvp.Dozen#Of(@slip, default);

		declare	@contractID int, @obillingCycle tinyint;
		select  @contractID=ID,  @obillingCycle=BillingCycle
		from	acct.Contract#For(@context, @source);

		if((@billingCycle<>@obillingCycle) or nullif(@contractID, 0) is null)
		begin
		insert	into acct._Contract
				(TenantID, BizUnitID,  SourceID, BillingCycle,  DutyTerms,  NonDutyTerms,  EffectiveOn,  ExpiredOn)
		values	(@context, @bizUnitID, @source,  @billingCycle, @dutyTerms, @nondutyTerms, @effectiveOn, @expiredOn)
		;
		select	@contractID=scope_identity();
		end
		else
		begin
		update acct._Contract set BizUnitID=@bizUnitID,  BillingCycle=@billingCycle, 
								  DutyTerms=@dutyTerms,  NonDutyTerms=@nondutyTerms,
								  EffectiveOn=@effectiveOn,  ExpiredOn=@expiredOn
		where	ID=@contractID
		end

		delete	from tms._SvcContract where ContractID=@contractID;
		insert	tms._SvcContract(SvcType, ContractID)
		select	isnull(s.ID, k.Major), @contractID
		from	tvp.Many#Slice(@svcTypes)        x
		cross	apply tms.SvcType#Major(x.Piece) k
		outer	apply (
				 select top(1) t.ID
				 from	tms.SvcType#Raw()        t
				 where	t.TenantID=@context 
				 and	t.ID between k.Major and k.Upto

			  )                                  s;
		declare	@userID I32=(select	UserID from	loc.Tenancy#Of(@tenancy));
		insert	core._ChangeLog(RegID, RowID, ChangedBy, ChangedOn)
		select			  SvcContract, @contractID, @userID, getutcdate()
		from	core.Registry#ID();
	


		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [co].[@-------------------@co]...';


GO
CREATE PROCEDURE [co].[@-------------------@co]
AS
BEGIN
SET NOCOUNT ON;
/*

*/
END
GO
PRINT N'Creating [core].[RefParty#MergeVia]...';


GO
--AaronLiu
CREATE PROCEDURE [core].[RefParty#MergeVia](@idsInCsv tvp, @partyRole E8, @partyID E32)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with	cteSlip as
	(
		select	MatterID=cast(Piece as bigint )
		from	tvp.Comma#Slice(@idsInCsv)
	)
	merge	core._RefParty as o using cteSlip as n
	on		(o.MatterID=n.MatterID and o.PartyRole=@partyRole)
	when	matched		and @partyID=0          then delete
	when	matched		and o.PartyID<>@partyID then update set PartyID=@partyID
	when	not matched and @partyID>0			then insert	(  MatterID,  PartyRole,  PartyID)
													 values (n.MatterID, @partyRole, @partyID)
	;
END
GO
PRINT N'Creating [core].[@------------------@core]...';


GO
CREATE PROCEDURE [core].[@------------------@core]
AS
BEGIN
	SET NOCOUNT ON;
/*

@slip = at.Tvp.Field.Join(PID, AID, Alias, Contact)
CREATE PROCEDURE [core].[Party#Add](@id I64 out, @source E8, @type E8, @slip tvp)
;
@slip = at.Tvp.Field.Join(PID, AID, Alias, Contact, UtcPlace, UtcOffset)
CREATE PROCEDURE [core].[Tenant#Add](@id I64 out, @source E8, @type E8, @slip tvp)
;
@slip = at.Tvp.Field.Join(PID, AID, Alias, Contact, UserRoles:Comma[RoleID])
CREATE PROCEDURE [core].[User#Add](@id I64 out, @source E8, @type E8, @slip tvp)

*/
END
GO
PRINT N'Creating [core].[Activity#AddByIdSeqs]...';


GO
--PeterHo
CREATE PROCEDURE [core].[Activity#AddByIdSeqs](@idSeqs I64Seqs readonly, @stateID I32, @userID I32)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._Activity
	(		MatterID,  StateID, ActionID,  UserID, TalliedOn)
	select	x.ID,     @stateID, 0,        @userID, getutcdate()
	from	@idSeqs x;
END
GO
PRINT N'Creating [core].[Activity#AddBySpec]...';


GO
--PeterHo
CREATE PROCEDURE [core].[Activity#AddBySpec](@spec core.TransitionSpec readonly, @userID I32)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._Activity
	(		MatterID,   StateID, ActionID,  UserID,  TalliedOn)
	select	MatterID, ToStateID, ActionID, @userID, getutcdate() from @spec;
END
GO
PRINT N'Creating [core].[Concern#Add]...';


GO
/*
@concerns = Comma[ConcernType]
*/
--PeterHo
CREATE PROCEDURE [core].[Concern#Add](@matterID bigint, @concerns tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteConcern as
	(
		select	MatterID=@matterID, Type=cast(c.Piece as tinyint)
		from	tvp.Comma#Slice(@concerns) c
	)
	insert	core._Concern
	select	x.MatterID, x.Type
	from	cteConcern  x left join core._Concern c
	on		c.MatterID= x.MatterID and c.Type=x.Type
	where	c.MatterID is null
END
GO
PRINT N'Creating [core].[Concern#AddVia]...';


GO
/*
@slip = Many[Duad<MatterID, Comma[ConcernType]>]
*/
--PeterHo
CREATE PROCEDURE [core].[Concern#AddVia](@slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteConcern as
	(
		select	MatterID=cast(x.v1 as bigint), Type=cast(c.Piece as tinyint)
		from	tvp.Duad#Slice(@slip, default, default) x
		cross	apply tvp.Comma#Slice(x.v2) c
	)
	insert	core._Concern
	select	x.MatterID, x.Type
	from	cteConcern  x left join core._Concern c
	on		c.MatterID= x.MatterID and c.Type=x.Type	
	where	c.MatterID is null
END
GO
PRINT N'Creating [core].[Concern#Remove]...';


GO
/*
@concerns = Comma[ConcernType]
*/
--Smile
CREATE PROCEDURE [core].[Concern#Remove](@matterID bigint, @concerns tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteConcern as
	(
		select	MatterID, Type
		from	tvp.Comma#Slice(@concerns) c
		join	core.Concern#Raw()         x
		on		x.MatterID=@matterID and x.Type=cast(c.Piece as tinyint)
	)
	delete	from cteConcern;
END
GO
PRINT N'Creating [core].[Contact#Add]...';


GO
--PeterHo
CREATE PROCEDURE [core].[Contact#Add](@id I32 out, @partyID I32, @type E8, @contact tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._Contact
	(		 PartyID,  Type, Name, Phone, Email, Company, Street1, Street2, Street3, City, District, Province, PostalCode, CountryCode)
	select	@partyID, @type, Name, Phone, Email, Company, Street1, Street2, Street3, City, District, Province, PostalCode, CountryCode
	from	loc.Contact#Of(@contact);
END
GO
PRINT N'Creating [core].[Contact#AddVia]...';


GO
--Smile
CREATE PROCEDURE [core].[Contact#AddVia](@partyID I32, @contact tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._Contact
	(		 PartyID,  Type, Name, Phone, Email, Company, Street1, Street2, Street3, City, District, Province, PostalCode, CountryCode)
	select	@partyID, x.v1, Name, Phone, Email, Company, Street1, Street2, Street3, City, District, Province, PostalCode, CountryCode
	from	tvp.Duad#Slice(@contact, default, default) x
	cross	apply loc.Contact#Of(x.v2);
END
GO
PRINT N'Creating [core].[Message#Invoke]...';


GO
--PeterHo
CREATE PROCEDURE [core].[Message#Invoke](@regID I32, @rowAuxes I64Enums readonly, @body msg, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	declare	@posterID I32=(select UserID from loc.Tenancy#Of(@tenancy));
	insert	core._Message
	(		 RegID, RowID, AuxID,  PosterID,  Body)
	select	@regID,    ID,   Val, @posterID, @body from @rowAuxes
END
GO
PRINT N'Creating [core].[OutboundQ#Dequeue]...';


GO
/*
@source = Source of Application.
@qtype  = 0 means all items, otherwise specified that belong to @source.
@result = Many[Quad<MatterID, StateID, QueueType, QueuedOn>]
*/
--PeterHo
CREATE PROCEDURE [core].[OutboundQ#Dequeue](@source E8, @qtype E8=0, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		declare	@q as table
		(
			QueueType dbo.E8  not null,
			QueuedOn  dbo.DT  not null,
			MatterID  dbo.I64 not null,
			StateID   dbo.I32 not null
		)
		delete	top(1000) core._OutboundQ
		output	deleted.QueueType, deleted.QueuedOn, deleted.MatterID, deleted.StateID into @q
		where	ToSource=@source and (nullif(0, @qtype) is null or QueueType=@qtype);

		insert	core._OutboundX
		(		ToSource, QueueType, QueuedOn, MatterID, StateID)
		select	 @source, QueueType, QueuedOn, MatterID, StateID from @q;

		with cte(text) as
		(
			select	[text()]=concat(k.Many, MatterID, k.Quad, StateID, k.Quad, QueueType, k.Quad, QueuedOn)
			from	tvp.Spr#Const()k, @q for xml path(N'')
		)
		select	@result=Tvp from cte cross apply tvp.Spr#Purify(text, default);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [core].[OutboundQ#Enqueue]...';


GO
--PeterHo
CREATE PROCEDURE [core].[OutboundQ#Enqueue](@source E8, @qtype E8=0, @matterID I64, @stateID I32)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	declare	@src E8=(select Source from core.Source#Rectify(@source, @qtype));
	insert	core._OutboundQ
			(ToSource, QueueType,  MatterID,  StateID)
	values	(@src,     @qtype,    @matterID, @stateID)  
END
GO
PRINT N'Creating [core].[OutboundQ#EnqueueBySpec]...';


GO
--PeterHo:
CREATE PROCEDURE [core].[OutboundQ#EnqueueBySpec](@spec core.TransitionSpec readonly)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	with cteSpec as
	(
		select	Source,   QueueType=try_cast(c.Piece as tinyint)
		,		MatterID, ToStateID
		from	@spec cross apply tvp.Comma#Slice(OutboundQ) c
	)
	insert	core._OutboundQ
	(		ToSource, QueueType, MatterID,   StateID)
	select	q.Source, QueueType, MatterID, ToStateID
	from	cteSpec cross apply core.Source#Rectify(Source, QueueType) q
	where	QueueType>0

/*	2017/11/11 by Peter.
	insert	core._OutboundQ
	(		ToSource, QueueType, MatterID,   StateID)
	select	q.Source, OutboundQ, MatterID, ToStateID
	from	@spec cross apply core.Source#Rectify(Source, OutboundQ) q
	where	OutboundQ>0;
*/
END
GO
PRINT N'Creating [core].[Party#Add]...';


GO
/*
@slip = at.Tvp.Field.Join(PID, AID, Alias, Contact)
*/
--PeterHo
CREATE PROCEDURE [core].[Party#Add](@id I32 out, @source E8, @type E8, @slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		select	@id=next value for core.PartySeq;

		declare	@pid I32, @aid I32, @alias loc.Alias, @contact tvp;
		select	@pid=v1,  @aid=v2,  @alias=v3,        @contact=v4
		from	tvp.Field#Of(@slip, default);

		declare	@tobePID I32=iif(@pid is null or @pid<0, 0,   @pid);
		declare	@tobeAID I32=iif(@aid is null or @aid<1, @id, @aid);
		insert	core._Party
				( ID,  PID,      AID,      Type,  Source,  Alias)
		values	(@id, @tobePID, @tobeAID, @type, @source, @alias);

		--declare	@contactID I32, @kind E8=(select Billing from Contact#Type());
		--execute	core.Contact#Add @id=@contactID out, @partyID=@id, @type=@kind, @contact=@contact;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [core].[RefInfo#AddBlock]...';


GO
--PeterHo
CREATE PROCEDURE [core].[RefInfo#AddBlock](@index int, @idSeqs I64Seqs readonly, @slip nvarchar(max), @type tinyint)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._RefInfo
	(		MatterID, Type, Info)
	select	Master,  @type, House
	from	tvp.Block#FoldT(@index, @idSeqs, @slip, default, default)
	where	House>N''
/*
	insert	core._RefInfo
	(		MatterID, Type,  Info)
	select	x.Master, @type, h.Piece
	from	tvp.Block#FoldT(@index, @idSeqs, @slip, default, default) x
	cross	apply tvp.Many#Slice(x.House) h
	where	h.Piece>N''
*/
END
GO
PRINT N'Creating [core].[RefInfo#AddContact]...';


GO
--PeterHo
CREATE PROCEDURE [core].[RefInfo#AddContact](@idSeqs I64Seqs readonly, @partyID I32, @type tinyint)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	declare	@shprInfo tvp=(select Tvp from core.Contact#TvpForRefInfo(@partyID, @type));
	insert	core._RefInfo
	(		MatterID, Type,  Info)
	select	ID,       @type, isnull(@shprInfo, N'???')
	from	@idSeqs
END
GO
PRINT N'Creating [core].[RefInfo#AddViaCells]...';


GO
--PeterHo
CREATE PROCEDURE [core].[RefInfo#AddViaCells](@column int, @cells dbo.Cells readonly, @type tinyint)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._RefInfo
	(		MatterID, Type, Info)
	select	Row,     @type, Val
	from	@cells
	where	Col=@column and Val>N''
/*
	insert	core._RefInfo
	(		MatterID, Type,  Info)
	select	x.Master, @type, h.Piece
	from	tvp.Block#FoldT(@index, @idSeqs, @slip, default, default) x
	cross	apply tvp.Many#Slice(x.House) h
	where	h.Piece>N''
*/
END
GO
PRINT N'Creating [core].[RefInfo#Merge]...';


GO
--PeterHo
CREATE PROCEDURE [core].[RefInfo#Merge](@slip nvarchar(max))
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteSlip as
	(
		select	MatterID=cast(v1 as bigint), Type=cast(v2 as tinyint), Info=v3
		from	tvp.Triad#Slice(@slip, default, default)
	)
	merge	core._RefInfo as o using cteSlip as n
	on		(o.MatterID=n.MatterID and o.Type=n.Type)
	when	matched and len(n.Info)=0     then delete
	when	matched and o.Info<>n.Info    then update set Info=n.Info
	when	not matched and len(n.Info)>0 then insert (  MatterID,   Type,   Info)
			                                   values (n.MatterID, n.Type, n.Info)
	;
END
GO
PRINT N'Creating [core].[RefNbr#AddBlock]...';


GO
--PeterHo
CREATE PROCEDURE [core].[RefNbr#AddBlock](@index int, @idSeqs I64Seqs readonly, @slip nvarchar(max), @type tinyint)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._RefNbr
	(		MatterID, Type, Number)
	select	Master,  @type, House
	from	tvp.Block#FoldT(@index, @idSeqs, @slip, default, default)
	where	House>N''
/*
	insert	core._RefNbr
	(		MatterID,  Type, Number)
	select	x.Master, @type, h.Piece
	from	tvp.Block#FoldT(@index, @idSeqs, @slip, default, default) x
	cross	apply tvp.Many#Slice(x.House) h
	where	h.Piece>N''
*/
END
GO
PRINT N'Creating [core].[RefNbr#AddMIC]...';


GO
--PeterHo
CREATE PROCEDURE [core].[RefNbr#AddMIC](@idSeqs I64Seqs readonly, @source E8, @type E8)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	declare	@now DT=getutcdate();

	insert	core._RefNbr
	(		MatterID, Type,  Number)
	select	x.ID,     k.MIT, m.MIC
	from	core.RefNbr#Type() k, @idSeqs x
	cross	apply core.MIC#Emit(x.ID, @source, @type, @now) m
END
GO
PRINT N'Creating [core].[RefNbr#AddViaCells]...';


GO
--PeterHo
CREATE PROCEDURE [core].[RefNbr#AddViaCells](@column int, @cells dbo.Cells readonly, @type tinyint)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._RefNbr
	(		MatterID,  Type, Number)
	select	Row,      @type, Val
	from	@cells
	where	Col=@column and Val>N''
END
GO
PRINT N'Creating [core].[RefNbr#Merge]...';


GO
/*
@slip = Many[Triad<MatterID, Type, Number>]
*/
--PeterHo
CREATE PROCEDURE [core].[RefNbr#Merge](@slip nvarchar(max))
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteSlip as
	(
		select	MatterID=cast(v1 as bigint), Type=cast(v2 as tinyint), n.Number
		from	tvp.Triad#Slice(@slip, default, default) x
		cross	apply loc.RefNbr#Cast(x.v3) n
	)
	merge	core._RefNbr as o using cteSlip as n
	on		(o.MatterID=n.MatterID and o.Type=n.Type)
	when	matched and len(n.Number)=0     then delete
	when	matched and o.Number<>n.Number  then update set Number=n.Number
	when	not matched and len(n.Number)>0 then insert (  MatterID,   Type,   Number)
			                                     values (n.MatterID, n.Type, n.Number)
	;
END
GO
PRINT N'Creating [core].[RefParty#Merge]...';


GO
--PeterHo
CREATE PROCEDURE [core].[RefParty#Merge](@slip nvarchar(max))
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteSlip as
	(
		select	MatterID =cast(v1 as bigint )
		,		PartyRole=cast(v2 as tinyint)
		,		PartyID  =cast(v3 as int    )
		from	tvp.Triad#Slice(@slip, default, default)
	)
	merge	core._RefParty as o using cteSlip as n
	on		(o.MatterID=n.MatterID and o.PartyRole=n.PartyRole)
	when	matched and n.PartyID=0          then delete
	when	matched and o.PartyID<>n.PartyID then update set PartyID=n.PartyID
	when	not matched and n.PartyID>0      then insert (  MatterID,   PartyRole,   PartyID)
			                                      values (n.MatterID, n.PartyRole, n.PartyID)
	;
END
GO
PRINT N'Creating [core].[RefStamp#Merge]...';


GO
--PeterHo
CREATE PROCEDURE [core].[RefStamp#Merge](@slip nvarchar(max))
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteSlip as
	(
		select	MatterID  =cast(x.v1 as bigint)
		,		StateID   =cast(x.v2 as int   )
		,		UtcTime   =cast(isnull(nullif(t.v1, ''), '0001') as datetime2(2))
		,		UtcOffset =cast(t.v2 as smallint)
		,		UtcPlaceID=cast(t.v3 as int)
		from	tvp.Triad#Slice(@slip, default, default) x
		cross	apply tvp.Trio#Of(x.v3) t
	)
	merge	core._RefStamp as o using cteSlip as n
	on		(o.MatterID=n.MatterID and o.StateID=n.StateID)
	when	matched and n.UtcTime=cast('0001' as datetime2(2)) then
				delete
	when	matched and o.UtcTime<>n.UtcTime then
				update  set o.UtcTime=n.UtcTime, o.UtcOffset=n.UtcOffset, o.UtcPlaceID=n.UtcPlaceID
	when	not matched and n.UtcTime<>cast('0001' as datetime2(2)) then
				insert (  MatterID,   StateID,   UtcTime,   UtcOffset,   UtcPlaceID)
				values (n.MatterID, n.StateID, n.UtcTime, n.UtcOffset, n.UtcPlaceID);
END
GO
PRINT N'Creating [core].[RefStamp#MergeBySpec]...';


GO
--PeterHo
CREATE PROCEDURE [core].[RefStamp#MergeBySpec](@spec core.TransitionSpec readonly, @utcStamp tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	declare	@slip tvp;
	with cte(text) as
	(
		select	[text()]=concat(k.Many, MatterID, k.Triad, ToStateID, k.Triad, @utcStamp)
		from	@spec cross apply tvp.Spr#Const() k for xml path(N'')
	)
	select	@slip=Tvp from cte cross apply tvp.Spr#Purify(text, default);
	execute core.RefStamp#Merge @slip=@slip;
END
GO
PRINT N'Creating [core].[Supplement#Merge]...';


GO
--PeterHo
CREATE PROCEDURE [core].[Supplement#Merge](@regID I32, @rowID I64, @supplement nvarchar(max))
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteNew as
	(
		select	RegID=@regID, RowID=@rowID, Supplement=isnull(@supplement, N'')
	)
	merge	core._Supplement as o using cteNew as n
	on		(n.RegID=o.RegID and n.RowID=o.RowID)
	when	matched and len(n.Supplement)=0        then delete
	when	matched and o.Supplement<>n.Supplement then update set Supplement=n.Supplement
	when	not matched and len(n.Supplement)>0    then insert (RegID,     RowID,   Supplement)
			                                            values (n.RegID, n.RowID, n.Supplement)
	;
END
GO
PRINT N'Creating [core].[Supplement#MergeVia]...';


GO
--Smile
CREATE PROCEDURE [core].[Supplement#MergeVia](@supplements tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteNew as
	(
		select	RegID=cast(v1 as int), RowID=cast(v2 as bigint), Supplement=v3
		from	tvp.Triad#Slice(@supplements, default, default)
	)
	merge	core._Supplement as o using cteNew as n
	on		(n.RegID=o.RegID and n.RowID=o.RowID)
	when	matched and len(n.Supplement)=0        then delete
	when	matched and o.Supplement<>n.Supplement then update set Supplement=n.Supplement
	when	not matched and len(n.Supplement)>0    then insert (RegID,     RowID,   Supplement)
			                                            values (n.RegID, n.RowID, n.Supplement)
	;
END
GO
PRINT N'Creating [core].[Tenant#Add]...';


GO
/*
@slip = at.Tvp.Field.Join(PID, AID, Alias, Contact, UtcPlace, UtcOffset)
*/
--PeterHo
CREATE PROCEDURE [core].[Tenant#Add](@id I32 out, @source E8, @type E8, @slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		exec	core.Party#Add @id=@id out, @source=@source, @type=@type, @slip=@slip;

		insert	core._Tenant
		(		ID,   Source, Alias, UtcPlace, UtcOffset)
		select	@id, @source, x.v3,  x.v5,     x.v6
		from	tvp.Field#Of(@slip, default) x

		declare	@contact tvp=(select v4 from tvp.Field#Of(@slip, default)); 
		execute	core.Contact#AddVia @partyID=@id, @contact=@contact;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [core].[User#Add]...';


GO
/*
@slip = at.Tvp.Field.Join(PID, AID, Alias, Contact, UserRoles)
*/
--PeterHo
CREATE PROCEDURE [core].[User#Add](@id I32 out, @source E8, @type E8, @slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		execute	core.Party#Add @id=@id out, @source=@source, @type=@type, @slip=@slip;

		declare	@roles tvp, @alias loc.Alias, @contact tvp;
		select	@roles=v5,  @alias=v3, @contact=v4
		from	tvp.Field#Of(@slip, default);

		insert	core._User (ID, Alias) values (@id, @alias);

		insert	core._UserRole
		(		UserID, RoleID)
		select	@id,    cast(r.Piece as int)
		from	tvp.Comma#Slice(@roles) r;

		execute	core.Contact#AddVia @partyID=@id, @contact=@contact;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [hub].[@-----@hub]...';


GO
CREATE PROCEDURE [hub].[@-----@hub]
AS
BEGIN
SET NOCOUNT ON;
/*

*/
END
GO
PRINT N'Creating [hub].[Parcel$TryRack]...';


GO
/*
	@number = Barcode
	!!! Temperory function, need complete
*/
-- Eason
CREATE PROCEDURE [hub].[Parcel$TryRack](@number tvp)

-- WITH ENCRYPTION
AS BEGIN
	select	isnull(
			(select	case (select cast(Number as bigint) % 2)
					when 1 then  cast(1 as bit)
					else         cast(0 as bit) end
			from	svc.Parcel$ScanOne(@number))
	,		0)  as result
END
GO
PRINT N'Creating [ic].[@-------------------@ic]...';


GO
CREATE PROCEDURE [ic].[@-------------------@ic]
AS
BEGIN
SET NOCOUNT ON;

END
GO
PRINT N'Creating [ic].[Parcel$MergeStamp]...';


GO
/*
@slip=Many[Triad<ParcelID, StateID, Trio<UtcTime, UtcOffset, UtcPlaceID>>]
*/
--Smile
CREATE PROCEDURE [ic].[Parcel$MergeStamp](@slip tvp)
WITH ENCRYPTION
AS
BEGIN	
	SET	NOCOUNT ON;

	execute core.RefStamp#Merge @slip=@slip;	

END
GO
PRINT N'Creating [ic].[Handler$Assigned]...';


GO
/*
@slip  =Comma[ParcelID]  
@context= UserID
*/
--Smile
CREATE PROCEDURE [ic].[Handler$Assigned](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;

		declare	@userID I32; select @userID=UserID from	loc.Tenancy#Of(@tenancy);
		with cteMatter as
		(
			select	m.ID, HandlerID
			from	tvp.I64#Slice(@slip) x
			join	core.Matter#Raw()    m on m.ID=x.ID
			where	HandlerID IN (0, @userID)
		)
		update	cteMatter set HandlerID=@context;
		
END
GO
PRINT N'Creating [ic].[Concern$Post]...';


GO
/*
@slip=Duad<Comma[AddedConcernType], Comma[DeletedConcernType]>
@context=MatterID
*/
--Smile
CREATE PROCEDURE [ic].[Concern$Post](@slip tvp, @context tvp)
WITH ENCRYPTION
AS
BEGIN	
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

	declare	@addedConcerns tvp, @deletedConcerns tvp, @matterID bigint;
	select	@addedConcerns=v1,  @deletedConcerns=v2,  @matterID=@context
	from	tvp.Duad#Of(@slip, default);

	execute	core.Concern#Add	@matterID=@matterID, @concerns=@addedConcerns;
	execute	core.Concern#Remove @matterID=@matterID, @concerns=@deletedConcerns;

	update	core._Matter set HandlerID=0 where ID=@matterID;

COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [invt].[SkuInfo#AddBlock]...';


GO
--PeterHo
CREATE PROCEDURE [invt].[SkuInfo#AddBlock]
(
	@index int, @idSeqs I64Seqs readonly, @slip nvarchar(max), @routeID int
)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._RefInfo
	(		MatterID,   Type,   Info)
	select	x.Master, i.Type, i.Info
	from	tvp.Block#FoldT(@index, @idSeqs, @slip, default, default) x
	cross	apply
	(
		select	Type=k.DeclaredInfo,  s.Info
		from	core.RefInfo#Type()   k, invt.SkuInfo#ToDeclared(x.House) s
		UNION	ALL
		select	Type=k.BrokerageInfo, b.Info
		from	core.RefInfo#Type()   k, tms.Route#Raw() r
		cross	apply invt.SkuInfo#ToBrokerage(x.House, r.BrokerID, r.ClrMethodID) b
		where	r.ID=@routeID
	) i;
END
GO
PRINT N'Creating [shpt].[Parcel#TalliedOrDeduct]...';


GO
--Smile, PeterHo
CREATE PROCEDURE [shpt].[Parcel#TalliedOrDeduct](@parcelIDs dbo.I64Array readonly)
--WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
					
		-- 1	Insert  Invoice(s):
		declare	@ledgerSide E8=(select AR from acct.Ledger#Side());
		declare	@invoiceds I64Array; 
		declare	@vaultType  E8=(select Fund from acct.Vault#Type());
		with cteInvoice as
		(
			select	LedgerPartyID, x.CurrencyID, c.VaultTag, x.ContractID, ChargeRawAmt=sum(m.RawAmt)
			from	shpt.Parcel#FreightAndDutyFor(@parcelIDs) x
			join	acct.Charge#Raw() c on c.ID=x.ChargeID
			cross	apply dbo.Money#Of(x.ChargeAmt) m
			where	not exists(
			select	ID from acct.Contract#Raw() t 
			where	t.ID=x.ContractID and t.BillingCycle>0) 
			group	by LedgerPartyID, x.CurrencyID, c.VaultTag, x.ContractID
		)	
		insert	acct._Invoice
		(		PartyID,       VaultTag, LedgerSide, CurrencyID, DueBalance, InvoiceAmt, ContractID)
		output	inserted.ID into @invoiceds
		select	LedgerPartyID, VaultTag, @ledgerSide, x.CurrencyID, 0,         m.Amt,    ContractID
		from	cteInvoice x
		cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
		where	x.ChargeRawAmt>0;

		declare	@ledgerIDs I64Array;
		with	cteInvoiced as
		(
			select	x.ID, PartyID, CurrencyID, VaultTag, ContractID
			from	@invoiceds x
			join	acct.Invoice#Raw() i on x.ID=i.ID
		)
		-- 2	Insert  Ledger(s):
		insert	acct._Ledger
		(		PartyID,       MatterID,   ChargeID, ChargeAmt,   CurrencyID,   LedgerSide, InvoiceID)
		output	inserted.ID into @ledgerIDs
		select	LedgerPartyID, MatterID, p.ChargeID, ChargeAmt, p.CurrencyID,  @ledgerSide, iif(ChargeAmt=p.CurrencyID, -1, isnull(i.ID, 0))
		from	shpt.Parcel#FreightAndDutyFor(@parcelIDs) p
		join	acct.Charge#Raw()  c  on c.ID=p.ChargeID
		left	join cteInvoiced   i  on i.PartyID=p.LedgerPartyID 
										 and i.VaultTag=c.VaultTag
										 and i.CurrencyID=p.CurrencyID
										 and i.ContractID=p.ContractID;
		with cteUnInvoiceds as
		(
			select	PartyID, x.CurrencyID, ChargeRawAmt=sum(x.ChargeRaw)
			from	@ledgerIDs l
			join	acct.Ledger#Raw() x on x.ID=l.ID
			where	InvoiceID=0
			group	by PartyID, x.CurrencyID
		), cteVaults as
		(
			select	PartyID, CurrencyID, ChargeAmt=m.Amt
			from	cteUnInvoiceds x
			cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
		)
		merge	acct._Vault as o using cteVaults as n
		on		(o.PartyID=n.PartyID and o.VaultType=@vaultType and o.CurrencyID=n.CurrencyID)
		when	matched then
				update set UninvoicedAmt=(select Amt from dbo.Money#Sum(n.ChargeAmt, o.UninvoicedAmt)), TalliedOn=getutcdate()
		when	not matched then
				insert(  PartyID,   VaultBal,    VaultType,   CurrencyID,   UninvoicedAmt)
				values(n.PartyID, n.CurrencyID, @vaultType, n.CurrencyID, n.ChargeAmt)
		;
		execute acct.Vault#XactByInvoice @invoiceds=@invoiceds, @paymentID=default, @vaultType=@vaultType;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [shpt].[PreCourier#Concern]...';


GO
/*
	@slip = Comma<PreCourierNbr>
*/
-- AaronLiu
CREATE PROCEDURE [shpt].[PreCourier#Concern](@slip tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@minStage E32,    @maxStage E32;
		select	@minStage=PreMin, @maxStage=CurMax
		from	core.Stage#Boundary();

		declare	@concernType E8=(select PreCouierDuplicate from core.Concern#Type())
		;
		with	cte as
		(
			select	Seq, Number=Piece
			from	tvp.Comma#Slice(@slip)
			where	Piece>N''
		),	cteMatched as
		(
			select	distinct n.MatterID
			,		MatchedCnt=count(1) over(partition by Seq)
			from	core.RefNbr#Type() t, core.Matter#Type() e, cte x
			join	core.RefNbr#Raw()  n on x.Number=n.Number 
			join	core.Matter#Raw()  m on n.MatterID=m.ID
			where	n.Type=t.PreCourier and m.Type<>e.OrphanParcel 
			and		m.Stage between @minStage and @maxStage
		), cteSlip(text) as
		(
			select	[text()]=concat(k.Many, x.MatterID, k.Duad, @concernType)
			from	cteMatched x, tvp.Spr#Const() k
			where	MatchedCnt>1
			for		xml path(N'')
		)
		select	@slip=Tvp from cteSlip cross apply tvp.Spr#Purify(text, default);
		execute	core.Concern#AddVia @slip=@slip;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [shpt].[Orphan#Init]...';


GO
-- AaronLiu
CREATE PROCEDURE [shpt].[Orphan#Init](@numbersInCsv tvp, @tenancy tvp, @matterID I64 out, @number tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32,	@siteID I32;
		select	@userID=UserID, @roleID=RoleID, @siteID=SiteID
		from	loc.Tenancy#Of(@tenancy);

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(1);

		declare	@stateID  I32=(select OrphanCreated from core.State#ID());
		declare	@source	  E8=(select InfoPath	   from core.Source#ID())
		,		@stage	  E32=(select Stage		   from core.Stage#Of(@stateID))
		,		@type	  E8=(select OrphanParcel  from core.Matter#Type());
		insert	core._Matter
		(		ID, PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID, @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 2.	Add RefNbrs
		declare	@preCourierNbr loc.RefNbr
		,		@preCourier	   E8=(select PreCourier from core.RefNbr#Type());
		with	cte as
		(
			select	top 1 Number
			from	loc.RefNbr#Slice(@numbersInCsv)
			order	by len(Number) desc
		)
		select	@preCourierNbr=Number from cte

		execute	core.RefNbr#AddMIC			   @idSeqs=@idSeqs, @source=@source,	  @type=@type;
		execute	core.RefNbr#AddBlock @index=1, @idSeqs=@idSeqs, @slip=@preCourierNbr, @type=@preCourier;

		-- 3.	Add Batch & Parcels:
		insert	shpt._Parcel
		(		ID, BatchID, RouteID, LastMilerID, SvcType, SvcZone, SvcClass, POA, ContractID)
		select	ID, 0,		 0,		  0,		   0,		1,		 1,		   N'', 0
		from	@idSeqs;

		-- 4.	Result:
		select	@number=@preCourierNbr;
		select	@matterID=(select ID from @idSeqs);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [shpt].[Parcel#BillForVmi]...';


GO
--Smile
CREATE PROCEDURE [shpt].[Parcel#BillForVmi](@parcelIDs dbo.I64Array readonly)
--WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
					
		-- 1	Insert  Invoice(s):
		declare	@ledgerSide E8=(select AR from acct.Ledger#Side());
		declare	@invoiceds I64Array; 
		declare	@vaultType  E8=(select Fund from acct.Vault#Type());
		with cteInvoice as
		(
			select	LedgerPartyID, x.CurrencyID, c.VaultTag, x.ContractID, ChargeRawAmt=sum(m.RawAmt)
			from	shpt.Parcel#LedgerForVmi(@parcelIDs) x
			join	acct.Charge#Raw() c on c.ID=x.ChargeID
			cross	apply dbo.Money#Of(x.ChargeAmt) m
			where	not exists(
			select	ID from acct.Contract#Raw() t 
			where	t.ID=x.ContractID and t.BillingCycle>0) 
			group	by LedgerPartyID, x.CurrencyID, c.VaultTag, x.ContractID
		)	
		insert	acct._Invoice
		(		PartyID,       VaultTag, LedgerSide, CurrencyID, DueBalance, InvoiceAmt, ContractID)
		output	inserted.ID into @invoiceds
		select	LedgerPartyID, VaultTag, @ledgerSide, x.CurrencyID, x.CurrencyID, m.Amt,    ContractID
		from	cteInvoice x
		cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
		where	x.ChargeRawAmt>0;

		declare	@ledgerIDs I64Array;
		with	cteInvoiced as
		(
			select	x.ID, PartyID, CurrencyID, VaultTag, ContractID
			from	@invoiceds x
			join	acct.Invoice#Raw() i on x.ID=i.ID
		)
		-- 2	Insert  Ledger(s):
		insert	acct._Ledger
		(		PartyID,       MatterID,   ChargeID, ChargeAmt,   CurrencyID,   LedgerSide, InvoiceID)
		output	inserted.ID into @ledgerIDs
		select	LedgerPartyID, MatterID, p.ChargeID, ChargeAmt, p.CurrencyID,  @ledgerSide, iif(ChargeAmt=p.CurrencyID, -1, isnull(i.ID, 0))
		from	shpt.Parcel#LedgerForVmi(@parcelIDs) p
		join	acct.Charge#Raw()  c  on c.ID=p.ChargeID
		left	join cteInvoiced   i  on i.PartyID=p.LedgerPartyID 
										 and i.VaultTag=c.VaultTag
										 and i.CurrencyID=p.CurrencyID
										 and i.ContractID=p.ContractID;
		with cteUnInvoiceds as
		(
			select	PartyID, x.CurrencyID, ChargeRawAmt=sum(x.ChargeRaw)
			from	@ledgerIDs l
			join	acct.Ledger#Raw() x on x.ID=l.ID
			where	InvoiceID=0
			group	by PartyID, x.CurrencyID
		), cteVaults as
		(
			select	PartyID, CurrencyID, ChargeAmt=m.Amt
			from	cteUnInvoiceds x
			cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
		)
		merge	acct._Vault as o using cteVaults as n
		on		(o.PartyID=n.PartyID and o.VaultType=@vaultType and o.CurrencyID=n.CurrencyID)
		when	matched then
				update set UninvoicedAmt=(select Amt from dbo.Money#Sum(n.ChargeAmt, o.UninvoicedAmt)), TalliedOn=getutcdate()
		when	not matched then
				insert(  PartyID,   VaultBal,    VaultType,   CurrencyID,   UninvoicedAmt)
				values(n.PartyID, n.CurrencyID, @vaultType, n.CurrencyID, n.ChargeAmt)
		;
		execute acct.Vault#XactByInvoice @invoiceds=@invoiceds, @paymentID=default, @vaultType=@vaultType;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [shpt].[Parcel#BillForFactor]...';


GO
--Daxia
CREATE PROCEDURE [shpt].[Parcel#BillForFactor](@parcelIDs dbo.I64Array readonly)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
					
		-- 1	Insert  Invoice(s):
		declare	@ledgerSide E8=(select AR from acct.Ledger#Side());
		declare	@invoiceds I64Array; 
		declare	@vaultType  E8=(select Fund from acct.Vault#Type());
		with cteInvoice as
		(
			select	LedgerPartyID, x.CurrencyID, c.VaultTag, x.ContractID, ChargeRawAmt=x.InvDueAmt
			from	shpt.Parcel#LedgerByFactor(@parcelIDs) x
			join	acct.Charge#Raw() c on c.ID=x.ChargeID
			where	not exists
			(
				select	ID from acct.Contract#Raw() t 
				where	t.ID=x.ContractID and t.BillingCycle>0
			) 
			group	by LedgerPartyID, x.CurrencyID, c.VaultTag, x.ContractID
		)	
		insert	acct._Invoice
		(		PartyID,       VaultTag,  LedgerSide,   CurrencyID, DueBalance, InvoiceAmt, ContractID)
		output	inserted.ID into @invoiceds
		select	LedgerPartyID, VaultTag, @ledgerSide, x.CurrencyID, 0,               m.Amt, ContractID
		from	cteInvoice x
		cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
		where	x.ChargeRawAmt>0;
		
		declare	@ledgerIDs I64Array;
		with	cteInvoiced as
		(
			select	x.ID, PartyID, CurrencyID, VaultTag, ContractID
			from	@invoiceds x
			join	acct.Invoice#Raw() i on x.ID=i.ID
		)
		-- 2	Insert  Ledger(s):
		insert	acct._Ledger
		(		PartyID,       MatterID,   ChargeID, ChargeAmt,   CurrencyID,   LedgerSide, InvoiceID)
		output	inserted.ID into @ledgerIDs
		select	LedgerPartyID, MatterID, p.ChargeID, ChargeAmt, p.CurrencyID,  @ledgerSide, iif(ChargeAmt=p.CurrencyID, -1, isnull(i.ID, 0))
		from	shpt.Parcel#LedgerByFactor(@parcelIDs) p
		join	acct.Charge#Raw()  c  on c.ID=p.ChargeID
		left	join cteInvoiced   i  on i.PartyID=p.LedgerPartyID 
										 and i.VaultTag=c.VaultTag
										 and i.CurrencyID=p.CurrencyID
										 and i.ContractID=p.ContractID;
		with cteUnInvoiceds as
		(
			select	PartyID, x.CurrencyID, ChargeRawAmt=sum(x.ChargeRaw)
			from	@ledgerIDs l
			join	acct.Ledger#Raw() x on x.ID=l.ID
			where	InvoiceID=0
			group	by PartyID, x.CurrencyID
		), cteVaults as
		(
			select	PartyID, CurrencyID, ChargeAmt=m.Amt
			from	cteUnInvoiceds x
			cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
		)
		merge	acct._Vault as o using cteVaults as n
		on		(o.PartyID=n.PartyID and o.VaultType=@vaultType and o.CurrencyID=n.CurrencyID)
		when	matched then
				update set UninvoicedAmt=(select Amt from dbo.Money#Sum(n.ChargeAmt, o.UninvoicedAmt)), TalliedOn=getutcdate()
		when	not matched then
				insert(  PartyID,   VaultBal,    VaultType,   CurrencyID, UninvoicedAmt)
				values(n.PartyID, n.CurrencyID, @vaultType, n.CurrencyID,   n.ChargeAmt)
		;
		execute acct.Vault#XactByInvoice @invoiceds=@invoiceds, @paymentID=default, @vaultType=@vaultType;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [shpt].[@------------------@shpt]...';


GO
CREATE PROCEDURE [shpt].[@------------------@shpt]
AS
BEGIN
	SET NOCOUNT ON;
/*
	-- Seedings:
	BEGIN   TRAN;

	insert  core._Calendar
	(       Value, Year, Quarter, Month, Week, Day, Dow, YOffset, QOffset, MOffset, WOffset, DOffset)
	select  Value, Year, Quarter, Month, Week, Day, Dow, YOffset, QOffset, MOffset, WOffset, DOffset
	from    core.Calendar#Emit(36524, 0);
	
	COMMIT  TRAN;
*/
END
GO
PRINT N'Creating [shpt].[Batch#Create]...';


GO
--PeterHo
CREATE PROCEDURE [shpt].[Batch#Create](@id I64 out, @siteID I32, @errorCnt int, @errors json)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		insert	shpt._Batch (SiteID, ErrorCnt) values (@siteID, @errorCnt);
		select	@id=scope_identity();

		if (@errorCnt>0)
		begin
			declare	@regID I32=(select ParcelBatch from core.Registry#ID());
			insert	core._Supplement (RegID, RowID, Supplement) values (@regID, @id, @errors);
		end

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [shpt].[Concern#AttachPreCheckTo]...';


GO
/*
@idSeqs => [MatterID, Seqence]
*/
--PeterHo
CREATE PROCEDURE [shpt].[Concern#AttachPreCheckTo](@idSeqs dbo.I64Seqs readonly)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	declare	@type E8=(select PreCheckIncomplete from core.Concern#Type());

	with cteNotYetBeenAdded as
	(
		select	x.ID, p.SvcType
		from	@idSeqs x
		join	shpt.Parcel#Raw()       p on p.ID=x.ID
		join	tms.SvcType#Raw()       s on s.ID=p.SvcType
		left	join core.Concern#Raw() c on c.MatterID=p.ID and c.Type=@type
		where	s.UsePreCheck=1 and c.MatterID is null
	)
	insert	core._Concern
	(		MatterID,  Type)
	select	ID,       @type
	from	cteNotYetBeenAdded

END
GO
PRINT N'Creating [shpt].[Concern#DetachPreCheckFrom]...';


GO
/*
@idSeqs => [MatterID, Seqence]
*/
--PeterHo
CREATE PROCEDURE [shpt].[Concern#DetachPreCheckFrom](@idSeqs dbo.I64Seqs readonly)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	declare	@type E8=(select PreCheckIncomplete from core.Concern#Type());

	delete	core._Concern
	where	Type=@type
	and		MatterID in (select ID from @idSeqs)
END
GO
PRINT N'Creating [shpt].[SackMft#Create]...';


GO
/*
@context =at.Quad.Of(POD, POA, Mawb, FlightNbr)
*/
--PeterHo
CREATE PROCEDURE [shpt].[SackMft#Create](@id bigint out, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @hubID I32;
		select	@userID=UserID, @hubID=HubID
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@now       DT=getutcdate();
		declare	@stateID   I32=(select SackMftCreated from core.State#ID());		
		declare	@source    E8=(select  InfoPath       from core.Source#ID());	
		declare	@type      E8=(select  SackMft        from core.Matter#Type());
		declare	@stage     E32=(select Stage from core.State#Raw() where ID=@stateID);
		declare	@sackMftID I64=next value for core.MatterSeq;

		insert	core._Matter
				(ID,         PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		values	(@sackMftID,   @hubID, @stateID, @stage, @source, @type,     @now);

		insert	shpt._SackMft
				(       ID, POD, POA, MawbNbr, FlightNbr)
		select	@sackMftID, v1,  v2,  v3,      v4
		from	tvp.Quad#Of(@context, default)

		insert	core._Activity
				(  MatterID,  StateID,  UserID, TalliedOn)
		values	(@sackMftID, @stateID, @userID,      @now);

		select	@id=@sackMftID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [shpt].[SackMft#CreateForFlight]...';


GO
/*
@context =Dozen<POD, POA, Mawb, FlightNbr>
*/
--PeterHo
CREATE PROCEDURE [shpt].[SackMft#CreateForFlight](@id bigint out, @flightID bigint, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @site I32;
		select	@userID=UserID, @site=SiteID
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@now        DT =getutcdate();
		declare	@type       E8 =(select SackMft        from core.Matter#Type());
		declare	@stage      E32=(select SackManifested from core.Stage#ID());
		declare	@stateID    I32=(select SackMftCreated from core.State#ID());
		declare	@source     E8 =(select Source         from core.Matter#Raw() where ID=@flightID);
		declare	@sackMftID I64=next value for core.MatterSeq;

		insert	core._Matter
				(ID,               PID, PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		values	(@sackMftID, @flightID, @site,    @stateID, @stage, @source, @type,     @now);

		insert	shpt._SackMft
				(       ID, POD, POA, MawbNbr, FlightNbr)
		select	@sackMftID, v1,  v2,  v3,      v4
		from	tvp.Dozen#Of(@context, default)

		insert	core._Activity
				(  MatterID,  StateID,  UserID, TalliedOn)
		values	(@sackMftID, @stateID, @userID,      @now);

		select	@id=@sackMftID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Sku$ImportEndorsement]...';


GO
/*
@slip    = at.Tvp.Triad.Join(SkuID, Endorsement, at.Tvp.Duad.Join(DutyCode, DutyRate).Over(at.Tvp.Many.Join)
@context = at.Tvp.Duad.Join(ClrMethodID, BrokerID)
*/
--Smile, PeterHo
CREATE PROCEDURE [svc].[Sku$ImportEndorsement](@slip tvp, @context tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;	 

		declare	@clrMethodID I32, @brokerID I32;
		select	@clrMethodID=v1,  @brokerID=v2
		from	tvp.Duad#Of(@context, default);
		
		declare	@countryCode char(2)=(select CountryCode from brkg.ClrMethod#Raw() where ID=@clrMethodID);

		--1.	Upsert Duty:
		with cteDuty as
		(
			select	distinct -- ToSmile: Moving to Client-Side.
					DutyCode=cast(d.v1 as varchar(15))
			,		DutyRate=cast(d.v2 as real)
			from	tvp.Triad#Slice  (@slip, default, default) x
			cross	apply tvp.Duad#Of(x.v3,  default) d
		)
		merge	into brkg._Duty as o using cteDuty as n
		on		(o.CountryCode=@countryCode and o.DutyCode=n.DutyCode)
		when	matched	then update set o.DutyRate=n.DutyRate
		when	not matched then insert( CountryCode,   DutyCode,   DutyRate)
				                 values(@countryCode, n.DutyCode, n.DutyRate);

		-- 2.	Upsert SkuBrokerage:
		with cteSkuBrokerage as
		(	
			select	SkuID=cast(x.v1 as int)
			,		ClrMethodID=@clrMethodID, BrokerID=@brokerID, Endorsement=x.v2, DutyID=w.ID
			from	tvp.Triad#Slice  (@slip, default, default) x
			cross	apply tvp.Duad#Of(x.v3,  default)          d
			join	brkg.Duty#Raw() w on w.CountryCode=@countryCode and w.DutyCode=cast(d.v1 as varchar(15))
		)
		merge	into invt._SkuBrokerage as o using cteSkuBrokerage as n 
		on		(o.SkuID=n.SkuID and o.ClrMethodID=n.ClrMethodID and o.BrokerID=n.BrokerID)
		when	matched     then update set o.Endorsement=n.Endorsement, o.DutyID=n.DutyID
		when	not matched then insert(  SkuID,  ClrMethodID,    BrokerID,    DutyID,  Endorsement) 
				                 values(n.SkuID, n.ClrMethodID, n.BrokerID, n.DutyID, n.Endorsement);
		
		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Sku$Import]...';


GO
/*
@slip    = at.Tvp.Duad.Join(x.SKU, FiledInfo)).Over(at.MyTvp.Mucho.Join)
@context = TenantID
*/
--Smile, PeterHo
CREATE PROCEDURE [svc].[Sku$Import](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT ON;
	
	declare	@tenantID I32=@context;
	with cteSku as
	(
		select	s.SkuNbr, FiledInfo=d.v2
		from	tvp.Spr#Const() k
		cross	apply tvp.Duad#Slice(@slip, k.Duad, k.Mucho) d
		cross	apply loc.SkuNbr#Cast(d.v1) s
	)
	merge	into invt._Sku as o using cteSku as n 
	on		(o.TenantID=@tenantID and o.SkuNbr=n.SkuNbr)		
	when	matched	    then update set o.FiledInfo=n.FiledInfo
	when	not matched then insert( TenantID,   SkuNbr,   FiledInfo)
	                         values(@TenantID, n.SkuNbr, n.FiledInfo);
END
GO
PRINT N'Creating [svc].[SackMft$MergeStamp]...';


GO
/*
@slip = at.Tvp.Triad.Join(SackMftID, StateID, at.Tvp.Trio.Join(UtcTime, UtcOffset, UtcPlaceID)).Over(at.Tvp.Many.Join)
*/
--Smile
CREATE PROCEDURE [svc].[SackMft$MergeStamp](@slip tvp)
--WITH ENCRYPTION--
AS
BEGIN	
	SET	NOCOUNT ON;
	execute core.RefStamp#Merge @slip=@slip;	
END
GO
PRINT N'Creating [svc].[IDNbr$Import]...';


GO
/*
@slip   = at.Tvp.Quad.Join(ClientRefNbr, IDNbr, IDName, Phone).Over(at.Tvp.Many)
@result = at.Tvp.Many.Join(NotFoundClientRefNbr)
*/
--Eva, Smile, PeterHo
CREATE PROCEDURE [svc].[IDNbr$Import](@slip tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;

		declare	@siteID     I32=(select SiteID     from loc.Tenancy#Of(@tenancy))
		,		@maxStage    E32=(select RouteCfmed from core.Stage#ID())
		,		@refNbrType  E8=(select	ClientRef  from core.RefNbr#Type())
		,		@idInfoType  E8=(select IDInfo     from core.RefInfo#Type());
		
		declare	@idSeqs I64Seqs;
		with cteNew as
		(
			select	MatterID=m.ID
			,		Info=concat(x.v2/*IDNbr*/,        d.Tuplet,
					'0'/*IsValid*/,                   d.Tuplet, 
					x.v3/*Name*/,                     d.Tuplet,
					x.v4/*Phone*/,                    d.Tuplet,
					''/*PreviousName*/)
			,		x.Seq
			from	tvp.Quad#Slice(@slip, default, default) x cross apply loc.RefNbr#Cast(x.v1) r
			join	core.RefNbr#Raw() n on n.Number=r.Number and n.Type=@refNbrType
			join	core.Matter#Raw() m on m.ID=n.MatterID   and m.Stage<@maxStage and m.PosterID=@siteID
			cross	apply tvp.Spr#Const() d
		)
		merge	core._RefInfo as o using cteNew as n
		on		(o.MatterID=n.MatterID and o.Type=@idInfoType)
		when	matched     and n.Info=N'' then delete
		when	matched     and n.Info>N'' then update set Info=n.Info
		when	not matched and n.Info>N'' then insert(  MatterID,  Type,         Info)
												values(n.MatterID, @idInfoType, n.Info)
		output	inserted.MatterID, n.Seq into @idSeqs;

		with cteResult (text) as
		(
			select	[text()]=concat(k.Many, x.v1)
			from	tvp.Quad#Slice(@slip, default, default) x
			left	join @idSeqs i on i.Seq=x.Seq
			cross	apply tvp.Spr#Const() k
			where	i.ID is null
			for xml path(N'')
		)
		select	@result=Tvp from cteResult cross apply tvp.Spr#Purify(text, default);

		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[@-------------------@svc]...';


GO
CREATE PROCEDURE [svc].[@-------------------@svc]
AS
BEGIN
SET NOCOUNT ON;
/*

@slip    = string.Join(",", TrkNbrs);
@context = at.Quad.Of(POD, POA, Mawb, FlightNbr)
--PeterHo
CREATE PROCEDURE [svc].[HubManifest$Import](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
;

@slip = Items.EachTo(x => x.MIC.Duad(at.Tvp.Pair.Join(x.TrkNbr, x.CourierCode))).Over(at.Tvp.Many.Join);
--PeterHo
CREATE PROCEDURE [svc].[ICManifest$Import](@slip tvp, @tenancy tvp)
;

@slip   = at.Tvp.Duad.Join(ClientRefNbr, IDNbr).Over(at.Tvp.Many)
@result = at.Tvp.Many.Join(NotFoundClientRefNbr)
--Eva, Smile, PeterHo
CREATE PROCEDURE [svc].[IDNbr$Import](@slip tvp, @tenancy tvp, @result tvp out)
;

@slip    tvp=at.Tvp.Comma.Join(TrackingNbrs);
@context tvp=at.Tvp.Triad.Join(ActionID, POA, at.Tvp.Trio.Join(UtcTime, UtcOffSet, UtcPlaceID));
--Smile
CREATE PROCEDURE [svc].[Parcel$CfmCustomsStatus](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
;


--GoodsInfo: Tuplet<Name, Brand, Model, Spec, LineQty, LineTotal>
--SkuInfo  : Mucho[Triad<SkuID, LineQty, LineTotal>]
--3. DeclaredInfo: Mucho[GoodsInfo]
--4. VerifiedInfo: almost same as DeclaredInfo
--7. BrokerageInfo : Duad<{Pair<DutyRate, DutyCode>}, Translated VerifiedInfo>

*/
END
GO
PRINT N'Creating [svc].[Parcel$MergePostCourier]...';


GO
/*
@slip   =Many[Triad<TrackingNbr, PostCourier, CourierCode>]
*/
--Smile
CREATE PROCEDURE [svc].[Parcel$MergePostCourier](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
	
		declare	@type E8=(select PostCourier from core.RefNbr#Type());
		
		declare	@parcelCourierIDs dbo.I64Pairs;
		with cteCourierNbr as
		(
			select	m.MatterID, Number=cast(v2 as varchar(40)), CourierID
			from	tvp.Triad#Slice(@slip, default, default) x
			cross	apply core.RefNbr#ScanOne(x.v1, default, default) m
			cross	apply tms.Courier#IdOfAlias(v3) t
		)
		merge	core._RefNbr as r using cteCourierNbr as n
		on		(r.MatterID=n.MatterID and r.Type=@type)
		when	matched     and n.Number=N'' then delete
		when	matched     and n.Number>N'' then update set r.Number=n.Number
		when	not matched and n.Number>N'' then insert(MatterID,  Type,   Number)
												values(n.MatterID, @type, n.Number)
		output inserted.MatterID, n.CourierID into @parcelCourierIDs;

		update o set o.LastMilerID=n.RID from shpt._Parcel o join @parcelCourierIDs n on o.ID=n.LID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Account$AssignPayment]...';


GO
/*
declare	@slip tvp =Tuplet<PartyID, CurrencyID, ChequeAmount, ChequeBalance>
        @context  =Many[Triad<ID, PayAmt, PayBalAmt>]
*/
--Smile
CREATE PROCEDURE [svc].[Account$AssignPayment](@slip tvp, @context tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		--declare	@partyID int, @currencyID tinyint, @amount bigint, @balAmt bigint;
		--select	@partyID=v1,  @currencyID=v2,      @amount=m.Amt,  @balAmt=b.Amt
		--from	tvp.Tuplet#Of(@slip, default)    x
		--cross	apply dbo.Money#Make(x.v3, x.v2) m
		--cross	apply dbo.Money#Make(x.v4, x.v2) b
		--;
		--with cteInvoice as
		--(
		--	select  ID=cast(x.v1 as bigint), DueBalance, NewDueBlance=n.Amt
		--	from	tvp.Triad#Slice(@context, default, default) x
		--	join	acct.Invoice#Raw()                          i on cast(x.v1 as bigint)=i.ID
		--	cross	apply dbo.Money#Make(x.v2, @currencyID)     b
		--	cross	apply dbo.Money#Make(x.v3, @currencyID)     c
		--	cross	apply dbo.Money#Sum( b.Amt, c.Amt)          s
		--	cross	apply dbo.Money#Sum(-s.Amt, i.DueBalance)   n
		--)		
		--update cteInvoice set DueBalance=NewDueBlance 
		--;
		----insert Payment
		--declare	@paymentID I64, @ledgerSide E8=(select AR from acct.Ledger#Side());
		--declare	@payMethod E8=(select Cash from acct.Payment#Method());
		--insert	acct._Payment
		--		( PartyID,  LedgerSide,  CurrencyID,  PayMethod,  PaidAmt)
		--values	(@partyID, @ledgerSide, @currencyID, @payMethod, @amount);
		--select	 @paymentID=scope_identity()
		--;
		
		--declare	@invoiceID I64=0 -- 0: wihtout invoice.
		--declare	@vaultType  E8=(select Fund from acct.Vault#Type());
		--declare @xactAmt bigint=(select Amt from dbo.Money#Sum(-@balAmt, @amount));
		--execute	acct.Vault#Xact    @paymentID=@paymentID, @invoiceID=@invoiceID
		--,		@partyID=@partyID, @vaultType=@vaultType, @xactAmt=@xactAmt
		--;
		--declare	@invoiceds acct.InvoicedSpec;
		--insert	into @invoiceds
		--select	@partyID, x.v1, @vaultType, Amt, @CurrencyID
		--from	tvp.Triad#Slice(@context, default, default)  x
		--cross	apply dbo.Money#Make(x.v2, @currencyID)      b
		--;
		--execute acct.Vault#XactVia @invoiceds=@invoiceds , @paymentID=@paymentID;

		--select	@vaultType=CreditMemo from acct.Vault#Type();
		--execute	acct.Vault#Xact    @paymentID=@paymentID, @invoiceID=@invoiceID
		--,		@partyID=@partyID, @vaultType=@vaultType, @xactAmt=@balAmt
		--;
		--declare	@creditInvoiceds acct.InvoicedSpec;
		--insert	into @creditInvoiceds
		--select	@partyID, x.v1, @vaultType, Amt, @CurrencyID
		--from	tvp.Triad#Slice(@context, default, default)  x
		--cross	apply dbo.Money#Make(x.v3, @currencyID)      b
		--;
		--execute acct.Vault#XactVia @invoiceds=@creditInvoiceds, @paymentID=@paymentID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Account$InvoiceTallied]...';


GO
/*
declare	@slip tvp = Tuplet[Source, VaultTag, PartyID, BizUnitID, IssueDate]
*/
--@slip=Quad[];
--Smile
CREATE PROCEDURE [svc].[Account$InvoiceTallied](@slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@source tinyint, @vaultTag tinyint, @partyID int, @bizUnitID int, @issueDate datetime2(2);
		select	@source=v1,      @vaultTag=v2,      @partyID=v3,  @bizUnitID=v4, @issueDate=v5
		from	tvp.Tuplet#Of(@slip, default);

		declare	@ledgerSide E8=(select AR from acct.Ledger#Side())
		,		@ids I64Array;	
		insert	acct._Invoice( PartyID,      ContractID,   VaultTag,   LedgerSide,  
							   CurrencyID,   DueBalance,   InvoiceAmt, IssueDate, DueDate)
		output	inserted.ID into @ids
		select	               ID,           ContractID,   VaultTag,   @ledgerSide,
		                       CurrencyID,   ChargeAmt,    ChargeAmt,  IssueDate, DueDate
		from	svc.Invoice$ProcessingList(@source, @vaultTag, @partyID, @bizUnitID, @issueDate);

		with	cteLedgerGroup as
		(
		select	l.ID, l.PartyID, x.SourceID, p.ContractID, l.CurrencyID, g.VaultTag
		,		IssueDate=iif(BillingCycle%7=0, cd.BOWeek, cd.BOMonth)
		,		l.ChargeRaw, LastInvoiceDate=isnull(i.LastInvoiceDate, dbo.DT@Empty()),	l.TalliedOn, BillingCycle
		from	acct.Contract#Raw()               x
		cross	apply dbo.Calendar#Of(@issueDate) cd
		join	shpt.Parcel#Raw()                 p on p.ContractID=x.ID
		join	acct.Ledger#Raw()                 l on l.MatterID=p.ID
		join	acct.Charge#Raw()                 g on l.ChargeID=g.ID
		cross	apply acct.Vault#Tag()            a
		cross	apply acct.Ledger#Side()          d
		outer	apply (
						select  LastInvoiceDate=max(IssueDate)
						from	acct.Invoice#Raw()
						where	PartyID=x.TenantID
						and		ContractID=x.ID
						and		VaultTag=g.VaultTag
						and		CurrencyID=l.CurrencyID
						and     ID not in (select ID from @ids)
					  )                           i           
		where	l.InvoiceID=0
		and		(nullif(@vaultTag,0) is null or g.VaultTag=@vaultTag)
		and		l.LedgerSide=d.AR
		and		(nullif(@bizUnitID,0) is null or x.BizUnitID=@bizUnitID)
		and		(nullif(@partyID, 0) is null or x.TenantID=@partyID)
		and		(nullif(@source,  0) is null or x.SourceID=@source)
		and		BillingCycle>0
		and	    l.TalliedOn<iif(BillingCycle%7=0, cd.BOWeek, cd.BOMonth)
		), cteInvoiceSummary as
		(
		select	ID, PartyID, SourceID, ContractID, CurrencyID, VaultTag
		,		IssueDate, ChargeRaw
		,		InvoiceGroup=DateDiff(day, TalliedOn, dateadd(day, -1,IssueDate))/BillingCycle
		from	cteLedgerGroup               x
		where	(BillingCycle%7=0 and datediff(day, LastInvoiceDate, IssueDate)>=BillingCycle)
		or		(BillingCycle%7>0 and datediff(month, LastInvoiceDate, IssueDate)=1)
		), cteInvoice as
		(
		select	ID, PartyID, VaultTag, CurrencyID, ContractID, InvoiceGroup, IssueDate
		,		ChargeRawAmt=sum(ChargeRaw) over(partition	by PartyID, VaultTag, CurrencyID, ContractID, InvoiceGroup, IssueDate)
		from	cteInvoiceSummary  		
		), cteLedger as
		(
		select	InvoiceID=x.ID, LedgerID=d.ID
		from	@ids               x
		join	acct.Invoice#Raw() i on x.ID=i.ID
		join	cteInvoice         d on d.PartyID=i.PartyID       and 
										d.ContractID=i.ContractID and 
										d.CurrencyID=i.CurrencyID and 
										d.VaultTag=i.VaultTag     and
										d.ChargeRawAmt=i.DueBalanceRaw
		)update l set l.InvoiceID=i.InvoiceID from acct._Ledger l join cteLedger i on l.ID=I.LedgerID;

		declare	@vaultType  E8=(select Fund from acct.Vault#Type());
		with cteInvoiceds as
		(
			select	PartyID, x.CurrencyID, ChargeRawAmt=sum(x.InvoiceRawAmt)
			from	@ids               i
			join	acct.Invoice#Raw() x on i.ID=x.ID
			group	by PartyID, x.CurrencyID
		), cteVaults as
		(
			select	v.ID,  UninvoicedAmt, NewUninvoicedAmt=iif(u.Amt<0, 0, u.Amt)
			from	acct.Vault#Raw() v
			join	cteInvoiceds     x on v.PartyID=x.PartyID and v.CurrencyID=x.CurrencyID and v.VaultType=@vaultType
			cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
			cross	apply dbo.Money#Sum(-m.Amt,v.UninvoicedAmt) u
		)
		update	cteVaults set UninvoicedAmt=NewUninvoicedAmt;
		

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$MergeRefInfo]...';


GO
/*
@slip   =Many[Triad<MatterID, RefInfoType, RefInfo>]
*/
CREATE PROCEDURE [svc].[Parcel$MergeRefInfo](@slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT ON;	

	execute	core.RefInfo#Merge @slip=@slip;	
END
GO
PRINT N'Creating [svc].[Tenancy$AddUser]...';


GO
/*
@slip   =at.Tvp.Field.Join(PID, AID, Alias, Contact, UserRoles)
@context=Source
*/
--Smile
CREATE PROCEDURE [svc].[Tenancy$AddUser](@slip tvp, @context tvp, @result tvp out)
WITH ENCRYPTION--
AS
BEGIN
	SET NOCOUNT ON;

	declare	@id I64, @type E32=(select Operator from core.Party#Type());
	exec	core.User#Add @id=@id out, @source=@context, @type=@type, @slip=@slip;
	select	@result=@id;
END
GO
PRINT N'Creating [svc].[Tenancy$AddTenant]...';


GO
/*
@slip = Field <PID, AID, Alias, Contact, UtcPlace, UtcOffset>
@context=Dozen<Source, DutyTerms, NoDutyTerms, BillingCycle, 
			   EffectiveOn, ExpiredOn, BIZUnitID,
			   Many[SvcType], Many[FileID]>
*/
--Smile
CREATE PROCEDURE [svc].[Tenancy$AddTenant](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;

		declare	@source E8,  
			@dutyTerms tinyint,  @nondutyTerms tinyint, @billingCycle tinyint,
			@effectiveOn dbo.DT, @expiredOn dbo.DT, 
			@bizUnitID I32, @svcTypes tvp, @fileBankIDs tvp;

		select	@source=v1,
				@dutyTerms=v2,   @nondutyTerms=v3, @billingCycle=v4,
				@effectiveOn=v5, @expiredOn=v6,
				@bizUnitID=v7,   @svcTypes=v8, @fileBankIDs=v9
		from	tvp.Dozen#Of(@context, default);

		declare	@id I64, @type E32=(select Tenant from core.Party#Type())
		execute	core.Tenant#Add @id=@id out, @source=@source, @type=@type, @slip=@slip;

		declare	@contractID I32;
		insert	acct._Contract
				(TenantID, BizUnitID,  SourceID, BillingCycle,  DutyTerms,  NonDutyTerms,  EffectiveOn,  ExpiredOn)
		values	(@id,     @bizUnitID, @source,  @billingCycle, @dutyTerms, @nondutyTerms, @effectiveOn, @expiredOn)
		;
		select	@contractID=scope_identity();

		declare	@userID I32=(select UserID from	loc.Tenancy#Of(@tenancy)),
				@auxID E32=(select SalesContract from core.Attachment#Type()),
				@regID I32=(select Contract from core.Registry#ID());

		insert	core._Attachment
				( RegID,  RowID,       AuxID,  PosterID,  FileBankID)
		select	 @regID, @contractID, @auxID, @userID,  x.Piece
		from	tvp.Many#Slice(@fileBankIDs) x;

		insert	tms._SvcContract(SvcType, ContractID) select s.Major, @contractID
		from	tvp.Many#Slice(@svcTypes)        x
		cross	apply tms.SvcType#Major(x.Piece) s

		select	@result=Tvp from tvp.Duad#Make(@id, @contractID);

		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Tenancy$AddSite]...';


GO
/*
@slip = Field<PID, AID, Alias, Contact, UtcPlace, UtcOffset>
        Contact=Many[Duad<type, ContactTvp>]
@context=Source
*/
--Smile
CREATE PROCEDURE [svc].[Tenancy$AddSite](@slip tvp, @context tvp, @result tvp out)
WITH ENCRYPTION--
AS
BEGIN
	SET NOCOUNT ON;

	declare	@id I64, @type E32=(select TenantSite from core.Party#Type());
	exec	core.Tenant#Add @id=@id out, @source=@context, @type=@type, @slip=@slip;
	select	@result=@id;
END
GO
PRINT N'Creating [svc].[Tenancy$Import]...';


GO
/*
TenantAlias=CustomerCode + " (Admin)"
SiteAlias  =CustomerCode
@slip   = Block[Triad<CustomerCode, UtcOffSet, UtcPlace>, BillingContact, Triad<CustomerCode, UtcOffSet, UtcPlace>, ShippingContact]
@context= Duad<Source, PreAlias>
*/
--Smile
CREATE PROCEDURE [svc].[Tenancy$Import](@slip tvp, @context tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;

		declare	@source tinyint, @preAlias nvarchar(30);
		select	@source=v1, @preAlias=v2
		from	tvp.Duad#Of(@context, default);

		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.PartySeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		-- 1.	Add Tennat && BillingContact:
		declare	@tenantType E8=(select Tenant from core.Party#Type());
		declare	@tenantSeqs I64Seqs;
		with cteParty as
		(
			select	ID=x.Master, PID=0, AID=0, Type=@tenantType, Alias=concat(h.v1, @preAlias), Source=@source, Seq=x.Seq
			from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default) x
			cross	apply tvp.Triad#Slice(x.House, default, default)     h
		
		)
		merge	into core._Party as o using cteParty as n
		on		(o.Alias=n.Alias and o.Source=n.Source)
		when	matched	    then update set  o.PID=n.PID, o.Type=n.Type
		when	not matched then insert(     ID,   PID,   AID,   Type,   Source,    Alias)
									values(n.ID, n.PID,  n.ID, n.Type, n.Source,  n.Alias)
		output inserted.ID, n.Seq into @tenantSeqs
		;
		with cteTenant as
		(
			select	ID=t.ID,  Alias=concat(h.v1, @preAlias), UtcOffset=h.v2, UtcPlace=h.v3
			from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default)  x
			cross	apply tvp.Triad#Slice(x.House, default, default)      h	
			join	@tenantSeqs                                           t on x.Seq=t.Seq
		)
		merge	into core._Tenant as o using cteTenant as n
		on		(o.ID=n.ID)
		when	matched	    then update set o.Alias=n.Alias, o.UtcOffset=n.UtcOffset, o.UtcPlace=n.UtcPlace, o.Source=@source
		when	not matched then insert(     ID,   Alias,   UtcPlace,   UtcOffset, Source)
									values(n.ID, n.Alias, n.UtcPlace, n.UtcOffset, @source)
		;
		--1.1. Add Contract
		insert into acct._Contract
					(TenantID, SourceID,  BillingCycle, DutyTerms, NonDutyTerms,  EffectiveOn,  ExpiredOn)
		select	           ID,  @source,  255,          255,        255,          getutcdate(), dateadd(year, 1, getutcdate())
		from			   @tenantSeqs x
		where			   not exists(select ID from acct.Contract#Raw() where TenantID=x.ID and SourceID=@source)
		;
		declare @billing E8=(select Billing from core.Contact#Type());
		with cteBilling as
		(   
			select	PartyID=i.ID, Type=@billing, Name, Phone, Email, Company, Street1, Street2, Street3, City, District, Province, PostalCode, CountryCode
			from	tvp.Block#FoldT(2, @idSeqs, @slip, default, default)  x
			cross	apply loc.Contact#Of(x.House)                         h
			join	@tenantSeqs                                           i on x.Seq=i.Seq
			where	Name>N''
		)
		merge	into core._Contact as o using cteBilling as n
		on		(o.PartyID=n.PartyID and o.Type=@billing)
		when	matched	    then update set o.PartyID=n.PartyID,  o.Type=n.Type, o.Name=n.Name,  o.Phone=n.Phone,  o.Email=n.Email, o.Company=n.Company, 
											o.Street1=n.Street1,  o.Street2=n.Street2,   o.Street3=n.Street3, o.City=n.City, o.District=n.District,   
											o.Province=n.Province,  o.PostalCode=n.PostalCode,   o.CountryCode=n.CountryCode
		when	not matched then insert(      PartyID,    Type,   Name,  Phone,    Email,   Company,   Street1,   Street2,   Street3,   City,   District,   Province,   PostalCode,   CountryCode)
									values( n.PartyID,  n.Type, n.Name, n.Phone, n.Email, n.Company, n.Street1, n.Street2, n.Street3, n.City,n. District, n.Province, n.PostalCode, n.CountryCode)
		;
		-- 2.	Add Site && Ship from:
		declare	@siteSeq I64Seqs; insert @siteSeq(ID, Seq)
		select	next value for core.PartySeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));
		declare	@siteType E8=(select TenantSite from core.Party#Type());
		declare	@site I64Seqs;
		with	cteParty as
		(
			select	ID=x.Master, PID=t.ID, AID=t.ID, Type=@siteType, Alias=h.v1, Source=@source, Seq=x.Seq
			from	tvp.Block#FoldT(3, @siteSeq, @slip, default, default)  x
			cross	apply tvp.Triad#Slice(x.House, default, default)       h
			join	@tenantSeqs                                            t on x.Seq=t.Seq
		)
		merge	into core._Party as o using cteParty as n
		on		(o.Alias=n.Alias and o.Source=n.Source)
		when	matched     then update set o.Alias=n.Alias
		when	not matched then insert(  ID,   PID,   AID,   Type,   Source,    Alias)
								 values(n.ID, n.PID, n.AID, n.Type, n.Source,  n.Alias)
		output inserted.ID, n.Seq into @site
		;
		with cteSite as
		(
			select	ID=t.ID,  Alias=h.v1, UtcOffset=h.v2, UtcPlace=h.v3
			from	tvp.Block#FoldT(3, @siteSeq, @slip, default, default)  x
			cross	apply tvp.Triad#Slice(x.House, default, default)       h	
			join	@site                                                  t on x.Seq=t.Seq
		)
		merge	into core._Tenant as o using cteSite as n
		on		(o.ID=n.ID)
		when	matched	    then update set o.Alias=n.Alias, o.UtcOffset=n.UtcOffset, o.UtcPlace=n.UtcPlace, o.Source=@source
		when	not matched then insert(  ID,   Alias,   UtcPlace,   UtcOffset, Source)
								 values(n.ID, n.Alias, n.UtcPlace, n.UtcOffset, @source)
		;
		declare @shipper E8=(select Shipping from core.Contact#Type());
		with cteShipper as
		(   
			select	PartyID=i.ID, Type=@shipper, Name, Phone, Email, Company, Street1, Street2, Street3, City, District, Province, PostalCode, CountryCode
			from	tvp.Block#FoldT(4, @siteSeq, @slip, default, default)  x
			cross	apply loc.Contact#Of(x.House)                          h
			join	@site                                                  i on x.Seq=i.Seq
			where	Name>N''
		)
		merge	into core._Contact as o using cteShipper as n
		on		(o.PartyID=n.PartyID and o.Type=@shipper)
		when	matched	    then update set o.PartyID=n.PartyID,  o.Type=n.Type, o.Name=n.Name,  o.Phone=n.Phone,  o.Email=n.Email, o.Company=n.Company, 
											o.Street1=n.Street1,  o.Street2=n.Street2,   o.Street3=n.Street3, o.City=n.City, o.District=n.District,   
											o.Province=n.Province,  o.PostalCode=n.PostalCode,   o.CountryCode=n.CountryCode
		when	not matched then insert(   PartyID,    Type,   Name,  Phone,    Email,   Company,   Street1,   Street2,   Street3,   City,   District,   Province,   PostalCode,   CountryCode)
								 values( n.PartyID,  n.Type, n.Name, n.Phone, n.Email, n.Company, n.Street1, n.Street2, n.Street3, n.City,n. District, n.Province, n.PostalCode, n.CountryCode)
		;
		select @result=count(*) from @tenantSeqs;

COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Sku$ImportByPlatform]...';


GO
/*
@slip    = Many[Duo<CustomCode, Mucho[Duad<x.SKU, FiledInfo>]>]
@context = Source
*/
--Eva, Smile
CREATE PROCEDURE [svc].[Sku$ImportByPlatform](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT ON;
	
	declare	@source E8=@context;
	with cteSku as
	(
		select	TenantID=t.PID, s.SkuNbr, FiledInfo=d.v2
		from	tvp.Spr#Const()                              k
		cross	apply tvp.Duad#Slice(@slip, k.Duo, k.Many )  c
		cross	apply tvp.Duad#Slice(c.v2,  k.Duad, k.Mucho) d
		cross	apply loc.SkuNbr#Cast(d.v1)                  s
		join	core.Party#Raw()                             t on t.Alias=c.v1 and t.Source=@source		
	)
	merge	into invt._Sku as o using cteSku as n 
	on		(o.TenantID=n.TenantID and o.SkuNbr=n.SkuNbr)
	when	matched	    then update set o.FiledInfo=n.FiledInfo
	when	not matched then insert(  TenantID,   SkuNbr,   FiledInfo)
	                         values(n.TenantID, n.SkuNbr, n.FiledInfo);
END
GO
PRINT N'Creating [svc].[Tenancy$UpdateContact]...';


GO
/*
@slip =  at.Tvp.Field.Join(PartyID, Alias, Contact, UtcPlace, UtcOffset)
@context=Source
*/
--Smile
CREATE PROCEDURE [svc].[Tenancy$UpdateContact](@slip tvp, @context tvp)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;

		declare	@partyID int, @alias loc.Alias, @contact tvp, @utcPlace loc.Alias, @utcOffset smallint;

		select	@partyID=v1, @alias=v2, @contact=v3, @utcPlace=v4, @utcOffset=v5
		from	tvp.Field#Of(@slip, default);

		update	core._Tenant set UtcOffset=@utcOffset, UtcPlace=@utcPlace where ID=@partyID;

		with cteContact as
		(
			select	PartyID=@partyID, Type=cast(x.v1 as tinyint), Name, Phone, Email, Company, 
					Street1, Street2, Street3, City, District, Province, PostalCode, CountryCode
			from	tvp.Duad#Slice(@contact, default, default) x
			cross	apply loc.Contact#Of(x.v2)
		)
		merge	into core._Contact as o using cteContact as n
		on		(o.PartyID=n.PartyID and o.Type=n.Type)
		when	matched	    then update set o.PartyID=n.PartyID, o.Type=n.Type,         o.Name=n.Name, 
											o.Phone=n.Phone,     o.Email=n.Email,       o.Company=n.Company, 
											o.Street1=n.Street1, o.Street2=n.Street2,   o.Street3=n.Street3, 
											o.City=n.City,       o.District=n.District, o.Province=n.Province,  
											o.PostalCode=n.PostalCode, o.CountryCode=n.CountryCode
		when	not matched then insert(  PartyID,   Type,   Name,   Phone,  Email,   Company,   
										  Street1,   Street2,   Street3,   City,  District,    Province,   PostalCode,   CountryCode)
								 values(n.PartyID, n.Type, n.Name, n.Phone, n.Email, n.Company, 
										n.Street1, n.Street2, n.Street3, n.City, n.District, n.Province, n.PostalCode, n.CountryCode)
		;

		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Flight$Assign]...';


GO
/*
	@slip    = Block[Comma<AddedSackMftID>, Comma<RemovedSackMftID>]
	@context = Flight
*/
-- AaronLiu
CREATE PROCEDURE [svc].[Flight$Assign](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		with cteSlip as
		(
			select	s.ID, FlightID=cast(@context as bigint)
			from	tvp.Block#At(1, @slip, default, default) x
			cross	apply tvp.I64#Slice(x.Tvp)				 s
			union	all
			select	s.ID, FlightID=0
			from	tvp.Block#At(2, @slip, default, default) x
			cross	apply tvp.I64#Slice(x.Tvp)				 s
		), cteMatter as
		(
			select	m.ID, m.PID, x.FlightID
			from	cteSlip x
			join	core.Matter#Raw() m on x.ID=m.ID
		)
		update	cteMatter set PID=FlightID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Flight$Import]...';


GO
/*
	@slip = Many[Tuplet<POD, POA, AirlineID, FlightNbr, ETD, ETA>];
*/
-- AaronLiu
CREATE PROCEDURE [svc].[Flight$Import](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @site I32;
		select	@userID=UserID, @site=SiteID
		from	loc.Tenancy#Of(@tenancy);

		declare	@now        DT=getutcdate()
		,		@type       E8=(select Flight       from core.Matter#Type())
		,		@stage      E32=(select InfoImported from core.Stage#ID())
		,		@source     E8=(select InfoPath     from core.Source#ID())
		,		@stateID   I32=(select FlightBooked from core.State#ID())
		;

		declare	@idSeqs I64Seqs; 
		insert	@idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Many@Count(@slip));

		insert	core._Matter
		(		ID, PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		select	ID,    @site, @stateID, @stage, @source, @type,     @now
		from	@idSeqs;

		with cteFlight as
		(
			select	Seq, POD=v1, POA=v2, AirlineID=cast(v3 as bigint), FlightNbr=v4
			,		ETD=cast(isnull(nullif(v5, ''), '0001') as datetime2(2))
			,		ETA=cast(isnull(nullif(v6, ''), '0001') as datetime2(2))
			from	tvp.Tuplet#Slice(@slip, default, default)
		)
		insert	tms._Flight
		(		ID, POD, ETD, POA, ETA, FlightNbr, AirlineID)
		select	ID, POD, ETD, POA, ETA, FlightNbr, AirlineID
		from	cteFlight x
		join	@idSeqs   m on x.Seq=m.Seq;

		insert	core._Activity
		(		MatterID,  StateID,  UserID, TalliedOn)
		select	ID,		  @stateID, @userID,      @now
		from	@idSeqs;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[CourierNbr$Fetch]...';


GO
/*
@slip		=Count
@context	=courierID
*/
--Eva
CREATE PROCEDURE [svc].[CourierNbr$Fetch](@slip tvp, @context tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	declare	@cnt        E32=cast(@slip as int)
	,		@deletedNbr PcsAutoSeqs;
	with	cte as
	(
		select	top(@cnt) CourierID, TrackingNbr
		from	tms._CourierNbrPool
		where	CourierID=@context
	)
	delete	from cte
	output	deleted.TrackingNbr into @deletedNbr;
	;
	with	cte(text) as
	(
		select	top(@cnt) [text()]=concat(N',', Piece)
		from	@deletedNbr
		for xml path(N'')
	)
	select	@result=Tvp from cte cross apply tvp.Spr#Purify(text, 1);

END
GO
PRINT N'Creating [svc].[SackMft$UpdMawbNbr]...';


GO
/*
@slip =at.Tvp.Duad.Join(SackMftID, MawbNbr);
*/
--Aimee, Smile
CREATE PROCEDURE [svc].[SackMft$UpdMawbNbr](@slip tvp)
--WITH ENCRYPTION--
AS
BEGIN
	SET NOCOUNT    ON;
	
			with cteSackMft as
			(
				select	x.ID, x.MawbNbr, NewMawbNbr=d.v2
				from	shpt.SackMft#Raw()          x
				join	tvp.Duad#Of(@slip, default) d on x.ID=cast(d.v1 as bigint)
			)
			update	cteSackMft set MawbNbr=NewMawbNbr;
	
END
GO
PRINT N'Creating [svc].[Setting$Update]...';


GO
-- Eason
CREATE PROCEDURE [svc].[Setting$Update](@name tvp, @value tvp)

-- WITH ENCRYPTION
AS BEGIN
	update	core._Setting
	set		Value=@value
	where	Name=@name
END
GO
PRINT N'Creating [svc].[Parcel$MergeRefInfoByMics]...';


GO
/*
@slip   =Many[Triad<MIC, RefInfoType, RefInfo>]
*/
CREATE PROCEDURE [svc].[Parcel$MergeRefInfoByMics](@slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT ON;	

	declare @refInfoSlip tvp;
	with cteParcel(text) as
	(
		select	[text()]=concat(k.Many, m.MatterID, k.Triad, x.v2, k.Triad, x.v3)
		from	tvp.Triad#Slice(@slip, default, default) x
		cross	apply core.MIC#IdOf(x.v1) m
		join	core.Matter#Raw()         t on t.ID=m.MatterID
		cross	apply core.Stage#ID()     s
		cross	apply tvp.Spr#Const()     k
		where t.Stage=s.RouteAssigned
		for xml path(N'')
	)
	select @refInfoSlip=Tvp from cteParcel cross apply tvp.Spr#Purify(text, default);
	execute core.RefInfo#Merge @slip=@refInfoSlip;

END
GO
PRINT N'Creating [svc].[AddOnSvc$Post]...';


GO
/*
for 通用增值服务 (拍照,内件清点除外)
@slip    tvp=at.Tvp.Comma.join(AddOnSvcIDs);
@context tvp=Started UtcTime;
@result  tvp=at.Tvp.Comma.join(updatedIDs);
*/
--Eason
CREATE PROCEDURE [svc].[AddOnSvc$Post](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;
	    
		declare	@ids I64Array, @updatedIds I64Array;
		insert	into @ids select  x.Piece
		from	tvp.Comma#Slice(@slip) x

		declare	@userID I32 = (select UserID from loc.Tenancy#Of(@tenancy));

		with	n as (
				select	x.ID
				from	@ids x
				cross	apply core.AddOnSvc#Type() t
				join	core._AddOnSvc a on  a.ID=x.ID 
				where	a.OperatorID = 0 and a.Type not in (t.TakePhoto, t.Inventory) -- 不为需要操作内容的增值服务
		)
		update	core._AddOnSvc set OperatorID=@userID, StartedOn=@context, EndedOn=GETUTCDATE()
		output	Inserted.ID into @updatedIds
		from	n
		where	core._AddOnSvc.ID=n.ID
		;
				
		with	cte(Text) as
		(
			select	[text()]=concat(N',', ID) from @updatedIds	
			for	xml path(N'')	
		)	
		select	@result=Tvp from cte cross apply tvp.Spr#Purify(text, 1);
	
		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Appointment$Init]...';


GO
/*
@slip    = Entry[Block<PickupInfo, PickupOn, EstWeight>]
@context = Source
*/
--AaronLiu
CREATE PROCEDURE [svc].[Appointment$Init](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32
		select	@siteID=SiteID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy) x

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@stateID E32=(select AppointmentInit=17271	from core.State#ID());	--HACK
		declare	@type	  E8=(select Appointment			from core.Matter#Type())
		,		@stage	 E32=(select Stage					from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type,  PostedOn   )
		select	ID,  @siteID,  @stateID, @stage, @context, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 2.	Add RefInfos:
		declare	@pickupInfo E8=(select PickupInfo from core.RefInfo#Type());
		execute	core.RefInfo#AddBlock @index=1, @idSeqs=@idSeqs, @slip=@slip, @type=@pickupInfo;

		-- 3.	Add Appointments:
		insert	shpt._Appointment
		(		ID, PickupOn, EstWeight)
		select	ID, t.v2,	  t.v3
		from	@idSeqs x
		cross	apply tvp.Spr#Const() k
		cross	apply tvp.Triad#Slice(@slip, k.Block, k.Entry) t
		where	x.Seq=t.Seq

		-- 4.	Result:
		select	@result=(select Tvp from tvp.I64Seqs#Join(@idSeqs));

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Contact$DefaultTo]...';


GO
/*
@slip = ContactID
*/
--AaronLiu
CREATE PROCEDURE [svc].[Contact$DefaultTo](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@siteID I32;
		select	@siteID=SiteID
		from	loc.Tenancy#Of(@tenancy);

		with	cte as
		(
			select	c.ID, c.IsDefault
			from	core.Contact#Raw() x, core.Contact#Raw() c
			where	x.ID=@slip and x.Type=c.Type and c.PartyID=@siteID
		)
		update	cte set IsDefault=0;
		update	core._Contact set IsDefault=1 where ID=@slip;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Contact$Merge]...';


GO
/*
@slip = Many[Triad<ID, Type, ContactTvp>]
*/
--AaronLiu
CREATE PROCEDURE [svc].[Contact$Merge](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@siteID I32;
		select	@siteID=SiteID
		from	loc.Tenancy#Of(@tenancy);

		with	cteNew as
		(
			select	ID=cast(x.v1 as bigint), PartyID=@siteID,  Type=cast(x.v2 as tinyint), Name, Phone
			,		Email, Company, Street1, Street2, Street3, City, District, Province,   PostalCode
			,		CountryCode
			from	tvp.Triad#Slice(@slip, default, default) x
			cross	apply loc.Contact#Of(x.v3)
		)
		,	cteOld as
		(
			select	c.ID,	   c.PartyID, c.Type,	 c.Name,	 c.Phone, c.Email,    c.Company
			,		c.Street1, c.Street2, c.Street3, c.District, c.City,  c.Province, c.PostalCode, c.CountryCode
			from	cteNew x,  core.Contact#Raw() c 
			where	abs(x.ID) =c.ID
		)
		merge	cteOld as o using cteNew as n
		on		o.ID=n.ID
		when	matched then
			update set o.Name=n.Name,		o.Phone=n.Phone,	   o.Email=n.Email,			  o.Company=n.Company
			,		   o.Street1=n.Street1, o.Street2=n.Street2,   o.Street3=n.Street3,		  o.District=n.District
			,		   o.City=n.City,		o.Province=n.Province, o.PostalCode=n.PostalCode, o.CountryCode=n.CountryCode
		when	not matched and n.ID=0 then
			insert(  PartyID,	Type,	   Name,   Phone,	   Email,	   Company,		 Street1
			,		 Street2,   Street3,   City,   District,   Province,   PostalCode,	 CountryCode)
			values(  @siteID, n.Type,	 n.Name, n.Phone,    n.Email,    n.Company,	   n.Street1
			,	   n.Street2, n.Street3, n.City, n.District, n.Province, n.PostalCode, n.CountryCode)
		when	not matched by source then delete
		;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [tms].[@------------------@tms]...';


GO
--Daxia
CREATE PROCEDURE [tms].[@------------------@tms]
AS
BEGIN SET NOCOUNT ON;
/*
	Document comes here.
*/
END
GO
PRINT N'Creating [tms].[Flight#Create]...';


GO
/*
@context =Dozen<POD, ETD, POA, ETA, FlightNbr, AirlineID>
*/
--Daxia
CREATE PROCEDURE [tms].[Flight#Create](@id bigint out, @source tinyint, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @site I32;
		select	@userID=UserID, @site=SiteID
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@now           DT =getutcdate();
		-- 1.	Add Flight
		declare	@type    E8 =(select Flight       from core.Matter#Type());
		declare	@stage   E32=(select InfoImported from core.Stage#ID());
		declare	@stateID I32=(select FlightBooked from core.State#ID());
		declare	@flightID      I64=next value for core.MatterSeq;

		insert	core._Matter
				(ID,         PosterID, StateID,  Stage,  Source,  Type, PostedOn)
		values	(@flightID,  @site,   @stateID, @stage, @source, @type, @now);

		insert	tms._Flight
		(		ID,        POD, ETD, POA, ETA, FlightNbr, AirlineID)
		select	@flightID, v1,  v2,  v3,  v4,  v5,        v6
		from	tvp.Dozen#Of(@context, default)

		insert	core._Activity
				( MatterID,  StateID,  UserID, TalliedOn)
		values	(@flightID, @stateID, @userID, @now);

		select	@id=@flightID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [tms].[Pic#Emit]...';


GO
--PeterHo: HACKED.
CREATE PROCEDURE [tms].[Pic#Emit](@source tinyint, @picSpec tms.PicSpec readonly)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT ON;

	declare	@parts as table
	(
		SeqNbr   bigint  NOT NULL PRIMARY KEY CLUSTERED,
		SvcClass tinyint NOT NULL,
		SvcCode  char(3) NOT NULL,
		MailerID char(9) NOT NULL,
		TokenID  char(9) NOT NULL,
		POA      char(3) NOT NULL,
		OnZip3   char(3) NOT NULL
	);
	insert	@parts
	select	x.SeqNbr
	,		[SvcClass]=iif(f.MailerID is null, 0,           r.SvcClass)
	,		[SvcCode] =iif(f.MailerID is null, '000',       f.ClassCode)
	,		[MailerID]=iif(f.MailerID is null, '000000000', f.MailerID)
	,		[TokenID] =iif(f.MailerID is null, '',          f.TokenID)
	,		[POA] =    iif(f.MailerID is null, '',          f.POA)
	,		[OnZip3] = iif(f.MailerID is null, '000',       f.ImportZip3)
	from	@picSpec  x
	cross	apply tms.SvcClass#For(x.SvcType, x.MeasuredWt)        r
	outer	apply tms.SvcFacility#For(@source, r.SvcClass, x.Zip3) f

	--UAA:
	declare	@idPairs dbo.I32Pairs;
	insert	@idPairs (LID, RID)  select SeqNbr, 0 from @parts where TokenID='';

	----USPS:
	
	--FedEx(9016)-USD(08):
	insert	@idPairs (LID, RID)  select SeqNbr, next value for tms.JFK901608
	from	@parts cross apply tms.SvcToken#ID() s where TokenID=s.JFK901608;
	;
	insert	@idPairs (LID, RID)  select SeqNbr, next value for tms.LAX901608
	from	@parts cross apply tms.SvcToken#ID() s where TokenID=s.LAX901608;
	
	--FedEx(9016)-XPD(07):
	insert	@idPairs (LID, RID)  select SeqNbr, next value for tms.JFK901607
	from	@parts cross apply tms.SvcToken#ID() s where TokenID=s.JFK901607;
	;
	insert	@idPairs (LID, RID)  select SeqNbr, next value for tms.LAX901607
	from	@parts cross apply tms.SvcToken#ID() s where TokenID=s.LAX901607;

	--PICs:
	select	SeqNbr, SvcClass, SvcCode, MailerID, MailerSeq=x.RID, p.POA, p.OnZip3
	from	@idPairs x join @parts p on p.SeqNbr=x.LID;
END
GO
PRINT N'Creating [vmi].[@-------------------@vmi]...';


GO
CREATE PROCEDURE [vmi].[@-------------------@vmi]
AS
BEGIN
SET NOCOUNT ON;

END
GO
PRINT N'Creating [vmi].[StockInOrder$Create]...';


GO
/*
@result=Duad<MatterID, AsnNbr>
*/
--Smile
CREATE PROCEDURE [vmi].[StockInOrder$Create](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @siteID I32;
		select	@userID=UserID, @siteID=SiteID
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@now       DT=getutcdate();
		declare	@type      E8=(select  StockInOrder    from core.Matter#Type());
		declare	@stage     E32=(select InfoImported    from core.Stage#ID());
		declare	@source    E8=(select  eVMI            from core.Source#ID());
		declare	@stateID   I32=(select AsnNbrGenerated from core.State#ID());
		declare	@matterID  I64=next value for core.MatterSeq;
		declare @asnNbr    char(13)=('VMI_'+format(next value for whse.AsnNbrSeq, '000000000') );

		insert	core._Matter
				(ID,         PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		values	(@matterID,  @siteID,  @stateID, @stage, @source, @type,     @now);

		insert	whse._StockInOrder
				(       ID, RcvHubID, TotalSkuQty, ContractID)
		select   @matterID,  0,        0,          c.ID
		from	acct.Contract#For(@siteID, @source) c

		insert	core._Activity
				(  MatterID,  StateID,  UserID, TalliedOn)
		values	(@matterID, @stateID, @userID,      @now);

		insert core._RefNbr
		       ( MatterID,  Number, Type)
		select	@matterID, @asnNbr, AsnNbr
		from	core.RefNbr#Type()

		select	@result=Tvp from tvp.Duad#Make(@matterID, @asnNbr);


		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [vmi].[StorageFee$Bill]...';


GO
/*
@slip    =Triad[TenantAlias, ChargeID, Volume]
@context =Duad<Source, HubAlias>
@result  =Comma[MatterID]
*/
--Smile
CREATE PROCEDURE [vmi].[StorageFee$Bill](@slip tvp,  @context tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN	TRY
		BEGIN	TRAN;
		
		declare	@source E8=(select eVMI from core.Source#ID());
		declare	@hubID I32=(select t.ID from tvp.Duad#Of(@context, default) x 
							join   core.Tenant#Raw() t on t.Alias=x.v2);

		declare	@ledgers dbo.I64TrioAmts; --PartyID, MatterID, ChargeID, Amt
		with cte as
		(
			select	TenantID=t.ID, ChargeID=cast(x.v2 as int), Cbm=x.v3, CurrencyID
			,		Rate= (
							  case cast(x.v2 as int) 
							  when k.StorageCbmFee30Day then r.StorageCbmFee30Day
							  when k.StorageCbmFee60Day then r.StorageCbmFee60Day
							  else StorageCbmFeeOther end
						  )

			from	tvp.Triad#Slice(@slip, default, default) x
			cross	apply loc.TenantAlias#Encode(x.v1)       d
			join	core.Tenant#Raw()                        t on t.Source=@source and t.Alias=d.TenantAlias
			cross	apply whse.StorageRate#For(@hubID, t.ID) r
			cross	apply acct.Charge#ID()                   k			
		)
		insert	@ledgers select TenantID, next value for core.MatterSeq, ChargeID, Amt
		from	cte x
		cross	apply dbo.Money#Make(Cbm*Rate, CurrencyID) m
		where	not exists(
								select	ID
								from	acct.Ledger#Raw() 
								where	PartyID=x.TenantID
								and		ChargeID=x.ChargeID
								and		cast(TalliedOn as date)=cast(getutcdate() as date)
								)
		;

		declare	@type  E8=(select StorageFee from core.Matter#Type());
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	MID,  @hubID,         0,      0, @source, @type, getutcdate()
		from	@ledgers;

		declare	@ledgerSide E8=(select AR from acct.Ledger#Side());
		declare	@invoiceds  I64Array; 
		declare	@vaultType  E8=(select Fund from acct.Vault#Type());
		declare	@vaultTag   E8=(select NotDuty from acct.Vault#Tag());

		with cteInvoice as
		(
			select	LedgerPartyID=x.LID, CurrencyID, ContractID=c.ID, ChargeRawAmt=sum(m.RawAmt)
			from	@ledgers x			
			cross	apply acct.Contract#For(x.LID, @source) c
			cross	apply dbo.Money#Of(x.Amt)               m
			where	not exists(
								select	ID from acct.Contract#Raw() t 
								where	t.ID=c.ID and t.BillingCycle>0
			) 
			group	by x.LID, m.CurrencyID, c.ID
		)	
		insert	acct._Invoice
		(		PartyID,       VaultTag, LedgerSide, CurrencyID, DueBalance, InvoiceAmt, ContractID)
		output	inserted.ID into @invoiceds
		select	LedgerPartyID, @vaultTag, @ledgerSide, x.CurrencyID, x.CurrencyID, m.Amt,    ContractID
		from	cteInvoice x
		cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
		where	x.ChargeRawAmt>0;

		declare	@ledgerIDs I64Array;
		with	cteInvoiced as
		(
			select	x.ID, PartyID, CurrencyID, VaultTag, ContractID
			from	@invoiceds x
			join	acct.Invoice#Raw() i on x.ID=i.ID
		)
		-- 2	Insert  Ledger(s):
		insert	acct._Ledger
		(		PartyID,       MatterID,   ChargeID, ChargeAmt,   CurrencyID,   LedgerSide, InvoiceID)
		output	inserted.ID into @ledgerIDs
		select	x.LID, x.MID, x.RID, x.Amt, m.CurrencyID,  @ledgerSide, iif(x.Amt=m.CurrencyID, -1, isnull(i.ID, 0))
		from	@ledgers x
		cross	apply dbo.Money#Of(x.Amt) m
		cross	apply acct.Contract#For(x.LID, @source) c
		left	join cteInvoiced       i  on i.PartyID=x.LID
										 and i.CurrencyID=m.CurrencyID
										 and i.ContractID=c.ID
		;		
		with cteUnInvoiceds as
		(
			select	PartyID, x.CurrencyID, ChargeRawAmt=sum(x.ChargeRaw)
			from	@ledgerIDs l
			join	acct.Ledger#Raw() x on x.ID=l.ID
			where	InvoiceID=0
			group	by PartyID, x.CurrencyID
		), cteVaults as
		(
			select	PartyID, CurrencyID, ChargeAmt=m.Amt
			from	cteUnInvoiceds x
			cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
		)
		merge	acct._Vault as o using cteVaults as n
		on		(o.PartyID=n.PartyID and o.VaultType=@vaultType and o.CurrencyID=n.CurrencyID)
		when	matched then
				update set UninvoicedAmt=(select Amt from dbo.Money#Sum(n.ChargeAmt, o.UninvoicedAmt)), TalliedOn=getutcdate()
		when	not matched then
				insert(  PartyID,   VaultBal,    VaultType,   CurrencyID,   UninvoicedAmt)
				values(n.PartyID, n.CurrencyID, @vaultType, n.CurrencyID, n.ChargeAmt)
		;
		execute acct.Vault#XactByInvoice @invoiceds=@invoiceds, @paymentID=default, @vaultType=@vaultType;

		declare	@supplements tvp;
		with cte as
		(
			select	l.ID, Cbm=x.v3
			,		Rate= (
							  case cast(x.v2 as int) 
							  when k.StorageCbmFee30Day then r.StorageCbmFee30Day
							  when k.StorageCbmFee60Day then r.StorageCbmFee60Day
							  else StorageCbmFeeOther end
						  )

			from	tvp.Triad#Slice(@slip, default, default) x
			cross	apply loc.TenantAlias#Encode(x.v1)       d
			join	core.Tenant#Raw()                        t on t.Source=@source and t.Alias=d.TenantAlias
			cross	apply whse.StorageRate#For(@hubID, t.ID) r
			cross	apply acct.Charge#ID()                   k	
			join	acct.Ledger#Raw()                        l			
			on		l.PartyID=t.ID
			and		l.ChargeID= cast(x.v2 as int) 
			where	l.ID in (select ID from @ledgerIDs)
		)
		insert	core._Supplement(RegID, RowID, Supplement)
		select	k.Ledger, x.ID, concat(x.Cbm, N'CBM', ' * ', x.Rate)
		from	core.Registry#ID() k, cte x

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [vmi].[StockInOrder$Init]...';


GO
/*
@result=Duad<MatterID, AsnNbr>
*/
--Smile
CREATE PROCEDURE [vmi].[StockInOrder$Init](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @siteID I32;
		select	@userID=UserID, @siteID=SiteID
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@now       DT=getutcdate();
		declare	@type      E8=(select  StockInOrder      from core.Matter#Type());
		declare	@source    E8=(select  eVMI              from core.Source#ID());
		declare	@stateID   I32=(select AsnImported=11220 from core.State#ID());
		declare	@stage     E32=(select Stage  from core.Stage#Of(@stateID));
		declare	@matterID  I64=next value for core.MatterSeq;
		declare @asnNbr    char(13)=('VMI_'+format(next value for whse.AsnNbrSeq, '000000000') );

		insert	core._Matter
				(ID,         PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		values	(@matterID,  @siteID,  @stateID, @stage, @source, @type,     @now);

		insert	whse._StockInOrder
				(       ID, RcvHubID, TotalSkuQty, ContractID)
		select   @matterID,  0,        0,          c.ID
		from	acct.Contract#For(@siteID, @source) c

		insert	core._Activity
				(  MatterID,  StateID,  UserID, TalliedOn)
		values	(@matterID, @stateID, @userID,      @now);

		insert core._RefNbr
		       ( MatterID,  Number, Type)
		select	@matterID, @asnNbr, AsnNbr
		from	core.RefNbr#Type()

		select	@result=Tvp from tvp.Duad#Make(@matterID, @asnNbr);


		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [vmi].[Parcel$Release]...';


GO
/*
@result=Triad<Comma[MatterID], ReleasedSkus>
*/
--Smile
CREATE PROCEDURE [vmi].[Parcel$Release](@result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
		BEGIN TRY
		BEGIN	TRAN;
	
		declare	@source E8=(select eVMI		       from core.Source#ID())
		,		@qtype	E8=(select ReadyForRelease from core.Queue#Type());
		execute	core.OutboundQ#Dequeue @source=@source, @qtype=@qtype, @result=@result out;

		declare	@exeSlip tvp;
		with cteSkuOnHeld(text) as
		(
			select	[text()]=concat(c.Many, TenantAlias, c.Tuplet
										  , g.Sku,		 c.Tuplet 
										  , g.SkuBatch,	 c.Tuplet
										  , g.Condition, c.Tuplet
										  , l.LineQty)
			from	tvp.Quad#Slice(@result, default, default) q
			cross	apply core.RefInfo#Type() k
			join	core.RefInfo#Raw()        i on i.MatterID=cast(q.v1 as bigint) and i.Type=k.DeclaredInfo
			join	shpt.Parcel#Base()        m on m.ID=i.MatterID
			join	core.Party#Raw()          p on p.ID=m.SiteID
			join	core.Tenant#Raw()         t on t.ID=p.PID
			cross	apply loc.TenantAlias#Rectify(t.Alias) s
			cross	apply tvp.Mucho#Slice(i.Info)          d
			cross	apply loc.LineInfo#Of(d.Piece)         l
			cross	apply loc.GoodsInfo#Of(l.GoodsInfo)    g
			cross	apply tvp.Spr#Const()                  c
			for	xml path(N'')
			
		)
		select	@exeSlip=d.Tvp
		from	cteSkuOnHeld x cross apply tvp.Spr#Purify(text, default) t
		cross	apply tvp.Duad#Make(@source, t.Tvp)                      d;

		--execute	[$(FLUX_SERVER)].[$(FLUX_WMS)].svc.SkuOnHold$Release @exeSlip;

		
		;with cte(text) as
		(
			select	[text()]=concat(N',', q.v1)		
			from	tvp.Quad#Slice(@result, default, default) q				
			for		xml path(N'')
		)
		select	@result=s.Tvp from cte                     x
		cross	apply tvp.Spr#Purify(text, 1)              d
		cross	apply tvp.Triad#Make(d.Tvp, @exeSlip, N'') s;
	
		COMMIT	TRAN;
		END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [vmi].[Parcel$Init]...';


GO
/*
@slip    = Entry[Block<RefNbr, PreCourier, Shipper, Consignee, LineInfo, IDNbr, Weight, BrkgInfo, PostCourier>]
@context = Tuplet<Source, SvcType, HubID, TenantAlias, Quad[Sku, BatchNo, IsDefective, SkuQty], ErorCnt, Errors>
@result  = Comma[MatterID]
*/
--Smile
CREATE PROCEDURE [vmi].[Parcel$Init](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32,    @tenantAlias loc.Alias;
		select	@siteID=SiteID, @userID=UserID, @tenantAlias=t.TenantAlias
		from	loc.Tenancy#Of(@tenancy) x
		join	core.Party#Raw()         p on x.AID=p.ID
		cross	apply loc.TenantAlias#Rectify(p.Alias) t;

		declare	@source E8, @hubID int, @hubAlias loc.Alias
		,		@errorCnt int,   @errors json,  @poa char(3), @svcType I32
		,		@routeID I32,    @courierID I32,              @stateID I32
		,       @contractID I32, @initQueue varchar(20);
		select	@source=v1, @hubID=v3,  @hubAlias=p.Alias
		,		@errorCnt=x.v6, @errors=x.v7,  @poa=r.POA,   @svcType=t.ID
		,		@routeID=r.RouteID, @courierID=r.CourierID, @stateID=t.InitStateID
		,		@contractID=c.ID, @initQueue=t.InitQueue
		from	tvp.Tuplet#Of(@context, default)                        x
		join	core.Party#Raw()                                        p on p.ID=cast(x.v3 as int)
		cross	apply tms.SvcType#For(cast(x.v2 as int), @siteID)       t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)             r
		cross	apply acct.Contract#For(@siteID, cast(x.v1 as tinyint)) c;

		--declare	@exeSlip tvp;
		--select	@exeSlip=Tvp
		--from	tvp.Triad#Make(@tenantAlias, @source, @skus);
		--execute [$(FLUX_SERVER)].[$(FLUX_WMS)].svc.SkuOnHold$Merge @exeSlip;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	ID=next value for core.MatterSeq,   Seq=Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8 =(select Parcel from core.Matter#Type())
		,		@stage E32=(select Stage  from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID,  @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 1.1	Add OutboundQ:
		with cteq as
		(
			select	QueueType=try_cast(c.Piece as tinyint)
			from	tvp.Comma#Slice(@initQueue) c
		)
		insert	core._OutboundQ
			    (ToSource, QueueType, MatterID,  StateID)
		select	s.Source,  QueueType, ID, @stateID
		from	@idSeqs x, cteq q
		cross	apply core.Source#Rectify(@source, QueueType) s;

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef    E8, @preCourier E8, @postCourier E8
		,		@cneeInfo     E8, @shprInfo   E8, @idInfo      E8
		,		@declaredInfo E8, @brkgInfo   E8;
		select	@clientRef=n.ClientRef, @preCourier=n.PreCourier, @postCourier=n.PostCourier    
		,		@cneeInfo=i.CneeInfo,   @shprInfo=i.ShprInfo,     @idInfo=i.IDInfo
		,		@declaredInfo=i.DeclaredInfo, @brkgInfo=i.BrokerageInfo
		from	core.RefNbr#Type() n, core.RefInfo#Type() i

--> NEW:
		declare	@cells dbo.Cells;
		insert	@cells
		(		  Col,   Row,   Val)
		select	c.Col,  x.ID, c.Val
		from	@idSeqs x join tvp.Cell#Slice(@slip, default, default) c on x.Seq=c.Row

		execute	core.RefNbr#AddMIC @idSeqs=@idSeqs, @source=@source, @type=@type;

		execute	core.RefNbr#AddViaCells  @column=1, @cells=@cells, @type=@clientRef;
		execute	core.RefNbr#AddViaCells  @column=2, @cells=@cells, @type=@preCourier;
		execute	core.RefNbr#AddViaCells  @column=9, @cells=@cells, @type=@postCourier;

		execute	core.RefInfo#AddViaCells @column=3, @cells=@cells, @type=@shprInfo;
		execute	core.RefInfo#AddViaCells @column=4, @cells=@cells, @type=@cneeInfo;
		execute	core.RefInfo#AddViaCells @column=5, @cells=@cells, @type=@declaredInfo;
		execute	core.RefInfo#AddViaCells @column=6, @cells=@cells, @type=@idInfo;
		execute	core.RefInfo#AddViaCells @column=8, @cells=@cells, @type=@brkgInfo;

		-- 3.	Add Batch & Parcels:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=@errorCnt, @errors=@errors;

		insert	shpt._Parcel
		(		ID,     BatchID,  RouteID,  LastMilerID,  SvcType, SvcZone, SvcClass,  POA, DeclaredWt, Weight,  ContractID,  RcvHubID)
		select	x.Row, @batchID, @routeID, @courierID,   @svcType, 1,       1,        @poa, x.Val,      0,      @contractID, @hubID
		from	@cells x where x.Col=7
--> ORI:
/*
		execute	core.RefNbr#AddMIC @idSeqs=@idSeqs, @source=@source, @type=@type;

		execute	core.RefNbr#AddBlock  @index=1, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefNbr#AddBlock  @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@preCourier;
		execute	core.RefNbr#AddBlock  @index=9, @idSeqs=@idSeqs, @slip=@slip, @type=@postCourier;

		execute	core.RefInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@declaredInfo;
		execute	core.RefInfo#AddBlock @index=6, @idSeqs=@idSeqs, @slip=@slip, @type=@idInfo;
		execute	core.RefInfo#AddBlock @index=8, @idSeqs=@idSeqs, @slip=@slip, @type=@brkgInfo;

		-- 3.	Add Batch & Parcels:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=@errorCnt, @errors=@errors;

		insert	shpt._Parcel
		(		ID,        BatchID,  RouteID,  LastMilerID, SvcType, SvcZone, SvcClass,  POA, DeclaredWt,  Weight, ContractID,  RcvHubID)
		select	x.Master, @batchID, @routeID, @courierID,  @svcType, 1,       1,        @poa, x.House,     0,     @contractID, @hubID
		from	tvp.Block#FoldT(7, @idSeqs, @slip, default, default) x 
*/	
		-- 4.	Result:
		;with cte(text) as
		(
			select	[text()]=concat(N',', q.ID)		
			from	@idSeqs     q				
			for		xml path(N'')
		)
		select	@result=d.Tvp from cte                     x
		cross	apply tvp.Spr#Purify(text, 1)              d;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [whse].[RcvSkuFee#Bill]...';


GO
--Smile
CREATE PROCEDURE [whse].[RcvSkuFee#Bill](@orderIDs dbo.I64Array readonly)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

	-- 1	Insert  Invoice(s):
		declare	@ledgerSide E8=(select AR from acct.Ledger#Side());
		declare	@invoiceds I64Array; 
		declare	@vaultType  E8=(select Fund from acct.Vault#Type());

		declare	@chargeID  I32,  @vaultTag E8;
		select	@chargeID=ID,    @vaultTag=VaultTag
		from	acct.Charge#ID() k, acct.Charge#Raw() c
		where	c.ID=k.RcvSkuFee;

		with cteInvoice as
		(
			select	LedgerPartyID=p.AID, CurrencyID, x.ContractID, ChargeRawAmt=sum(m.RawAmt)
			from	whse.StockInOrder#Base()                         x
			join	core.Party#Raw()                                 p on p.ID=x.SiteID
			cross	apply whse.StorageRate#For(x.RcvHubID, x.SiteID) s
			cross	apply dbo.Money#Make(s.RcvSkuFee*x.TotalSkuQty, s.CurrencyID) m
			where	not exists(
								select	ID from acct.Contract#Raw() t 
								where	t.ID=x.ContractID and t.BillingCycle>0
			) 
			and		x.ID in (select ID from @orderIDs)
			group	by P.AID, s.CurrencyID, x.ContractID
		)	
		insert	acct._Invoice
		(		PartyID,       VaultTag, LedgerSide, CurrencyID, DueBalance, InvoiceAmt, ContractID)
		output	inserted.ID into @invoiceds
		select	LedgerPartyID, @vaultTag, @ledgerSide, x.CurrencyID, 0,         m.Amt,    ContractID
		from	cteInvoice x
		cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m;

		declare	@ledgerIDs I64Array;
		with	cteInvoiced as
		(
			select	x.ID, PartyID, CurrencyID, VaultTag, ContractID
			from	@invoiceds x
			join	acct.Invoice#Raw() i on x.ID=i.ID
		)
		-- 2	Insert  Ledger(s):
		insert	acct._Ledger
		(		PartyID,       MatterID,   ChargeID, ChargeAmt,   CurrencyID,   LedgerSide, InvoiceID)
		output	inserted.ID into @ledgerIDs
		select	p.AID, x.ID, @chargeID, m.Amt, s.CurrencyID,  @ledgerSide, isnull(i.ID,0)
		from	whse.StockInOrder#Base()                         x
		join	core.Party#Raw()                                 p on p.ID=x.SiteID
		cross	apply whse.StorageRate#For(x.RcvHubID, x.SiteID) s
		cross	apply dbo.Money#Make(s.RcvSkuFee*x.TotalSkuQty, s.CurrencyID) m
		left	join cteInvoiced       i  on i.PartyID=p.AID 
										 and i.CurrencyID=s.CurrencyID
										 and i.ContractID=x.ContractID
		where	x.ID in (select ID from @orderIDs)
		;		
		with cteUnInvoiceds as
		(
			select	PartyID, x.CurrencyID, ChargeRawAmt=sum(x.ChargeRaw)
			from	@ledgerIDs l
			join	acct.Ledger#Raw() x on x.ID=l.ID
			where	InvoiceID=0
			group	by PartyID, x.CurrencyID
		), cteVaults as
		(
			select	PartyID, CurrencyID, ChargeAmt=m.Amt
			from	cteUnInvoiceds x
			cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
		)
		merge	acct._Vault as o using cteVaults as n
		on		(o.PartyID=n.PartyID and o.VaultType=@vaultType and o.CurrencyID=n.CurrencyID)
		when	matched then
				update set UninvoicedAmt=(select Amt from dbo.Money#Sum(n.ChargeAmt, o.UninvoicedAmt)), TalliedOn=getutcdate()
		when	not matched then
				insert(  PartyID,   VaultBal,    VaultType,   CurrencyID,   UninvoicedAmt)
				values(n.PartyID, n.CurrencyID, @vaultType, n.CurrencyID, n.ChargeAmt)
		;
		execute acct.Vault#XactByInvoice @invoiceds=@invoiceds, @paymentID=default, @vaultType=@vaultType;


		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [whse].[@------------------@whse]...';


GO
CREATE PROCEDURE [whse].[@------------------@whse]
AS
BEGIN
	SET NOCOUNT ON;
/*
	
*/
END
GO
PRINT N'Creating [whse].[RackOrder#Create]...';


GO
--Smile, PeterHo
CREATE PROCEDURE [whse].[RackOrder#Create](@id I32 out, @rackerID I32, @orderType E8)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	insert	whse._RackOrder
			( RackerID,  OrderType)--, CreatedOn,    CompletedOn)
	values	(@rackerID, @orderType)--, getutcdate(), dbo.DT@Empty())
	select  @id=scope_identity();
END
GO
PRINT N'Creating [xpd].[Parcel$InitForXpd]...';


GO
/*
@slip    = at.Tvp.Block.Join(RefNbr, ShprInfo, CneeInfo
,          DeclaredInfo[Quad.Join(GoodsInfo, LineQty, LineTotal, CmdyID).Over(at.Tvp.Mucho)]
,          BrokerageInfo[Triad.Join(SkuID, CmdyInfo, Quad.Join(GoodsInfo, LineQty, LineTotal, CmdyID)).Over(at.Tvp.Mucho)]
,          Weight, Height, Width, Length ).Over(at.Tvp.Entry)
@context = at.Duad.Join(Source, SvcType)
*/
--Daxia
CREATE PROCEDURE [xpd].[Parcel$InitForXpd](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32;
		select	@siteID=SiteID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy);

		declare	@source E8, @errorCnt int, @errors json, @svcType I32,  @routeID I32,       @courierID I32,         @stateID I32,           @contractID I32;
		select	@source=v1, @errorCnt=0,   @errors=N'',  @svcType=t.ID, @routeID=r.RouteID, @courierID=r.CourierID, @stateID=t.InitStateID, @contractID=c.ID
		from	tvp.Duad#Of(@context, default)                          x
		cross	apply tms.SvcType#For(cast(x.v2 as int), @siteID)       t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)             r
		cross	apply acct.Contract#For(@siteID, cast(x.v1 as tinyint)) c;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@stage E32=(select Stage  from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID,  @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef E8,          @shprInfo E8,         @cneeInfo E8,          @declaredInfo E8,             @brkgInfo E8;
		select	@clientRef=n.ClientRef, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo,  @declaredInfo=i.DeclaredInfo, @brkgInfo=i.BrokerageInfo
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;

		execute	core.RefNbr#AddBlock  @index=1, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefInfo#AddBlock @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@declaredInfo;
		execute	core.RefInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@brkgInfo;

		-- 3.	Add Batch:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=@errorCnt, @errors=@errors;

		-- 3.	Add Parcels: TODO: add ZoneCode Slice Function.
		insert	shpt._Parcel
		(		ID,  BatchID,  RouteID, LastMilerID,  SvcType, SvcZone,   SvcClass,   POA,  ContractID, Weight, DeclaredWt, Height, Width, Length, ZoneCode)
		select	ID, @batchID, @routeID, @courierID,  @svcType,  z.Zone, c.SvcClass, f.POA, @contractID, s.v6,   s.v6,       s.v7,   s.v8,  s.v9,   left(i.v11, 5)
		from	@idSeqs x join tvp.Field#Slice(@slip, N'	%	', default) s on s.Seq=x.Seq
		cross	apply tms.SvcClass#For(@svcType, s.v6)                                   c
		cross	apply tvp.Dozen#Of(s.v3, default)                                        i
		cross	apply tms.SvcFacility#For(@source, c.SvcClass, left(i.v11, 3))           f
		outer	apply tms.SvcZone#For(@source, c.SvcClass, f.ImportZip3, left(i.v11, 3)) z;

		-- 5.	Result:
		with cteResult(text) as
		(
			select	[text()]=concat(k.Many, c.Number, k.Duad, m.Number)
			from	tvp.Spr#Const() k, @idSeqs x
			cross	apply core.RefNbr#Type()   t
			join	core.RefNbr#Raw() m on m.MatterID=x.ID and m.Type=t.MIT
			join	core.RefNbr#Raw() c on c.MatterID=x.ID and c.Type=t.ClientRef
			for		xml path(N'')
		)
		select	@result=r.Tvp from cteResult
		cross	apply tvp.Spr#Purify(text, default)  x
		cross	apply tvp.Pair#Make(@batchID, x.Tvp) r
		;
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [xpd].[@-------------------@xpd]...';


GO
CREATE PROCEDURE [xpd].[@-------------------@xpd]
AS
BEGIN
SET NOCOUNT ON;
/*



*/
END
GO
PRINT N'Creating [xpd].[Parcel$UpdateForXpd]...';


GO
/*
@slip    = =Many[Triad<MIC, RefInfoType, RefInfo>]
*/
--Aimee
CREATE PROCEDURE [xpd].[Parcel$UpdateForXpd](@slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;

		declare @exeSlip tvp;
		with cteParcel(text) as
		(
			select	[text()]=concat(k.Many, m.MatterID, k.Triad, x.v2, k.Triad, x.v3)
			from	tvp.Triad#Slice(@slip, default, default) x
			cross	apply core.MIC#IdOf(x.v1) m
			join	core.Matter#Raw()         t on t.ID=m.MatterID
			cross	apply core.Stage#ID()     s
			cross	apply tvp.Spr#Const()     k
			where	t.Stage<=s.RouteAssigned
			for		xml path(N'')
		)
		select @exeSlip=Tvp from cteParcel cross apply tvp.Spr#Purify(text, default);
		execute core.RefInfo#Merge @slip=@exeSlip;
	
END
GO
PRINT N'Creating [xpd].[SackMft$UploadLabelForXpd]...';


GO
/*
	@slip = Duad<mawbNbr, FileBankID>
*/
-- Aimee
CREATE PROCEDURE [xpd].[SackMft$UploadLabelForXpd](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	BEGIN TRY
		BEGIN	TRAN;
			declare	@siteID I32=(select SiteID from loc.Tenancy#Of(@tenancy));
			with cte as
			(
				select	RegID=k.Matter, RowID=cast(x.v1 as bigint), AuxID=31, FileBankID=x.v2, PosterID=@siteID -- HACK
				from	tvp.Duad#Slice(@slip, default, default) x
				cross	apply core.Attachment#Type()            t
				cross	apply core.Registry#ID()                k
			)
			merge	core._Attachment as o using cte as n
			on		(o.RegID=n.RegID and o.RowID=n.RowID and o.AuxID=n.AuxID and o.PosterID=n.PosterID)
			when	matched then update set FileBankID=n.FileBankID
			when	not matched then 
					insert(  RegID,   RowID,   AuxID,   PosterID,   FileBankID, PostedOn)
					values(n.RegID, n.RowID, n.AuxID, n.PosterID, n.FileBankID, getutcdate())
					;
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [xpd].[Parcel$ReweighForXpd]...';


GO
/*
@slip	= at.Duad.Join(Mic, Weight).Over(at.Tvp.Many)
@context= Source
@result	= at.Many.Join(ParcelID)
*/
-- Aimee
CREATE PROCEDURE [xpd].[Parcel$ReweighForXpd](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		 --0.	Tenancy & Contexts:
		declare @siteID I32=(select SiteID from	loc.Tenancy#Of(@tenancy));
		declare	@source E8=@context;

		-- 1.	Prepare IdTexts:
		declare	@idTexts I64Texts; 
		insert	@idTexts(ID, Text) select m.MatterID, v2
		from	tvp.Duad#Slice(@slip, default, default)           x
		cross	apply core.RefNbr#ScanOne(x.v1, default, default) m  --
		join	core.Matter#Raw() p on p.ID=m.MatterID
		where	p.PosterID=@siteID;

		-- 2.	Update Parcel Weight:
		update	o set o.Weight=n.Text 
		from	shpt._Parcel o join @idTexts n on n.ID=o.ID;

		-- 3.	Prepare LabelSpecs:
		declare	@labelSpecs as table 
		(
			Seq         I32  identity(1,1)
		,	ID          I64  not null
		,	NewWeight   real not null
		,	NewSvcClass I32  not null
		);
		insert	@labelSpecs
		(		  ID, NewWeight, NewSvcClass)
		select	m.ID, x.v2,       s.SvcClass
		from	tvp.Duad#Slice(@slip, default, default)           x
		cross	apply core.RefNbr#ScanOne(x.v1, default, default) r
		join	shpt.Parcel#Base() m on m.ID=r.MatterID
		cross	apply tms.SvcClass#For(m.SvcType, x.v2) s
		where	m.SvcClass<>s.SvcClass and m.SiteID=@siteID

		-- 4.	Prepare PicSpecs:
		declare	@picSpec tms.PicSpec; insert @picSpec
		(		MeasuredWt,    SvcType, Zip3,                Plus2)
		select	x.NewWeight, m.SvcType, left(m.ZoneCode, 3), substring(m.ZoneCode, 4, 2)
		from	@labelSpecs x join shpt.Parcel#Raw() m on m.ID=x.ID

		-- 5.	Emit PICs:
		declare	@picResult tms.PicResult; insert @picResult
		exec	tms.Pic#Emit @source=@source, @picSpec=@picSpec;

		-- 6.	Update PostCourier and SvcClass
		update	o set SvcClass=n.NewSvcClass
		from	shpt._Parcel o join @labelSpecs n on n.ID=o.ID;

		declare	@postCourier E8=(select PostCourier from core.RefNbr#Type());
		update	o set o.Number=t.TrackingNbr 
		from	core._RefNbr o
		join	@labelSpecs  n on (n.ID=o.MatterID and o.Type=@postCourier)
		join	@picResult   r on r.SeqNbr=n.Seq
		cross	apply tms.TrackingNbr#Make(r.SvcCode, r.MailerID, r.MailerSeq, n.ID) t;

		-- 7.	Result
		with cteResult(text) as
		(
			select	[text()]=concat(k.Many, x.ID)
			from	tvp.Spr#Const() k, @idTexts x
			for		xml path(N'')
		)
		select	@result=x.Tvp from cteResult 
		cross	apply tvp.Spr#Purify(text, default)  x
		;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [zeb].[RefNbr$Merge]...';


GO
--Eva
CREATE PROCEDURE [zeb].[RefNbr$Merge](@slip nvarchar(max))
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	
	execute	core.RefNbr#Merge @slip=@slip;
END
GO
PRINT N'Creating [zeb].[OutboundQ$Dequeue]...';


GO
--Eva
CREATE PROCEDURE [zeb].[OutboundQ$Dequeue](@source E8, @qtype E8=0, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	execute	core.OutboundQ#Dequeue @source=@source, @qtype=@qtype, @result=@result out
END
GO
PRINT N'Creating [zeb].[@-------------------@zeb]...';


GO
CREATE PROCEDURE [zeb].[@-------------------@zeb]
AS
BEGIN
SET NOCOUNT ON;
/*



*/
END
GO
PRINT N'Creating [zeb].[RefInfo$Merge]...';


GO
--AaronLiu
CREATE PROCEDURE [zeb].[RefInfo$Merge](@slip nvarchar(max))
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	
	execute	core.RefInfo#Merge @slip=@slip;
END
GO
PRINT N'Creating [zeb].[Parcel$InitForZeb]...';


GO
/*
@slip    = at.Tvp.Block.Join(IDInfo, ShprInof, CneeInfo, DeclaredInfo:Mucho[GoodsInfo])
@context = at.Quad.Join(SvcType)
*/
--PeterHo
CREATE PROCEDURE [zeb].[Parcel$InitForZeb](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32;
		select	@siteID=SiteID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy);

		declare	@source E8,    @poa char(3), @svcType I32,  @routeID I32,       @courierID I32,         @stateID I32;
		select	@source=s.ZEB, @poa=r.POA,   @svcType=t.ID, @routeID=r.RouteID, @courierID=r.CourierID, @stateID=t.InitStateID
		from	tms.SvcType#For(cast(@context as int), @siteID) t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA) r
		cross	apply core.Source#ID() s;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@stage E32=(select Stage  from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID,  @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 2.	Add RefNbrs & RefInfos:
		declare	@idInfo E8,       @shprInfo E8,         @cneeInfo E8,         @declaredInfo E8;
		select	@idInfo=i.IDInfo, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo, @declaredInfo=i.DeclaredInfo 
		from	core.RefInfo#Type() i

		execute	core.RefNbr#AddMIC    @idSeqs=@idSeqs,   @source=@source,     @type=@type;
		execute	core.RefInfo#AddBlock @index=1, @idSeqs=@idSeqs, @slip=@slip, @type=@idInfo;
		execute	core.RefInfo#AddBlock @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@declaredInfo;

		declare	@contractID I32=(select ID from acct.Contract#For(@siteID, @source));
		insert	shpt._Parcel
		(		ID, BatchID,  RouteID,  LastMilerID,  SvcType, SvcZone, SvcClass,  POA,  ContractID)
		select	ID, 0,       @routeID, @courierID,   @svcType, 1,       1,        @poa, @contractID
		from	@idSeqs;

		-- 4.	Result:
		select	@result=(select Tvp from tvp.I64Seqs#Join(@idSeqs));

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [zeb].[Zack$InitForZeb]...';


GO
/*
	NOTE: Just for hold batch parcel, nothing else.
*/
-- AaronLiu
CREATE PROCEDURE [zeb].[Zack$InitForZeb](@slip tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32;
		select	@siteID=SiteID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy);

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(1);

		declare	@source   E8=(select ZEB				from core.Source#ID())
		,		@type     E8=(select Zack				from core.Matter#Type())
		,		@stateID I32=(select ZackReceived=25010 from core.State#ID())    -- Todo: Refine
		declare	@stage   E32=(select Stage				from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID, PosterID, StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID, @siteID, @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		-- 2.	Result:
		select	@result=(select Tvp from tvp.I64Seqs#Join(@idSeqs));

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [zeb].[Parcel$UpdForZeb]...';


GO
/*
	@slip = Duad.Join(parcelID, svcTypeID)
*/
-- AaronLiu
CREATE PROCEDURE [zeb].[Parcel$UpdForZeb](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@siteID I32,    @userID I32;
		select	@siteID=SiteID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy);

		declare	@parcelID I64, @svcTypeID I32;
		select	@parcelID =v1, @svcTypeID =v2
		from	tvp.Duad#Of(@slip, default);

		declare	@poa char(3), @routeID I32,     @lastMilerID I32;
		select	@poa=POA,     @routeID=RouteID, @lastMilerID=CourierID
		from	tms.SvcType#For(@svcTypeID, @siteID)		x
		cross	apply tms.SvcRoute#For(x.ID, x.FallbackPOA) s;

		update	shpt._Parcel
		set		SvcType=@svcTypeID, POA=@poa, RouteID=@routeID, LastMilerID=@lastMilerID
		where	ID=@parcelID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [zeb].[PIP$InitForZeb]...';


GO
/*
	@slip = Entry<Block[Comma<ParcelIDs>, ShprInfo, CneeInfo]>
	NOTE: PIP = Parcel in Parcel.
*/
-- AaronLiu
CREATE PROCEDURE [zeb].[PIP$InitForZeb](@slip tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32;
		select	@siteID=SiteID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy);

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@source   E8=(select ZEB			  from core.Source#ID())
		,		@type     E8=(select PIP			  from core.Matter#Type())
		,		@stateID I32=(select PIPCreated=27010 from core.State#ID()) -- Todo: Add 27010 To core.State#ID()
		declare	@stage   E32=(select Stage			  from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID, PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID,  @siteID, @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 2.	Add RefNbrs & RefInfos:
		declare	@shprInfo E8=(select ShprInfo from core.RefInfo#Type())
		,		@ceeeInfo E8=(select CneeInfo from core.RefInfo#Type())
		;
		execute	core.RefNbr#AddMIC				@idSeqs=@idSeqs, @source=@source, @type=@type;
		execute	core.RefInfo#AddBlock @index=2, @idSeqs=@idSeqs, @slip=@slip,	  @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip,	  @type=@ceeeInfo;

		-- 3.	Move Parcel Into PIP
		with	cte as
		(
			select	m.ID, m.AID, NewAID=x.Master
			from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default) x
			cross	apply tvp.I64#Slice(x.House) h
			join	core.Matter#Raw()			 m on h.ID=m.ID
		)
		update	cte set AID=NewAID;

		declare	@contractID I32=(select ID from acct.Contract#For(@siteID, @source));
		insert	shpt._Parcel
		(		ID, BatchID, RouteID, LastMilerID, SvcType, SvcZone, SvcClass, POA,  ContractID)
		select	ID, 0,       0,		  0,		   0,		1,       1,        N'', @contractID
		from	@idSeqs;

		-- 3.	Result:
		select	@result=(select Tvp from tvp.I64Seqs#Join(@idSeqs));

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [zeb].[PIP$Append]...';


GO
/*
	@slip	 = Comma<ParcelID>
	@context = PIPID
*/
-- AaronLiu
CREATE PROCEDURE [zeb].[PIP$Append](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		with	cte as
		(
			select	m.ID, m.AID
			from	tvp.I64#Slice(@slip) x
			join	core.Matter#Raw()	 m on x.ID=m.ID
		)
		update	cte set AID=@context;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH 
END
GO
PRINT N'Creating [zeb].[Parcel$Reset]...';


GO
/*
	@slip    = Comma<ParcelID>
*/
-- AaronLiu
CREATE PROCEDURE [zeb].[Parcel$Reset](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		with	cte as
		(
			select	m.ID, m.AID
			from	tvp.I64#Slice(@slip) x
			join	core.Matter#Raw()	 m on x.ID=m.ID
		)
		update	cte set AID=0;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH 
END
GO
PRINT N'Creating [zeb].[Appt$InitForZeb]...';


GO
/*
	NOTE: Just for hold batch parcel, nothing else.
*/
-- AaronLiu
CREATE PROCEDURE [zeb].[Appt$InitForZeb](@slip tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32;
		select	@siteID=SiteID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy);

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(1);

		declare	@source   E8=(select ZEB				from core.Source#ID())
		,		@type     E8=(select Appointment		from core.Matter#Type())
		,		@stateID I32=(select ApptReceived=26010 from core.State#ID())    -- Todo: Refine
		declare	@stage   E32=(select Stage				from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID, PosterID, StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID, @siteID, @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		-- 2.	Result:
		select	@result=(select Tvp from tvp.I64Seqs#Join(@idSeqs));

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [dbo].[@-------------------@dbo]...';


GO
CREATE PROCEDURE [dbo].[@-------------------@dbo]
AS
BEGIN
	SET NOCOUNT ON;
/*
	-- Transaction Block:
	SET NOCOUNT     ON;
	SET XACT_ABORT  ON;
--	SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
	BEGIN TRY
		BEGIN	TRAN;

		--	Statement goes to here...

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH


	-- Common Commands:
	dbcc checkident(['Schema.Table'], reseed, 100);


	SET IDENTITY_INSERT [schema].[Table] ON
	--	Insert statement comes here...
	SET IDENTITY_INSERT [schema].[Table] OFF
*/
END
GO
PRINT N'Creating [dbo].[Assert#Concurrency]...';


GO
CREATE PROCEDURE [dbo].[Assert#Concurrency]
WITH ENCRYPTION
AS
BEGIN ----SET NOCOUNT ON;
	if (@@ROWCOUNT<>0) return;
	throw 50000, N'{{ The data had been altered since last read. }}', 0;
END
GO
PRINT N'Creating [dbo].[Assert#Fail]...';


GO
CREATE PROCEDURE [dbo].[Assert#Fail](@msg NVARCHAR (2048)=null, @state TINYINT=0)
WITH ENCRYPTION
AS
BEGIN ----SET NOCOUNT ON;
	declare	@message nvarchar(2048) = concat(N'{{', iif(@msg is null, N'Failed', @msg), N'}}');
	declare	@exstate tinyint = iif(@state is null, 0, @state);
	throw 50000, @message, @exstate;
END
GO
PRINT N'Creating [dbo].[Assert#RowCntEQ]...';


GO
CREATE PROCEDURE [dbo].[Assert#RowCntEQ](@rowCnt INT, @msg NVARCHAR (2048)=null, @state TINYINT=0)
WITH ENCRYPTION
AS
BEGIN ----SET NOCOUNT ON;
	if (@@ROWCOUNT = @rowCnt) return;
	declare	@message nvarchar(2048) = concat(N'{{', iif(@msg is null, N'The data had been altered since last read.', @msg), N'}}');
	declare	@exstate tinyint = iif(@state is null, 0, @state);
	throw 50000, @message, @exstate;
END
GO
PRINT N'Creating [dbo].[Assert#RowCntNE]...';


GO
CREATE PROCEDURE [dbo].[Assert#RowCntNE](@rowCnt INT, @msg NVARCHAR (2048)=null, @state TINYINT=0)
WITH ENCRYPTION
AS
BEGIN ----SET NOCOUNT ON;
	if (@@ROWCOUNT <> @rowCnt) return;
	declare	@message nvarchar(2048) = concat(N'{{', iif(@msg is null, N'The data had been altered since last read.', @msg), N'}}');
	declare	@exstate tinyint = iif(@state is null, 0, @state);
	throw 50000, @message, @exstate;
END
GO
PRINT N'Creating [dbo].[Assert#Transited]...';


GO
CREATE PROCEDURE [dbo].[Assert#Transited](@rowCnt INT, @state TINYINT=0)
WITH ENCRYPTION
AS
BEGIN ----SET NOCOUNT ON;
	if (@@ROWCOUNT=@rowCnt) return;
	throw 50000, N'{{ State Transition Violation }}', @state;
END
GO
PRINT N'Creating [acct].[Payment#Insert]...';


GO
--Smile, PeterHo
CREATE PROCEDURE [acct].[Payment#Insert]
(
	@partyID   I32,  @ledgerSide E8,   @xactAmt amt,
	@payMethod E8,   @supplement nax,  @id  I64 out
)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@currencyID E8=(select CurrencyID from dbo.Currency#Decode(@xactAmt));

		insert	acct._Payment
				( PartyID,  LedgerSide,  CurrencyID,  PayMethod,  PaidAmt)
		values	(@partyID, @ledgerSide, @currencyID, @payMethod, @xactAmt);
		select	 @id=scope_identity();
		
		declare	@regID I32=(select Payment from core.Registry#ID());
		execute	core.Supplement#Merge @regID=@regID, @rowID=@id, @supplement=@supplement;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[Brokerage$Dequeue]...';


GO
-- Eason
CREATE PROCEDURE [api].[Brokerage$Dequeue](@source tinyint, @qtype tinyint, @result tvp out)
AS
BEGIN
	SET NOCOUNT ON;

	execute	core.OutboundQ#Dequeue @source=@source, @qtype=@qtype, @result=@result out;
END
GO
PRINT N'Creating [api].[SubscribeCallback$Dequeue]...';


GO
-- Jim Qiu, Smile, AaronLiu
CREATE PROCEDURE [api].[SubscribeCallback$Dequeue](@result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@source	E8=(select eShip             from core.Source#ID())
		,		@qtype	E8=(select SubscribeCallback from core.Queue#Type());
		execute	core.OutboundQ#Dequeue @source=@source, @qtype=@qtype, @result=@result out;

		with cte(text) as
		(
			select	[text()]=concat
			(
				k.Many,  x.ID,          k.Quire, x.MIC,         k.Quire, x.FlightNbr,
				k.Quire, x.POA,         k.Quire, x.POD,         k.Quire, x.LastMilerID,
				k.Quire, x.PostCourier, k.Quire, x.RcvHubAlias, k.Quire, a.Stage,
				k.Quire, s.RefNbr,		k.Quire, a.UtcTime,		k.Quire, a.UtcOffset,
				k.Quire, x.RouteID
			)
			from	tvp.Spr#Const() k, tvp.Quad#Slice(@result, default, default) q
			join	svc.Parcel$ListForCainiao()    x on x.ID=cast(v1 as bigint)
			cross	apply core.Activity#TrackSpecific(  x.ID,cast(v2 as    int)) a
			join	api.ActivitySubscription#Raw() s on s.MatterID=x.ID		
			for		xml path(N'')
		)
		select	@result=Tvp from cte cross apply tvp.Spr#Purify(text, default);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[Activity$Subscribe]...';


GO
-- JimQiu, Smile, AaronLiu
CREATE PROCEDURE [api].[Activity$Subscribe](@mic varchar(40), @refNbr varchar(16))
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@matterID I64=(select MatterID from core.MIC#IdOf(@mic));

		insert	api._ActivitySubscription
		(		 MatterID,  RefNbr) 
		values(	@matterID, @refNbr)

		insert	core._OutboundQ select ToSource, QueueType, dateadd(millisecond, 10, QueuedOn), x.MatterID, StateID 
		from	core.Queue#OutboundX()    x
		cross	apply core.Queue#Type()   k
		where	x.MatterID=@matterID
		and		x.QueueType=k.SubscribeCallback 
		and		x.QueuedOn<GETUTCDATE()

		declare	@source E8=(select InfoPath from core.Source#ID())
		,		@qtype	E8=(select SubscriberRegister=207 from core.Queue#Type()); --HACK
		execute	core.OutboundQ#Enqueue @source=@source, @qtype=@qtype, @matterID=@matterID, @stateID=0;
	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[IDInfoReview$Dequeue]...';


GO
-- AaronLiu
CREATE PROCEDURE [api].[IDInfoReview$Dequeue](@result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@source E8=(select InfoPath		from core.Source#ID())
		,		@qtype	E8=(select IDInfoReview from core.Queue#Type());
		execute	core.OutboundQ#Dequeue @source=@source, @qtype=@qtype, @result=@result out;

		with cte(text) as
		(
			select	[text()]=concat
			(	
				k.Entry, x.ID,
				k.Block, x.RefNbrs,
				k.Block, x.RefInfos
			)
			from	tvp.Spr#Const()	k, tvp.Quad#Slice(@result, default, default) q
			join	shpt.Parcel#Deep() x on x.ID=cast(q.v1 as bigint)			
			for		xml path(N'')
		)
		select	@result=Tvp from cte cross apply tvp.Spr#Purify(text, default);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[PolyCallback$Dequeue]...';


GO
-- AaronLiu
CREATE PROCEDURE [api].[PolyCallback$Dequeue](@result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@source E8=(select eShip		from core.Source#ID())
		,		@qtype	E8=(select PolyCallback from core.Queue#Type());
		execute	core.OutboundQ#Dequeue @source=@source, @qtype=@qtype, @result=@result out;

		with cte(text) as
		(
			select	[text()]=concat
			(	
				k.Entry, x.ID,
				k.Block, x.SiteID,
				k.Block, x.RefNbrs,
				k.Block, i.Info
			)
			from	tvp.Spr#Const()	k, tvp.Quad#Slice(@result, default, default) q
			join	shpt.Parcel#Deep()		    x on x.ID=cast(q.v1 as bigint)	
			cross	apply core.RefInfo#Type()   t
			cross	apply core.RefInfo#Of(x.ID, t.IDInfo) i
			for		xml path(N'')
		)
		select	@result=Tvp from cte cross apply tvp.Spr#Purify(text, default);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[IDInfo$Dequeue]...';


GO
-- AaronLiu
CREATE PROCEDURE [api].[IDInfo$Dequeue](@result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@source E8=(select InfoPath		  from core.Source#ID())
		,		@qtype	E8=(select IDInfoRequired from core.Queue#Type());
		execute	core.OutboundQ#Dequeue @source=@source, @qtype=@qtype, @result=@result out;

		with cte(text) as
		(
			select	[text()]=concat
			(	
				k.Entry, x.ID,
				k.Block, x.RefNbrs,
				k.Block, x.RefInfos
			)
			from	tvp.Spr#Const()	k, tvp.Quad#Slice(@result, default, default) q
			join	shpt.Parcel#Deep() x on x.ID=cast(q.v1 as bigint)			
			for		xml path(N'')
		)
		select	@result=Tvp from cte cross apply tvp.Spr#Purify(text, default);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[Snapshot$Merge]...';


GO
/*
	@slip = Many[Duad<Number, Mucho<FilebankID>>]

	SnapshotInfo = Mucho<FilebankID>
*/
-- AaronLiu
CREATE PROCEDURE [api].[Snapshot$Merge](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		with	cte(text) as
		(
			select	[text()]= concat
			(
				k.Many,  m.MatterID,
				k.Triad, t.SnapshotInfo,
				k.Triad, x.v2
			)
			from	tvp.Spr#Const() k, tvp.Duad#Slice(@slip, default, default) x
			cross	apply core.RefNbr#ScanOne(x.v1, default, default)		   m
			cross	apply core.RefInfo#Type() t
			for		xml path(N'')
		)
		select	@slip=Tvp from cte cross apply tvp.Spr#Purify(text, default);
		execute	core.RefInfo#Merge @slip=@slip;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[PostCourier$DequeueForTC]...';


GO
-- AaronLiu
CREATE PROCEDURE [api].[PostCourier$DequeueForTC](@result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@source E8=(select InfoPath		  from core.Source#ID())
		,		@qtype	E8=(select PostCourierApi from core.Queue#Type());
		execute	core.OutboundQ#Dequeue @source=@source, @qtype=@qtype, @result=@result out;

		with cte(text) as
		(
			select	[text()]=concat
			(	
				k.Many, x.ID,
				k.Quad, x.RouteID,
				k.Quad, x.LastMilerID,
				k.Quad, n.Number
			)
			from	tvp.Spr#Const() k, tvp.Quad#Slice(@result, default, default) q
			join	shpt.Parcel#Deep()		   x on x.ID=cast(q.v1 as bigint)
			cross	apply core.RefNbr#Type()   t
			cross	apply core.RefNbr#Of(x.ID, t.PostCourier) n
			for		xml path(N'')
		)
		select	@result=Tvp from cte cross apply tvp.Spr#Purify(text, default);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[PostCourier$DequeueForPull]...';


GO
-- AaronLiu
CREATE PROCEDURE [api].[PostCourier$DequeueForPull](@result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@source E8=(select InfoPath			   from core.Source#ID())
		,		@qtype	E8=(select PostCourierPull=204 from core.Queue#Type()); --HACK
		execute	core.OutboundQ#Dequeue @source=@source, @qtype=@qtype, @result=@result out;

		with cte(text) as
		(
			select	[text()]=concat
			(	
				k.Many,	  q.v1,
				k.Tuplet, m.Number,
				k.Tuplet, p.Number,
				k.Tuplet, x.CourierCode,
				k.Tuplet, isnull(a.RefNbr,N'')
			)
			from	tvp.Spr#Const() k, tvp.Quad#Slice(@result, default, default) q
			join	shpt.Parcel#Deep()		   x on x.ID=cast(q.v1 as bigint)
			cross	apply core.RefNbr#Type()   t
			cross	apply core.RefNbr#Of(x.ID, t.MIT)		  m
			cross	apply core.RefNbr#Of(x.ID, t.PostCourier) p
			join	api.ActivitySubscription#Raw() a on  x.ID=a.MatterID
			for		xml path(N'')
		)
		select	@result=Tvp from cte cross apply tvp.Spr#Purify(text, default);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[Subscriber$DequeueForTC]...';


GO
-- AaronLiu
CREATE PROCEDURE [api].[Subscriber$DequeueForTC](@result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@source E8=(select InfoPath				  from core.Source#ID())
		,		@qtype	E8=(select SubscriberRegister=207 from core.Queue#Type());
		execute	core.OutboundQ#Dequeue @source=@source, @qtype=@qtype, @result=@result out;

		with cte(text) as
		(
			select	[text()]=concat
			(	
				k.Many,	q.v1,
				k.Quad,	x.RouteID,
				k.Quad, m.Number,
				k.Quad, a.RefNbr
			)
			from	tvp.Spr#Const() k, tvp.Quad#Slice(@result, default, default) q
			join	shpt.Parcel#Deep()		   x on x.ID=cast(q.v1 as bigint)
			cross	apply core.RefNbr#Type()   t
			cross	apply core.RefNbr#Of(x.ID, t.MIT) m
			join	api.ActivitySubscription#Raw() a on  x.ID=a.MatterID
			for		xml path(N'')
		)
		select	@result=Tvp from cte cross apply tvp.Spr#Purify(text, default);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [app].[Parcel$InitForAmz]...';


GO
/*
@slip    = at.Tvp.Block.Join(RefNbr, CneeInfo, DeclaredInfo[Triad.Join(SkuID, LineQty, LineTotal).Over(at.Tvp.Mucho)], IDInfo).Over(at.Tvp.Entry)
@context = at.Quad.Join(Source, SvcType, errorCnt, errors)
*/
--PeterHo: Todo Smile
CREATE PROCEDURE [app].[Parcel$InitForAmz](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32;
		select	@siteID=SiteID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy);

		declare	@source E8, @errorCnt int, @errors json, @poa char(3), @svcType I32,  @routeID I32,       @courierID I32,         @stateID I32,           @contractID I32;
		select	@source=v1, @errorCnt=v3,  @errors=v4,   @poa=r.POA,   @svcType=t.ID, @routeID=r.RouteID, @courierID=r.CourierID, @stateID=t.InitStateID, @contractID=c.ID
		from	tvp.Quad#Of(@context, default)                          x
		cross	apply tms.SvcType#For(cast(x.v2 as int), @siteID)       t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)             r
		cross	apply acct.Contract#For(@siteID, cast(x.v1 as tinyint)) c;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@stage E32=(select Stage  from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID,  @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef E8,          @shprInfo E8,         @cneeInfo E8,         @idInfo E8;
		select	@clientRef=n.ClientRef, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo, @idInfo=i.IDInfo
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;
		execute	core.RefInfo#AddContact  @idSeqs=@idSeqs, @partyID=@siteID, @type=@shprInfo;

		execute	core.RefNbr#AddBlock  @index=1, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefInfo#AddBlock @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	invt.SkuInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip, @routeID=@routeID;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@idInfo;

		-- 3.	Add Batch & Parcels:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=@errorCnt, @errors=@errors;

		insert	shpt._Parcel
		(		ID,  BatchID,  RouteID,  LastMilerID,  SvcType, SvcZone, SvcClass,  POA, ContractID)
		select	ID, @batchID, @routeID, @courierID,   @svcType, 1,       1,        @poa, @contractID
		from	@idSeqs;

		execute shpt.Concern#AttachPreCheckTo @idSeqs=@idSeqs;
		-- 4.	Result:
		select	@result=@batchID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [app].[Parcel$InitForAmzNonSku]...';


GO
/*
@slip    = at.Tvp.Block.Join(RefNbr, CneeInfo, DeclaredInfo, IDInfo).Over(at.Tvp.Entry)
@context = at.Quad.Join(Source, SvcType, errorCnt, errors)
*/
--Daxia
CREATE PROCEDURE [app].[Parcel$InitForAmzNonSku](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32;
		select	@siteID=SiteID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy);

		declare	@source E8, @errorCnt int, @errors json, @poa char(3), @svcType I32,  @routeID I32,       @courierID I32,         @stateID I32,           @contractID I32;
		select	@source=v1, @errorCnt=v3,  @errors=v4,   @poa=r.POA,   @svcType=t.ID, @routeID=r.RouteID, @courierID=r.CourierID, @stateID=t.InitStateID, @contractID=c.ID
		from	tvp.Quad#Of(@context, default)                          x
		cross	apply tms.SvcType#For(cast(x.v2 as int), @siteID)       t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)             r
		cross	apply acct.Contract#For(@siteID, cast(x.v1 as tinyint)) c;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@stage E32=(select Stage  from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID,  @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef E8,          @shprInfo E8,         @cneeInfo E8,         @declaredInfo E8,             @idInfo E8;
		select	@clientRef=n.ClientRef, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo, @declaredInfo=i.DeclaredInfo, @idInfo=i.IDInfo
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;
		execute	core.RefInfo#AddContact  @idSeqs=@idSeqs, @partyID=@siteID, @type=@shprInfo;

		execute	core.RefNbr#AddBlock  @index=1, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefInfo#AddBlock @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@declaredInfo;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@idInfo;

		-- 3.	Add Batch & Parcels:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=@errorCnt, @errors=@errors;

		insert	shpt._Parcel
		(		ID,  BatchID,  RouteID,  LastMilerID,  SvcType, SvcZone, SvcClass,  POA, ContractID)
		select	ID, @batchID, @routeID, @courierID,   @svcType, 1,       1,        @poa, @contractID
		from	@idSeqs;

		execute shpt.Concern#AttachPreCheckTo @idSeqs=@idSeqs;
		-- 4.	Result:
		select	@result=@batchID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [app].[Parcel$InitForUsd]...';


GO
/*
@slip    = at.Tvp.Block.Join(RefNbr, ShprInfo, CneeInfo
,          DeclaredInfo[Quad.Join(GoodsInfo, LineQty, LineTotal, CmdyID).Over(at.Tvp.Mucho)]
,          Weight, Height, Width, Length ).Over(at.Tvp.Entry)
@context = at.Quad.Join(Source, SvcType, errorCnt, errors)
*/
--Daxia
CREATE PROCEDURE [app].[Parcel$InitForUsd](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32;
		select	@siteID=SiteID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy);

		declare	@source E8, @errorCnt int, @errors json, @svcType I32,  @routeID I32,       @courierID I32,         @stateID I32,           @contractID I32;
		select	@source=v1, @errorCnt=v3,  @errors=v4,   @svcType=t.ID, @routeID=r.RouteID, @courierID=r.CourierID, @stateID=t.InitStateID, @contractID=c.ID
		from	tvp.Quad#Of(@context, default)                          x
		cross	apply tms.SvcType#For(cast(x.v2 as int), @siteID)       t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)             r
		cross	apply acct.Contract#For(@siteID, cast(x.v1 as tinyint)) c;
		
		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@stage E32=(select Stage  from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID,  @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 2.1	Add RefNbrs & RefInfos:
		declare	@clientRef E8,          @postCourier E8,            @shprInfo E8,         @cneeInfo E8,         @declaredInfo E8,             @brkgInfo E8;
		select	@clientRef=n.ClientRef, @postCourier=n.PostCourier, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo, @declaredInfo=i.DeclaredInfo, @brkgInfo=i.BrokerageInfo
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;

		execute	core.RefNbr#AddBlock  @index=1, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefInfo#AddBlock @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@declaredInfo;
		execute	core.RefInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@brkgInfo;
		
		-- 2.2	Prepare PicSpecs:
		declare	@picSpec tms.PicSpec; insert @picSpec
		(		MeasuredWt, SvcType, Zip3,           Plus2,                  RefNbr)
		select	f.v5,      @svcType, left(i.v11, 3), substring(i.v11, 4, 2), f.v1
		from	tvp.Field#Slice(@slip, N'	%	', default) f
		cross	apply tvp.Dozen#Of(f.v3, default)           i;

		-- 2.3	Emit PICs:
		declare	@picResult tms.PicResult; insert @picResult
		exec	tms.Pic#Emit @source=@source, @picSpec=@picSpec;
		
		-- 2.4	Init TrackingNbr
		insert	core._RefNbr
		(		MatterID, Type,         Number)
		select	x.ID,     @postCourier, t.TrackingNbr
		from	@idSeqs x
		join	@picResult r on r.SeqNbr=x.Seq
		cross	apply tms.TrackingNbr#Make(r.SvcCode, r.MailerID, r.MailerSeq, x.ID) t;


		-- 3.1	Add Batch:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=@errorCnt, @errors=@errors;

		
		-- 3.2	Add Parcels:
		declare @weight real, @length real, @width real, @height real;
		insert	shpt._Parcel
		(		ID,  BatchID,  RouteID, LastMilerID,  SvcType,  SvcZone,              SvcClass,   POA,  ContractID, Weight, Height, Width, Length, ZoneCode)
		select	ID, @batchID, @routeID, @courierID,  @svcType,  isnull(z.Zone, 1),  r.SvcClass, r.POA, @contractID, s.v5,   s.v6,   s.v7,  s.v8,   left(i.v11, 5)
		from	@idSeqs x join @picResult r on r.SeqNbr=x.Seq
		join	tvp.Field#Slice(@slip, N'	%	', default) s on s.Seq=x.Seq
		cross	apply tvp.Dozen#Of(s.v3, default)           i
		outer	apply tms.SvcZone#For(@source, r.SvcClass, r.OnZip3, left(i.v11, 3)) z;
		
		-- 5.	Result:
		select	@result=@batchID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [app].[Parcel$InitForAae]...';


GO
/*
@slip    = Entry[Block<RefNbr, Shipper, Consignee, Mucho[LineInfo], Remark, GrossWeight.G, InsuranceAmt, PackageCnt>]
@context = Duad<Source, SvcType>
*/
--AaronLiu
CREATE PROCEDURE [app].[Parcel$InitForAae](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32
		select	@siteID=SiteID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy) x

		declare	@source E8, @poa char(3), @svcType I32,  @routeID I32,       @courierID I32,         @stateID I32,           @contractID I32;
		select	@source=v1, @poa=r.POA,   @svcType=t.ID, @routeID=r.RouteID, @courierID=r.CourierID, @stateID=t.InitStateID, @contractID=c.ID
		from	tvp.Duad#Of(@context, default)                          x
		cross	apply tms.SvcType#For(cast(x.v2 as int), @siteID)       t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)             r
		cross	apply acct.Contract#For(@siteID, cast(x.v1 as tinyint)) c;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@stage E32=(select Stage  from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID,  @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef E8,          @shprInfo E8,         @cneeInfo E8,         @declaredInfo E8,             @remarkInfo E8;
		select	@clientRef=n.ClientRef, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo, @declaredInfo=i.DeclaredInfo, @remarkInfo=RemarkInfo
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i
		
		execute	core.RefNbr#AddMIC @idSeqs=@idSeqs, @source=@source, @type=@type;

		execute	core.RefNbr#AddBlock  @index=1, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefInfo#AddBlock @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@declaredInfo;
		execute	core.RefInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@remarkInfo;

		-- 3.	Add Batch & Parcels:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=0, @errors=N'';

		insert	shpt._Parcel
		(		ID,  BatchID,  RouteID,  LastMilerID, SvcType, SvcZone, SvcClass,  POA, Weight,  ContractID)
		select	ID, @batchID, @routeID, @courierID,  @svcType, 1,       1,        @poa, v.Piece, @contractID
		from	@idSeqs x
		join	tvp.Pcs#SliceV(/*index*/6, @slip, default, default) v on v.Seq=x.Seq;

		-- 4.	Add Insurances
		--TODO:

		-- 5.	Result:
		select	@result=@batchID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [bo].[AssortedFees$Bill]...';


GO
/*
@slip   =Quad<TenantID, Source, ClientRef, Remark>
@context=Duad[ChargeID, XactAmt]
*/
--Smile
CREATE PROCEDURE [bo].[AssortedFees$Bill](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;

		declare	@tenantID I32,    @source E8,  @supplement nvarchar(max)
		,		@contractID I32,  @billingCycle tinyint, @clientRef loc.RefNbr;
		select	@tenantID=v1,     @source=v2,  @supplement=v4, @clientRef=v3
		,		@contractID=c.ID, @billingCycle=BillingCycle
		from	tvp.Quad#Of(@slip, default)
		cross	apply acct.Contract#For(v1, v2) c;

		declare	@type     E8=(select AssortedFees from core.Matter#Type());
		declare	@matterID I64=next value for core.MatterSeq;
		declare	@userID   I32=(select UserID from loc.Tenancy#Of(@tenancy));
		insert	core._Matter
				(ID,        PosterID, StateID, Stage, Source,  Type, PostedOn)
		values	(@matterID, @tenantID,  0,       0,    @source, @type, getutcdate());

		insert	core._RefNbr(MatterID, Type, Number) select @matterID, ClientRef, @clientRef 
		from	core.RefNbr#Type()

		declare	@regID I32=(select AssortedFees from core.Registry#ID());
		execute	core.Supplement#Merge @regID=@regID, @rowID=@matterID, @supplement=@supplement; 

		declare	@ledgerSide E8=(select AR from acct.Ledger#Side());
		declare	@vaultType  E8=(select Fund from acct.Vault#Type());
		declare	@ledgerIDs I64Array,  @invoiceds I64Array;
		with cteInvoice as
		(
			select	m.CurrencyID, c.VaultTag, XactDecAmt=sum(m.DecAmt)
			from	tvp.Duad#Slice(@context, default, default) x
			join	acct.Charge#Raw()      c on c.ID=cast(x.v1 as int)
			cross	apply dbo.Money#Of(cast(x.v2 as bigint)) m
			where	@billingCycle=0
			group	by m.CurrencyID, c.VaultTag
		)
		insert	acct._Invoice
		(		PartyID,   VaultTag,  LedgerSide, CurrencyID, DueBalance, InvoiceAmt, ContractID)
		output	inserted.ID into @invoiceds
		select	@tenantID, VaultTag, @ledgerSide, CurrencyID, CurrencyID, m.Amt,   @contractID
		from	cteInvoice x
		cross	apply dbo.Money#Make(x.XactDecAmt, x.CurrencyID) m;
	    
		with	cteInvoiced as
		(
			select	x.ID, PartyID, CurrencyID, VaultTag, ContractID
			from	@invoiceds x
			join	acct.Invoice#Raw() i on x.ID=i.ID
		)
		insert	acct._Ledger
		(		PartyID,   MatterID, ChargeID, ChargeAmt,  CurrencyID, LedgerSide,  InvoiceID)
		output	inserted.ID into @ledgerIDs
		select	@tenantID, @matterID, x.v1,    x.v2,     p.CurrencyID, @ledgerSide, isnull(i.ID, 0)
		from	tvp.Duad#Slice(@context, default, default) x
		cross	apply dbo.Money#Of(x.v2)                 p
		join	acct.Charge#Raw()  c on c.ID=cast(x.v1 as int)
		left	join cteInvoiced   i on i.VaultTag=c.VaultTag
									and i.CurrencyID=p.CurrencyID;
										
		with cteUnInvoiceds as
		(
			select	PartyID, x.CurrencyID, ChargeRawAmt=sum(x.ChargeRaw)
			from	@ledgerIDs l
			join	acct.Ledger#Raw() x on x.ID=l.ID
			where	InvoiceID=0
			group	by PartyID, x.CurrencyID
		), cteVaults as
		(
			select	PartyID, CurrencyID, ChargeAmt=m.Amt
			from	cteUnInvoiceds x
			cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
		)
		merge	acct._Vault as o using cteVaults as n
		on		(o.PartyID=n.PartyID and o.VaultType=@vaultType and o.CurrencyID=n.CurrencyID)
		when	matched then
				update set UninvoicedAmt=(select Amt from dbo.Money#Sum(n.ChargeAmt, o.UninvoicedAmt)), TalliedOn=getutcdate()
		when	not matched then
				insert(  PartyID,   VaultBal,    VaultType,   CurrencyID,   UninvoicedAmt)
				values(n.PartyID, n.CurrencyID, @vaultType, n.CurrencyID, n.ChargeAmt)
		;
		execute acct.Vault#XactByInvoice @invoiceds=@invoiceds, @paymentID=default, @vaultType=@vaultType;

		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [co].[PaymentPlan$Init]...';


GO
/*
@slip    tvp =Triad<PartyID, XactAmt, PayMethod>
@context tvp =Many[Duad<PartyID, AssignedAmt>]
@result  tvp =Duad<PaymentID, XactAmt>
*/
--Smile
CREATE PROCEDURE [co].[PaymentPlan$Init](@slip tvp, @context tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@partyID I32, @paidAmt amt, @paidDecAmt float,    @payMethod E8, 	@currencyID E8;
		select	@partyID=v1,  @paidAmt=v2,  @paidDecAmt=m.DecAmt, @payMethod=v3,  @currencyID=m.CurrencyID
		from	tvp.Triad#Of(@slip, default) x
		cross	apply dbo.Money#Of(v2)       m;

		if(@partyID=0) throw  50000, N'{{ Please Log In! }}', 0; --Hack, Timeout issue

		declare	@planedAmt float;
		select	@planedAmt=round(sum(m.DecAmt/s.ForPayment), 2)
		from	tvp.Duad#Slice(@context, default, default) x
		cross	apply dbo.Money#Of(x.v2)                   m
		join	svc.CurrencyRate$Summary() s on s.FmCurrencyID=@currencyID and s.ToCurrencyID=m.CurrencyID;

		if(@planedAmt>@paidDecAmt) throw  50000, N'{{ Please Confirm The Paid Amt! }}', 0;

		declare	@paymentID I64, @ledgerSide E8=(select AR from acct.Ledger#Side());
	
		insert	acct._Payment
				( PartyID, XID, LedgerSide,  CurrencyID,  PayMethod,  PaidAmt)
		values	(@partyID, 1,  @ledgerSide, @currencyID, @payMethod, @paidAmt);
		select	 @paymentID=scope_identity();
		
		declare	@regID I32=(select PaymentPlan from core.Registry#ID());
		execute	core.Supplement#Merge @regID=@regID, @rowID=@paymentID, @supplement=@context;
		
		select	@result=Tvp from tvp.Duad#Make(@paymentID, @paidAmt);
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [core].[Activity#Once]...';


GO
--PeterHo
CREATE PROCEDURE [core].[Activity#Once](@matterID I64, @stateID I32, @qtype E8=0, @userID I32=0)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	if (@matterID is null or exists(select * from core._Activity where MatterID=@matterID and StateID=@stateID))
		return;

	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		insert	core._Activity
				( MatterID,  StateID, ActionID,  UserID)
		values	(@matterID, @stateID, 0,        @userID);

		if (@qtype>0) -- need outboundQ
		begin
			declare	@source E8=(select Source from core._Matter where ID=@matterID);
			execute	core.OutboundQ#Enqueue @source=@source, @qtype=@qtype, @matterID=@matterID, @stateID=@stateID;
		end

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [core].[Activity#OnceHubAccepted]...';


GO
--PeterHo
CREATE PROCEDURE [core].[Activity#OnceHubAccepted](@matterID I64, @userID I32=0)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	declare	@stateID I32=(select HubAccepted       from core.State#ID());
	declare	@qtype    E8=(select SubscribeCallback from core.Queue#Type());
	execute	core.Activity#Once @matterID=@matterID, @stateID=@stateID, @qtype=@qtype, @userID=@userID;
END
GO
PRINT N'Creating [core].[Challenge#Pull]...';


GO
/*
@slip    = Many[Duad<MatterID, ChallengeType>]
@context = MessageBody
*/
--PeterHo
CREATE PROCEDURE [core].[Challenge#Pull](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@rowAuxes I64Enums;
		with	cteSlip as
		(
			select	c.MatterID, c.Type
			from	tvp.Duad#Slice(@slip, default, default) x
			join	core._Challenge c
			on		c.MatterID=cast(v1 as bigint) and c.Type=cast(v2 as tinyint)
		)
		delete	cteSlip output deleted.MatterID, deleted.Type into @rowAuxes;

		declare	@regID I32=(select Matter from core.Registry#ID());

		if  (/*HumanPull*/(select UserID from loc.Tenancy#Of(@tenancy))>0)
			execute	core.Message#Invoke @regID=@regID, @rowAuxes=@rowAuxes, @body=@context, @tenancy=@tenancy;

		else /*DaemonPull*/ begin
			with cteDameonPull as
			(
				select	RegID, RowID, AuxID, PostedOn
				from	core._Message x
				where	exists
				(
					select	* from @rowAuxes a
					where	(x.RegID=@regID and x.RowID=a.ID and x.AuxID=a.Val)
					and		x.PosterID=0 -- Daemon
				)
			) delete cteDameonPull;
		end

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [core].[Challenge#Push]...';


GO
/*
@slip    = Many[Triad<MatterID, ChallengeType, BoundStage>]
@context = MessageBody
*/
--PeterHo
CREATE PROCEDURE [core].[Challenge#Push](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@rowAuxes I64Enums;
		with cteSlip as
		(
			select	MatterID  =cast(v1 as bigint)
			,		Type      =cast(v2 as tinyint)
			,		BoundStage=cast(v3 as int)
			from	tvp.Triad#Slice(@slip, default, default)
		)
		merge	core._Challenge as o using cteSlip as n on (o.MatterID=n.MatterID and o.Type=n.Type)
		when	matched     and n.BoundStage=0 then delete --- Preventing GHOST.
		when	matched     and n.BoundStage>0 then update set BoundStage=n.BoundStage
		when	not matched and n.BoundStage>0 then insert (  MatterID,   Type,   BoundStage)
				                                    values (n.MatterID, n.Type, n.BoundStage)
		output	inserted.MatterID, inserted.Type into @rowAuxes;

		declare	@regID I32=(select Matter from core.Registry#ID());
		execute	core.Message#Invoke @regID=@regID, @rowAuxes=@rowAuxes, @body=@context, @tenancy=@tenancy;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [core].[Matter#TransitBySpec]...';


GO
--PeterHo
CREATE PROCEDURE [core].[Matter#TransitBySpec](@spec core.TransitionSpec readonly, @userID I32, @beAffected bit=0)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@expectedCnt int=(select count(*) from @spec);
		if (@beAffected=1 and @expectedCnt=0)
			execute	dbo.Assert#Fail N'Empty transition is not allowed.';

		with cteMatter as
		(
			select	m.ID,      m.StatedOn
			,		m.StateID, x.ToStateID
			,		m.Stage,   x.ToStage
			,		m.HandlerID
			from	@spec  x join core._Matter m
			on		m.ID=x.MatterID
			and		m.StateID=x.OnStateID                   -- Geninue    Check.
			and		m.LockCnt=0                             -- AdminLock  Check.
			cross	apply core.Challenge#Borderline(m.ID) c -- Borderline Check.
			where	x.ToStage<=c.Borderline
		)
		update	cteMatter set StateID=ToStateID, StatedOn=getutcdate(), Stage=ToStage, HandlerID=0;

		execute	dbo.Assert#Transited @expectedCnt;

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;
		execute	core.OutboundQ#EnqueueBySpec @spec=@spec;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [core].[Matter#TransitBySpecWithPID]...';


GO
--PeterHo
CREATE PROCEDURE [core].[Matter#TransitBySpecWithPID](@spec core.TransitionSpec readonly, @userID I32, @pid bigint)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@expectedCnt int=(select count(*) from @spec);
		with cteMatter as
		(
			select	m.ID, m.PID, m.StatedOn
			,		m.StateID,   x.ToStateID
			,		m.Stage,     x.ToStage
			,		m.HandlerID
			from	@spec  x join core._Matter m
			on		m.ID=x.MatterID
			and		m.StateID=x.OnStateID                   -- Geninue Check.
			and		m.LockCnt=0                             -- AdminLock Check.
			cross	apply core.Challenge#Borderline(m.ID) c -- Borderline Check.
			where	x.ToStage<=c.Borderline
		)
		update	cteMatter set PID=@pid, StateID=ToStateID, StatedOn=getutcdate(), Stage=ToStage, HandlerID=0;

		execute	dbo.Assert#Transited @expectedCnt;

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;
		execute	core.OutboundQ#EnqueueBySpec @spec=@spec;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [hub].[Sack$Create]...';


GO
/*
	@slip    = Comma<ParceID>
	@context = Triad<ManifestID, ClrMethodID, Weight>
	@result  = Triad<SackID, SackNbr, Comma<ErrorParcelIDs>>
*/
-- AaronLiu
CREATE PROCEDURE [hub].[Sack$Create](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	-- 1.0	Check Parcel Transit
	declare	@userID I32,    @hubID I32,	  @roleID I32;
	select	@userID=UserID, @hubID=HubID, @roleID=RoleID
	from	loc.Tenancy#Of(@tenancy);

	declare @invalidIDs tvp
	,		@actionID	E32=(select AddParcelToSack from core.Action#ID())
	,		@ids		I64Array
	,		@spec		core.TransitionSpec;
	insert	@spec 
	output	inserted.MatterID into @ids
	select	t.* 
	from	shpt.Parcel#TobeVia(@slip, @roleID, @actionID) t;

	with cte(text) as
	(
		select	[text()]=concat(N',', x.ID)
		from	tvp.I64#Slice(@slip) x
		left	join @ids			 p on x.ID=p.ID
		where	p.ID is null for xml path (N'')
	)
	select	@invalidIDs=Tvp from cte cross apply tvp.Spr#Purify(text, 1);
	if		@invalidIDs<>N''
	begin
		select	@result=Tvp from tvp.Triad#Make(N'0', N'', @invalidIDs);
		return;
	end	

	BEGIN TRY
		BEGIN	TRAN;

		declare	@manifestID I64, @clrMethodID I32, @weight float;
		select	@manifestID=v1,  @clrMethodID=v2,  @weight=v3
		from	tvp.Triad#Of(@context, default);

		-- 1.1	Init Sack
		declare	@now      DT=getutcdate()
		,		@type     E8=(select Sack			from core.Matter#Type())
		,		@stage    E32=(select SackManifested from core.Stage#ID())
		,		@source   E8=(select InfoPath		from core.Source#ID())
		,		@stateID I32=(select SackManifested from core.State#ID())
		,		@sackID	 I64=next value for core.MatterSeq
		;

		insert	core._Matter
				(     ID,         PID, PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		values	(@sackID, @manifestID,   @hubID, @stateID, @stage, @source, @type,     @now);

		insert	shpt._Sack
				(    ID, BrokerID,  ClrMethodID, POA,  SackWt)
		select	@sackID, BrokerID, @clrMethodID, POA, @weight
		from	shpt.SackMft#Raw()
		where	ID=@manifestID

		insert	core._Activity
				(MatterID,  StateID,  UserID, TalliedOn)
		values	( @sackID, @stateID, @userID,      @now);

		declare	@idTexts I64Texts;
		insert	core._RefNbr
		(		MatterID, Type,  Number)
		output	inserted.MatterID, inserted.Number into @idTexts
		select	@sackID,  k.MIT, m.MIC
		from	core.RefNbr#Type() k
		cross	apply core.MIC#Emit(@sackID, @source, @type, @now) m
		;

		-- 2.1	Link Parcel's PID from SackMft to Sack:
		with cteParcel as
		(
			select	m.ID, m.PID
			from	tvp.I64#Slice(@slip) x
			join	core.Matter#Raw() m on x.ID=m.ID
		)
		update cteParcel set PID=@sackID;

		-- 2.2	Transit Parcel
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

		-- 3.1	Return Result
		select	@result=r.Tvp
		from	@idTexts x
		cross	apply tvp.Triad#Make(x.ID, x.Text, N'') r;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [hub].[Sack$Close]...';


GO
/*
	@slip    = Block[Comma<AddedParceID>, Comma<RemovedParceID>]
	@context = Duad<SackID, Weight>
*/
-- AaronLiu
CREATE PROCEDURE [hub].[Sack$Close](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	declare	@userID I32,    @roleID I32;
	select	@userID=UserID, @roleID=RoleID
	from	loc.Tenancy#Of(@tenancy);
	declare @invalidIDs		tvp
	,		@addActionID	E32=(select AddParcelToSack		 from core.Action#ID())
	,		@removeActionID E32=(select RemoveParcelFromSack from core.Action#ID())
	,		@ids			I64Enums
	,		@spec			core.TransitionSpec;
	insert	@spec 
	output	inserted.MatterID, 1 into @ids
	select	t.* 
	from	tvp.Block#At(1, @slip, default, default) x
	cross	apply shpt.Parcel#TobeVia(x.Tvp, @roleID, @addActionID) t;

	insert	@spec 
	output	inserted.MatterID, 0 into @ids
	select	t.* 
	from	tvp.Block#At(2, @slip, default, default) x
	cross	apply shpt.Parcel#TobeVia(x.Tvp, @roleID, @removeActionID) t;

	with cteParcel as
	(
		select	p.ID
		from	tvp.Spr#Const() k
		cross	apply tvp.I64#Slice(replace(@slip, k.Block, N',')) p 
		where	p.ID>0
	), cte(text) as
	(
		select	[text()]=concat(N',', x.ID)
		from	cteParcel x
		left	join  @ids p on x.ID=p.ID
		where	p.ID is null for xml path (N'')
	)
	select	@invalidIDs=Tvp from cte cross apply tvp.Spr#Purify(text, 1);
	if		@invalidIDs<>N''
	begin
		select	@result=@invalidIDs;
		return;
	end	

	BEGIN TRY
		BEGIN	TRAN;

		-- 1.1	Update Sack Weight
		declare	@sackID I64, @weight float;
		select	@sackID=v1,  @weight=v2
		from	tvp.Duad#Of( @context, default);
		update	shpt._Sack set SackWt=@weight where ID=@sackID;

		-- 2.1	Merge Parcels into Sack:
		declare	@sackMftID I64=(select PID from core.Matter#Raw() where ID=@sackID)
		;
		with cteDiff as
		(
			select	m.ID, m.PID, NewPID=iif(x.Val=1, @sackID, @sackMftID)
			from	@ids x
			join	core.Matter#Raw() m on x.ID=m.ID
		)
		update cteDiff set PID=NewPID;

		-- 2.2	Transit Parcel:
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [hub].[Sack$Reload]...';


GO
/*
	@slip    = Block[Comma<AddedSackID>, Comma<RemovedSackID>]
	@context = Traid<SackLoadID, TruckerID, BookingNbr>
	@result  = Comma<InvalidSackID>
*/
-- AaronLiu
CREATE PROCEDURE [hub].[Sack$Reload](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	-- 1.0	Check Sack Transit
	declare	@userID I32,    @roleID I32;
	select	@userID=UserID, @roleID=RoleID
	from	loc.Tenancy#Of(@tenancy);
	declare @invalidIDs		tvp
	,		@addActionID	E32=(select AddToSackLoad	   from core.Action#ID())
	,		@removeActionID E32=(select RemoveFromSackLoad from core.Action#ID())
	,		@ids			I64Enums
	,		@spec			core.TransitionSpec;
	insert	@spec 
	output	inserted.MatterID, 1 into @ids
	select	t.* 
	from	tvp.Block#At(1, @slip, default, default) x
	cross	apply core.Matter#TobeVia(x.Tvp, @roleID, @addActionID) t;

	insert	@spec 
	output	inserted.MatterID, 0 into @ids
	select	t.* 
	from	tvp.Block#At(2, @slip, default, default) x
	cross	apply core.Matter#TobeVia(x.Tvp, @roleID, @removeActionID) t;

	with cteSack as
	(
		select	s.ID
		from	tvp.Spr#Const() k
		cross	apply tvp.I64#Slice(replace(@slip, k.Block, N',')) s
		where	s.ID>0
	), cte(text) as
	(
		select	[text()]=concat(N',', x.ID)
		from	cteSack   x
		left	join @ids p on x.ID=p.ID
		where	p.ID is null for xml path (N'')
	)
	select	@invalidIDs=Tvp from cte cross apply tvp.Spr#Purify(text, 1);
	if		@invalidIDs<>N''
	begin
		select	@result=@invalidIDs;
		return;
	end	

	BEGIN TRY
		BEGIN	TRAN;
			
		-- 1.1	Update SackLoad Info
		declare	@sackLoadID I64, @truckerID I32, @number loc.RefNbr;
		select	@sackLoadID=v1,	 @truckerID=v2,	 @number=v3
		from	tvp.Triad#Of(@context, default);

		update	shpt._SackLoad set TruckerID=@truckerID where ID=@sackLoadID;
		
		declare	@refNbrs tvp;
		select	@refNbrs=n.Tvp
		from	core.RefNbr#Type() t
		cross	apply tvp.Triad#Make(@sackLoadID, t.BookingNbr, @number) n;
		execute	core.RefNbr#Merge @slip=@refNbrs;

		-- 2.1	Merge Sacks Into SackLoad
		with cteDiff as
		(
			select	m.ID, m.AID, NewAID=iif(x.Val=1, @sackLoadID, 0)
			from	@ids x
			join	core.Matter#Raw() m on x.ID=m.ID
		)
		update	cteDiff set AID=NewAID;

		-- 2.2	Transit Sack:
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [hub].[Sack$Load]...';


GO
/*
	@slip    = Comma<SackID>
	@context = Duad<TruckerID, BookingNbr>
	@result  = Traid[SackLoadID, SackLoadMIC, Comma<InvalidSackID>]
*/
-- AaronLiu
CREATE PROCEDURE [hub].[Sack$Load](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	-- 1.0	Check Sack Transit
	declare	@userID I32,    @hubID I32,	  @roleID I32;
	select	@userID=UserID, @hubID=HubID, @roleID=RoleID
	from	loc.Tenancy#Of(@tenancy);

	declare @invalidIDs tvp
	,		@actionID	E32=(select AddToSackLoad from core.Action#ID())
	,		@ids		I64Array
	,		@spec		core.TransitionSpec;
	insert	@spec 
	output	inserted.MatterID into @ids
	select	t.* 
	from	core.Matter#TobeVia(@slip, @roleID, @actionID) t;

	with cte(text) as
	(
		select	[text()]=concat(N',', x.ID)
		from	tvp.I64#Slice(@slip)  x
		left	join @ids			  p on x.ID=p.ID
		where	p.ID is null for xml path (N'')
	)
	select	@invalidIDs=Tvp from cte cross apply tvp.Spr#Purify(text, 1);
	if		@invalidIDs<>N''
	begin
		select	@result=Tvp from tvp.Triad#Make(N'0', N'', @invalidIDs);
		return;
	end

	BEGIN TRY
		BEGIN	TRAN;

		-- 1.1	Init SackLoad
		declare	@truckerID I32, @number loc.RefNbr;
		select	@truckerID=v1,	@number=v2
		from	tvp.Duad#Of(@context, default);

		declare	@now         DT=getutcdate()
		,		@type        E8=(select SackLoad        from core.Matter#Type())
		,		@stage       E32=(select SackLoaded      from core.Stage#ID())
		,		@source      E8=(select InfoPath        from core.Source#ID())
		,		@stateID    I32=(select SackLoadCreated	from core.State#ID())
		,		@sackLoadID	I64=next value for core.MatterSeq
		;

		insert	core._Matter
				(ID,		  PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		values	(@sackLoadID,   @hubID, @stateID, @stage, @source, @type,     @now);

		insert	shpt._SackLoad
				(ID,		   TruckerID)
		values	(@sackLoadID, @truckerID)

		insert	core._Activity
				(MatterID,     StateID,  UserID, TalliedOn)
		values	(@sackLoadID, @stateID, @userID,      @now);

		declare	@refNbrs tvp;
		with cteRefNbr as
		(
			select	MatterID=@sackLoadID, Type=k.MIT,		 Number=m.MIC
			from	core.RefNbr#Type() k
			cross	apply core.MIC#Emit(@sackLoadID, @source, @type, @now) m
			union	all
			select	MatterID=@sackLoadID, Type=k.BookingNbr, Number=@number
			from	core.RefNbr#Type() k
		), cte(text) as
		(
			select	[text()]=concat(k.Many, MatterID, k.Triad, Type, k.Triad, Number)
			from	tvp.Spr#Const() k, cteRefNbr for xml path(N'')
		)
		select	@refNbrs=Tvp from cte cross apply tvp.Spr#Purify(text, default);
		execute	core.RefNbr#Merge @slip=@refNbrs;

		-- 2.1	Link Sack's AID To SackLoad
		with cteSack as
		(
			select	m.ID, m.AID
			from	tvp.I64#Slice(@slip) x
			join	core.Matter#Raw() m on x.ID=m.ID	
		)
		update	cteSack set AID=@sackLoadID;

		-- 2.2	Transit Sack
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

		-- 3.1	Return Result
		select	@result=r.Tvp
		from	tvp.Triad#Slice(@refNbrs, default, default) x
		cross	apply tvp.Triad#Make(x.v1, x.v3, N'')		r
		cross	apply core.RefNbr#Type()					k
		where	k.MIT=cast(x.v2 as tinyint)
		;
		
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [hub].[RackOutOrder$Complete]...';


GO
/*
	@slip    = Traid<RackedOutParcels, NotFoundParcels, ExceptionParcels>
	@context = OrderOutID
	@result  = Quad<ID, CreatedOn, CompletedOn, RackedOutCount>
*/
-- Smile, AaronLiu
CREATE PROCEDURE [hub].[RackOutOrder$Complete](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
	
		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@rackedOutParcels tvp, @notFoundParcels tvp, @exceptionParcels tvp;
		select	@rackedOutParcels =v1, @notFoundParcels =v2, @exceptionParcels =v3
		from	tvp.Triad#Of(@slip, default);

		declare	@actionID I32=11350;--(select Rack from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* 
		from	tvp.I64#Slice(@rackedOutParcels) x
		cross	apply shpt.Parcel#Tobe(x.ID, @roleID, @actionID) t;
		declare	@rackedOutCount int=(@@rowcount);
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		with	cte as
		(
			select	r.ParcelID, r.OrderOutID
			from	tvp.I64#Slice(concat(@notFoundParcels,N',',@exceptionParcels)) x
			join	shpt.RackXact#Raw() r on x.ID=r.ParcelID
		)
		update	cte set OrderOutID=0;
		update	whse._RackOrder set CompletedOn=getutcdate() where ID=cast(@context as int);

		select	@result=Tvp
		from	whse.RackOrder#Raw() x
		cross	apply tvp.Quad#Make(x.ID, x.CreatedOn, x.CompletedOn, @rackedOutCount)
		where	x.ID=cast(@context as int)
	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [hub].[RackOutOrder$Init]...';


GO
/*
	@result  = Duad<OrderOutID, CreatedOn>
*/
-- Smile, AaronLiu
CREATE PROCEDURE [hub].[RackOutOrder$Init](@tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
	
		declare	@userID I32,    @hubID I32;
		select	@userID=UserID, @hubID=HubID
		from	loc.Tenancy#Of(@tenancy);

		declare	@orderType E8=(select RackOut from whse.Order#Type());
		declare	@id I32, @createdOn DT=(getutcdate());
		select	@id=ID,  @createdOn=CreatedOn
		from	whse.RackOrder#Raw()
		where	RackerID=@userID and OrderType=@orderType and CompletedOn=dbo.DT@Empty();

		if(isnull(@id, 0)=0)
		begin
			execute	whse.RackOrder#Create @id=@id out, @rackerID=@userID, @orderType=@orderType;
			with	cte as
			(
				select	x.ParcelID, x.RackID, x.OrderInID, x.OrderOutID, p.AID
				,		LagAID=lag(p.AID, 1, 0) over(order by x.ParcelID)
				from	shpt.RackXact#Raw()	  x
				join	shpt.Parcel#Base()	  p on p.ID=x.ParcelID
				join	whse.Rack#Raw()		  r on r.ID=x.RackID
				cross	apply core.State#ID() s
				where	r.HubID=@hubID and x.OrderOutID=0 and p.StateID=s.TobeRackedOut
			),	cteMarker as
			(
				select	ParcelID, RackID, OrderInID, OrderOutID
				,		Marker=sum(case when AID=0 or AID<>LagAID then 1 else 0 end) over (order by AID, ParcelID)
				from	cte
			), cteRackOut as
			(
				select	ParcelID, RackID, OrderInID, OrderOutID
				from	cteMarker
				where	Marker<101
			)
			update	cteRackOut set OrderOutID=@id;
			declare	@expectedCnt int=(@@rowcount);
			if (@expectedCnt=0)
				delete	from whse._RackOrder where ID=@id;
		end

		select	@result=Tvp from tvp.Duad#Make(@id, @createdOn);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [hub].[RackInOrder$Init]...';


GO
/*
	@result  = Duad<OrderInID, CreatedOn>
*/
-- Smile
CREATE PROCEDURE [hub].[RackInOrder$Init](@tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	
		declare	@userID I32  =(select UserID from loc.Tenancy#Of(@tenancy));
		declare	@orderType E8=(select RackIn from whse.Order#Type());
		declare	@id I32;
		execute	whse.RackOrder#Create @id=@id out, @rackerID=@userID, @orderType=@orderType;

		select	@result=Tvp from tvp.Duad#Make(@id, getutcdate());
	
END
GO
PRINT N'Creating [hub].[Parcel$SortForRackIn]...';


GO
/*
	@slip    = TrackingNbr
	@result  = Triad<ParcelID, StateID, ParcelID/1000000>
*/
-- Smile
CREATE PROCEDURE [hub].[Parcel$SortForRackIn](@slip tvp,  @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		declare	@minStage E32,     @maxStage E32;
		select	@minStage=PreMin, @maxStage=CurMax
		from	core.Stage#Boundary();

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@parcelType E8=(select Parcel from core.Matter#Type()); 

		declare	@matterID I64,  @matterType E8;
		select	@matterID=m.ID, @matterType=m.Type
		from	core.RefNbr#ScanOne(@slip, default, default) x
		join	core.Matter#Raw() m on m.ID=x.MatterID;

		if(@matterType<>@parcelType)
		begin
			declare	@parcelCnt I32=(select count(*) from core.Matter#Raw() where ID=@matterID or PID=@matterID);

			declare	@actionID I32=(select HubMeasure from core.Action#ID());
			declare	@spec core.TransitionSpec;
			insert	@spec select t.* 
			from	core.Matter#Raw()                                x
			cross	apply shpt.Parcel#Tobe(x.ID, @roleID, @actionID) t
			cross	apply core.State#ID()                            s
			where	(x.PID=@matterID or x.ID=@matterID) and x.StateID=s.TobeRackedIn

			declare	@specCnt I32=(select count(*) from @spec);
			if(@parcelCnt=@specCnt) 
				execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;
		end

		declare	@cartAction I32=(select Cart from core.Action#ID());
		declare	@cartSpec core.TransitionSpec;
		insert	@cartSpec select t.*
		from	shpt.Parcel#Tobe(@matterID, @roleID, @cartAction) t
		execute	core.Matter#TransitBySpec @spec=@cartSpec, @userID=@userID;

		select	@result=t.Tvp 
		from	core.Matter#Raw()        x		
		cross	apply tvp.Triad#Make(x.ID, x.StateID, format(x.ID % 1000000, '000000')) t
		where	x.ID=@matterID;

			
	COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [hub].[Sack$ReBag]...';


GO
/*
@slip    = Duad<Comma[AddedParceID], Comma[RemovedParceID]>
@context = Duad<SackID, Weight>
*/
--Smile
CREATE PROCEDURE [hub].[Sack$ReBag](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
		BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @hubID I32,	  @roleID I32;
		select	@userID=UserID, @hubID=HubID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@addedParcelIDs tvp, @deletedParcelIDs tvp;
		select	@addedParcelIDs=v1, @deletedParcelIDs=v2
		from	tvp.Duad#Of(@slip, default)

		declare	@sackID I64, @sackWt float, @brokerID I32, @clrMethodID I32, @poa char(3);
		select	@sackID=v1, @sackWt=v2, @brokerID=BrokerID, @clrMethodID=ClrMethodID, @poa=POA
		from	tvp.Duad#Of(@context, default) x
		join	shpt.Sack#Raw() s on s.ID=cast(x.v1 as bigint);

		declare	@addActionID	I32=(select AddParcelToSack		 from core.Action#ID()),
				@deletedActionID I32=(select RemoveParcelFromSack from core.Action#ID()),
				@addedSpec core.TransitionSpec, @deletedSpec core.TransitionSpec;

		insert	into @deletedSpec select t.*
		from	shpt.Parcel#TobeVia(@deletedParcelIDs, @roleID, @deletedActionID) t;

		insert	into @addedSpec select t.*
		from	shpt.Parcel#Raw() x
		cross	apply shpt.Parcel#Tobe(x.ID, @roleID, @addActionID) t
		where	x.ID  in (select ID from tvp.I64#Slice(@addedParcelIDs))
		and		x.POA=@poa
		and		x.RouteID in (
								select	RouteID 
								from	tms.Route#Raw() 
								where	BrokerID=@brokerID and ClrMethodID=@clrMethodID
							 )

		if(exists (select * from @deletedSpec))
		BEGIN
		execute	core.Matter#TransitBySpec @spec=@deletedSpec, @userID=@userID, @beAffected=1;
		with cteParcel as
		(
			select	ID, PID
			from	core.Matter#Raw() x
			join	@deletedSpec      c on c.MatterID=x.ID			
		)
		update	cteParcel set PID=0;
		END

		if(exists (select * from @addedSpec))
		BEGIN
		execute	core.Matter#TransitBySpec @spec=@addedSpec, @userID=@userID, @beAffected=1;
		with cteParcel as
		(
			select	ID, PID
			from	core.Matter#Raw() x
			join	@addedSpec      c on c.MatterID=x.ID			
		)
		update	cteParcel set PID=@sackID;
		END

		update shpt._Sack set SackWt=@sackWt;

		COMMIT	TRAN;
		END TRY
		BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
		END CATCH	
END
GO
PRINT N'Creating [hub].[Sack$Init]...';


GO
/*
@slip    tvp =Comma[ParcelID]
@spec	 tvp =Triad<RouteID, POA, SackWt>
@result	 tvp=Duad<SackID, MIC>
*/
--Smile
CREATE PROCEDURE [hub].[Sack$Init](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	
		declare	@userID I32,    @hubID I32,	  @roleID I32;
		select	@userID=UserID, @hubID=HubID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@routeID I32, @brokerID I32, @clrMethodID I32, 
				@poa char(3), @weight float;
		select	@routeID=v1,  @brokerID=BrokerID,  @clrMethodID=ClrMethodID, 
				@poa=v2, @weight=v3
		from	tvp.Triad#Of(@context, default) x
		join	tms.Route#Raw() t on t.ID=cast(x.v1 as int);

		declare	@spec core.TransitionSpec,
				@actionID	E32=(select AddParcelToSack from core.Action#ID());
		insert	@spec select t.* 
		from	shpt.Parcel#Raw() x
		cross	apply shpt.Parcel#Tobe(x.ID, @roleID, @actionID) t
		where	x.ID  in (select ID from tvp.I64#Slice(@slip))
		and		x.RouteID=@routeID
		and		x.RcvHubID=@hubID;

		if(exists (select * from @spec))
		begin
		SET XACT_ABORT ON;
		BEGIN TRY
		BEGIN	TRAN;
		declare	@type	    E32=(select Sack from core.Matter#Type()),
				@stateID    I32=(select SackCreated from core.State#ID()),
				@stage		I32=(select Sacked from core.Stage#ID()),
				@source     E8=(select InfoPath		from core.Source#ID()),
				@sackID		I64=(next value for core.MatterSeq);
	
		
		insert	core._Matter
				(     ID, PID, PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		values	(@sackID, 0,     @hubID, @stateID, @stage, @source, @type, getutcdate());

		insert	shpt._Sack
				(    ID,   BrokerID,  ClrMethodID,  POA,  SackWt)
		values	(@sackID, @brokerID, @clrMethodID, @poa, @weight)
		
		insert	core._Activity
				(MatterID,  StateID,  UserID,  TalliedOn)
		values	( @sackID, @stateID, @userID,  getutcdate());

		declare	@sackNbrType E8=(select MIT from core.RefNbr#Type()),
				@sackNbr loc.RefNbr=(select MIC from core.MIC#Emit(@sackID, @source, @type, getutcdate()));

		insert	core._RefNbr( MatterID,       Type,  Number)
		values              (@sackID, @sackNbrType, @sackNbr);

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

		with cteParcel as
		(
			select	ID, PID
			from	core.Matter#Raw() x
			join	@spec c on c.MatterID=x.ID			
		)
		update	cteParcel set PID=@sackID;

		select	@result=(select Tvp from tvp.Duad#Make(@sackID, @sackNbr));

			COMMIT	TRAN;
		END TRY
		BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
		END CATCH
		end	
END
GO
PRINT N'Creating [hub].[Parcel$ReleaseForUsps]...';


GO
/*
@slip	= TrackingNbr
*/
--Smile
CREATE PROCEDURE [hub].[Parcel$ReleaseForUsps](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	
	declare	@userID I32,    @roleID I32;
	select	@userID=UserID, @roleID=RoleID
	from	loc.Tenancy#Of(@tenancy);

	declare	@actionID  I32=(select ImportHubManifest from core.Action#ID());

	declare	@spec core.TransitionSpec;
	insert	@spec select t.* 
	from	core.RefNbr#ScanOne(@slip, default, default)           x
	cross	apply shpt.Parcel#Tobe(x.MatterID, @roleID, @actionID) t
	
	execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=0;

	
	
END
GO
PRINT N'Creating [hub].[Parcel$Unified]...';


GO
/*
	@slip    = Comma[MediumParcelID]
	@context = UnityParcelID
	@result  = Duad<MatterID, MIC>
*/
-- Smile
CREATE PROCEDURE [hub].[Parcel$Unified](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@unityID I64=@context;
		declare	@rowCnt int, @expectedCnt int=(select count(*) from core.Matter#Raw() where AID=@unityID);

		declare	@actionID I32=(select Unify from core.Action#ID());
		declare	@spec core.TransitionSpec; insert @spec select t.*
		from	tvp.I64#Slice(@slip) x
		join	core.Matter#Raw()    m on m.ID=x.ID and m.AID=@unityID
		cross	apply shpt.Parcel#Tobe(m.ID, @roleID, @actionID) t;
		select	@rowCnt=@@ROWCOUNT;

		if(@rowCnt<>@expectedCnt) execute dbo.Assert#Fail @msg=N'';
	    
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

		declare	@hubCheckIn I32=(select HubCheckIn from core.Action#ID());
		declare	@specVia core.TransitionSpec; insert @specVia select t.*
		from	shpt.Parcel#Tobe(@unityID, @roleID, @hubCheckIn) t;
		execute	core.Matter#TransitBySpec @spec=@specVia, @userID=@userID, @beAffected=1;

		declare	@declaredInfo tvp;
		with	cte(text) as
		(
			select	[text()]=concat(k.Mucho, i.Info)
			from	tvp.I64#Slice(@slip)      x
			cross	apply core.RefInfo#Type() t
			join	core.RefInfo#Raw()        i on i.MatterID=x.ID and i.Type=t.DeclaredInfo
			cross	apply tvp.Spr#Const()     k
			for		xml path(N'')
		)
		select	@declaredInfo=Tvp from cte cross apply tvp.Spr#Purify(text, default);

		declare	@brkgInfo tvp;
		with	cte(text) as
		(
			select	[text()]=concat(k.Mucho, i.Info)
			from	tvp.I64#Slice(@slip)      x
			cross	apply core.RefInfo#Type() t
			join	core.RefInfo#Raw()        i on i.MatterID=x.ID and i.Type=t.BrokerageInfo
			cross	apply tvp.Spr#Const()     k
			for		xml path(N'')
		)
		select	@brkgInfo=Tvp from cte cross apply tvp.Spr#Purify(text, default);

		declare	@refInfoSlip tvp;
		select	@refInfoSlip=concat( k.Many, @unityID, k.Triad,	t.DeclaredInfo, k.Triad,  @declaredInfo,									
									 k.Many, @unityID, k.Triad, t.BrokerageInfo, k.Triad, @brkgInfo)
		from	core.RefInfo#Type() t, tvp.Spr#Const() k;
		execute	core.RefInfo#Merge @slip=@refInfoSlip;


		select	@result=t.Tvp
		from	core.RefNbr#Type() k, core.RefNbr#Raw()   x
		cross	apply tvp.Duad#Make(x.MatterID, x.Number) t
		where	x.MatterID=@unityID and x.Type=k.MIT


		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [hub].[Sack$Void]...';


GO
/*
	@slip = SackID
*/
-- AaronLiu
CREATE PROCEDURE [hub].[Sack$Void](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@sackActionID	E32=(select VoidSack			 from core.Action#ID());
		declare	@parcelActionID E32=(select RemoveParcelFromSack from core.Action#ID());
		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from core.Matter#TobeVia(@slip, @roleID, @sackActionID) t;
		insert	@spec select t.* from core.Matter#Raw() m
		cross	apply shpt.Parcel#Tobe(m.ID, @roleID, @parcelActionID) t
		where	m.PID=cast(@slip as bigint);

		-- 1.1	Link Parcel's PID to Original SackMft
		with cteParcel as
		(
			select	p.ID, p.PID, SackMftID=x.PID
			from	shpt.Sack#Base()  x
			join	core.Matter#Raw() p on p.PID=x.ID
			where	x.ID=cast(@slip as bigint)
		)
		update cteParcel set PID=SackMftID;

		-- 1.2	Change Sack's PID to 0
		update	core._Matter set PID=0, AID=0 where ID=cast(@slip as bigint);

		-- 2.0	Transit Sack&Parcel
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [ic].[Parcel$PromoteToShippingPlan]...';


GO
/*
@slip  = ParcelID
*/
--Eva, PeterHo
CREATE PROCEDURE [ic].[Parcel$PromoteToShippingPlan](@slip tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	declare	@userID I32,    @roleID I32,    @actionID I32;
	select	@userID=UserID, @roleID=RoleID, @actionID=PromoteToShippingPlan
	from	loc.Tenancy#Of(@tenancy), core.Action#ID();

	declare	@parcelID I64=@slip;
	declare	@spec core.TransitionSpec;
	insert	@spec select t.* from shpt.Parcel#Tobe(@parcelID, @roleID, @actionID) t;
	execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;
END
GO
PRINT N'Creating [ic].[ShippingPlan$Compose]...';


GO
/*
@slip    = Entry[Mucho[Qty:in order of LineInfoSeq]]
@context = ParcelID
*/
--Eva, PeterHo
CREATE PROCEDURE [ic].[ShippingPlan$Compose](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@parcelID I64=@context;
		declare	@infoSlip tvp=
		(
			select	Tvp
			from	core.RefInfo#ToShippingPlan(@parcelID, @slip)    x
			cross	apply tvp.Triad#Make(x.MatterID, x.Type, x.Info) t
		);
		execute	core.RefInfo#Merge @slip=@infoSlip;

		declare	@userID I32,    @roleID I32,    @actionID I32;
		select	@userID=UserID, @roleID=RoleID, @actionID=ComposeShippingPlan
		from	loc.Tenancy#Of(@tenancy), core.Action#ID();

		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from shpt.Parcel#Tobe(@context, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [ic].[Parcel$Bounce]...';


GO
/*
@slip	tvp=string.Join(at.Tvp.Comma, TrackingNbrs)
@result	tvp=Many[Duad<UnReturnID, TrackingNbr>]
*/
--Aimee
CREATE PROCEDURE [ic].[Parcel$Bounce](@slip tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		--	0.	Tenancy:
		declare	@userID I32,    @roleID I32,    @actionID I32;
		select	@userID=UserID, @roleID=RoleID, @actionID=Bounce
		from	loc.Tenancy#Of(@tenancy), core.Action#ID();

		--	1.	Ids
		declare @ids I64Array;
		insert	@ids select distinct m.MatterID
		from	tvp.Comma#Slice(@slip)        x
		cross	apply core.MIC#IdOf(x.Piece)  m

		--	3.	Parcel Transit
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from @ids x
		cross	apply shpt.Parcel#Tobe(x.ID, @roleID, @actionID) t
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;
		
		--	4.	Result
		with cteResult(text) as
		(
			select	[text()]=concat(k.Many, x.Piece)
			from	tvp.Comma#Slice(@slip)       x
			outer	apply core.MIC#IdOf(x.Piece) m
			cross	apply tvp.Spr#Const()        k
			where	not exists(select MatterID from @spec where MatterID=m.MatterID)
			for		xml path(N'')
		)
		select	@result=Tvp from cteResult cross apply tvp.Spr#Purify(text, default);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [ic].[Sack#CreateForImport]...';


GO
/*
	@slip    = Entry[Triad<PickupNbr, PickupedOn, Many[Duad<ParcelID, Weight>]>]
	@context = ManifestID
*/
-- Daxia
CREATE PROCEDURE [ic].[Sack#CreateForImport](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	BEGIN TRY
		BEGIN	TRAN;
		
		-- 0.	Tenancy & Contexts:
		declare	@userID I32,    @hubID I32,	  @roleID I32;
		select	@userID=UserID, @hubID=HubID, @roleID=RoleID    --HubID is IC Site
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@sackMftID I64=@context, @clrMethodID I32=0, @weight float=0;

		-- 1	Init Matters & Sacks
		declare	@now      DT=getutcdate()
		,		@type     E8=(select Sack			 from core.Matter#Type())
		,		@stage    E32=(select SackManifested from core.Stage#ID())
		,		@source   E8=(select InfoPath		 from core.Source#ID())
		,		@stateID I32=(select SackManifested  from core.State#ID())
		,		@sackID	 I64=next value for core.MatterSeq
		;
		
		-- 1.1	Init Matters
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		insert	core._Matter
				( ID,        PID, PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		select	x.ID, @sackMftID,   @hubID, @stateID, @stage, @source, @type,     @now
		from	@idSeqs x;
		
		
		-- 1.2	Init Sacks
		declare	@poa char(3), @brokerID I32;
		select	@poa=POA,     @brokerID=BrokerID from shpt.SackMft#Raw() where ID=@sackMftID;

		insert	shpt._Sack
				( ID,  BrokerID,  ClrMethodID,  POA,  SackWt)
		select	  ID, @brokerID, @clrMethodID, @poa, @weight
		from	@idSeqs ;
		

		-- 1.3	Add Activities : 
		insert	core._Activity
				(MatterID,  StateID,  UserID, TalliedOn)
		select	       ID, @stateID, @userID, @now from @idSeqs ;
		
		-- 1.4	Add RefNbrs - Mic : 
		insert	core._RefNbr (MatterID, Type, Number) select x.ID, k.MIT, m.MIC
		from	@idSeqs x cross apply core.RefNbr#Type() k cross apply core.MIC#Emit(x.ID, @source, @type, @now) m
		;
		
		-- 1.5	Add RefNbrs - ClientRef : 
		insert	core._RefNbr (MatterID, Type, Number) select x.ID, k.ClientRef, s.v1
		from	@idSeqs x cross apply core.RefNbr#Type() k
		join	tvp.Triad#Slice(@slip, default, default) s on s.Seq=x.Seq
		;

		-- 2.1	Link Parcel's PID from SackMft to Sack:
		declare	@ids I64Array;
		with cteParcel as
		(
			select	m.ID, m.PID, SackID=x.ID, m.Weight, NewWeight=cast(p.v2 as real)
			from	@idSeqs x
			join	tvp.Triad#Slice(@slip, default, default) s on s.Seq=x.Seq
			cross	apply tvp.Duad#Slice(s.v3, default, default) p
			join	shpt.Parcel#Base() m on m.ID=p.v1
		)
		update	cteParcel set PID=SackID, Weight=NewWeight
		output	inserted.ID into @ids;

		---- 2.2	Transit Parcel
		declare	@parcelActionID E32=(select AddParcelToSack from core.Action#ID())
		,		@spec           core.TransitionSpec;
		with cte(text) as
		(
			select	[text()]=concat(N',', x.ID) from @ids x
			where	x.ID is null for xml path (N'')
		)
		insert	@spec select t.* from cte     x
		cross	apply tvp.Spr#Purify(text, 1) i
		cross	apply shpt.Parcel#TobeVia(i.Tvp, @roleID, @parcelActionID) t;

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;


		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [ic].[Parcel$Outgated]...';


GO
/*
@slip		tvp=Entry[Triad<PickupNbr, PickupedOn, Many[Duad<ParcelID, Weight>]>]
@context	tvp=POA
*/
--Daxia
CREATE PROCEDURE [ic].[Parcel$Outgated](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		--	0.	Tenancy:
		declare	@userID I32,    @roleID I32,    @actionID I32;
		select	@userID=UserID, @roleID=RoleID, @actionID=Bounce
		from	loc.Tenancy#Of(@tenancy), core.Action#ID();
		
		declare	@pod char(3)=@context
		,		@poa char(3)=@context;

		--	1.	Add SackMft
		declare	@sackMftID I64, @mawb tvp=N'', @flightNbr tvp=N'';
		--at.Quad.Of(POD, POA, Mawb, FlightNbr)
		declare	@sackMftContext tvp=(select Tvp from tvp.Quad#Make(@pod, @poa, @mawb, @flightNbr));
		execute	shpt.SackMft#Create @id=@sackMftID out, @context=@sackMftContext, @tenancy=@tenancy;

		--	2.	Add Sack
		exec	ic.Sack#CreateForImport @slip=@slip, @context=@sackMftID, @tenancy=@tenancy;

		--	3.	Add SackLoad
		--	4.	Add SackTransloaded

		--	5.1	Bill -AR
		declare	@parcelIDs I64Array;insert into @parcelIDs(ID)
		select	i.v1 from tvp.Triad#Slice(@slip, default, default)     x
		cross	apply tvp.Duad#Slice(x.v3, default, default)           i
		join	shpt.Parcel#Raw()   p on p.ID=i.v1
		cross	apply tms.SvcRate#For(p.SvcType, p.RcvHubID, p.Weight) s
		where	s.SvcRate>0
		and		not exists(
					select	ID from acct.Ledger#Raw()  l
					cross	apply acct.Ledger#Side()   d
					where	MatterID=i.v1 and l.LedgerSide=d.AR
				);
		exec	shpt.Parcel#BillForFactor @parcelIDs=@parcelIDs;

		--	6.	Push FedEx


		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [shpt].[Parcel#ReleaseByDeposit]...';


GO
--Smile
CREATE PROCEDURE [shpt].[Parcel#ReleaseByDeposit](@partyID I32, @tenancy tvp)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@actionID I32=(select CfmPayment from core.Action#ID());
		declare	@spec core.TransitionSpec;
		with	cteCumulation as
		(
			select	x.ID, x.MatterID, x.ChargeRaw,  x.CurrencyID 
			,		CurBalRaw
			,		Cumulation=sum(ChargeRaw) over( partition by x.PartyID, x.CurrencyID order by x.ID desc) 
			from	core.Matter#Raw()          m
			join	core.Party#Raw()           p on p.ID=m.PosterID and p.AID=@partyID
			join	acct.Ledger#Raw()          x on x.MatterID=m.ID
			cross	apply acct.Ledger#Side()   d
			cross	apply (
								select	PartyID, CurrencyID, CurBalRaw=sum(CurBalRaw)
								from	acct.Vault#Raw() 
								where	PartyID=x.PartyID and CurrencyID=x.CurrencyID
								group	by PartyID, CurrencyID
						  ) v
			cross	apply core.State#ID() k
			where	x.LedgerSide=d.AR and StateID=k.CreditLimitExceeded
		), cteSummary as
		(
			select	MatterID, Marker=(case when CurBalRaw>=0 then 0  										  
										   when CurBalRaw<0 and (Cumulation+CurBalRaw)>ChargeRaw then 0
										   else 1 end)
			
			from	cteCumulation	
			
		), cteParcelGroup as
		(
			select	MatterID, ParcelGroup=sum(Marker)
			from	cteSummary
			group	by MatterID			
		)
		insert	@spec select t.*
		from	cteParcelGroup x
		cross	apply shpt.Parcel#Tobe(x.MatterID, @roleID, @actionID) t
		where	x.ParcelGroup=0

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=0;
	

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [shpt].[Parcel#UnfiledCPSInitByPlatform]...';


GO
/*
@slip    = Entry[Block< Quad<SiteID, SvcType, RchHubAlias, POA>
					, RefNbr
					, Shpr
					, Cnee
					, IDInfo
					, Bag[Path<Precourier, Shpr, Mucho[LineInfo], Weight>]
					, AddOnSvc>]
@context = batchID
*/
--Smile
CREATE PROCEDURE [shpt].[Parcel#UnfiledCPSInitByPlatform](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
	
		-- 0.	Contexts:
		declare	@siteID I32,    @userID I32,    @source tinyint;
		select	@siteID=SiteID, @userID=UserID, @source=p.Source
		from	loc.Tenancy#Of(@tenancy) x
		join	core.Party#Raw()         p on p.ID=x.UserID;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select UnityParcel from core.Matter#Type())
		,		@spec core.TransitionSpec;
		insert	core._Matter
		(		ID,  PosterID,   StateID,       Stage,  Source,  Type, PostedOn    )
		output	inserted.ID, 0, 0, inserted.StateID, inserted.Stage, inserted.Source, 0, 0 into @spec
		select	x.Master,  cast(q.v1 as int), t.InitStateID, s.Stage, @source,  @type, getutcdate()
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default)        x 
		cross	apply tvp.Quad#Of(x.House, default)                         q	
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		cross	apply core.Stage#Of(t.InitStateID)                          s

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;
		
		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef E8,  @shprInfo E8,  @cneeInfo E8,  @preCourier E8,  @IDInfo E8
		,		@declaredInfo E8,  @brokerageInfo E8, @addOnSvcInfo E8;
		select	@clientRef=n.ClientRef, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo
		,		@preCourier=n.PreCourier, @IDInfo=i.IDInfo, @declaredInfo=i.DeclaredInfo
		,		@brokerageInfo=i.BrokerageInfo, @addOnSvcInfo=I.AddOnSvcInfo
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i;

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;
		execute	core.RefNbr#AddBlock     @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefInfo#AddBlock	 @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock	 @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock	 @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@IDInfo;
		execute	core.RefInfo#AddBlock	 @index=7, @idSeqs=@idSeqs, @slip=@slip, @type=@addOnSvcInfo;
		

		-- 3.	Add  Parcels:
		declare	@batchID I64=(@context);
		
		insert	shpt._Parcel
		(		ID,       BatchID,  RouteID, LastMilerID,  
				SvcType,  SvcZone, SvcClass, POA, RcvHubID, ContractID)
		select	x.Master, @batchID, isnull(d.RouteID, r.RouteID), r.CourierID,  
				t.ID, 1, 1, iif(nullif(q.v4, '') is null, r.POA, q.v4), isnull(h.ID, 0), c.ID
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default) x 
		cross	apply tvp.Quad#Of(x.House, default)                  q
		cross	apply core.Party#Type()                              e
		left	join  core.Party#Raw()                               h on h.Alias=q.v3 and h.Type=e.ZebraHub
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		outer	apply tms.SvcRoute#For(t.ID, cast(q.v4 as char(3)))  d
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)          r	
		cross	apply acct.Contract#For(cast(q.v1 as int), @source)  c;

		--4.	init MediumParcel
		select	@type=MediumParcel from core.Matter#Type();
		declare	@mediumSeqs I64Seqs; insert @mediumSeqs(ID, Seq)
		select  next value for core.MatterSeq, x.Seq*100 + p.Seq
		from	tvp.Block#FoldT(6, @idSeqs, @slip, default, default) x 
		cross	apply tvp.Bag#Slice(x.House)                         p
        ;
		insert	core._Matter
		(		ID,  AID, PosterID, StateID, Stage, Source, Type, PostedOn    )
		output	inserted.ID, 0, 0, inserted.StateID, inserted.Stage, inserted.Source, 0, 0 into @spec
		select	h.ID, x.Master,  m.PosterID, m.StateID, m.Stage, @source,  @type, getutcdate()
		from	tvp.Block#FoldT(6, @idSeqs, @slip, default, default) x
		cross	apply tvp.Bag#Slice(x.House)                         p
		join	@mediumSeqs                                          h on h.Seq=x.Seq*100 + p.Seq
		join	core.Matter#Raw()                                    m on m.ID=x.Master

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;
		execute	core.RefNbr#AddMIC           @idSeqs=@mediumSeqs, @source=@source,  @type=@type;
		
		insert	into core._RefNbr(MatterID, Type, Number)
		select	h.ID, @preCourier, f.v1
		from	tvp.Block#FoldT(6, @idSeqs, @slip, default, default) x
		cross	apply tvp.Bag#Slice(x.House)                         p
		cross	apply tvp.Spr#Const()                                k
		cross   apply tvp.Field#Of(p.Piece, k.Path)                  f
		join	@mediumSeqs                                          h on h.Seq=x.Seq*100 + p.Seq
		;
		declare	@refInfoSlip tvp;
		with	cte(text) as
		(
			select	[text()]=concat( k.Many, h.ID, k.Triad,	@shprInfo, k.Triad, f.v2									
									,k.Many, h.ID, k.Triad, @declaredInfo, k.Triad, f.v3
									,k.Many, h.ID, k.Triad, @brokerageInfo, k.Triad, b.BrokerageInfo)
			from	tvp.Block#FoldT(6, @idSeqs, @slip, default, default) x
			cross	apply tvp.Bag#Slice(x.House)                         p
			cross	apply tvp.Spr#Const()                                k
			cross   apply tvp.Field#Of(p.Piece, k.Path)                  f
			cross	apply loc.Declared$ToBrokerage(f.v3, default)		 b
			join	@mediumSeqs                                          h on h.Seq=x.Seq*100 + p.Seq
			for		xml path(N'')
		)
		select	@refInfoSlip=Tvp from cte cross apply tvp.Spr#Purify(text, default);
		execute	core.RefInfo#Merge @slip=@refInfoSlip;

		insert	into shpt._Parcel
		(		ID,   BatchID,  RouteID,   LastMilerID,  SvcType, SvcZone, SvcClass,  POA,  Weight, RcvHubID,        ContractID)
		select	h.ID, @batchID, r.RouteID, r.LastMilerID, r.SvcType,     1,      1,   r.POA, cast(f.v6 as real),   r.RcvHubID, r.ContractID
		from	tvp.Block#FoldT(6, @idSeqs, @slip, default, default) x
		cross	apply tvp.Bag#Slice(x.House)                         p
		join	@mediumSeqs                                          h on h.Seq=x.Seq*100 + p.Seq
		cross	apply tvp.Spr#Const()                                k
		cross   apply tvp.Field#Of(p.Piece, k.Path)                  f
		join	shpt.Parcel#Raw()                                    r on r.ID=x.Master
		;

		-- PreCourier Concern
		declare	@preCouriers tvp;
		with	cte(text) as
		(
			select	[text()]=concat(N',', f.v1)
			from	tvp.Block#At(6, @slip, default, default) x
			cross	apply tvp.Spr#Const()					 k
			cross	apply tvp.Pcs#Slice(x.Tvp, k.Entry)		 p
			cross	apply tvp.Bag#Slice(p.Piece)			 m
			cross   apply tvp.Field#Of(m.Piece, k.Path)		 f
			for		xml path(N'')
		)
		select	@preCouriers=Tvp from cte cross apply tvp.Spr#Purify(text, 1)
		execute	shpt.PreCourier#Concern @slip=@preCouriers;
		
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [shpt].[Parcel#UnfiledMPSInitByPlatform]...';


GO
/*
@slip    = Entry[Block< Quad<SiteID, SvcType, RchHubAlias, POA>
				, RefNbr
				, Shpr
				, Cnee
				, Mucho[LineInfo]
				, ID
				, Mucho[Duad<Precourier, Weight>]>
				, AddOnSvc]
@context = batchID
*/
--Smile
CREATE PROCEDURE [shpt].[Parcel#UnfiledMPSInitByPlatform](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Contexts:
		declare	@siteID I32,    @userID I32,    @source tinyint;
		select	@siteID=SiteID, @userID=UserID, @source=p.Source
		from	loc.Tenancy#Of(@tenancy) x
		join	core.Party#Raw()         p on p.ID=x.UserID;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select MasterParcel from core.Matter#Type())
		,		@spec core.TransitionSpec;
		insert	core._Matter
		(		ID,  PosterID,   StateID,       Stage,  Source,  Type, PostedOn    )
		output	inserted.ID, 0, 0, inserted.StateID, inserted.Stage, inserted.Source, 0, 0 into @spec
		select	x.Master,  cast(q.v1 as int), t.InitStateID, s.Stage, @source,  @type, getutcdate()
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default)        x 
		cross	apply tvp.Quad#Of(x.House, default)                         q	
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		cross	apply core.Stage#Of(t.InitStateID)                          s

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;
		

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef E8,  @shprInfo E8,  @cneeInfo E8,  @preCourier E8,  @IDInfo E8
		,		@declaredInfo E8,  @brokerageInfo E8, @addOnSvcInfo E8;
		select	@clientRef=n.ClientRef, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo
		,		@preCourier=n.PreCourier, @IDInfo=i.IDInfo, @declaredInfo=i.DeclaredInfo
		,		@brokerageInfo=i.BrokerageInfo, @addOnSvcInfo=I.AddOnSvcInfo
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i;

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;

		execute	core.RefNbr#AddBlock  @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;		
		execute	core.RefInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@declaredInfo;
		execute	core.RefInfo#AddBlock @index=6, @idSeqs=@idSeqs, @slip=@slip, @type=@IDInfo;
		execute	core.RefInfo#AddBlock @index=8, @idSeqs=@idSeqs, @slip=@slip, @type=@addOnSvcInfo;
		insert	into core._RefInfo(MatterID, Type, Info)
		select	x.Master, @brokerageInfo, b.BrokerageInfo
		from	tvp.Block#FoldT(5, @idSeqs, @slip, default, default) x
		cross	apply loc.Declared$ToBrokerage(x.House, default)	 b	

		-- 3.	Add Matser Parcels:
		declare	@batchID I64=(@context);
		
		insert	shpt._Parcel
		(		ID, BatchID,  RouteID, LastMilerID, SvcType,
				SvcZone, SvcClass,  POA, RcvHubID, ContractID)
		select	x.Master, @batchID, isnull(d.RouteID, r.RouteID), r.CourierID,  t.ID,
				1, 1,  iif(nullif(q.v4, '') is null, r.POA, q.v4), isnull(h.ID, 0), c.ID
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default) x 
		cross	apply tvp.Quad#Of(x.House, default)                  q
		cross	apply core.Party#Type()                              e
		left	join  core.Party#Raw()                               h on h.Alias=q.v3 and h.Type=e.ZebraHub
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		outer	apply tms.SvcRoute#For(t.ID, cast(q.v4 as char(3)))  d
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)          r
		cross	apply acct.Contract#For(cast(q.v1 as int), @source)  c;

		--4.	init HouseParcel
		declare	@houseSeqs I64Seqs; insert @houseSeqs(ID, Seq)
		select  next value for core.MatterSeq, x.Seq*100 + d.Seq
		from	tvp.Block#FoldT(7, @idSeqs, @slip, default, default) x
		cross	apply tvp.Mucho#Slice(x.House)                       p
		cross	apply tvp.Duad#Slice(p.Piece, default, default)      d
        ;

		select	@type=HouseParcel from core.Matter#Type();
		insert	core._Matter
		(		ID,  AID, PosterID, StateID, Stage, Source, Type, PostedOn    )
		output	inserted.ID, 0, 0, inserted.StateID, inserted.Stage, inserted.Source, 0, 0 into @spec
		select	h.ID, x.Master,  m.PosterID, m.StateID, m.Stage, @source,  @type, getutcdate()
		from	tvp.Block#FoldT(7, @idSeqs, @slip, default, default) x
		cross	apply tvp.Mucho#Slice(x.House)                       p
		cross	apply tvp.Duad#Slice(p.Piece, default, default)      d
		join	@houseSeqs                                           h on h.Seq=x.Seq*100 + d.Seq
		join	core.Matter#Raw()                                    m on m.ID=x.Master

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;

		execute	core.RefNbr#AddMIC       @idSeqs=@houseSeqs, @source=@source,  @type=@type;
		insert	into core._RefNbr(MatterID, Type, Number)
		select	h.ID, @preCourier, d.v1
		from	tvp.Block#FoldT(7, @idSeqs, @slip, default, default) x
		cross	apply tvp.Mucho#Slice(x.House)                       p
		cross	apply tvp.Duad#Slice(p.Piece, default, default)      d
		join	@houseSeqs                                           h on h.Seq=x.Seq*100 + d.Seq
		;
		insert	into shpt._Parcel
		(		ID,   BatchID,  RouteID,   LastMilerID,  SvcType, SvcZone, SvcClass,  POA,  Weight, RcvHubID,        ContractID)
		select	h.ID, @batchID, r.RouteID, r.LastMilerID, r.SvcType,     1,      1,   r.POA, cast(d.v2 as real),   r.RcvHubID, r.ContractID
		from	tvp.Block#FoldT(7, @idSeqs, @slip, default, default) x
		cross	apply tvp.Mucho#Slice(x.House)                       p
		cross	apply tvp.Duad#Slice(p.Piece, default, default)      d
		join	@houseSeqs                                           h on h.Seq=x.Seq*100 + d.Seq
		join	shpt.Parcel#Raw()                                    r on r.ID=x.Master
		;
		
		-- PreCourier Concern
		declare	@preCouriers tvp;
		with	cte(text) as
		(
			select	[text()]=concat(N',', d.v1)
			from	tvp.Block#At(7, @slip, default, default)		x
			cross	apply tvp.Spr#Const()							k
			cross	apply tvp.Pcs#Slice(x.Tvp, k.Entry)				p
			cross	apply tvp.Mucho#Slice(p.Piece)					m
			cross	apply tvp.Duad#Slice(m.Piece, default, default) d
			for		xml path(N'')
		)
		select	@preCouriers=Tvp from cte cross apply tvp.Spr#Purify(text, 1)
		execute	shpt.PreCourier#Concern @slip=@preCouriers;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [shpt].[PreCourier#ConcernBlock]...';


GO
/*
	@slip = Entry[Block<***>]
*/
-- AaronLiu
CREATE PROCEDURE [shpt].[PreCourier#ConcernBlock](@index int, @slip tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	
	with	cte as
	(
		select	Tvp=replace(x.Tvp, k.Entry, N',')
		from	tvp.Block#At(@index, @slip, default, default) x
		cross	apply tvp.Spr#Const() k
	)
	select	@slip=Tvp from cte;
	execute	shpt.PreCourier#Concern @slip=@slip;
END
GO
PRINT N'Creating [shpt].[Parcel#TryRackOut]...';


GO
-- AaronLiu
CREATE PROCEDURE [shpt].[Parcel#TryRackOut]
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@slip tvp;
		with	cte(text) as
		(
			select	[text()]=concat(N',', x.ParcelID)
			from	shpt.RackXact#Raw()	  x
			join	core.Matter#Raw()	  m on m.ID=x.ParcelID
			cross	apply core.State#ID() s
			cross	apply shpt.Siblings#Cnt(x.ParcelID)		  c
			cross	apply shpt.Siblings#CntInRack(x.ParcelID) k
			where	x.OrderOutID=0 and c.Cnt=k.Cnt and m.AID>0 and m.StateID=s.RackingRackedIn
			for		xml path(N'')
		)
		select	@slip=Tvp from cte cross apply tvp.Spr#Purify(text, 1);

		declare	@actionID I32=(select QueueRackOut from core.Action#ID())
		,		@userID	  I32=0
		,		@roleID	  I32=0
		,		@spec core.TransitionSpec;
		insert	@spec select t.* from shpt.Parcel#TobeVia(@slip, @roleID, @actionID) t

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [shpt].[Parcel#Measure]...';


GO
-- AaronLiu
CREATE PROCEDURE [shpt].[Parcel#Measure](@matterID I64, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@actionID I32,		@exeActionID I32;
		select	@actionID=ActionID, @exeActionID=ExeActionID, @tenancy=TobeTenancy
		from	core.Measure#Todo(@matterID, @tenancy)

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare @spec core.TransitionSpec;
		insert	@spec select t.* from shpt.Parcel#TobeVia(@matterID, @roleID, @actionID) t;

		declare	@exeSpec core.TransitionSpec;
		insert	@exeSpec select t.* from shpt.Parcel#TobeVia(@matterID, @roleID, @exeActionID) t;

		with	cteMatter as
		(
			select	m.ID, RejoinID, NewRejoinID=x.ToStateID
			from	core.Matter#Raw() m
			join	@spec			  x on x.MatterID=m.ID
			join	@exeSpec		  v on x.MatterID=v.MatterID
		)
		update	cteMatter set RejoinID=NewRejoinID;

		execute	core.Matter#TransitBySpec @spec=@exeSpec, @userID=@userID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Route$Confirm]...';


GO
/*
@slip = IDs.Over(at.Tvp.Comma.Join)
*/
--Smile
CREATE PROCEDURE [svc].[Route$Confirm](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

	declare	@userID I32,    @roleID I32;
	select	@userID=UserID, @roleID=RoleID
	from	loc.Tenancy#Of(@tenancy);

	declare	@creditExceeded I32, @svcRateNotFound I32, @routeCfm I32;
	select	@creditExceeded=ReportCreditLimitExceeded, @svcRateNotFound=ReportSvcRateNotFound, @routeCfm=ConfirmRoute
	from	core.Action#ID();
	
	declare	@branchSpec core.TransitionSpec; 
	insert	@branchSpec select t.* from shpt.Parcel#TobeVia(@slip, @roleID, @routeCfm) t
	join	core.Matter#Raw() m on m.ID=t.MatterID 
	cross	apply core.Source#ID() k
	cross	apply core.Stage#ID()  s
	where	m.Source=k.eVMI or m.Stage=s.PreScreenParcelCreated;
	if(exists(select Seq from @branchSpec))
		execute	core.Matter#TransitBySpec @spec=@branchSpec, @userID=@userID, @beAffected=1;

	declare	@spec core.TransitionSpec, @specVia core.TransitionSpec;
	insert	@spec select t.* from shpt.Parcel#TobeVia(@slip, @roleID, @routeCfm) t
	
	if(exists(select Seq from @spec))
	begin

		declare	@parcelIDs I64Array;insert	into @parcelIDs(ID)
		select	MatterID from @spec x
		join	shpt.Parcel#Raw()   p on p.ID=x.MatterID
		cross	apply tms.SvcRate#For(p.SvcType, p.RcvHubID, p.Weight) s
		where	s.SvcRate>0
		and		not exists(
								select	ID from acct.Ledger#Raw()  l
								cross	apply acct.Ledger#Side() d
								where	MatterID=x.MatterID and l.LedgerSide=d.AR
						   );
		execute	shpt.Parcel#TalliedOrDeduct @parcelIDs=@parcelIDs;

		with cteCumulation as
		(
			select	x.ID, x.MatterID, x.ChargeRaw,  x.CurrencyID 
			,		CurBalRaw
			,		Cumulation=sum(ChargeRaw) over( partition by x.PartyID, x.CurrencyID order by x.ID desc) 
			from	@spec                    p
			join	acct.Ledger#Raw()        x on p.MatterID=x.MatterID
			cross	apply acct.Ledger#Side() d
			cross	apply (
								select	PartyID, CurrencyID, CurBalRaw=sum(CurBalRaw)
								from	acct.Vault#Raw() 
								where	PartyID=x.PartyID and CurrencyID=x.CurrencyID
								group	by PartyID, CurrencyID
						  ) v
			
			where	x.LedgerSide=d.AR 
		), cteSummary as
		(
			select	MatterID, Marker=(case when CurBalRaw>=0 then 0  										  
										   when CurBalRaw<0 and (Cumulation+CurBalRaw)>ChargeRaw then 0
										   else 1 end)
			,		isSvcRateFound=0
			from	cteCumulation	
			union	all
			select	MatterID, 0, isSvcRateFound=isnull(s.SvcRate, 0)
			from	@spec                    x
			join	shpt.Parcel#Raw()        p on x.MatterID=p.ID
			outer	apply tms.SvcRate#For(p.SvcType, p.RcvHubID, p.Weight) s
		), cteParcelGroup as
		(
			select	MatterID, ParcelGroup=sum(Marker), isSvcRateFound=sum(isSvcRateFound)
			from	cteSummary
			group	by MatterID			
		), cteParcelTodo as
		(
			select	MatterID
			,		ActionID=iif(isSvcRateFound=0, @svcRateNotFound, iif(ParcelGroup=0, @routeCfm, @creditExceeded))
			from	cteParcelGroup
		)
		insert	into @specVia select t.* 
		from	cteParcelTodo x
		cross	apply shpt.Parcel#Tobe(x.MatterID, @roleID, x.ActionID) t;
		
		with	cteMatter as
		(
			select	m.ID, RejoinID, NewRejoinID=m.StateID
			from	core._Matter m
			join	@specVia     v on m.ID=v.MatterID
			where	v.ActionID in (@svcRateNotFound, @creditExceeded)
		)
		update	cteMatter set RejoinID=NewRejoinID;

		execute	core.Matter#TransitBySpec @spec=@specVia, @userID=@userID, @beAffected=1;

	end

	COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END

--/*
--@slip = IDs.Over(at.Tvp.Comma.Join)
--*/
----PeterHo
--CREATE PROCEDURE [svc].[Route$Confirm](@slip tvp, @tenancy tvp)
----WITH ENCRYPTION
--AS
--BEGIN
--	SET NOCOUNT    ON;
--	SET XACT_ABORT ON;
--	BEGIN TRY
--		BEGIN	TRAN;

--	declare	@userID I32,    @roleID I32;
--	select	@userID=UserID, @roleID=RoleID
--	from	loc.Tenancy#Of(@tenancy);

--	declare	@actionID I32=(select ConfirmRoute from core.Action#ID());
--	declare	@spec core.TransitionSpec;
--	insert	@spec select t.* from shpt.Parcel#TobeVia(@slip, @roleID, @actionID) t;

--	declare	@exeSpec core.TransitionSpec;
--	declare	@exceptionAction I32=(select ReportSvcRateNotFound from core.Action#ID());
--	with	cteParcelTodo as
--	(
--		select	ID, ActionID=iif(nullif(SvcRate, 0) is null, @exceptionAction, @actionID)
--		from	shpt.Parcel#Raw() p
--		outer	apply tms.SvcRate#For(p.SvcType, p.RcvHubID, p.Weight) s
--		where	p.ID in (select ID from tvp.I64#Slice(@slip))
--	)
--	insert	@exeSpec select t.*
--	from	cteParcelTodo x
--	cross	apply shpt.Parcel#Tobe(x.ID, @roleID, x.ActionID) t;
--	with	cteMatter as
--	(
--		select	m.ID, RejoinID, NewRejoinID=m.StateID
--		from	core._Matter m
--		join	@exeSpec     v on m.ID=v.MatterID
--		where	v.ActionID=@exceptionAction
--	)
--	update	cteMatter set RejoinID=NewRejoinID;

--	execute	core.Matter#TransitBySpec @spec=@exeSpec, @userID=@userID, @beAffected=1;

	

--	declare	@parcelIDs I64Array;
--	insert	into @parcelIDs(ID)
--	select	MatterID 
--	from	@exeSpec x 
--	where	not exists(select ID from acct.Ledger#Raw() where MatterID=x.MatterID)
--	and		ActionID=@actionID;

--	execute	shpt.Parcel#TalliedOrDeduct @parcelIDs=@parcelIDs;

--	COMMIT	TRAN;
--	END TRY
--	BEGIN CATCH
--		if (xact_state() = -1) ROLLBACK TRAN; throw;
--	END CATCH
--END
GO
PRINT N'Creating [svc].[Parcel$Transit]...';


GO
--PeterHo
CREATE PROCEDURE [svc].[Parcel$Transit](@idsInCsv tvp, @actionID I32, @tenancy tvp, @beAffected bit=0)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	declare	@userID I32,    @roleID I32;
	select	@userID=UserID, @roleID=RoleID
	from	loc.Tenancy#Of(@tenancy);

	--declare	@expectedCnt int=tvp.Comma@Count(@idsInCsv);
	declare	@spec core.TransitionSpec;
	insert	@spec select t.* from shpt.Parcel#TobeVia(@idsInCsv, @roleID, @actionID) t

	--if (@beAffected=1)
	--execute	dbo.Assert#RowCntEQ @rowCnt=@expectedCnt;

	execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=@beAffected;
END
GO
PRINT N'Creating [svc].[Parcel$MergeBrkgInfo]...';


GO
/*
@slip    = Mucho[Triad<SkuID, CmdyInfo, LineInfo>]
@context = MatterID
*/
--Daxia, PeterHo, Aimee
CREATE PROCEDURE [svc].[Parcel$MergeBrkgInfo](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@exeSlip tvp=
		(
			select	Tvp   from core.RefInfo#Type() k
			cross	apply tvp.Triad#Make(@context, k.BrokerageInfo, @slip)
		);
		execute	core.RefInfo#Merge @slip=@exeSlip;

		declare	@actionID I32=(select TranslateForBrokerage from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@context, @actionID=@actionID, @tenancy=@tenancy;
	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$CheckIn]...';


GO
--PeterHo
CREATE PROCEDURE [svc].[Parcel$CheckIn](@numbersInCsv tvp, @tenancy tvp, @result tvp out, @number tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@minStage E32,    @maxStage E32;
		select	@minStage=PreMin, @maxStage=PreMax
		from	core.Stage#Boundary();

		declare	@matterID I64;
		select	@matterID=MatterID, @number=Number
		from	core.RefNbr#ScanMulti(@numbersInCsv, @minStage, @maxStage);
		
		declare	@rcvHubID I32,   @userID I32;
		select	@rcvHubID=HubID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy);

		execute	core.Activity#OnceHubAccepted @matterID=@matterID, @userID=@userID;

		update	shpt._Parcel set RcvHubID=@rcvHubID where ID=@matterID;

		declare	@actionID I32=(select HubCheckIn from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@matterID, @actionID=@actionID, @tenancy=@tenancy;

		select	@result=@matterID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$CfmCustomsStatus]...';


GO
/*
@slip    tvp=at.Tvp.Comma.Join(TrackingNbrs);
@context tvp=at.Tvp.Triad.Join(ActionID, POA, at.Tvp.Trio.Join(UtcTime, UtcOffset, UtcPlaceID));
*/
--Smile, PeterHo
CREATE PROCEDURE [svc].[Parcel$CfmCustomsStatus](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;

		declare	@minStage E32,       @maxStage E32;
		select	@minStage=Outgated, @maxStage=Surrendered
		from	core.Stage#ID();

		declare	@actionID I32,  @poa char(3), @utcStamp tvp;
		select	@actionID=x.v1, @poa=x.v2,    @utcStamp=x.v3
		from	tvp.Triad#Of(@context, default) x

		declare @ids I64Array;
		insert	@ids select distinct MatterID
		from	loc.RefNbr#Slice(@slip) x
		cross	apply core.RefNbr#ScanOne(x.Number, @minStage, @maxStage) r
		join	shpt.Parcel#Raw() p on p.ID=r.MatterID		
		where	p.POA=@poa;


		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from @ids
		cross	apply shpt.Parcel#Tobe(ID, @roleID, @actionID) t;

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;
		execute	core.RefStamp#MergeBySpec @spec=@spec, @utcStamp=@utcStamp;

		select	@result=(select count(*) from @ids);

		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Message$Post]...';


GO
/*
@slip    = MatterID
@context = Duad<Body, (Message==0, BoundStage!=0)>
*/
--PeterHo: HACK!!! (Matter Only)
CREATE PROCEDURE [svc].[Message$Post](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT ON;

	declare	@body msg, @boundStage E32;
	select	@body=v1,  @boundStage=v2
	from	tvp.Duad#Of(@context, default);

	if (@boundStage>0) begin
		declare	@auxID   E32=(select Instruction from core.Challenge#Type());
		declare	@exeSlip tvp=(select Tvp from tvp.Triad#Make(/*rowID*/@slip, @auxID, @boundStage));
		execute core.Challenge#Push @slip=@exeSlip, @context=@body, @tenancy=@tenancy;
	end
	else begin
		declare	@rowAuxes I64Enums;
		insert	@rowAuxes (ID, Val) select ID, 0 from tvp.I64#Slice(@slip);
		
		declare	@regID I32=(select Matter from core.Registry#ID());
		execute	core.Message#Invoke @regID=@regID, @rowAuxes=@rowAuxes, @body=@body, @tenancy=@tenancy;
	end
END
GO
PRINT N'Creating [svc].[ICManifest$Import]...';


GO
/*
@slip = Many[Duad<MIC, TrkNbr>]
*/
--PeterHo, Eva:For Special POA(TPE,HKG), no need postcourierNbr still can transit
CREATE PROCEDURE [svc].[ICManifest$Import](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);
	
		declare	@ids I64Array;
		/*BEGIN--For Special POA(TPE,HKG), no need postcourierNbr still can transit*/
		declare	@refNbrSlip tvp;
		with	cte(text) as
		(
			select	[text()]=concat(k.Many, i.MatterID, k.Triad, t.PostCourier, k.Triad, x.v2)
			from	tvp.Duad#Slice(@slip, default, default) x
			cross	apply loc.RefNbr#Cast(x.v1)   m
			cross	apply core.MIC#IdOf(m.Number) i
			cross	apply core.RefNbr#Type() t
			cross	apply tvp.Spr#Const()    k
			for		xml path(N'')
		)
		select	@refNbrSlip=Tvp from cte cross apply tvp.Spr#Purify(text, default);
		exec	core.RefNbr#Merge @slip=@refNbrSlip;

		with	cte as
		(
			select	MatterID=cast(x.v1 as bigint)
			from	tvp.Triad#Slice(@refNbrSlip, default, default) x
		)
		insert	@ids select MatterID from cte
		/*END--For Special POA(TPE,HKG), no need postcourierNbr still can transit*/

		--with cteSlip as
		--(
		--	select	i.MatterID, Type=k.PostCourier, n.Number
		--	from	tvp.Duad#Slice(@slip, default, default) x
		--	cross	apply loc.RefNbr#Cast(x.v1)   m
		--	cross	apply loc.RefNbr#Cast(x.v2)   n
		--	cross	apply core.MIC#IdOf(m.Number) i
		--	cross	apply core.RefNbr#Type()      k
		--)
		--merge	into core._RefNbr as o using cteSlip as n
		--on		(o.MatterID=n.MatterID and o.Type=n.Type)
		--when	    matched and n.Number>N'' then update set o.Number=n.Number
		--when	not matched	and n.Number>N'' then insert (  MatterID,   Type,   Number)
		--										  values (n.MatterID, n.Type, n.Number)
		--output	inserted.MatterID into @ids;

		declare	@actionID I32=(select ICManifest from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from @ids
		cross	apply shpt.Parcel#Maybe(ID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[HubManifest$Import]...';


GO
/*
@slip    = string.Join(",", TrkNbrs);
@context = at.Quad.Of(POD, POA, Mawb, FlightNbr)
*/
--PeterHo
CREATE PROCEDURE [svc].[HubManifest$Import](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	declare	@ids I64Array;
	insert	@ids (ID) 
	select	distinct t.MatterID
	from	loc.RefNbr#Slice(@slip)   x
	cross	apply core.RefNbr#ScanOne(x.Number, default, default) t;

	if (not exists(select * from @ids)) return;

	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@sackMftID I64;
		execute	shpt.SackMft#Create @id=@sackMftID out, @context=@context, @tenancy=@tenancy;

		declare	@actionID  I32=(select ImportHubManifest from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from @ids
		cross	apply shpt.Parcel#Maybe(ID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpecWithPID @spec=@spec, @userID=@userID, @pid=@sackMftID;

		select	@result=(select count(*) from @spec);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Account$Transact]...';


GO
/*
@slip    tvp =Quad<PartyID, XactAmt, PayMethod, Supplemnt>
*/
--Smile
CREATE PROCEDURE [svc].[Account$Transact](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@partyID I32, @xactAmt amt, @payMethod E8, @supplement nax;
		select	@partyID=v1,  @xactAmt=v2,  @payMethod=v3, @supplement=v4
		from	tvp.Quad#Of(@slip, default)

		
		declare	@paymentID I64, @ledgerSide E8=(select AR from acct.Ledger#Side());
		execute	acct.Payment#Insert    @id=@paymentID out
		,		@partyID=@partyID,     @ledgerSide=@ledgerSide, @xactAmt=@xactAmt
		,		@payMethod=@payMethod, @supplement=@supplement;

		declare	@invoiceID I64=0 -- 0: wihtout invoice.
		declare	@vaultType  E8=(select Fund from acct.Vault#Type());
		execute	acct.Vault#Xact    @paymentID=@paymentID, @invoiceID=@invoiceID
		,		@partyID=@partyID, @vaultType=@vaultType, @xactAmt=@xactAmt;

		if(@xactAmt>0)
			execute	shpt.Parcel#ReleaseByDeposit @partyID=@partyID, @tenancy=null

		declare	@userID I32=(select UserID from	loc.Tenancy#Of(@tenancy)),
				@regID I32=(select Contract from core.Registry#ID());

		insert	core._ChangeLog(RegID,       RowID, ChangedBy, ChangedOn)
		select			      SvcRate,  @paymentID,   @userID, getutcdate()
		from	core.Registry#ID();

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[ShippingPlan$Fallback]...';


GO
/*
@slip  = Duad.Join(parcelID, svcTypeID)
*/
--Eva, PeterHo, Daxia
CREATE PROCEDURE [svc].[ShippingPlan$Fallback](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@altSvcType I32=78010001; -- TODO:
		declare	@poa char(3), @routeID I32,     @lastMilerID I32;
		select	@poa=POA,     @routeID=RouteID, @lastMilerID=CourierID
		from	tms.SvcRoute#For(@altSvcType, '')

		declare	@parcelID I64=(select v1 from tvp.Duad#Of(@slip, default));
		update	shpt._Parcel
		set		SvcType=@altSvcType, POA=@poa, RouteID=@routeID, LastMilerID=@lastMilerID
		where	ID=@parcelID;

		declare	@userID I32,    @roleID I32,    @actionID I32;
		select	@userID=UserID, @roleID=RoleID, @actionID=FallbackShipping
		from	loc.Tenancy#Of(@tenancy), core.Action#ID();

		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from shpt.Parcel#Tobe(@parcelID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[ShippingPlan$Return]...';


GO
/*
@slip  =parcelID
*/
--Eva, Daxia
CREATE PROCEDURE [svc].[ShippingPlan$Return](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@parcelID I64=@slip;

		declare	@userID I32,    @roleID I32,    @actionID I32;
		select	@userID=UserID, @roleID=RoleID, @actionID=FlagForReturn
		from	loc.Tenancy#Of(@tenancy), core.Action#ID();

		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from shpt.Parcel#Tobe(@parcelID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$PromoteToShippingPlan]...';


GO
/*
@slip    = MatterID
*/
--Daxia
CREATE PROCEDURE [svc].[Parcel$PromoteToShippingPlan](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@actionID I32=(select PromoteToShippingPlan from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@slip, @actionID=@actionID, @tenancy=@tenancy;
	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$ComposeShippingPlan]...';


GO
/*
@slip    = Block[Mucho[LineInfo]]
@context = MatterID
*/
--Daxia
CREATE PROCEDURE [svc].[Parcel$ComposeShippingPlan](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@exeSlip tvp=
		(
			select	Tvp   from core.RefInfo#Type() k
			cross	apply tvp.Triad#Make(@context, k.ShippingPlanInfo, @slip)
		);
		execute	core.RefInfo#Merge @slip=@exeSlip;

		declare	@actionID I32=(select ComposeShippingPlan from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@context, @actionID=@actionID, @tenancy=@tenancy;
	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[HubManifest$ImportForUSPS]...';


GO
/*
@slip    = Many[Triad<MIC, PostCourier, LocalTime>];
*/
--Smile
CREATE PROCEDURE [svc].[HubManifest$ImportForUSPS](@slip tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@ids I64Array;
		with cteSlip as
		(
			select	i.MatterID, Type=k.PostCourier, n.Number
			from	tvp.Triad#Slice(@slip, default, default)     x
			cross	apply loc.RefNbr#Cast(x.v1)                  m
			cross	apply loc.RefNbr#Cast(x.v2)                  n
			cross	apply core.RefNbr#Type()                     k
			cross	apply core.RefNbr#IdOfFirst(m.Number, k.MIT) i	
			join	shpt.Parcel#Raw()                            p on p.ID=i.MatterID
			where	p.RouteID in(select ID from tms.Route#Raw() where BrokerID=7004)
		)
		merge	into core._RefNbr as o using cteSlip as n
		on		(o.MatterID=n.MatterID and o.Type=n.Type)
		when	    matched and n.Number>N'' then update set o.Number=n.Number
		when	not matched	and n.Number>N'' then insert (  MatterID,   Type,   Number)
												  values (n.MatterID, n.Type, n.Number)
		output	inserted.MatterID into @ids;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);	

		declare	@actionID  I32=(select ImportHubManifest from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from @ids
		cross	apply shpt.Parcel#Maybe(ID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;
		
		declare	@exeSlip tvp;
		with cteStamp(Text) as
		(
			select	[text()]=concat(k.Many, i.MatterID, k.Triad, ToStateID, k.Triad
							 ,		dateadd(hour, -t.UtcOffset, x.v3), k.Trio, t.UtcOffset, k.Trio, t.ID)
			from	tvp.Triad#Slice(@slip, default, default) x		
			cross	apply core.MIC#IdOf(x.v1)                i
			join	@spec                                    s on s.MatterID=i.MatterID
			join	shpt.Parcel#Base()                       p on i.MatterID=p.ID
			join	core.Tenant#Raw()                        t on t.ID=p.RcvHubID
			cross	apply tvp.Spr#Const()                    k 
			for	xml path(N'')		
		)
		select	@exeSlip=Tvp from cteStamp cross apply tvp.Spr#Purify(text, default);
		execute core.RefStamp#Merge @slip=@exeSlip;

		select	@result=(select count(*) from @spec);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[SackMft$Import]...';


GO
/*
	@slip    = Many[Duad<MIC, TrkNbr>];
	@context = Quad<HubID, POA, BrokerID, Mawb>
*/
-- AaronLiu, Eva:For Special POA(TPE,HKG), no need postcourierNbr still can transit
CREATE PROCEDURE [svc].[SackMft$Import](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	BEGIN TRY
		BEGIN	TRAN;

		-- 1.1	Init SackMft
		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@hubID I32, @pOA char(3), @brokerID I32, @mawbNbr char(11)
		select	@hubID=v1,  @pOA=v2,      @brokerID=v3,  @mawbNbr=v4
		from	tvp.Quad#Of(@context, default)

		declare	@now        DT=getutcdate();
		declare	@type       E8=(select SackMft        from core.Matter#Type());
		declare	@stage      E32=(select SackManifested from core.Stage#ID());
		declare	@source     E8=(select InfoPath       from core.Source#ID());
		declare	@stateID   I32=(select SackMftCreated from core.State#ID());
		declare	@sackMftID I64=next value for core.MatterSeq;

		insert	core._Matter
				(ID,         PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		values	(@sackMftID,   @hubID, @stateID, @stage, @source, @type,     @now);

		insert	shpt._SackMft
				(       ID,  POA, POD,  BrokerID,  MawbNbr, FlightNbr)
		select	@sackMftID, @pOA, N'', @brokerID, @mawbNbr,       N''
		from	tvp.Triad#Of(@context, default)

		insert	core._Activity
				(  MatterID,  StateID,  UserID, TalliedOn)
		values	(@sackMftID, @stateID, @userID,      @now);

		-- 2.1	Merge PostCourier
		declare	@ids I64Array;
		/*BEGIN--For Special POA(TPE,HKG), no need postcourierNbr still can transit*/
		declare	@refNbrSlip tvp;
		with	cte(text) as
		(
			select	[text()]=concat(k.Many, i.MatterID, k.Triad, t.PostCourier, k.Triad, x.v2)
			from	tvp.Duad#Slice(@slip, default, default) x
			cross	apply loc.RefNbr#Cast(x.v1)   m
			cross	apply core.MIC#IdOf(m.Number) i
			cross	apply core.RefNbr#Type() t
			cross	apply tvp.Spr#Const()    k
			for		xml path(N'')
		)
		select	@refNbrSlip=Tvp from cte cross apply tvp.Spr#Purify(text, default);
		exec	core.RefNbr#Merge @slip=@refNbrSlip;

		with	cte as
		(
			select	MatterID=cast(x.v1 as bigint)
			from	tvp.Triad#Slice(@refNbrSlip, default, default) x
		)
		insert	@ids select MatterID from cte
		/*END--For Special POA(TPE,HKG), no need postcourierNbr still can transit*/
		--with cteSlip as
		--(
		--	select	i.MatterID, Type=k.PostCourier, n.Number
		--	from	tvp.Duad#Slice(@slip, default, default) x
		--	cross	apply loc.RefNbr#Cast(x.v1)   m
		--	cross	apply loc.RefNbr#Cast(x.v2)   n
		--	cross	apply core.MIC#IdOf(m.Number) i
		--	cross	apply core.RefNbr#Type()      k
		--)
		--merge	into core._RefNbr as o using cteSlip as n
		--on		(o.MatterID=n.MatterID and o.Type=n.Type)
		--when	    matched and n.Number>N'' then update set o.Number=n.Number
		--when	not matched	and n.Number>N'' then insert (  MatterID,   Type,   Number)
		--										  values (n.MatterID, n.Type, n.Number)
		--output	inserted.MatterID into @ids;

		-- 2.2	Transit Parcel To ICManifested
		declare	@actionID I32=(select ICManifest from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from @ids
		cross	apply shpt.Parcel#Maybe(ID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpecWithPID @spec=@spec, @userID=@userID, @pid=@sackMftID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$MergeIDInfo]...';


GO
/*
@slip    = Many[Triad<MatterID, RefInfoType, RefInfo>]
@context = MatterID
*/
--Daxia
CREATE PROCEDURE [svc].[Parcel$MergeIDInfo](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		execute	core.RefInfo#Merge @slip=@slip;	

		declare	@actionID I32=(select UpdateIDPicture from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@context, @actionID=@actionID, @tenancy=@tenancy;
	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Challenge$Pull]...';


GO
/*
@slip    = Many[Duad<MatterID, ChallengeType>]
@context = MessageBody
*/
--Aimee
Create PROCEDURE [svc].[Challenge$Pull](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION--
AS
BEGIN
	SET NOCOUNT	ON;

	execute	core.Challenge#Pull @slip=@slip, @context=@context, @tenancy=@tenancy;
END
GO
PRINT N'Creating [svc].[Parcel$Void]...';


GO
/*
@slip    tvp=Comma[ParcelID]
@result  tvp=Many[Duad<UnVoidID, ClientRefNbr>]
*/
--Smile
CREATE PROCEDURE [svc].[Parcel$Void](@slip tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;
	    
		declare	@userID I32,    @roleID I32,    @actionID I32;
		select	@userID=UserID, @roleID=RoleID, @actionID=VoidParcel
		from	loc.Tenancy#Of(@tenancy), core.Action#ID();

		--	1.Parcel Transit
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* 
		from	tvp.I64#Slice(@slip) x
		cross	apply shpt.Parcel#Tobe(x.ID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		declare	@clientRef E8=(select ClientRef from core.RefNbr#Type());
		declare	@voidInfo  E8=(select VoidInfo  from core.RefInfo#Type());
		--	2.  Insert VoidInfo
		with cteVoidInfo as
		(
			select	r.MatterID, Info=Number
			from	@spec                    x
			join	core.RefNbr#Raw()        r on r.MatterID=x.MatterID and r.Type=@clientRef
		)
		insert	into core._RefInfo(MatterID, Type,      Info)
		select					   MatterID, @voidInfo, Info
		from	cteVoidInfo;

		-- 3.	delete ClientRefNbr		
		delete	from core._RefNbr 
		where	Type=@clientRef	and MatterID in (select MatterID from @spec)
		;

		with cteResult(text) as
		(

			select	[text()]=concat(k.Many, x.ID, k.Duad, c.Number)
			from	tvp.I64#Slice(@slip)  x
			join	core.RefNbr#Raw()     c on c.MatterID=x.ID and c.Type=@clientRef
			cross	apply tvp.Spr#Const() k
			where	not exists(select MatterID from @spec where MatterID=x.ID)
			for		xml path(N'')
		)
		select	@result=Tvp from cteResult cross apply tvp.Spr#Purify(text, default)  
		;
	
		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[SackMft$ImportWithLabelInfo]...';


GO
/*
	@slip    = Block[Many[Duad<MIC, TrkNbr>], Many[LabelInfo]];
	@context = Quad<HubID, POA, BrokerID, Mawb>
*/
-- Eva
CREATE PROCEDURE [svc].[SackMft$ImportWithLabelInfo](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	BEGIN TRY
		BEGIN	TRAN;

		declare	@importSlip tvp;
		select	@importSlip=Tvp
		from	tvp.Block#At(1, @slip, default, default);
		execute	svc.SackMft$Import @slip=@importSlip, @context=@context, @tenancy=@tenancy;

		declare	@labelTvp tvp;
		select	@labelTvp=Tvp
		from	tvp.Block#At(2, @slip, default, default);
		with	cteSlip as
		(
			select	m.MatterID, Type=k.ShippingLabelInfo, Info=i.Piece
			from	tvp.Duad#Slice(@importSlip, default, default) x
			join	tvp.Many#Slice(@labelTvp)     i on i.Seq=x.Seq
			cross	apply loc.RefNbr#Cast(x.v1)   n
			cross	apply core.MIC#IdOf(n.Number) m
			cross	apply core.RefInfo#Type()     k
		)
		merge	into core._RefInfo as o using cteSlip as n
		on		(o.MatterID=n.MatterID and o.Type=n.Type)
		when	    matched and n.Info>N'' then update set o.Info=n.Info
		when	not matched	and n.Info>N'' then insert (  MatterID,   Type,   Info)
												  values (n.MatterID, n.Type, n.Info);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$CfmRelease]...';


GO
/*
@slip    tvp=Many[Duad<TenantID, ClientRefNbr>]
@result  tvp=Duad<Many[Quad<ID,ClientRefNbr, ServiceType,Stage>],Many[Quad<ID,ClientRefNbr, ServiceType,Stage>]>
*/
--Daxia
CREATE PROCEDURE [svc].[Parcel$CfmRelease](@slip tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;
		
		declare	@userID I32,    @roleID I32,    @actionID I32;
		select	@userID=UserID, @roleID=RoleID, @actionID=SourceConfirm
		from	loc.Tenancy#Of(@tenancy), core.Action#ID();

		--	1.Parcel Transit
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* 
		from	tvp.Duad#Slice(@slip, default, default) x
		join	core.RefNbr#Raw()      r on r.Number=x.v2
		join	shpt.Parcel#Base()     p on p.ID=r.MatterID and p.SiteID=cast(x.v1 as int)
		cross	apply shpt.Parcel#Tobe(r.MatterID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		declare	@clientRef E8=(select ClientRef from core.RefNbr#Type());
		declare	@failure tvp;
		with cteResult(text) as
		(
			select	[text()]=concat(k.Many, c.MatterID, k.Quad, c.Number, k.Quad, p.SvcType, k.Quad, p.Stage)
			from	tvp.Duad#Slice(@slip, default, default) x
			join	core.RefNbr#Raw()     c on c.Number=x.v2 and c.Type=@clientRef
			join	shpt.Parcel#Base()    p on p.ID=c.MatterID
			cross	apply tvp.Spr#Const() k
			where	not exists(select MatterID from @spec where MatterID=c.MatterID)
			for		xml path(N'')
		)
		select	@failure=Tvp from cteResult cross apply tvp.Spr#Purify(text, default);
		with cteSuccess(text) as
		(
			select	[text()]=concat(k.Many, x.MatterID, k.Quad, c.Number, k.Quad, p.SvcType, k.Quad, p.Stage)
			from	@spec                 x
			join	core.RefNbr#Raw()     c on c.MatterID=x.MatterID and c.Type=@clientRef
			join	shpt.Parcel#Base()    p on p.ID=x.MatterID
			cross	apply tvp.Spr#Const() k
			for		xml path(N'')
		)
		select	@result=r.Tvp from cteSuccess 
		cross	apply tvp.Spr#Purify(text, default)  x
		cross	apply tvp.Duad#Make(x.Tvp, @failure) r
		;

		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$ChangeRouteToUsps]...';


GO
/*
@slip    = MatterID
*/
--Aimee
Create PROCEDURE [svc].[Parcel$ChangeRouteToUsps](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@actionID I32=(select RouteToUSPS from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@slip, @actionID=@actionID, @tenancy=@tenancy;
	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$VoidViaMic]...';


GO
/*
@slip    tvp=Many[Duad<TenantID, ClientRefNbr>]
@result  tvp=Duad<Many[Quad<ID,ClientRefNbr, ServiceType,Stage>],Many[Quad<ID,ClientRefNbr, ServiceType,Stage>]>
*/
--Daxia
CREATE PROCEDURE [svc].[Parcel$VoidViaMic](@slip tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;

		declare	@userID I32,    @roleID I32,    @actionID I32;
		select	@userID=UserID, @roleID=RoleID, @actionID=VoidParcel
		from	loc.Tenancy#Of(@tenancy), core.Action#ID();

		--	1.Parcel Transit
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* 
		from	tvp.Duad#Slice(@slip, default, default) x
		join	core.RefNbr#Raw()      r on r.Number=x.v2
		join	shpt.Parcel#Base()     p on p.ID=r.MatterID and p.SiteID=cast(x.v1 as int)
		cross	apply shpt.Parcel#Tobe(r.MatterID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		declare	@clientRef E8=(select ClientRef from core.RefNbr#Type());
		declare	@voidInfo  E8=(select VoidInfo  from core.RefInfo#Type());
		--	2.  Insert VoidInfo
		with cteVoidInfo as
		(
			select	r.MatterID, Info=Number
			from	@spec             x
			join	core.RefNbr#Raw() r on r.MatterID=x.MatterID and r.Type=@clientRef
		)
		insert	into core._RefInfo(MatterID, Type,      Info)
		select					   MatterID, @voidInfo, Info
		from	cteVoidInfo;

		-- 3.	delete ClientRefNbr		
		delete	from core._RefNbr 
		where	Type=@clientRef	and MatterID in (select MatterID from @spec)
		;
		
		declare	@failure tvp;
		with cteResult(text) as
		(
			select	[text()]=concat(k.Many, c.MatterID, k.Quad, c.Number, k.Quad, p.SvcType, k.Quad, p.Stage)
			from	tvp.Duad#Slice(@slip, default, default) x
			join	core.RefNbr#Raw()     c on c.Number=x.v2 and c.Type=@clientRef
			join	shpt.Parcel#Base()    p on p.ID=c.MatterID
			cross	apply tvp.Spr#Const() k
			where	not exists(select MatterID from @spec where MatterID=c.MatterID)
			for		xml path(N'')
		)
		select	@failure=Tvp from cteResult cross apply tvp.Spr#Purify(text, default);
		with cteSuccess(text) as
		(
			select	[text()]=concat(k.Many, x.MatterID, k.Quad, c.Number, k.Quad, p.SvcType, k.Quad, p.Stage)
			from	@spec                 x
			join	core.RefNbr#Raw()     c on c.MatterID=x.MatterID and c.Type=@clientRef
			join	shpt.Parcel#Base()    p on p.ID=x.MatterID
			cross	apply tvp.Spr#Const() k
			for		xml path(N'')
		)
		select	@result=r.Tvp from cteSuccess 
		cross	apply tvp.Spr#Purify(text, default)  x
		cross	apply tvp.Duad#Make(x.Tvp, @failure) r
	
		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$SurrenderByImport]...';


GO
/*
@slip	=Many[Duad<MIC, LastMilerTrackingNbr>]
@result	=Many[Triad<MatterID, 9, LastMilerTrackingNbr>] // todo: may refine later
*/
--Eva
CREATE PROCEDURE [svc].[Parcel$SurrenderByImport](@slip tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@minStage E32,       @maxStage E32;
		select	@minStage=Outgated, @maxStage=Surrendered
		from	core.Stage#ID();

		declare	@idsInCsv tvp, @refNbrSlip tvp;
		with	cte(text) as
		(
			select	[text()]=concat(k.Many, i.MatterID, k.Triad, t.PostCourier, k.Triad, x.v2)
			from	tvp.Duad#Slice(@slip, default, default) x
			cross	apply loc.RefNbr#Cast(x.v1)   m
			cross	apply core.MIC#IdOf(m.Number) i
			cross	apply core.RefNbr#Type() t
			cross	apply tvp.Spr#Const()    k
			for		xml path(N'')
		)
		select	@refNbrSlip=Tvp from cte cross apply tvp.Spr#Purify(text, default);
		exec	core.RefNbr#Merge @slip=@refNbrSlip;
		;
		with	cte(text) as
		(
			select	[text()]=concat(N',', x.v1)
			from	tvp.Triad#Slice(@refNbrSlip, default, default) x
			cross	apply tvp.Spr#Const() k
			for		xml path(N'')
		)
		select	@idsInCsv=Tvp from cte cross apply tvp.Spr#Purify(text, 1);

		declare	@actionID I32=(select CfmSurrenderByImport from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@idsInCsv, @actionID=@actionID, @tenancy=@tenancy;

		select	@result=@refNbrSlip;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$CfmDoorDeliverd]...';


GO
/*
	@slip = Comma<PostCourierNbr>
*/
-- AaronLiu
CREATE PROCEDURE [svc].[Parcel$CfmDoorDeliverd](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		with cte(text) as
		(
			select	[text()]=concat(N',',  n.MatterID)
			from	tvp.Comma#Slice(@slip) x
			cross	apply core.Stage#ID()  s
			cross	apply core.RefNbr#ScanOne(x.Piece, s.Surrendered, s.DoorDelivered) n
			  for	xml path(N'')
		)
		select	@slip=Tvp from cte cross apply tvp.Spr#Purify(text, 1);

--		declare	@actionID I32=(select CfmDoorDelivered from core.Action#ID());
		declare	@actionID I32=19990;
		execute	svc.Parcel$Transit @idsInCsv=@slip, @actionID=@actionID, @tenancy=@tenancy;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$RequeueBrkgApi]...';


GO
--Daxia
CREATE PROCEDURE [svc].[Parcel$RequeueBrkgApi](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@actionID I32=(select RequeueBrkgApi from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@slip, @actionID=@actionID, @tenancy=@tenancy;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$Classified]...';


GO
/*
@slip    = Mucho[Triad<SkuID, CmdyInfo, LineInfo>]
@context = MatterID
*/
--Aimee
CREATE PROCEDURE [svc].[Parcel$Classified](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@exeSlip tvp=
		(
			select	Tvp   from core.RefInfo#Type() k
			cross	apply tvp.Triad#Make(@context, k.BrokerageInfo, @slip)
		);
		execute	core.RefInfo#Merge @slip=@exeSlip;

		declare	@actionID I32=(select DetermineCmdy from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@context, @actionID=@actionID, @tenancy=@tenancy;
	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$RequestIDInfo]...';


GO
/*
	@slip = Comma<ParcelID>
*/
-- AaronLiu
CREATE PROCEDURE [svc].[Parcel$RequestIDInfo](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@actionID	 I32=(select ConfirmIDInfo	  from core.Action#ID())
		,		@exeActionID I32=(select RequestIDPicture from core.Action#ID());

		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from shpt.Parcel#TobeVia(@slip, @roleID, @actionID) t;

		declare	@exeSpec core.TransitionSpec;
		insert	@exeSpec select t.* from shpt.Parcel#TobeVia(@slip, @roleID, @exeActionID) t;

		execute	core.Matter#TransitBySpec @spec=@exeSpec, @userID=@userID, @beAffected=1;

		with	cteMatter as
		(
			select	m.ID, RejoinID, NewRejoinID=x.ToStateID
			from	core._Matter m
			join	@spec        x on x.MatterID=m.ID
			join	@exeSpec     v on x.MatterID=v.MatterID
		)
		update	cteMatter set RejoinID=NewRejoinID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$CfmIDInfo]...';


GO
/*
	@slip = Many[Triad<MatterID, RefInfoType, IDInfo>]
*/
-- AaronLiu
CREATE PROCEDURE [svc].[Parcel$CfmIDInfo](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		execute	core.RefInfo#Merge @slip=@slip;	

		declare	@idsInCsv tvp;
		with	cte(text) as
		(
			select	[text()]=concat(N',', x.v1)
			from	tvp.Triad#Slice(@slip, default, default) x
			for		xml path(N'')
		)
		select	@idsInCsv=Tvp from cte cross apply tvp.Spr#Purify(text, 1);
		declare	@actionID I32=(select ConfirmIDInfo from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@idsInCsv, @actionID=@actionID, @tenancy=@tenancy;
	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$ImportClassified]...';


GO
/*
@slip    = Duad[ParcelID, BrkgInfo]
*/
--Smile
CREATE PROCEDURE [svc].[Parcel$ImportClassified](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@ids dbo.I64Array;
		with cteSlip as
		(
			select	MatterID=cast(v1 as bigint), Type=k.BrokerageInfo, Info=v2
			from	tvp.Duad#Slice(@slip, default, default) x
			cross	apply core.RefInfo#Type()               k
		)
		merge	core._RefInfo as o using cteSlip as n
		on		(o.MatterID=n.MatterID and o.Type=n.Type)
		when	matched and len(n.Info)=0     then delete
		when	matched and o.Info<>n.Info    then update set Info=n.Info
		when	not matched and len(n.Info)>0 then insert (  MatterID,   Type,   Info)
												   values (n.MatterID, n.Type, n.Info)
		output inserted.MatterID into @ids;
		;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@actionID I32=(select DetermineCmdy from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.*
		from	@ids  x
		cross	apply shpt.Parcel#Tobe(x.ID, @roleID, @actionID) t
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$ImportBrkgInfo]...';


GO
/*
@slip    = Duad[ParcelID, BrkgInfo]
*/
--Smile
CREATE PROCEDURE [svc].[Parcel$ImportBrkgInfo](@slip tvp,  @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@ids dbo.I64Array;
		with cteSlip as
		(
			select	MatterID=cast(v1 as bigint), Type=k.BrokerageInfo, Info=v2
			from	tvp.Duad#Slice(@slip, default, default) x
			cross	apply core.RefInfo#Type()               k
		)
		merge	core._RefInfo as o using cteSlip as n
		on		(o.MatterID=n.MatterID and o.Type=n.Type)
		when	matched and len(n.Info)=0     then delete
		when	matched and o.Info<>n.Info    then update set Info=n.Info
		when	not matched and len(n.Info)>0 then insert (  MatterID,   Type,   Info)
												   values (n.MatterID, n.Type, n.Info)
		output inserted.MatterID into @ids;
		;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@actionID I32=(select TranslateForBrokerage from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.*
		from	@ids  x
		cross	apply shpt.Parcel#Tobe(x.ID, @roleID, @actionID) t
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;
	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Appointment$CallOff]...';


GO
/*
@slip = Comma<AppointmentID>
*/
--AaronLiu
CREATE PROCEDURE [svc].[Appointment$CallOff](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@actionID  E32=(select CallOffDriver=17275 from core.Action#ID())	--HACK
		,		@partyRole E32=(select Ramper			   from core.Party#Role());

		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from core.Matter#TobeVia(@slip, @roleID, @actionID) t
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

		execute	core.RefParty#MergeVia @idsInCsv=@slip, @partyRole=@partyRole, @partyID=0;
			
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH 
END
GO
PRINT N'Creating [svc].[Appointment$CancelStartOff]...';


GO
/*
@slip = Comma<AppointmentID>
*/
--AaronLiu
CREATE PROCEDURE [svc].[Appointment$CancelStartOff](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@actionID  E32=(select CancelStartOff=17277 from core.Action#ID());	--HACK

		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from core.Matter#TobeVia(@slip, @roleID, @actionID) t
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;
			
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH 
END
GO
PRINT N'Creating [svc].[Appointment$StartOff]...';


GO
/*
@slip = Comma<AppointmentID>
*/
--AaronLiu
CREATE PROCEDURE [svc].[Appointment$StartOff](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@actionID  E32=(select DriverStartOff=17276 from core.Action#ID());	--HACK

		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from core.Matter#TobeVia(@slip, @roleID, @actionID) t
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;
			
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH 
END
GO
PRINT N'Creating [svc].[Appointment$Dispatch]...';


GO
/*
@slip	 = Comma<AppointmentID>
@context = RamperID
*/
--AaronLiu
CREATE PROCEDURE [svc].[Appointment$Dispatch](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@actionID  E32=(select Dispatch=17284 from core.Action#ID())	--HACK
		,		@partyRole E32=(select Ramper		  from core.Party#Role());

		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from core.Matter#TobeVia(@slip, @roleID, @actionID) t
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

		execute	core.RefParty#MergeVia @idsInCsv=@slip, @partyRole=@partyRole, @partyID=@context;
			
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH 
END
GO
PRINT N'Creating [svc].[Parcel$Measure]...';


GO
-- PeterHo, AaronLiu
CREATE PROCEDURE [svc].[Parcel$Measure](@numbersInCsv tvp, @wlwhInCsv tvp, @tenancy tvp, @result tvp out, @number tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@minStage E32,    @maxStage E32;
		select	@minStage=PreMin, @maxStage=CurMax
		from	core.Stage#Boundary();
		
		declare	@matterID I64;
		select	@matterID=MatterID, @number=Number
		from	core.RefNbr#ScanMulti(@numbersInCsv, @minStage, @maxStage);
		/*
		if(@matterID is null)
			execute	shpt.Orphan#Init @numbersInCsv=@numbersInCsv, @tenancy=@tenancy, @matterID=@matterID out, @number=@number out;
		*/
		declare	@rcvHubID I32,   @userID I32;
		select	@rcvHubID=HubID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy);
		execute	core.Activity#OnceHubAccepted @matterID=@matterID, @userID=@userID;

		with cteParcel as
		(
			select	ID, q.v1,   q.v2,   q.v3,  q.v4
			from	tvp.Quad#Of(@wlwhInCsv, N',') q
			,		shpt.Parcel#Raw() where ID=@matterID
		)
		update	o set RcvHubID=@rcvHubID, Weight=v1, Length=v2, Width=v3, Height=v4
		from	shpt._Parcel o join cteParcel n on o.ID=n.ID;
		/*
		declare	@actionID I32=(select HubMeasure from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@matterID, @actionID=@actionID, @tenancy=@tenancy;
		*/
		execute	shpt.Parcel#Measure @matterID=@matterID, @tenancy=@tenancy;

		select	@result=@matterID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [vmi].[StockInOrder$HubVerified]...';


GO
/*
@slip=    Comma[AsnNbr]
@result=  StockInOrderID
*/
--Smile
CREATE PROCEDURE [vmi].[StockInOrder$HubVerified](@slip tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;	

		declare	@daemon I32=0;

		declare	@actionID I32=(select CfmAsnHubVerified from core.Action#ID());

		declare	@spec core.TransitionSpec;
		insert	@spec 		
		select	t.* 
		from	loc.RefNbr#Slice(@slip)  x
		cross	apply core.RefNbr#Type() k
		join	core.RefNbr#Raw()        r on  x.Number=r.Number and r.Type=k.AsnNbr
		cross	apply core.Matter#Tobe(r.MatterID, @daemon, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@daemon, @beAffected=1;
	
END
GO
PRINT N'Creating [vmi].[HubMft$Import]...';


GO
/*
@slip    = Quad[TrackingNbr, SackNbr, Quantity, Weight>;
@context = Tuplet<POD, POA, Mawb, FlightNbr, HubID>
@result  = parcelCnt
*/
--Smile
CREATE PROCEDURE [vmi].[HubMft$Import](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	declare	@ids I64Array;
	insert	@ids (ID) 
	select	distinct t.MatterID
	from	tvp.Quad#Slice(@slip, default, default) x
	cross	apply core.RefNbr#ScanOne(x.v1, default, default) t;

	if (not exists(select * from @ids)) return;

	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@sackMftID I64;
		execute	shpt.SackMft#Create @id=@sackMftID out, @context=@context, @tenancy=@tenancy;

		declare	@actionID  I32=(select ImportHubManifest from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from @ids
		cross	apply shpt.Parcel#Maybe(ID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpecWithPID @spec=@spec, @userID=@userID, @pid=@sackMftID;

		select	@result=(select count(*) from @spec);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [vmi].[Parcel$ReceivedWeight]...';


GO
/*
@slip    = Tuplet[TrackingNbr, Weight, Width, Length, Height]
*/
--Smile
CREATE PROCEDURE [vmi].[Parcel$ReceivedWeight](@slip tvp,  @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

	declare	@daemon I32=0;
	declare	@creditExceeded I32, @svcRateNotFound I32, @actionID I32;
	select	@creditExceeded=ReportCreditLimitExceeded, @svcRateNotFound=ReportSvcRateNotFound, @actionID=WMSProvideOutgoingWeight
	from core.Action#ID();
	
	declare	@spec core.TransitionSpec, @specVia core.TransitionSpec;
	insert	@spec select t.* from tvp.Tuplet#Slice(@slip, default, default) x
	cross	apply core.RefNbr#ScanOne(x.v1, default, default)     d
	cross	apply shpt.Parcel#TobeVia(d.MatterID, @daemon, @actionID) t;
	

	declare	@parcelIDs I64Array;insert	into @parcelIDs(ID)
	select	MatterID from @spec x
	join	shpt.Parcel#Raw()   p on p.ID=x.MatterID
	cross	apply tms.SvcRate#For(p.SvcType, p.RcvHubID, p.Weight) s
	where	not exists(
							select	ID from acct.Ledger#Raw()  l
							cross	apply acct.Ledger#Side() d
							where	MatterID=x.MatterID and l.LedgerSide=d.AR
						);
	execute	shpt.Parcel#BillForVmi @parcelIDs=@parcelIDs;

	with cteCumulation as
	(
		select	x.ID, x.MatterID, x.ChargeRaw,  x.CurrencyID 
		,		CurBalRaw
		,		Cumulation=sum(ChargeRaw) over( partition by x.PartyID, x.CurrencyID order by x.ID desc) 
		from	@spec                    p
		join	acct.Ledger#Raw()        x on p.MatterID=x.MatterID
		cross	apply acct.Ledger#Side() d
		cross	apply (
							select	PartyID, CurrencyID, CurBalRaw=sum(CurBalRaw)
							from	acct.Vault#Raw() 
							where	PartyID=x.PartyID and CurrencyID=x.CurrencyID
							group	by PartyID, CurrencyID
						) v
			
		where	x.LedgerSide=d.AR 
	), cteSummary as
	(
		select	MatterID, Marker=(case when CurBalRaw>=0 then 0  										  
										when CurBalRaw<0 and (Cumulation+CurBalRaw)>ChargeRaw then 0
										else 1 end)
		,		isSvcRateFound=0
		from	cteCumulation	
		union	all
		select	MatterID, 0, isSvcRateFound=iif(s.SvcRate is null, 0, 1)
		from	@spec                    x
		join	shpt.Parcel#Raw()        p on x.MatterID=p.ID
		outer	apply tms.SvcRate#For(p.SvcType, p.RcvHubID, p.Weight) s
	), cteParcelGroup as
	(
		select	MatterID, ParcelGroup=sum(Marker), isSvcRateFound=sum(isSvcRateFound)
		from	cteSummary
		group	by MatterID			
	), cteParcelTodo as
	(
		select	MatterID
		,		ActionID=iif(isSvcRateFound=0, @svcRateNotFound, iif(ParcelGroup=0, @actionID, @creditExceeded))
		from	cteParcelGroup
	)
	insert	into @specVia select t.* 
	from	cteParcelTodo x
	cross	apply shpt.Parcel#Tobe(x.MatterID, @daemon, x.ActionID) t;
		
	with	cteMatter as
	(
		select	m.ID, RejoinID, NewRejoinID=s.ToStateID
		from	core._Matter m
		join	@spec        s on m.ID=s.MatterID
		join	@specVia     v on m.ID=v.MatterID
		where	v.ActionID in (@svcRateNotFound, @creditExceeded)
	)
	update	cteMatter set RejoinID=NewRejoinID;

	execute	core.Matter#TransitBySpec @spec=@specVia, @userID=@daemon, @beAffected=1;

	with cteParcel as
	(
		select	p.ID, NewWeight=x.v2, NewWidth=x.v3, NewLength=x.v4, NewHeight=x.v5
		from	tvp.Tuplet#Slice(@slip, default, default)         x
		cross	apply core.RefNbr#ScanOne(x.v1, default, default) s
		join	shpt.Parcel#Raw()                                 p on p.ID=s.MatterID
	)
	update	o set Weight=NewWeight, Height=NewHeight, Length=NewLength, Width=NewWidth
	from	shpt._Parcel o join cteParcel n on o.ID=n.ID;
	

	COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [vmi].[StockInOrder$Void]...';


GO
/*
@slip=  Comma[AsnNbr]
@result=Pair<TenantAlias, Duad[RcvHub, AsnNbr]>
*/
--Smile
CREATE PROCEDURE [vmi].[StockInOrder$Void](@slip tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;

		declare	@userID I32,    @roleID I32,    @tenantAlias loc.Alias;;
		select	@userID=UserID, @roleID=RoleID, @tenantAlias=TenantAlias
		from	loc.Tenancy#Of(@tenancy) x
		join	core.Party#Raw()         p on x.AID=p.ID
		cross	apply loc.TenantAlias#Rectify(p.Alias) t;

	    declare	@actionID I32=(select VoidAsn from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec 		
		select	t.* 
		from	loc.RefNbr#Cast(@slip)   x
		cross	apply core.RefNbr#Type() k
		join	core.RefNbr#Raw()        r on r.Number=x.Number and r.Type=k.AsnNbr
		cross	apply core.Matter#Tobe(r.MatterID, @roleID, @actionID) t;
        
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

		with cteResult(text) as
		(
			select	[text()]=concat(k.Many, r.Alias, k.Duad, m.Number)
			from	@spec x
			join	whse.StockInOrder#Raw()  s on s.ID=x.MatterID
			join	core.Party#Raw()         r on r.ID=s.RcvHubID
			cross	apply core.RefNbr#Type() t
			join	core.RefNbr#Raw()        m on m.MatterID=s.ID and m.Type=t.AsnNbr
			cross	apply tvp.Spr#Const()    k
			for		xml path(N'')
		)
		select	@result=r.Tvp 
		from	cteResult 
		cross	apply tvp.Spr#Purify(text, default)  x
		cross	apply tvp.Pair#Make(@tenantAlias, x.Tvp) r
		;
END
GO
PRINT N'Creating [vmi].[StockInOrder$Racked]...';


GO
/*
@slip=    Many[Duad<AsnNbr, TotalSkuQty>]
@result=  RackedCnt
*/
--Smile
CREATE PROCEDURE [vmi].[StockInOrder$Racked](@slip tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@daemon I32=0;		
		declare	@actionID I32=(select CfmAsnRacked from core.Action#ID());

		declare	@orderIDs I64Array;
		insert	@orderIDs select  MatterID
		from	tvp.Duad#Slice(@slip, default, default)  x
		cross	apply core.RefNbr#Type() k
		join	core.RefNbr#Raw()        r on  x.v1=r.Number and r.Type=k.AsnNbr;

		declare	@spec core.TransitionSpec;
		insert	@spec 		
		select	t.* 
		from	@orderIDs r
		cross	apply core.Matter#Tobe(r.ID, @daemon, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@daemon, @beAffected=1;

		with cte as
		(
			select	TotalSkuQty, NewTotalSkuQty=cast(x.v2 as int)
			from	tvp.Duad#Slice(@slip, default, default)  x
			cross	apply core.RefNbr#Type() k
			join	core.RefNbr#Raw()        r on  x.v1=r.Number and r.Type=k.AsnNbr
			join	whse.StockInOrder#Raw()  c on c.ID=r.MatterID

		)
		update cte set TotalSkuQty=NewTotalSkuQty;
		
		execute	whse.RcvSkuFee#Bill @orderIDs=@orderIDs;

		select	@result=(select count(*) from @spec); 

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [vmi].[StockInOrder$Import]...';


GO
/*
@slip=    Comma[StockInOrderID]
@context= RcvHubID
@result=  Comma[StockInOrderID]
*/
--Smile
CREATE PROCEDURE [vmi].[StockInOrder$Import](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@actionID I32=(select ImportAsn from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec 		
		select	t.* 
		from	tvp.I64#Slice(@slip) x
		cross	apply core.Matter#Tobe(x.ID, @roleID, @actionID) t;
        
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

		--with cteAsn as
		--(
		--	select	ID, TotalSkuQty, NewTotalSkuQty=cast(v2 as int)
		--	from	tvp.Duad#Slice(@slip, default, default) x
		--	join	@spec                                   c on c.MatterID=cast(v1 as bigint)
		--	join	whse.StockInOrder#Raw()                 s on s.ID=c.MatterID

		--)
		--update cteAsn set TotalSkuQty=NewTotalSkuQty;

		with cte(text) as
		(
			select	[text()]=concat(N',', MatterID)
			from	@spec
			for xml path(N'')
		)
		select	@result=Tvp from cte cross apply tvp.Spr#Purify(text, default);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [vmi].[Parcel$Void]...';


GO
/*
@slip    =Many[Duad<TrackingNbr,HasWmsVoid>]
@result  =Triad<Pair<TenantAlias, Duad[RcvHub, OrderNbr]>, ReleasedSkus>
*/
--Smile
CREATE PROCEDURE [vmi].[Parcel$Void](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;
	    
		declare	@userID I32,    @roleID I32,    @tenantAlias loc.Alias;
		select	@userID=UserID, @roleID=RoleID, @tenantAlias=TenantAlias
		from	loc.Tenancy#Of(@tenancy) x
		join	core.Party#Raw()         p on x.AID=p.ID
		cross	apply loc.TenantAlias#Rectify(p.Alias) t;

	    declare	@actionID I32=(select VoidParcel from core.Action#ID());

		--	1.Parcel Transit
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* 
		from	tvp.Duad#Slice(@slip, default, default) x
		cross	apply loc.RefNbr#Cast(x.v1)             b
		cross	apply core.RefNbr#ScanOne(b.Number, default, default)  n
		cross	apply shpt.Parcel#Tobe(n.MatterID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		declare	@clientRef E8=(select ClientRef from core.RefNbr#Type());
		declare	@voidInfo  E8=(select VoidInfo  from core.RefInfo#Type());
		--	2.  Insert VoidInfo
		with cteVoidInfo as
		(
			select	r.MatterID, Info=Number
			from	@spec                    x
			join	core.RefNbr#Raw()        r on r.MatterID=x.MatterID and r.Type=@clientRef
		)
		insert	into core._RefInfo(MatterID, Type, Info) select MatterID, @voidInfo, Info
		from	cteVoidInfo;

		declare	@exeResult tvp;
		;with cteResult(text) as
		(
			select	[text()]=concat(k.Many, r.Alias, k.Duad, m.Number)
			from	@spec x
			join	shpt.Parcel#Raw()        s on s.ID=x.MatterID
			join	core.Party#Raw()         r on r.ID=s.RcvHubID
			cross	apply core.RefNbr#Type() t
			join	core.RefNbr#Raw()        m on m.MatterID=s.ID and m.Type=t.ClientRef
			cross	apply tvp.Spr#Const()    k
			for		xml path(N'')
		)
		select	@exeResult=r.Tvp 
		from	cteResult 
		cross	apply tvp.Spr#Purify(text, default)  x
		cross	apply tvp.Pair#Make(@tenantAlias, x.Tvp) r
		;

		-- 3.	delete ClientRefNbr		
		delete	from core._RefNbr 
		where	Type=@clientRef	and MatterID in (select MatterID from @spec)
		;

		
		declare	@exeSlip tvp;
		declare	@source E8=(select eVMI from core.Source#ID());
		with cteSkuOnHeld(text) as
		(
			select	[text()]=concat(c.Many, @tenantAlias, c.Tuplet
										  , g.Sku,		  c.Tuplet 
										  , g.SkuBatch,	  c.Tuplet
										  , g.Condition,  c.Tuplet
										  , l.LineQty)
			from	tvp.Duad#Slice(@slip, default, default) x
			cross	apply loc.RefNbr#Cast(x.v1)             b
			cross	apply core.RefNbr#ScanOne(b.Number, default, default)  n
			join	@spec                     q on q.MatterID=n.MatterID
			cross	apply core.RefInfo#Type() k
			join	core.RefInfo#Raw()        i on i.MatterID=q.MatterID and i.Type=k.DeclaredInfo
			join	shpt.Parcel#Base()        m on m.ID=i.MatterID
			cross	apply tvp.Mucho#Slice(i.Info)          d
			cross	apply loc.LineInfo#Of(d.Piece)         l
			cross	apply loc.GoodsInfo#Of(l.GoodsInfo)    g
			cross	apply tvp.Spr#Const()                  c
			cross	apply core.State#ID()                  s
			where	cast(x.v2 as bit)=0 and q.OnStateID<s.AwaitingMeasurement  --Hack 
			for	xml path(N'')
		)
		select	@exeSlip=d.Tvp
		from	cteSkuOnHeld x cross apply tvp.Spr#Purify(text, default) t
		cross	apply tvp.Duad#Make(@source, t.Tvp)                      d;

		select	@result=Tvp from tvp.Triad#Make(@exeResult, @exeSlip, N'');
		--execute	[$(FLUX_SERVER)].[$(FLUX_WMS)].svc.SkuOnHold$Release @exeSlip;
	
		COMMIT TRAN;			
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [xpd].[Parcel$MeasureForXpd]...';


GO
/*
@slip	= at.Duad.Join(Mic, Weight).Over(at.Tvp.Many)
@context= Source
@result	= at.Many.Join(ParcelID)
*/
-- Daxia
CREATE PROCEDURE [xpd].[Parcel$MeasureForXpd](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32,    @roleID I32;
		select	@siteID=SiteID, @userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@source E8=@context;

		-- 1.	Prepare idSeqs
		declare	@idSeqs I64Seqs; 
		insert	@idSeqs(ID, Seq) select m.MatterID, x.Seq
		from	tvp.Duad#Slice(@slip, default, default)           x
		cross	apply core.RefNbr#ScanOne(x.v1, default, default) m;

		-- 2.1	Prepare PicSpecs:
		declare	@idTexts I64Texts; 
		insert	@idTexts(ID, Text) select m.MatterID, v2
		from	tvp.Duad#Slice(@slip, default, default)           x
		cross	apply core.RefNbr#ScanOne(x.v1, default, default) m;

		declare	@picSpec tms.PicSpec; insert @picSpec
		(		MeasuredWt,   SvcType, Zip3,                Plus2)
		select	x.Text,     p.SvcType, left(p.ZoneCode, 3), substring(p.ZoneCode, 4, 2)
		from	@idTexts x join shpt.Parcel#Base() p on p.ID=x.ID;

		-- 2.2	Upd Parcel Weight
		with cteUpdWt as
		(
			select	x.ID, Weight, MeasureWt=cast(x.Text as real)
			from	@idTexts x join shpt.Parcel#Raw() p on p.ID=x.ID
		)
		update	cteUpdWt set Weight=MeasureWt;

		-- 3	Emit PICs:
		declare	@picResult tms.PicResult; insert @picResult
		exec	tms.Pic#Emit @source=@source, @picSpec=@picSpec;
		
		declare	@postCourier E8=(select PostCourier from core.RefNbr#Type());
		-- 4	Init TrackingNbr
		insert	core._RefNbr
		(		MatterID, Type,         Number)
		select	x.ID,     @postCourier, t.TrackingNbr
		from	@idSeqs x join @picResult r on r.SeqNbr=x.Seq
		cross	apply tms.TrackingNbr#Make(r.SvcCode, r.MailerID, r.MailerSeq, x.ID) t;
		
		-- 5	Transit
		declare	@actionID    I32=(select HubMeasure from core.Action#ID())
		,		@idsInCsv    tvp
		,		@idArray     I64Array;
		insert	@idArray(ID) select ID from @idSeqs;
		select	@idsInCsv=x.Tvp from tvp.I64#Join(@idArray) x;
		
		declare @spec core.TransitionSpec;
		insert	@spec select t.* from shpt.Parcel#TobeVia(@idsInCsv, @roleID, @actionID) t;

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		-- 6.	result
		with cteResult(text) as
		(
			select	[text()]=concat(k.Many, x.ID)
			from	tvp.Spr#Const() k, @idSeqs x
			for		xml path(N'')
		)
		select	@result=x.Tvp from cteResult 
		cross	apply tvp.Spr#Purify(text, default)  x
		;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [xpd].[Sack$CreateForXpd]...';


GO
/*
	@slip    = Many[Triad<SackNbr, Weight, string.Join(at.Spr.Comma, Mics)>]
	@context = Duad<SackMftID, ClrMethodID>
	@result  = Many[Duad<SackID, SackNbr>]
*/
-- Daxia
CREATE PROCEDURE [xpd].[Sack$CreateForXpd](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	BEGIN TRY
		BEGIN	TRAN;
		
		-- 1.0	Check Parcel Transit
		declare	@userID I32,    @siteID I32,    @roleID I32;
		select	@userID=UserID, @siteID=SiteID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare @actionID E32=(select ImportOutgateManifest from core.Action#ID())

		declare	@sackMftID I64, @clrMethodID I32;
		select	@sackMftID=v1,  @clrMethodID=v2
		from	tvp.Duad#Of(@context, default);

		-- 1.1	Init Sack
		declare	@now      DT=getutcdate()
		,		@type     E8 =(select Sack			from core.Matter#Type())
		,		@stage    E32=(select SackManifested from core.Stage#ID())
		,		@stateID  I32=(select SackManifested from core.State#ID())
		;
		declare	@source E8,     @brokerID I32,      @poa char(3);
		select	@source=Source, @brokerID=BrokerID, @poa=POA
		from	shpt.SackMft#Base() where ID=@sackMftID

		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Many@Count(@slip));

		insert	core._Matter
		(		ID,          PID, PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		select	x.ID, @sackMftID,  @siteID, @stateID, @stage, @source, @type,     @now
		from	@idSeqs x;

		insert	shpt._Sack
		(		  ID,  BrokerID,  ClrMethodID,  POA, SackWt)
		select	x.ID, @brokerID, @clrMethodID, @poa, s.v2
		from	@idSeqs x
		join	tvp.Triad#Slice(@slip, default, default) s on s.Seq=x.Seq;

		insert	core._Activity
		(		MatterID,  StateID,  UserID, TalliedOn)
		select	      ID, @stateID, @userID,      @now
		from	@idSeqs;
		
		-- 1.2	Insert Mic
		insert	core._RefNbr
		(		MatterID, Type,  Number)
		select	    x.ID, k.MIT, m.MIC
		from	@idSeqs x cross apply core.RefNbr#Type() k
		cross	apply core.MIC#Emit(x.ID, @source, @type, @now) m;
		-- 1.3	Insert RefNbr
		declare	@idTexts I64Texts;
		insert	core._RefNbr
		(		MatterID, Type,  Number)
		output	inserted.MatterID, inserted.Number into @idTexts
		select	    x.ID, k.ClientRef, s.v1
		from	@idSeqs x cross apply core.RefNbr#Type() k
		join	tvp.Triad#Slice(@slip, default, default) s on s.Seq=x.Seq
		;

		-- 2.1	Link Parcel's PID from SackMft to Sack:
		with cteParcel as
		(
			select	m.ID, m.PID, SackID=x.ID 
			from	@idSeqs x
			join	tvp.Triad#Slice(@slip, default, default) s on s.Seq=x.Seq
			cross	apply tvp.Comma#Slice(s.v3)                          i
			cross	apply core.RefNbr#ScanOne(i.Piece, default, default) r
			join	core.Matter#Raw() m on m.ID=r.MatterID
		)
		update cteParcel set PID=SackID;


		-- 2.2	Transit Parcel
		declare	@ids I64Array; insert @ids(ID) select m.MatterID
		from	tvp.Triad#Slice(@slip, default, default)             x
		cross	apply tvp.Comma#Slice(x.v3)                          i
		cross	apply core.RefNbr#ScanOne(i.Piece, default, default) m
		;
		declare	@idCommas tvp=(select Tvp from tvp.I64#Join(@ids));

		declare	@spec core.TransitionSpec; insert @spec select t.* 
		from	shpt.Parcel#TobeVia(@idCommas, @roleID, @actionID) t;

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=0;

		---- 2.3	Parcel Bill -AR
		--declare	@parcelIDs I64Array;insert into @parcelIDs(ID)
		--select	r.MatterID from tvp.Triad#Slice(@slip, default, default)   x
		--cross	apply tvp.Comma#Slice(x.v3)                          i
		--cross	apply core.RefNbr#ScanOne(i.Piece, default, default) r
		--join	shpt.Parcel#Raw()   p on p.ID=r.MatterID
		--cross	apply tms.SvcRate#For(p.SvcType, p.RcvHubID, p.Weight) s
		--where	s.SvcRate>0
		--and		not exists(
		--			select	ID from acct.Ledger#Raw()  l
		--			cross	apply acct.Ledger#Side()   d
		--			where	MatterID=r.MatterID and l.LedgerSide=d.AR
		--		);
		--exec	shpt.Parcel#BillForFactor @parcelIDs=@parcelIDs;
		
		---- 2.4	Manifest Bill -AR


		-- 3.1	Return Result
		with cteResult(text) as
		(
			select	[text()]=concat(k.Many, x.ID, k.Duad, x.Text)
			from	tvp.Spr#Const() k, @idTexts x
			for		xml path(N'')
		)
		select	@result=x.Tvp from cteResult 
		cross	apply tvp.Spr#Purify(text, default)  x
		;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [zeb].[ShippingPlan$Concur]...';


GO
/*
@slip    = ConcurredInfo: Bag[Pair<ClientRefNbr, InsuranceAmt>]
@context = ParcelID
*/
--Eva, PeterHo
CREATE PROCEDURE [zeb].[ShippingPlan$Concur](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@parcelID I64=@context;
		declare	@infoSlip tvp=
		(
			select	Tvp   from core.RefInfo#Type()  k
			cross	apply tvp.Triad#Make(@parcelID, k.ConcurredInfo, @slip)
		);
		execute	core.RefInfo#Merge @slip=@infoSlip;

		declare	@userID I32,    @roleID I32,    @actionID I32;
		select	@userID=UserID, @roleID=RoleID, @actionID=SourceConcur
		from	loc.Tenancy#Of(@tenancy), core.Action#ID();

		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from shpt.Parcel#Tobe(@parcelID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[Parcel$RcvBrkgRejection]...';


GO
/*
@slip = Many[Duad<ParcelID, ErrorMsg>]
@todo : Many[Duad<ParcelID, ErrorCode>]
*/
--PeterHo, Eva
CREATE PROCEDURE [api].[Parcel$RcvBrkgRejection](@slip tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@infoSlip tvp=
		(
			select	t.Tvp from core.RefInfo#Type() k
			cross	apply tvp.Duad#Slice(@slip, default, default) x
			cross	apply tvp.Trio#Make(0, '', x.v2) p
			cross	apply tvp.Triad#Make(x.v1, k.ShippingLabelInfo, p.Tvp) t
		);
		execute	core.RefInfo#Merge @slip=@infoSlip;

		declare	@idsInCsv tvp;
		with	cte(text) as
		(
			select	[text()]=concat(N',', x.v1)
			from	tvp.Duad#Slice(@slip, default, default) x for xml path(N'')
		)
		select	@idsInCsv=Tvp from cte cross apply tvp.Spr#Purify(text, 1);

		declare	@daemon   tvp=null;
		declare	@actionID I32=(select ReceiveBrkgRejection from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@idsInCsv, @actionID=@actionID, @tenancy=@daemon;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[Parcel$RcvBrkgAcceptance]...';


GO
/*
@slip = Quad<ParcelID, LastMilerAlias, LastMilerNbr, ShippingLabelAncillaries:Dozen>
*/
--PeterHo, Eva
CREATE PROCEDURE [api].[Parcel$RcvBrkgAcceptance](@slip tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		/*
		declare	@matterID tvp,  @mergeSlip tvp;
		select	@matterID=d.v1, @mergeSlip=t.Tvp
		from	core.RefNbr#Type() k
		cross	apply tvp.Duad#Of(@slip, default) d
		cross	apply tvp.Triad#Make(d.v1, k.PostCourier, d.v2) t
		execute	core.RefNbr#Merge @slip=@mergeSlip;
		*/

		declare	@parcelID tvp, @lastMilerNbr tvp, @ancillaries tvp, @lastMilerID I64;
		select	@parcelID=v1,  @lastMilerNbr=v3,  @ancillaries=v4,  @lastMilerID=c.CourierID
		from	tvp.Quad#Of(@slip, default) cross apply tms.Courier#IdOfAlias(v2) c;

		if (@lastMilerID is null or @lastMilerID=0)
			execute	dbo.Assert#Fail @msg=N'The alias of LastMiler can not be found.';

		declare	@nbrSlip tvp=
		(
			select	Tvp   from core.RefNbr#Type() k
			cross	apply tvp.Triad#Make(@parcelID, k.PostCourier, @lastMilerNbr)
		);
		execute	core.RefNbr#Merge @slip=@nbrSlip;
		
		declare	@infoSlip tvp=
		(
			select	t.Tvp from core.RefInfo#Type() k
			cross	apply tvp.Trio#Make(@lastMilerID, @ancillaries, '') p
			cross	apply tvp.Triad#Make(@parcelID, k.ShippingLabelInfo, p.Tvp) t
		);
		execute	core.RefInfo#Merge @slip=@infoSlip;

		declare	@daemon   tvp=null;
		declare	@actionID I32=(select ReceiveBrkgAcceptance from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@parcelID, @actionID=@actionID, @tenancy=@daemon;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[Parcel$Init]...';


GO
/*
@slip    = at.Tvp.Block.Join(RefNbr, PreCourier, ShprInfo, CneeInfo, DeclaredInfo[Triad.Join(SkuID, LineQty, LineTotal).Over(at.Tvp.Mucho)]).Over(at.Tvp.Entry)
@context = at.Quad.Join(Source, SvcType, errorCnt, errors)
*/
--Smile
CREATE PROCEDURE [api].[Parcel$Init](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32;
		select	@siteID=SiteID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy);

		declare	@source E8, @errorCnt int, @errors json, @poa char(3), @svcType I32,  @routeID I32,       @courierID I32,         @stateID I32,			  @contractID I32;
		select	@source=v1, @errorCnt=v3,  @errors=v4,   @poa=r.POA,   @svcType=t.ID, @routeID=r.RouteID, @courierID=r.CourierID, @stateID=t.InitStateID, @contractID=c.ID
		from	tvp.Quad#Of(@context, default)                          x
		cross	apply tms.SvcType#For(cast(x.v2 as int), @siteID)       t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)             r
		cross	apply acct.Contract#For(@siteID, cast(x.v1 as tinyint)) c;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@stage E32=(select Stage  from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID,  @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef E8,          @shprInfo E8,         @cneeInfo E8,          @preCourier E8;
		select	@clientRef=n.ClientRef, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo,  @preCourier=n.PreCourier
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;

		execute	core.RefNbr#AddBlock  @index=1, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefNbr#AddBlock  @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@preCourier;
		execute	core.RefInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	invt.SkuInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @routeID=@routeID;

		-- 3.	Add Batch & Parcels:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=@errorCnt, @errors=@errors;

		insert	shpt._Parcel
		(		ID,  BatchID,  RouteID, LastMilerID,  SvcType, SvcZone, SvcClass,  POA,  ContractID)
		select	ID, @batchID, @routeID, @courierID,  @svcType, 1,       1,        @poa, @contractID
		from	@idSeqs;

		-- 4.	Precourier Concern
		execute	shpt.PreCourier#ConcernBlock @index=2, @slip=@slip;

		-- 5.	Result:
		with cteResult(text) as
		(

			select	[text()]=concat(k.Many, c.Number, k.Duad, m.Number)
			from	tvp.Spr#Const() k, @idSeqs x
			cross	apply core.RefNbr#Type()   t
			join	core.RefNbr#Raw() m on m.MatterID=x.ID and m.Type=t.MIT
			join	core.RefNbr#Raw() c on c.MatterID=x.ID and c.Type=t.ClientRef
			for		xml path(N'')
		)
		select	@result=r.Tvp 
		from	cteResult 
		cross	apply tvp.Spr#Purify(text, default)  x
		cross	apply tvp.Pair#Make(@batchID, x.Tvp) r
		;
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[Parcel$InitForUnFiled]...';


GO
/*
@slip    = at.Tvp.Block.Join(RefNbr, PreCourier, Shipper, Consignee, LineInfo.Over(at.Tvp.Mucho), CneeIdNbr.IDNbr, GrossWeight.G).Over(at.Tvp.Entry)
@context = at.Quad.Join(Source, SvcType, errorCnt, errors)
*/
--Smile, AaronLiu
CREATE PROCEDURE [api].[Parcel$InitForUnFiled](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32,	@roleID I32;
		select	@siteID=SiteID, @userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@source E8, @errorCnt int, @errors json, @poa char(3), @svcType I32,  @routeID I32,       @courierID I32,         @stateID I32,           @contractID I32;
		select	@source=v1, @errorCnt=v3,  @errors=v4,   @poa=r.POA,   @svcType=t.ID, @routeID=r.RouteID, @courierID=r.CourierID, @stateID=t.InitStateID, @contractID=c.ID
		from	tvp.Quad#Of(@context, default)                          x
		cross	apply tms.SvcType#For(cast(x.v2 as int), @siteID)       t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)             r
		cross	apply acct.Contract#For(@siteID, cast(x.v1 as tinyint)) c;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@stage E32=(select Stage  from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID,  @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 1.1	For InitState OutboundQ
		declare	@actionID I32=(select InitParcel from core.Action#ID()) -- TODO: add this action id to Action#ID
		,		@spec	  core.TransitionSpec;
		with	cte as
		(
			select	MatterID=x.ID, ActionID=@actionID, OnStateID=0, ToStateID
			,		ToStage,	   Source=@source,	   OutboundQ,	TodoHours
			from	@idSeqs x
			cross	apply tms.RouteRole#For(@routeID,  @roleID, @actionID   ) r
			cross	apply core.Transition#Tobe(    0, r.RoleID, @actionID, 0) t
		)
		insert	@spec select * from cte;
		execute	core.OutboundQ#EnqueueBySpec @spec=@spec;

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef E8,          @shprInfo E8,         @cneeInfo E8,         @declaredInfo E8,             @IDInfo E8,       @preCourier E8;
		select	@clientRef=n.ClientRef, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo, @declaredInfo=i.DeclaredInfo, @IDInfo=i.IDInfo, @preCourier=n.PreCourier
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i
		
		execute	core.RefNbr#AddMIC @idSeqs=@idSeqs, @source=@source, @type=@type;

		execute	core.RefNbr#AddBlock  @index=1, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefNbr#AddBlock  @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@preCourier;
		execute	core.RefInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@declaredInfo;
		execute	core.RefInfo#AddBlock @index=6, @idSeqs=@idSeqs, @slip=@slip, @type=@IDInfo;

		-- 3.	Add Batch & Parcels:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=@errorCnt, @errors=@errors;

		insert	shpt._Parcel
		(		ID,  BatchID,  RouteID,  LastMilerID, SvcType, SvcZone, SvcClass,  POA, Weight,  ContractID)
		select	ID, @batchID, @routeID, @courierID,  @svcType, 1,       1,        @poa, v.Piece, @contractID
		from	@idSeqs x
		join	tvp.Pcs#SliceV(/*index*/7, @slip, default, default) v on v.Seq=x.Seq;

		-- 4.	Precourier Concern
		execute	shpt.PreCourier#ConcernBlock @index=2, @slip=@slip;

		-- 5.	Result:
		with cteResult(text) as
		(

			select	[text()]=concat(k.Many, c.Number, k.Duad, m.Number)
			from	tvp.Spr#Const() k, @idSeqs x
			cross	apply core.RefNbr#Type()   t
			join	core.RefNbr#Raw() m on m.MatterID=x.ID and m.Type=t.MIT
			join	core.RefNbr#Raw() c on c.MatterID=x.ID and c.Type=t.ClientRef
			for		xml path(N'')
		)
		select	@result=r.Tvp 
		from	cteResult 
		cross	apply tvp.Spr#Purify(text, default)  x
		cross	apply tvp.Pair#Make(@batchID, x.Tvp) r
		;
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[Parcel$InitForPlatform]...';


GO
/*
@slip    = Entry[Block< Quad<SiteID, SvcType, Weight, RchHubAlias>, RefNbr, PreCourier, ShprInfo, CneeInfo, 
		   Mucho[Triad<(SkuID, LineQty, LineTotal>], IDInfo>]
@context = Duad<errorCnt, errors>
*/
--Smile
CREATE PROCEDURE [api].[Parcel$InitForPlatform](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Contexts:
		declare	@siteID I32,    @userID I32,    @source tinyint;
		select	@siteID=SiteID, @userID=UserID, @source=p.Source
		from	loc.Tenancy#Of(@tenancy) x
		join	core.Party#Raw()         p on p.ID=x.UserID;

		declare	@errorCnt int, @errors json;
		select	@errorCnt=v1,  @errors=v2
		from	tvp.Duad#Of(@context, default) x
		;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@spec core.TransitionSpec;
		insert	core._Matter
		(		ID,  PosterID,   StateID,       Stage,  Source,  Type, PostedOn    )
		output	inserted.ID, 0, 0, inserted.StateID, inserted.Stage, inserted.Source, 0, 0 into @spec
		select	x.Master, cast(q.v1 as int), t.InitStateID, s.Stage, @source,  @type, getutcdate()
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default)        x 
		cross	apply tvp.Quad#Of(x.House, default)                         q
		--join	core.Party#Raw()                                     p on p.Alias=q.v1 and p.Source=@source
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		cross	apply core.Stage#Of(t.InitStateID)                          s

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;
		

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef E8,          @shprInfo E8,         @cneeInfo E8,          @preCourier E8,           @IDInfo E8;
		select	@clientRef=n.ClientRef, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo,  @preCourier=n.PreCourier, @IDInfo=i.IDInfo
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;

		execute	core.RefNbr#AddBlock  @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefNbr#AddBlock  @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@preCourier;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=7, @idSeqs=@idSeqs, @slip=@slip, @type=@IDInfo;
		
		-- TODO: get LineTotal by ServiceType???
		insert	core._RefInfo
		(		MatterID,   Type,   Info)
		select	x.Master, i.Type, i.Info
		from	tvp.Block#FoldT(6, @idSeqs, @slip, default, default) x
		cross	apply
		(
		select	Type=k.DeclaredInfo,  s.Info
		from	core.RefInfo#Type()   k, invt.SkuInfo#ToDeclared(x.House) s	
		UNION	ALL
		select	Type=k.BrokerageInfo, b.Info
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default) c 
		cross	apply tvp.Quad#Of(c.House, default)                  q
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)          r
		join	tms.Route#Raw()                                      d on d.ID=r.RouteID
		cross	apply invt.SkuInfo#ToBrokerage(x.House, d.BrokerID,  d.ClrMethodID) b
		cross	apply core.RefInfo#Type()                            k                  
		where	x.Master=c.Master
		) i;

		-- 3.	Add Batch & Parcels:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=@errorCnt, @errors=@errors;

		insert	shpt._Parcel
		(		ID,       BatchID,  RouteID,   LastMilerID,  SvcType, SvcZone, SvcClass,  POA, Weight, RcvHubID,        ContractID)
		select	x.Master, @batchID, r.RouteID, r.CourierID,  t.ID,     1,      1,       r.POA, q.v3,   isnull(h.ID, 0), c.ID
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default)        x 
		cross	apply tvp.Quad#Of(x.House, default)                         q
		cross	apply core.Party#Type()                                     e
		left	join  core.Party#Raw()                                      h on h.Alias=q.v4 and h.Type=e.ZebraHub
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)                 r
		cross	apply acct.Contract#For(cast(q.v1 as int), @source)         c;

		--4.	Enqueue
		declare	@toSource  tinyint=(select InfoPath  from core.Source#ID())
		,		@queueType tinyint=(select BrokerApi from core.Queue#Type());
		insert	core._OutboundQ
			    (ToSource,  QueueType, MatterID,   StateID)
		select	@toSource, @queueType, MatterID, ToStateID
		from	@spec;

		-- 5.	Precourier Concern
		execute	shpt.PreCourier#ConcernBlock @index=3, @slip=@slip;

		-- 6.	Result:
		with cteResult(text) as
		(

			select	[text()]=concat(k.Many, c.Number, k.Duad, m.Number)
			from	tvp.Spr#Const() k, @idSeqs x
			cross	apply core.RefNbr#Type()   t
			join	core.RefNbr#Raw() m on m.MatterID=x.ID and m.Type=t.MIT
			join	core.RefNbr#Raw() c on c.MatterID=x.ID and c.Type=t.ClientRef
			for		xml path(N'')
		)
		select	@result=r.Tvp 
		from	cteResult 
		cross	apply tvp.Spr#Purify(text, default)  x
		cross	apply tvp.Pair#Make(@batchID, x.Tvp) r
		;
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[Parcel$UpdateForPlatform]...';


GO
/*
@slip    = Entry[Block<ParcelID, Duad<SvcType, Weight>,Duad<RefNbr, PreCourier>, Triad<ShprInfo, CneeInfo, IDInfo>, Many[Triad<SkuID, LineQty, LineTotal>]>]
*/
--Smile
CREATE PROCEDURE [api].[Parcel$UpdateForPlatform](@slip tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Contexts:
		declare	@roleID I32,    @userID I32,    @source tinyint;
		select	@roleID=RoleID, @userID=UserID, @source=p.Source
		from	loc.Tenancy#Of(@tenancy) x
		join	core.Party#Raw()         p on p.ID=x.UserID;

		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	t.v1, t.Seq
		from	tvp.Block#At(1, @slip, default, default)       x
		cross	apply tvp.Spr#Const()                          k
		cross	apply tvp.Field#Slice(x.Tvp, k.Entry, k.Entry) t

		--Parcel transist;
		declare	@actionID  I32=(select UpdateParcelInfo from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from @idSeqs
		cross	apply shpt.Parcel#Tobe(ID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		declare	@updatedSeqs I64Seqs;insert @updatedSeqs(ID, Seq)
		select	ID, x.Seq from @idSeqs x join @spec d on x.ID=d.MatterID;

	    if(exists(select * from @spec))
		begin
		--Merge RefNbr;		
		declare	@exeNbr tvp;
		with exeNbr(text) as
		(
			select	[text()]=concat(k.Many, x.Master, k.Triad, t.ClientRef, k.Triad, d.v1
							, k.Many, x.Master, k.Triad, t.PreCourier, k.Triad, d.v2)
			from	tvp.Block#FoldT(3, @updatedSeqs, @slip, default, default) x
			cross	apply tvp.Duad#Of(x.House, default)                       d
			cross	apply tvp.Spr#Const()                                     k
			cross	apply core.RefNbr#Type()                                  t
			for xml path(N'')
		)
		select	@exeNbr=Tvp from exeNbr cross apply tvp.Spr#Purify(text, default)  	
		execute	core.RefNbr#Merge @slip=@exeNbr;

		--Merge RefInfo:
		declare	@exeInfo tvp;
		with exeInfo(text) as
		(
			select	[text()]=concat(k.Many, x.Master, k.Triad, t.ShprInfo, k.Triad, d.v1
							, k.Many, x.Master, k.Triad, t.CneeInfo, k.Triad, d.v2
							, k.Many, x.Master, k.Triad, t.IDInfo, k.Triad, d.v3)
			from	tvp.Block#FoldT(4, @updatedSeqs, @slip, default, default) x
			cross	apply tvp.Triad#Of(x.House, default)                      d
			cross	apply tvp.Spr#Const()                                     k
			cross	apply core.RefInfo#Type()                                 t
			for xml path(N'')
		)
		select	@exeInfo=Tvp from exeInfo cross apply tvp.Spr#Purify(text, default)  	
		execute	core.RefInfo#Merge @slip=@exeInfo;

		--Merge BrkgInfo, DeclaredInfo
		with exeInfo(text) as
		(
			select	[text()]=concat(n.Many, x.Master, n.Triad, i.Type, n.Triad, i.Info)
			from	tvp.Block#FoldT(5, @updatedSeqs, @slip, default, default) x
			cross	apply tvp.Spr#Const()                                     n
			cross	apply
			(
			select	Type=k.DeclaredInfo,  s.Info
			from	core.RefInfo#Type()   k, invt.SkuInfo#ToDeclared(x.House) s	
			UNION	ALL
			select	Type=k.BrokerageInfo, b.Info
			from	tvp.Block#FoldT(2, @updatedSeqs, @slip, default, default) c 
			cross	apply tvp.Duad#Of(c.House, default)                       q
			join	core.Matter#Raw()                                         m on m.ID=x.Master
			cross	apply tms.SvcType#For(cast(q.v1 as int), m.PosterID)      t
			cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)               o
			join	tms.Route#Raw()                                           d on d.ID=o.RouteID
			cross	apply invt.SkuInfo#ToBrokerage(x.House, d.BrokerID,  d.ClrMethodID) b
			cross	apply core.RefInfo#Type()                                 k                  
			where	x.Master=c.Master
			)                                                                 i
			
		)
		select	@exeInfo=Tvp from exeInfo cross apply tvp.Spr#Purify(text, default)  	
		execute	core.RefInfo#Merge @slip=@exeInfo;

		--update Parcel;
		with	cteParcel as
		(
			select	ParcelID=x.Master, SvcType=t.ID, Weight=cast(q.v2 as real)
			from	tvp.Block#FoldT(2, @updatedSeqs, @slip, default, default) x
			cross	apply tvp.Duad#Of(x.House, default)                       q
			join	core.Matter#Raw()                                         m on m.ID=x.Master
			join	core.Party#Raw()                                          r on r.ID=m.PosterID
			cross	apply tms.SvcType#For(cast(q.v1 as int), r.PID)           t
		)
		update o set SvcType=n.SvcType , Weight =n.Weight from shpt._Parcel o join cteParcel n on o.ID=n.ParcelID
		end

		;with cteResult(text) as
		(
			select	[text()]=concat(s.Many, a.Number, s.Duad, isnull(u.ID, 0))   
			from	@idSeqs                   x
			cross	apply core.RefNbr#Type()  k
			join	core.RefNbr#Raw()         a on a.Type=k.MIT and a.MatterID=x.ID
			cross	apply tvp.Spr#Const()     s
			left	join @updatedSeqs         u on x.ID=u.ID
			for xml path(N'')
		)
		select	@result=Tvp from cteResult cross apply tvp.Spr#Purify(text, default);	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[Parcel$UpdateForPlatformUnfiled]...';


GO
/*
@slip    = Entry[Block<ParcelID, Duad<SvcType, Weight>, Duad<RefNbr, PreCourier>, Triad<ShprInfo, CneeInfo, IDInfo>, Mucho[LineInfo], Mucho[CmdyInfo]>]
*/
--Smile, Aaron Liu
CREATE PROCEDURE [api].[Parcel$UpdateForPlatformUnfiled](@slip tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Contexts:
		declare	@roleID I32,    @userID I32,    @source tinyint;
		select	@roleID=RoleID, @userID=UserID, @source=p.Source
		from	loc.Tenancy#Of(@tenancy) x
		join	core.Party#Raw()         p on p.ID=x.UserID;

		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	t.v1, t.Seq
		from	tvp.Block#At(1, @slip, default, default)       x
		cross	apply tvp.Spr#Const()                          k
		cross	apply tvp.Field#Slice(x.Tvp, k.Entry, k.Entry) t

		--Parcel transist;
		declare	@actionID  I32=(select UpdateParcelInfo from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from @idSeqs
		cross	apply shpt.Parcel#Tobe(ID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		declare	@updatedSeqs I64Seqs;insert @updatedSeqs(ID, Seq)
		select	ID, x.Seq from @idSeqs x join @spec d on x.ID=d.MatterID;

	    if(exists(select * from @spec))
		begin
		--Merge RefNbr;		
		declare	@exeNbr tvp;
		with exeNbr(text) as
		(
			select	[text()]=concat
			(
				 k.Many, x.Master, k.Triad, t.ClientRef,  k.Triad, d.v1,
				 k.Many, x.Master, k.Triad, t.PreCourier, k.Triad, d.v2
			)
			from	tvp.Block#FoldT(3, @updatedSeqs, @slip, default, default) x
			cross	apply tvp.Duad#Of(x.House, default)                       d
			cross	apply tvp.Spr#Const()                                     k
			cross	apply core.RefNbr#Type()                                  t
			for xml path(N'')
		)
		select	@exeNbr=Tvp from exeNbr cross apply tvp.Spr#Purify(text, default)  	
		execute	core.RefNbr#Merge @slip=@exeNbr;

		--Merge RefInfo:
		declare	@exeInfo tvp;
		with exeInfo(text) as
		(
			select	[text()]=concat
			(	
				k.Many, x.Master, k.Triad, t.ShprInfo,		k.Triad, d.v1,
				k.Many, x.Master, k.Triad, t.CneeInfo,		k.Triad, d.v2,
				k.Many, x.Master, k.Triad, t.IDInfo,		k.Triad, d.v3,
				k.Many, x.Master, k.Triad, t.DeclaredInfo,  k.Triad, l.House,
				k.Many, x.Master, k.Triad, t.BrokerageInfo, k.Triad, b.BrokerageInfo
			)
			from	tvp.Block#FoldT(4, @updatedSeqs, @slip, default, default) x
			join	tvp.Block#FoldT(5, @updatedSeqs, @slip, default, default) l on x.Seq=l.Seq
			join	tvp.Block#FoldT(6, @updatedSeqs, @slip, default, default) c on x.Seq=c.Seq
			cross	apply loc.Declared$ToBrokerage(l.House, c.House)		  b
			cross	apply tvp.Triad#Of(x.House, default)                      d
			cross	apply core.RefInfo#Type()                                 t
			cross	apply tvp.Spr#Const()                                     k
			for		xml path(N'')
		)
		select	@exeInfo=Tvp from exeInfo cross apply tvp.Spr#Purify(text, default)  	
		execute	core.RefInfo#Merge @slip=@exeInfo;

		--update Parcel;
		with	cteParcel as
		(
			select	ParcelID=x.Master, SvcType=t.ID, Weight=cast(q.v2 as real)
			from	tvp.Block#FoldT(2, @updatedSeqs, @slip, default, default) x
			cross	apply tvp.Duad#Of(x.House, default)                       q
			join	core.Matter#Raw()                                         m on m.ID=x.Master
			join	core.Party#Raw()                                          r on r.ID=m.PosterID
			cross	apply tms.SvcType#For(cast(q.v1 as int), r.PID)           t
		)
		update o set SvcType=n.SvcType , Weight =n.Weight from shpt._Parcel o join cteParcel n on o.ID=n.ParcelID
		end

		;with cteResult(text) as
		(
			select	[text()]=concat(s.Many, a.Number, s.Duad, isnull(u.ID, 0))   
			from	@idSeqs                   x
			cross	apply core.RefNbr#Type()  k
			join	core.RefNbr#Raw()         a on a.Type=k.MIT and a.MatterID=x.ID
			cross	apply tvp.Spr#Const()     s
			left	join @updatedSeqs         u on x.ID=u.ID
			for xml path(N'')
		)
		select	@result=Tvp from cteResult cross apply tvp.Spr#Purify(text, default);	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[Parcel$InitForPlatformUnFiled]...';


GO
/*
@slip    = Entry[Block< Quad<SiteID, SvcType, Weight, RchHubAlias>, RefNbr, PreCourier, ShprInfo, CneeInfo, 
		   Mucho[LineInfo], IDInfo, Mucho[CmdyInfo]>]
@context = Duad<errorCnt, errors>
*/
--Smile, Aaron Liu
CREATE PROCEDURE [api].[Parcel$InitForPlatformUnFiled](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Contexts:
		declare	@siteID I32,    @userID I32,    @source tinyint;
		select	@siteID=SiteID, @userID=UserID, @source=p.Source
		from	loc.Tenancy#Of(@tenancy) x
		join	core.Party#Raw()         p on p.ID=x.UserID;

		declare	@errorCnt int, @errors json;
		select	@errorCnt=v1,  @errors=v2
		from	tvp.Duad#Of(@context, default) x
		;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@spec core.TransitionSpec;
		insert	core._Matter
		(		ID,  PosterID,   StateID,       Stage,  Source,  Type, PostedOn    )
		output	inserted.ID, 0, 0, inserted.StateID, inserted.Stage, inserted.Source, 0, 0 into @spec
		select	x.Master,  cast(q.v1 as int), t.InitStateID, s.Stage, @source,  @type, getutcdate()
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default)       x 
		cross	apply tvp.Quad#Of(x.House, default)                        q
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		cross	apply core.Stage#Of(t.InitStateID)                          s

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;
		

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef E8,          @shprInfo E8,         @cneeInfo E8,          @preCourier E8,           @IDInfo E8,       @declaredInfo E8;
		select	@clientRef=n.ClientRef, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo,  @preCourier=n.PreCourier, @IDInfo=i.IDInfo, @declaredInfo=i.DeclaredInfo
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;

		execute	core.RefNbr#AddBlock  @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefNbr#AddBlock  @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@preCourier;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=6, @idSeqs=@idSeqs, @slip=@slip, @type=@declaredInfo;
		execute	core.RefInfo#AddBlock @index=7, @idSeqs=@idSeqs, @slip=@slip, @type=@IDInfo;

		declare	@refInfoSlip tvp;
		with	cte(text) as
		(
			select	[text()]=concat(k.Many, x.Master, k.Triad, t.BrokerageInfo, k.Triad, b.BrokerageInfo)
			from	tvp.Block#FoldT(6, @idSeqs, @slip, default, default) x
			join	tvp.Block#FoldT(8, @idSeqs, @slip, default, default) c on x.Seq=c.Seq
			cross	apply loc.Declared$ToBrokerage(x.House, c.House)	 b
			cross	apply core.RefInfo#Type() t
			cross	apply tvp.Spr#Const() k
			for		xml path(N'')
		)
		select	@refInfoSlip=Tvp from cte cross apply tvp.Spr#Purify(text, default);
		execute	core.RefInfo#Merge @slip=@refInfoSlip;

		-- 3.	Add Batch & Parcels:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=@errorCnt, @errors=@errors;

		insert	shpt._Parcel
		(		ID,       BatchID,  RouteID,   LastMilerID,  SvcType, SvcZone, SvcClass,  POA, Weight, RcvHubID,        ContractID)
		select	x.Master, @batchID, r.RouteID, r.CourierID,  t.ID,     1,      1,       r.POA, q.v3,   isnull(h.ID, 0), c.ID
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default) x 
		cross	apply tvp.Quad#Of(x.House, default)                  q
		cross	apply core.Party#Type()                              e
		left	join  core.Party#Raw()                               h on h.Alias=q.v4 and h.Type=e.ZebraHub
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)          r
		cross	apply acct.Contract#For(cast(q.v1 as int), @source)  c;

		--4.	Enqueue
		declare	@toSource  tinyint=(select InfoPath  from core.Source#ID())
		,		@queueType tinyint=(select BrokerApi from core.Queue#Type());
		insert	core._OutboundQ
			    (ToSource,  QueueType, MatterID,   StateID)
		select	@toSource, @queueType, MatterID, ToStateID
		from	@spec;

		-- 5.	Precourier Concern
		execute	shpt.PreCourier#ConcernBlock @index=3, @slip=@slip;

		-- 6.	Result:
		with cteResult(text) as
		(

			select	[text()]=concat(k.Many, c.Number, k.Duad, m.Number)
			from	tvp.Spr#Const() k, @idSeqs x
			cross	apply core.RefNbr#Type()   t
			join	core.RefNbr#Raw() m on m.MatterID=x.ID and m.Type=t.MIT
			join	core.RefNbr#Raw() c on c.MatterID=x.ID and c.Type=t.ClientRef
			for		xml path(N'')
		)
		select	@result=r.Tvp 
		from	cteResult 
		cross	apply tvp.Spr#Purify(text, default)  x
		cross	apply tvp.Pair#Make(@batchID, x.Tvp) r
		;
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[Parcel$InitForHandWrittenOrder]...';


GO
/*
@slip    = Entry[Block<PreCourier, HandWrittenOrderImg>]
@context = Duad<Source, SiteID>
@result  = Pair<BatchID, Comma[ParcelID]>
*/
--Daxia
CREATE PROCEDURE [api].[Parcel$InitForHandWrittenOrder](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@userID I32=(select UserID from loc.Tenancy#Of(@tenancy));
		
		declare	@source E8, @siteID I32;
		select	@source=v1, @siteID=cast(v2 as int)
		from	tvp.Duad#Of(@context, default);

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type    E8 =(select Parcel from core.Matter#Type());
		declare	@stateID I32=(select InfoPictureReceived from core.State#ID());
		declare	@stage   E32=(select PreInterventionNeeded from core.Stage#ID());
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		select	ID,  @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 2.	Add RefNbrs & RefInfos:
		declare	@preCourier E8,           @handWrittenOrderImgInfo E8;
		select	@preCourier=n.PreCourier, @handWrittenOrderImgInfo=25
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;

		execute	core.RefNbr#AddBlock  @index=1, @idSeqs=@idSeqs, @slip=@slip, @type=@preCourier;
		execute	core.RefInfo#AddBlock @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@handWrittenOrderImgInfo;

		-- 3.	Add Batch & Parcels:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=0, @errors=N'';

		declare	@routeID I32=0, @courierID I32=0, @contractID I32=0, @poa char(3)=N'';
		insert	shpt._Parcel
		(		ID,  BatchID,  RouteID, LastMilerID,  SvcType, SvcZone, SvcClass,  POA,  ContractID)
		select	ID, @batchID, @routeID, @courierID,   0,	   1,       1,        @poa, @contractID
		from	@idSeqs;

		-- 4.	Precourier Concern
		execute	shpt.PreCourier#ConcernBlock @index=1, @slip=@slip;

		-- 5.	Result:
		with cteResult(text) as
		(
			select	[text()]=concat(N',', x.ID)
			from	@idSeqs x
			for		xml path(N'')
		)
		select	@result=r.Tvp 
		from	cteResult 
		cross	apply tvp.Spr#Purify(text, 1) x
		cross	apply tvp.Pair#Make(@batchID, x.Tvp) r
		;
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[Parcel$CfmDoorDeliverdForTC]...';


GO
/*
	@slip = Comma<ParcelID>
*/
-- AaronLiu
CREATE PROCEDURE [api].[Parcel$CfmDoorDeliverdForTC](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

--		declare	@actionID I32=(select CfmDoorDelivered from core.Action#ID());
		declare	@actionID I32=19990;
		execute	svc.Parcel$Transit @idsInCsv=@slip, @actionID=@actionID, @tenancy=@tenancy;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [app].[Parcel$InitForEship]...';


GO
/*
@slip		= Entry[Block<RefNbr, PreCourier, Shipper, Consignee, Mucho[LineInfo], CneeIdNbr.IDNbr, GrossWeight.G, RemarkInfo>]
 RemarkInfo = Quad<Remark1, Remark2, Remark3, Remark4>
@context	= Quad<Source, SvcType, errorCnt, errors>
*/
--Smile, AaronLiu
CREATE PROCEDURE [app].[Parcel$InitForEship](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32,    @tenantSource E8;
		select	@siteID=SiteID, @userID=UserID, @tenantSource=p.Source
		from	loc.Tenancy#Of(@tenancy) x
		join	core.Party#Raw() p on p.ID=x.SiteID;

		declare	@source E8, @errorCnt int, @errors json, @poa char(3), @svcType I32,  @routeID I32,       @courierID I32,         @stateID I32,           @contractID I32;
		select	@source=v1, @errorCnt=v3,  @errors=v4,   @poa=r.POA,   @svcType=t.ID, @routeID=r.RouteID, @courierID=r.CourierID, @stateID=t.InitStateID, @contractID=c.ID
		from	tvp.Quad#Of(@context, default)                          x
		cross	apply tms.SvcType#For(cast(x.v2 as int), @siteID)       t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)             r
		cross	apply acct.Contract#For(@siteID, @tenantSource) c;  --HACK
		

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@stage E32=(select Stage  from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID,  @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef	  E8, @shprInfo E8, @cneeInfo   E8
		,		@declaredInfo E8, @IDInfo   E8, @preCourier E8
		,		@remarkInfo	  E8
		;
		select	@clientRef=n.ClientRef,		  @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo
		,		@declaredInfo=i.DeclaredInfo, @IDInfo=i.IDInfo,		@preCourier=n.PreCourier
		,		@remarkInfo=i.RemarkInfo
		from	core.RefNbr#Type() n, core.RefInfo#Type() i
		
		execute	core.RefNbr#AddMIC @idSeqs=@idSeqs, @source=@source, @type=@type;

		execute	core.RefNbr#AddBlock  @index=1, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefNbr#AddBlock  @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@preCourier;
		execute	core.RefInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@declaredInfo;
		execute	core.RefInfo#AddBlock @index=6, @idSeqs=@idSeqs, @slip=@slip, @type=@IDInfo;
		execute	core.RefInfo#AddBlock @index=8, @idSeqs=@idSeqs, @slip=@slip, @type=@remarkInfo;

		-- 3.	Add Batch & Parcels:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=@errorCnt, @errors=@errors;

		insert	shpt._Parcel
		(		ID,  BatchID,  RouteID,  LastMilerID, SvcType, SvcZone, SvcClass,  POA, Weight,  ContractID)
		select	ID, @batchID, @routeID, @courierID,  @svcType, 1,       1,        @poa, v.Piece, @contractID
		from	@idSeqs x
		join	tvp.Pcs#SliceV(/*index*/7, @slip, default, default) v on v.Seq=x.Seq;

		-- 4.	Precourier Concern
		execute	shpt.PreCourier#ConcernBlock @index=2, @slip=@slip;
		execute shpt.Concern#AttachPreCheckTo @idSeqs=@idSeqs;
		-- 5.	Result:
		select	@result=@batchID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [app].[Parcel$InitWithSku]...';


GO
/*
@slip		= Entry[Block<RefNbr, PreCourier, ShprInfo, CneeInfo, Mucho[SkuInfo], IDInfo, RemarkInfo>]
 SkuInfo	= Triad<SkuID, LineQty, LineTotal>
 RemarkInfo = Quad<Remark1, Remark2, Remark3, Remark4>
@context	= Quad<Source, SvcType, errorCnt, errors>
*/
--Smile, AaronLiu
CREATE PROCEDURE [app].[Parcel$InitWithSku](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32,    @tenantSource E8;
		select	@siteID=SiteID, @userID=UserID, @tenantSource=p.Source
		from	loc.Tenancy#Of(@tenancy) x
		join	core.Party#Raw() p on p.ID=x.SiteID;

		declare	@source E8, @errorCnt int, @errors json, @poa char(3), @svcType I32,  @routeID I32,       @courierID I32,         @stateID I32,			  @contractID I32;
		select	@source=v1, @errorCnt=v3,  @errors=v4,   @poa=r.POA,   @svcType=t.ID, @routeID=r.RouteID, @courierID=r.CourierID, @stateID=t.InitStateID, @contractID=c.ID
		from	tvp.Quad#Of(@context, default)                          x
		cross	apply tms.SvcType#For(cast(x.v2 as int), @siteID)       t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)             r
		cross	apply acct.Contract#For(@siteID, @tenantSource) c;  --HACK

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@stage E32=(select Stage  from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID,  @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef  E8, @shprInfo E8, @cneeInfo	  E8
		,		@preCourier E8, @idInfo   E8, @remarkInfo E8
		;
		select	@clientRef=n.ClientRef,   @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo
		,		@preCourier=n.PreCourier, @idInfo=I.IDInfo,		@remarkInfo=i.RemarkInfo
		from	core.RefNbr#Type() n, core.RefInfo#Type() i

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;

		execute	core.RefNbr#AddBlock  @index=1, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefNbr#AddBlock  @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@preCourier;
		execute	core.RefInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	invt.SkuInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @routeID=@routeID;
		execute	core.RefInfo#AddBlock @index=6, @idSeqs=@idSeqs, @slip=@slip, @type=@idInfo;
		execute	core.RefInfo#AddBlock @index=7, @idSeqs=@idSeqs, @slip=@slip, @type=@remarkInfo;

		-- 3.	Add Batch & Parcels:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=@errorCnt, @errors=@errors;

		insert	shpt._Parcel
		(		ID,  BatchID,  RouteID, LastMilerID,  SvcType, SvcZone, SvcClass,  POA,  ContractID)
		select	ID, @batchID, @routeID, @courierID,  @svcType, 1,       1,        @poa, @contractID
		from	@idSeqs;

		-- 4.	Precourier Concern
		execute	shpt.PreCourier#ConcernBlock @index=2, @slip=@slip;
		execute shpt.Concern#AttachPreCheckTo @idSeqs=@idSeqs;
		-- 5.	Result:
		select	@result=@batchID;
		;
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [auto].[Parcel$Measure]...';


GO
-- AaronLiu
CREATE PROCEDURE [auto].[Parcel$Measure](@numbersInCsv tvp, @wlwhInCsv tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		-- Should Stage between PreMin and CurMax?
		declare	@minStage E32,    @maxStage E32;
		select	@minStage=PreMin, @maxStage=Ended
		from	core.Stage#Boundary();
		
		declare	@matterID I64;
		select	@matterID=MatterID
		from	core.RefNbr#ScanMulti(@numbersInCsv, @minStage, @maxStage);

		declare	@rcvHubID I32,   @userID I32;
		select	@rcvHubID=HubID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy);
		execute	core.Activity#OnceHubAccepted @matterID=@matterID, @userID=@userID;

		with cteParcel as
		(
			select	ID, q.v1,   q.v2,   q.v3,  q.v4
			from	tvp.Quad#Of(@wlwhInCsv, N',') q
			,		shpt.Parcel#Raw() where ID=@matterID
		)
		update	o set RcvHubID=@rcvHubID, Weight=v1, Length=v2, Width=v3, Height=v4
		from	shpt._Parcel o join cteParcel n on o.ID=n.ID;
		
		select	@result=(select Code from shpt.Parcel#PreSorting(@matterID));
		if(@result is null)
		begin
			execute	shpt.Parcel#Measure @matterID=@matterID, @tenancy=@tenancy;
			select	@result=Code from shpt.Parcel#Sorting(@matterID);
		end

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [bo].[Account$DepositFor]...';


GO
/*
@slip    tvp =Quad<TenantID, PaidAmt, PayMethod, Supplemnt>
@context tvp= Duad<TenantID, XactAmt)
*/
--Smile
CREATE PROCEDURE [bo].[Account$DepositFor](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@partyID I32,   @paidAmt amt,   @paidDecAmt float
		,		@payMethod E8, 	@currencyID E8, @supplement nax;
		select	@partyID=v1,    @paidAmt=v2,  @paidDecAmt=m.DecAmt
		,		@payMethod=v3,  @currencyID=m.CurrencyID, @supplement=v4
		from	tvp.Quad#Of(@slip, default)  x
		cross	apply dbo.Money#Of(v2)       m;

		declare	@planedAmt float;
		select	@planedAmt=round(sum(m.DecAmt/s.ForPayment), 2)
		from	tvp.Duad#Slice(@context, default, default) x
		cross	apply dbo.Money#Of(x.v2)                   m
		join	svc.CurrencyRate$Summary() s on s.FmCurrencyID=@currencyID and s.ToCurrencyID=m.CurrencyID;

		if(@planedAmt>@paidDecAmt) throw  50000, N'{{ Please Confirm The Paid Amt! }}', 0;

		declare	@paymentID I64, @ledgerSide E8=(select AR from acct.Ledger#Side());
		execute	acct.Payment#Insert    @id=@paymentID out
		,		@partyID=@partyID,     @ledgerSide=@ledgerSide, @xactAmt=@paidAmt
		,		@payMethod=@payMethod, @supplement=@supplement;

		declare	@vaultType E8=(select Fund from acct.Vault#Type());
		declare	@idAmts  I64PairAmts; insert @idAmts 
		(		LID,     RID,     Amt    )
	--	select	PartyID, VaultID, PrevBal)
		execute	acct.Vault#Upsert @partyAmts=@context, @vaultType=@vaultType;

		with	cteXact as
		(
			select	PartyID=cast(v1 as bigint)
			,		XactAmt=cast(v2 as bigint), c.CurrencyID
			from	tvp.Duad#Slice(@context, default, default)
			cross	apply dbo.Currency#Decode(cast(v2 as bigint)) c
		)
		insert	acct._VaultXact
		(		 PaymentID,  InvoiceID, VaultID, PrevBal,  XactAmt)
		select	@paymentID,          0,     RID,     Amt,  XactAmt
		from	@idAmts x
		cross	apply dbo.Currency#Decode(x.Amt) a
		join	cteXact                          t on a.CurrencyID=t.CurrencyID;

		execute	shpt.Parcel#ReleaseByDeposit @partyID=@partyID, @tenancy=null
	
		declare	@userID I32=(select UserID from	loc.Tenancy#Of(@tenancy)),
				@regID I32=(select Contract from core.Registry#ID());

		insert	core._ChangeLog(RegID,       RowID, ChangedBy, ChangedOn)
		select			      SvcRate,  @paymentID,   @userID, getutcdate()
		from	core.Registry#ID();
		
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [bo].[Account$ImportSvcRate]...';


GO
/*

@slip = Quad[SvcType, RcvHubID, SectionWt, SvcRate]
@context=Triad<TenantID, SvcType, FileID>

*/
--Smile
CREATE PROCEDURE [bo].[Account$ImportSvcRate](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;

		declare	@tenantID I32, @svcType I32, @major I32,      @fileID char(33), @contractID I32;
		select	@tenantID=v1,  @svcType=v2,  @major=t.Major,  @fileID=v3,       @contractID=c.ID
		from	tvp.Triad#Of(@context, default)  x
		cross	apply tms.SvcType#Major(cast(x.v2 as int)) t
		join	core.Party#Raw() p on p.ID=x.v1
		cross	apply acct.Contract#For(p.ID, p.Source) c;

		declare	@svcTypeVia I32;
		with cteSvcType as
		(
			select	x.ID, Marker=null
			from	tms.SvcType#Raw() x
			cross	apply tms.SvcType#Major(x.ID) m
			where	m.Major=@major and TenantID=@tenantID
			UNION ALL
			select	x.ID+1, Marker=lead(x.ID) over(order by ID)
			from	tms.SvcType#Raw() x
			cross	apply tms.SvcType#Major(x.ID) m
			where	m.Major=@major 
		)
		select	top(1) @svcTypeVia=ID from cteSvcType where Marker is null;

		if(exists(select * from tvp.Quad#Slice(@slip, default, default) where v1<>@svcType)) return;

		BEGIN TRY
		BEGIN TRAN;

		if(not exists(select * from tms.SvcType#Raw() where ID=@svcTypeVia))
		begin
		insert tms._SvcType(ID,  TenantID,  CurrencyID, DutyCurrencyID, FallbackPOA, InitStateID, ClrMethodID, CmdyRootID)
		select	   @svcTypeVia, @tenantID,  CurrencyID, DutyCurrencyID, FallbackPOA, InitStateID, ClrMethodID, CmdyRootID
		from	   tms.SvcType#Raw()
		where	   ID=@major;
		end

		delete	from tms._SvcRate where SvcType=@svcTypeVia;
		with cteSvcRate as
		(
			select	RcvHubID=x.v2, SectionWt=x.v3, SvcRate=x.v4
			from	tvp.Quad#Slice(@slip, default, default) x
		)
		insert	tms._SvcRate(SvcType, RcvHubID, SectionWt, SvcRate)
		select			 @svcTypeVia, RcvHubID, SectionWt, SvcRate
		from	cteSvcRate;

		delete	from tms._SvcContract where ContractID=@contractID and SvcType in (@major, @svcTypeVia);
		insert	tms._SvcContract(ContractID, SvcType) values(@contractID, @svcTypeVia);

		declare	@userID I32=(select UserID from	loc.Tenancy#Of(@tenancy)),
				@auxID E32=(select SvcRate from core.Attachment#Type()),
				@regID I32=(select Contract from core.Registry#ID());

		insert	core._Attachment
				( RegID,  RowID,       AuxID,  PosterID,  FileBankID)
		values	( @regID, @contractID, @auxID, @userID,  @fileID);
		
		insert	core._ChangeLog(RegID,       RowID, ChangedBy, ChangedOn)
		select			      SvcRate, @contractID,   @userID, getutcdate()
		from	core.Registry#ID();

		declare	@ids I64Array;
		with cteParcel as
		(
			select	ID, SvcType
			from	shpt.Parcel#Base()                 p
			cross	apply core.Stage#ID()              k
			cross	apply tms.SvcType#Major(p.SvcType) s
			where	p.Stage<k.RouteCfmed and s.Major=@major
			and		ContractID=@contractID
		)
		update	cteParcel set SvcType=@svcTypeVia
		output inserted.ID into @ids;

		declare	@daemon I32=0;
		declare	@actionID I32=(select ImportSvcRate from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from @ids x
		cross	apply shpt.Parcel#Tobe(x.ID, @daemon, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=0;

		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [co].[Account$Deposit]...';


GO
/*
@slip    tvp =Triad<PaymentID, PaidAmt, Suplement>
*/
--Smile
CREATE PROCEDURE [co].[Account$Deposit](@slip tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@paymentID I64, @paidAmt dbo.amt, @supplement nax;
		select	@paymentID=cast(v1 as bigint), @paidAmt=v2, @supplement=s.Tvp
		from	tvp.Triad#Of(@slip, default) x
		cross	apply tvp.Pair#Make(v2, v3)  s;
		
		declare	@isValid bit=0, @paymentPlan tvp, @partyID int;
		select	@isValid=iif(s.Amt<=@paidAmt, 1, 0)
		,		@paymentPlan=t.Supplement
		,		@partyID=x.PartyID
		from	acct.Payment#Raw() x
		cross	apply dbo.Money#Of(x.PaidAmt) m
		cross	apply dbo.Money#Of(@paidAmt)  p
		join	svc.CurrencyRate$Summary()    c on c.FmCurrencyID=m.CurrencyID and c.ToCurrencyID=p.CurrencyID
		cross	apply dbo.Money#Make(m.DecAmt*c.ForPayment, c.ToCurrencyID) s
		cross	apply core.Registry#ID()      g
		join	core.Supplement#Raw()         t on t.RegID=g.PaymentPlan and t.RowID=x.ID
		where	x.XID=1 and x.ID=@paymentID
		
		if(@isValid=1)
		begin
		update	acct._Payment set XID=0 where ID=@paymentID;
		
		declare	@regID I32=(select Payment from core.Registry#ID());
		execute	core.Supplement#Merge @regID=@regID, @rowID=@paymentID, @supplement=@supplement;

		declare	@vaultType E8=(select Fund from acct.Vault#Type());
		declare	@idAmts  I64PairAmts; insert @idAmts 
		(		LID,     RID,     Amt    )
	--	select	PartyID, VaultID, PrevBal)
		execute	acct.Vault#Upsert @partyAmts=@paymentPlan, @vaultType=@vaultType;

		with	cteXact as
		(
			select	PartyID=cast(v1 as bigint)
			,		XactAmt=cast(v2 as bigint), c.CurrencyID
			from	tvp.Duad#Slice(@paymentPlan, default, default)
			cross	apply dbo.Currency#Decode(cast(v2 as bigint)) c
		)
		insert	acct._VaultXact
		(		 PaymentID,  InvoiceID, VaultID, PrevBal,  XactAmt)
		select	@paymentID,          0,     RID,     Amt,  XactAmt
		from	@idAmts x
		cross	apply dbo.Currency#Decode(x.Amt) a
		join	cteXact                          t on a.CurrencyID=t.CurrencyID;

		execute	shpt.Parcel#ReleaseByDeposit @partyID=@partyID, @tenancy=null
		end
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [core].[Matter#CascadeAllBySpec]...';


GO
-- AaronLiu, PeterHo
CREATE PROCEDURE [core].[Matter#CascadeAllBySpec](@spec core.TransitionSpec readonly, @userID I32)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		declare	@descendantSpec core.TransitionSpec; insert @descendantSpec
		(		MatterID,   ActionID, OnStateID,   ToStateID,   ToStage,   Source,   TodoHours,   OutboundQ)
		select	    m.ID, x.ActionID, m.StateID, t.ToStateID, t.ToStage, m.Source, t.TodoHours, t.OutboundQ
		from	@spec x cross apply core.Matter#NodeDn (x.MatterID) m
		cross	apply core.Transition#Tobe(m.StateID, 0, x.ActionID, m.RejoinID) t

		execute	core.Matter#TransitBySpec @spec=@descendantSpec, @userID=@userID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [core].[Matter#CascadeBySpec]...';


GO
--PeterHo
CREATE PROCEDURE [core].[Matter#CascadeBySpec](@spec core.TransitionSpec readonly, @userID I32)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		declare	@descendantSpec core.TransitionSpec; insert @descendantSpec
		(		MatterID,   ActionID, OnStateID,   ToStateID,   ToStage,   Source,   TodoHours,   OutboundQ)
		select	    m.ID, x.ActionID, m.StateID, t.ToStateID, t.ToStage, m.Source, t.TodoHours, t.OutboundQ
		from	@spec x cross apply core.Matter#PNodeDn (x.MatterID) m
		cross	apply core.Transition#Tobe(m.StateID, 0, x.ActionID, m.RejoinID) t

		execute	core.Matter#TransitBySpec @spec=@descendantSpec, @userID=@userID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [core].[Matter#CascadeBySpecWithStamp]...';


GO
--Smile
CREATE PROCEDURE [core].[Matter#CascadeBySpecWithStamp](@spec core.TransitionSpec readonly, @utcStamp tvp, @userID I32)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;
		execute	core.RefStamp#MergeBySpec @spec=@spec, @utcStamp=@utcStamp;

		declare	@descendantSpec core.TransitionSpec; insert @descendantSpec
		(		MatterID,   ActionID, OnStateID,   ToStateID,   ToStage,   Source,   TodoHours,   OutboundQ)
		select	    m.ID, x.ActionID, m.StateID, t.ToStateID, t.ToStage, m.Source, t.TodoHours, t.OutboundQ
		from	@spec x cross apply core.Matter#PNodeDn (x.MatterID) m
		cross	apply core.Transition#Tobe(m.StateID, 0, x.ActionID, m.RejoinID) t

		execute	core.Matter#TransitBySpec @spec=@descendantSpec, @userID=@userID;
		execute	core.RefStamp#MergeBySpec @spec=@descendantSpec, @utcStamp=@utcStamp;
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [hub].[ShippingPlan$Comply]...';


GO
/*
@slip   = ParcelID
@result = Many[Duad<Seq, MIC>]
*/
--Eva, Smile
CREATE PROCEDURE [hub].[ShippingPlan$Comply](@slip tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- Transit Origion:
		declare	@parcelID I64=@slip;
		declare	@actionID E32=(select ComplyWithShippingPlan from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@slip, @actionID=@actionID, @tenancy=@tenancy, @beAffected=1;

		-- Promote Original to ShippingPlan:
		declare	@shippingPlan E8=(select ShippingPlan from core.Matter#Type());
		with cte as
		(
			select	Type
			from	core.Matter#Raw()
			where	ID=@parcelID
		)
		update	cte set Type=@shippingPlan;


		-- Init. Parcels from ShippingPlan:
		declare	@shippingPlanInfo tvp=(select Info from core.RefInfo#Type() k cross apply core.RefInfo#Of(@parcelID, k.ShippingPlanInfo))
		,		@concurredInfo    tvp=(select Info from core.RefInfo#Type() k cross apply core.RefInfo#Of(@parcelID, k.ConcurredInfo))
		,		@brkgInfo         tvp=(select Info from core.RefInfo#Type() k cross apply core.RefInfo#Of(@parcelID, k.BrokerageInfo))
		,		@newCnt int;
		select	@newCnt=count(*) from tvp.Bag#Slice(@shippingPlanInfo);

		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(@newCnt);
		
		declare	@source E8,       @svcType I32,       @lastMilerID I32, @siteID I32, @contractID I32
		,		@svcZone E8,      @svcClass E8,       @poa char(3), @routeID I32
		select	@source=Source,   @svcType=SvcType,   @lastMilerID =LastMilerID, @contractID=ContractID
		,		@svcZone=SvcZone, @svcClass=SvcClass, @poa=POA,     @routeID=RouteID
		,		@siteID=SiteID
		from	shpt.Parcel#Base() where ID=@parcelID;

		declare	@userID I32=(select	UserID from	loc.Tenancy#Of(@tenancy));

		declare	@stateID I32=(
								select	t.ToStateID
								from	tms.SvcType#Raw()      x
								cross	apply core.Action#ID() k
								join	core.Transition#Raw()  t on t.OnStateID=x.InitStateID and t.ActionID=k.HubCheckIn
								where	x.ID=@svcType

							 )
		 ;--ToAaron: get stateID by source or route?

		declare	@type    E8 =(select Parcel from core.Matter#Type())
		,		@stage   E32 =(select Stage  from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID, AID,       PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID, @parcelID, @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- Add RefNbrs
		execute	core.RefNbr#AddMIC     @idSeqs=@idSeqs, @source=@source, @type=@type;
		insert	core._RefNbr(MatterID, Type,        Number)
		select				 m.ID,     t.ClientRef, c.v1
		from	@idSeqs                       m
		join	tvp.Bag#Slice(@concurredInfo) p on p.Seq=m.Seq
		cross	apply tvp.Pair#Of(p.Piece)    c
		cross	apply core.RefNbr#Type()      t where len(c.v1)>0;

		-- Add RefInfos
		declare	@idInfo tvp,    @shprInfo tvp,    @cneeInfo tvp;
		select	@idInfo=i.Info, @shprInfo=s.Info, @cneeInfo=c.Info
		from	core.RefInfo#Type() k
		outer	apply core.RefInfo#Of(@parcelID, k.IDInfo)   i
		cross	apply core.RefInfo#Of(@parcelID, k.ShprInfo) s
		cross	apply core.RefInfo#Of(@parcelID, k.CneeInfo) c;
		with	cte as
		(
			select	MatterID=m.ID, Type=t.IDInfo, Info=@idInfo
			from	@idSeqs                   m
			cross	apply core.RefInfo#Type() t
			UNION	ALL
			select	MatterID=m.ID, Type=t.ShprInfo, Info=@shprInfo
			from	@idSeqs                   m
			cross	apply core.RefInfo#Type() t
			UNION	ALL
			select	MatterID=m.ID, Type=t.CneeInfo, Info=@cneeInfo
			from	@idSeqs                   m
			cross	apply core.RefInfo#Type() t
			UNION	ALL
			select	MatterID=m.ID, Type=t.DeclaredInfo, Info=p.Piece
			from	@idSeqs                          m
			cross	apply core.RefInfo#Type()        t
			join	tvp.Bag#Slice(@shippingPlanInfo) p on p.Seq=m.Seq
		)
		insert	core._RefInfo(MatterID, Type, Info)
		select				  MatterID, Type, Info from cte where len(Info)>0;

		with cteInfo as
		(
			select	MatterID=m.ID, m.Seq, Info=concat(e.v1, k.Triad, e.v2, k.Triad,  s.Piece)

			from	tvp.Spr#Const() k, @idSeqs       m
			join	tvp.Bag#Slice(@shippingPlanInfo) p on p.Seq=m.Seq
			cross	apply tvp.Mucho#Slice(p.Piece)   s
			join	tvp.Mucho#Slice(@brkgInfo)       b on b.Seq=s.Seq
			cross	apply tvp.Triad#Of(b.Piece, default)      e
		), cteMixed as
		(
			select	MatterID, Info=(select concat(k.Mucho, o.Info) from tvp.Spr#Const() k, cteInfo o where o.MatterID=x.MatterID  FOR XML PATH(N''))
			from	cteInfo x
			group	by MatterID

		)
		insert	core._RefInfo(MatterID, Type, Info)
		select	MatterID, k.BrokerageInfo, t.Tvp 
		from	core.RefInfo#Type() k, cteMixed x cross	apply tvp.Spr#Purify(x.Info, default) t;
		
		insert	shpt._Parcel
		(		ID, BatchID,  RouteID,  LastMilerID,  SvcType,  SvcZone,  SvcClass, POA,   ContractID)
		select	ID, 0,       @routeID, @lastMilerID, @svcType, @svcZone, @svcClass, @poa, @contractID
		from	@idSeqs;

		-- Result:
		with	cte(text) as
		(
			select	[text()]=concat(k.Many,  i.Seq, k.Duad, r.Number)
			from	@idSeqs i
			join	core.RefNbr#Raw()        r on r.MatterID=i.ID
			cross	apply core.RefNbr#Type() t
			cross	apply tvp.Spr#Const()    k
			where	r.Type=t.MIT for xml path(N'')
		) select	@result=Tvp  from cte cross apply tvp.Spr#Purify(text, default);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [hub].[SackLoad$Transload]...';


GO
/*
	@slip = Comma<SackLoadID>
*/
-- AaronLiu
CREATE PROCEDURE [hub].[SackLoad$Transload](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		--	Transit SackLoad and Cascading:
		declare	@actionID E32=(select CfmTransload from core.Action#ID());
		declare	@spec core.TransitionSpec
		insert	@spec select t.*
		from	tvp.I64#Slice(@slip)			x
		cross	apply core.Matter#ANodeDn(x.ID) m
		cross	apply core.Matter#Tobe(m.ID, @roleID, @actionID) t;

		-- TODO: Ask Peter Add BeAffected
		execute	core.Matter#CascadeAllBySpec @spec=@spec, @userID=@userID;
			
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [hub].[RackInOrder$Complete]...';


GO
/*
	@slip    = Many[Duad<RackCode, Comma[ParcelID]> ]
	@context = OrderInID
	@result  = Quad<ID, CreatedOn, CompletedOn, RackedCount>
*/
-- Smile
CREATE PROCEDURE [hub].[RackInOrder$Complete](@slip tvp,  @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32,    @hubID I32;
		select	@userID=UserID, @roleID=RoleID, @hubID=HubID
		from	loc.Tenancy#Of(@tenancy);

		with	cteRack as
		(
			select	RackCode=x.v1, RackID=isnull(ID, 0)
			from	tvp.Duad#Slice(@slip, default, default) x
			left	join whse.Rack#Raw()                    r on r.Code=x.v1 and r.HubID=@hubID
		)
		insert	into whse._Rack(HubID, Code) select	@hubID, RackCode from cteRack where	RackID=0;

		declare	@actionID I32=(select Rack from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* 
		from	tvp.Duad#Slice(@slip, default, default)          x
		cross	apply tvp.I64#Slice(x.v2)                        i
		cross	apply shpt.Parcel#Tobe(i.ID, @roleID, @actionID) t
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

		declare	@orderInID I32=(@context);
		with	cteRackedParcel as
		(
			select	RackID=r.ID, ParcelID=i.ID
			from	tvp.Duad#Slice(@slip, default, default) x
			cross	apply tvp.I64#Slice(x.v2)               i
			join	whse.Rack#Raw()                         r on r.Code=x.v1 and r.HubID=@hubID											 
		)
		merge	into shpt._RackXact as o using cteRackedParcel as n
		on		(o.RackID=n.RackID and o.ParcelID=n.ParcelID)
		when	matched		then update set o.OrderInID=@orderInID, o.OrderOutID=0
		when	not matched then insert(  ParcelID,   RackID,  OrderInID, OrderOutID)
								 values(n.ParcelID, n.RackID, @orderInID, 0)
		;
		declare	@rackedCnt I32=(@@rowcount);
		update	whse._RackOrder set CompletedOn=getutcdate() where ID=@orderInID;

		execute	shpt.Parcel#TryRackOut;

		select	@result=t.Tvp from whse.RackOrder#Raw()                           x 
		cross	apply tvp.Quad#Make(x.ID, x.CreatedOn, x.CompletedOn, @rackedCnt) t
		where	ID=@orderInID;

	COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [hub].[SackMft$Create]...';


GO
/*
@slip    tvp =Comma[SackID]
@context tvp =Triad<MawbNbr, FlightID, BrokerID>
@result	 tvp =SackMftID
*/
--Smile
CREATE PROCEDURE [hub].[SackMft$Create](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

		declare	@userID I32,    @hubID I32,	  @roleID I32;
		select	@userID=UserID, @hubID=HubID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@mawbNbr char(11), @flightID I64, @flightNbr varchar(30), @poa char(3), @pod char(3), @brokerID I32;
		select	@mawbNbr=v1, @flightID=v2, @flightNbr=FlightNbr, @poa=POA, @pod =POD, @brokerID=v3
		from	tvp.Triad#Of(@context, default) x
		join	tms.Flight#Raw()  f on f.ID=cast(x.v2 as bigint)
		join	core.Matter#Raw() m on m.ID=f.ID
		cross	apply core.State#ID() k
		where	m.StateID=k.FlightBooked;

		declare	@spec core.TransitionSpec,
				@actionID	E32=(select AddToSackMft from core.Action#ID());
		insert	@spec select t.* 
		from	shpt.Sack#Raw() x
		cross	apply core.Matter#Tobe(x.ID, @roleID, @actionID) t
		where	x.ID  in (select ID from tvp.I64#Slice(@slip))
		and		x.BrokerID=@brokerID;

		if (not exists(select * from @spec)) return;

		BEGIN TRY
		BEGIN	TRAN;

	    declare	@sackMftID I64, @exeContext tvp;
		select	@exeContext=Tvp from tvp.Quad#Make(@pod, @poa, @mawbNbr, @flightNbr);

	    execute shpt.SackMft#Create @id=@sackMftID out, @context=@exeContext, @tenancy=@tenancy;

		update	core._Matter set PID=@flightID where ID=@sackMftID;
	    execute core.Matter#CascadeBySpec @spec=@spec, @userID=@userID;

		with cteSack as
		(
			select	ID, PID
			from	core.Matter#Raw() x
			join	@spec c on c.MatterID=x.ID			
		)
		update	cteSack set PID=@sackMftID;

		select	@result=@sackMftID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [hub].[PIP$TearOff]...';


GO
/*
	@slip = Comma<PIPID>
*/
-- AaronLiu
CREATE PROCEDURE [hub].[PIP$TearOff](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@actionID E32=(select TearOff=11400 from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@slip, @actionID=@actionID, @tenancy=@tenancy, @beAffected=1;

		with	cte as
		(
			select	m.ID, m.PID
			from	tvp.I64#Slice(@slip) x
			join	core.Matter#Raw()	 m on x.ID=m.PID
		)
		update	cte set PID=0;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [ic].[Parcel$MergeHandWrittenOrder]...';


GO
/*
@slip    =  Triad[ParcelID, RefInfoType, RefInfo]
@context =  Duad <ParcelID, SvcType>;
*/
--Smile
CREATE PROCEDURE [ic].[Parcel$MergeHandWrittenOrder](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		execute	core.RefInfo#Merge @slip=@slip;	
		
		declare	@parcelID I64, @svcType I32;
		select	@parcelID=v1,  @svcType=v2
		from	tvp.Duad#Of(@context, default);
		with cteParcel as
		(
			select	p.SvcType, NSvcType=t.ID, 
					p.RouteID, NRouteID=r.RouteID, 
					p.POA, NPOA=r.POA, 
					p.ContractID,  NContractID=c.ID, 
					p.LastMilerID, NLastMilerID=r.CourierID
			from	shpt.Parcel#Base()                           p 
			cross	apply tms.SvcType#For(@svcType, p.SiteID)   t
			cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA) r
			cross	apply acct.Contract#For(p.SiteID, p.Source) c
			where	p.ID=@parcelID

		)		
		update	cteParcel set SvcType=NSvcType, RouteID=NRouteID, POA=NPOA
		,		ContractID=NContractID, LastMilerID=NLastMilerID;
		
		declare	@actionID I32=(select CompleteParcelInfo from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@parcelID, @actionID=@actionID, @tenancy=@tenancy;
		
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [ic].[ShippingPlan$Rollback]...';


GO
/*
@slip  = string.Join(at.Tvp.Comma, ids)
*/
--Aimee, Daxia
CREATE PROCEDURE [ic].[ShippingPlan$Rollback](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	
		declare	@actionID I32=(select FallbackShipping from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@slip, @actionID=@actionID, @tenancy=@tenancy;

END
GO
PRINT N'Creating [shpt].[Parcel#UnfiledNormalInitByPlatform]...';


GO
/*
@slip    =Entry[Block< Tuplet<SiteID, SvcType, Weight, RchHubAlias, POA>
			, RefNbr
			, PreCourier
			, ShprInfo
			, CneeInfo
			, Mucho[LineInfo]
			, IDInfo
			, AddOnSvcInfo>]
@context = batchID
*/
--Smile
CREATE PROCEDURE [shpt].[Parcel#UnfiledNormalInitByPlatform](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
			-- 0.	Contexts:
		declare	@siteID I32,    @userID I32,    @source tinyint;
		select	@siteID=SiteID, @userID=UserID, @source=p.Source
		from	loc.Tenancy#Of(@tenancy) x
		join	core.Party#Raw()         p on p.ID=x.UserID;

		declare	@errorCnt int, @errors json;
		select	@errorCnt=v1,  @errors=v2
		from	tvp.Duad#Of(@context, default) x
		;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@spec core.TransitionSpec;
		insert	core._Matter
		(		ID,  PosterID,   StateID,       Stage,  Source,  Type, PostedOn    )
		output	inserted.ID, 0, 0, inserted.StateID, inserted.Stage, inserted.Source, 0, 0 into @spec
		select	x.Master,  cast(q.v1 as int), t.InitStateID, s.Stage, @source,  @type, getutcdate()
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default)       x 
		cross	apply tvp.Tuplet#Of(x.House, default)                        q
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		cross	apply core.Stage#Of(t.InitStateID)                          s

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;
		

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef E8,  @shprInfo E8,  @cneeInfo E8,  @preCourier E8,  @IDInfo E8
		,		@declaredInfo E8,  @brokerageInfo E8, @addOnSvcInfo E8;
		select	@clientRef=n.ClientRef, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo
		,		@preCourier=n.PreCourier, @IDInfo=i.IDInfo, @declaredInfo=i.DeclaredInfo
		,		@brokerageInfo=i.BrokerageInfo, @addOnSvcInfo=I.AddOnSvcInfo
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i;

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;

		execute	core.RefNbr#AddBlock  @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefNbr#AddBlock  @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@preCourier;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=6, @idSeqs=@idSeqs, @slip=@slip, @type=@declaredInfo;
		execute	core.RefInfo#AddBlock @index=7, @idSeqs=@idSeqs, @slip=@slip, @type=@IDInfo;
		execute	core.RefInfo#AddBlock @index=8, @idSeqs=@idSeqs, @slip=@slip, @type=@addOnSvcInfo;

		insert	into core._RefInfo(MatterID, Type, Info)
		select	x.Master, @brokerageInfo, b.BrokerageInfo
		from	tvp.Block#FoldT(6, @idSeqs, @slip, default, default) x
		cross	apply loc.Declared$ToBrokerage(x.House, default)	 b
		;
		
		-- 3.	Add Batch & Parcels:
		declare	@batchID I64=(@context);
		insert	shpt._Parcel
		(		ID, BatchID, RouteID, LastMilerID, SvcType, SvcZone, SvcClass,
				POA, Weight, RcvHubID, ContractID)
		select	x.Master, @batchID, isnull(d.RouteID, r.RouteID), r.CourierID, t.ID, 1, 1, 
				iif(nullif(q.v5, '') is null, r.POA, q.v5), q.v3, isnull(h.ID, 0), c.ID
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default) x 
		cross	apply tvp.Tuplet#Of(x.House, default)                  q
		cross	apply core.Party#Type()                              e
		left	join  core.Party#Raw()                               h on h.Alias=q.v4 and h.Type=e.ZebraHub
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		outer	apply tms.SvcRoute#For(t.ID, cast(q.v5 as char(3)))  d
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)          r
		cross	apply acct.Contract#For(cast(q.v1 as int), @source)  c;
		
		-- 4.	Precourier Concern
		execute	shpt.PreCourier#ConcernBlock @index=3, @slip=@slip;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [shpt].[Orphan#Adopt]...';


GO
/*
	@slip = Comma<PreCourierNbr>
*/
-- AaronLiu
CREATE PROCEDURE [shpt].[Orphan#Adopt](@slip tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@pairs	  I64Pairs;
		declare	@minStage E32,    @maxStage E32;
		select	@minStage=PreMin, @maxStage=CurMax
		from	core.Stage#Boundary();

		with	cte as
		(
			select	Seq, Number=Piece
			from	tvp.Comma#Slice(@slip)
		),	cteMatched as
		(
			select	x.Seq, n.MatterID, m.Type
			,		MatchedCnt=count(1) over(partition by Seq)
			from	core.RefNbr#Type() t, cte x
			join	core.RefNbr#Raw()  n on x.Number=n.Number 
			join	core.Matter#Raw()  m on n.MatterID=m.ID
			where	n.Type=t.PreCourier and m.Stage between @minStage and @maxStage
		),	ctePair as
		(
			select	Seq, ParcelID=[1], OrphanID=[16] 
			from	cteMatched
			pivot	(max(MatterID) for Type in([1], [16])) p
			where	MatchedCnt=2 and [1] is not null and [16] is not null
		)
		insert	@pairs select ParcelID, OrphanID from ctePair;

		--1.0	Add RackLable for Parcel
		declare	@type		E8=(select RackLabel from core.RefNbr#Type())
		,		@mergeSlip tvp;
		with	cte(text) as
		(
			select	[text()]=concat
			(
				k.Many,	 x.LID, 
				k.Triad, @type, 
				k.Triad, format(x.RID %1000000, '000000')
			)
			from	tvp.Spr#Const() k, @pairs x
			cross	apply core.Stage#ID()	  s
			join	core.Matter#Raw()		  m on m.ID=x.RID
			where	m.Stage=s.Racking for xml path(N'')
		)
		select	@mergeSlip=Tvp from cte cross apply tvp.Spr#Purify(text, default);
		execute	core.RefNbr#Merge @slip=@mergeSlip;
		
		--2.0	Copy activity from Orphan to Parcel
		declare	@measure I32=(select HubMeasure from core.Action#ID());
		with	cte as
		(
			select	l.ID, l.AID,  l.StateID, l.Stage, l.RejoinID, RID
			,		OrphanStateID=r.StateID, OrphanStage=r.Stage, NewRejoinID=t.ToStateID
			from	@pairs x
			join	core.Matter#Raw() l on l.ID=x.LID
			join	core.Matter#Raw() r on r.ID=x.RID
			cross	apply shpt.Parcel#Tobe(x.LID, 0, @measure) t
		)
		update	cte set AID=RID, StateID=OrphanStateID, Stage=OrphanStage, RejoinID=NewRejoinID;
		with	cte as
		(
			select	MatterID=x.LID, StateID, ActionID, UserID, TalliedOn
			from	@pairs x
			join	core.Activity#Raw() a on x.RID=a.MatterID
		)
		insert	core._Activity
		(		MatterID, StateID, ActionID, UserID, TalliedOn)
		select	MatterID, StateID, ActionID, UserID, TalliedOn
		from	cte;
		
		--3.0	Replace Orphan with Parcel in Racking process (RackXact)
		with	cte as
		(
			select	ParcelID, NormalParcelID=x.LID
			from	@pairs x
			join	shpt.RackXact#Raw() r on x.RID=r.ParcelID
		)
		update	cte set ParcelID=NormalParcelID;

		--4.0	Orphan should be Adopted
		declare	@ids tvp;
		with	cte(text) as
		(
			select	[text()]=concat(N',', RID)
			from	@pairs for xml path(N'')
		)
		select	@ids=Tvp from cte cross apply tvp.Spr#Purify(text, 1);

		declare	@adopt I32=(select Adopt from core.Action#ID())
		,		@spec  core.TransitionSpec;
		insert	@spec  select t.* from	shpt.Parcel#TobeVia(@ids, @roleID, @adopt) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		--5.0	Check Pracel(RackedIn) whether meet the requirements for ToBeRackedOut or not
		execute	shpt.Parcel#TryRackOut;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[SackMft$Transit]...';


GO
/*
@slip    = at.Tvp.Duad.Join(ActionID, at.tvp.Trio.join(UtcTime, UtcOffset, UtcPlaceID))
@context = ManifestID;
*/
--PeterHo, Smile
CREATE PROCEDURE [svc].[SackMft$Transit](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@actionID I32, @utcStamp tvp;
		select	@actionID=v1,  @utcStamp=v2
		from	tvp.Duad#Of(@slip, default);

		declare	@sackMftID I64=@context;
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from core.Matter#Tobe(@sackMftID, @roleID, @actionID) t

		execute	core.Matter#CascadeBySpecWithStamp @spec=@spec, @userID=@userID, @utcStamp=@utcStamp;
		--execute	core.RefStamp#MergeBySpec @spec=@spec, @utcStamp=@utcStamp;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[SackMft$Release]...';


GO
/*
@slip    tvp=at.Tvp.Duad.join(at.Tvp.Comma.Join(heldTrackingNbrs), at.Tvp.Comma.Join(seizedTrackingNbrs));
@context tvp=at.Tvp.Duad.join(sackMftID, at.Tvp.Trio.Join(UtcTime, UtcOffSet, UtcPlaceID));
*/
--Smile, PeterHo
CREATE PROCEDURE [svc].[SackMft$Release](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;
	    
		declare	@helds tvp,  @seizeds tvp,  @sackMftID I64,  @utcStamp tvp;
		select  @helds=x.v1, @seizeds=x.v2, @sackMftID=s.v1, @utcStamp=s.v2
		from	tvp.Duad#Of(@slip, default)          x
		cross	apply tvp.Duad#Of(@context, default) s

		declare	@ignored tvp, @poa char(3)=(select POA from shpt.SackMft#Raw() where ID=@sackMftID);
		declare	@heldActionID I32,            @seizedActionID I32,              @clearedActionID I32;
		select	@heldActionID=CfmCustomsHeld, @seizedActionID=CfmCustomsSeized, @clearedActionID=CfmCustomsCleared
		from	core.Action#ID();

		declare @heldContext  tvp=(select Tvp from tvp.Triad#Make(@heldActionID, @poa, @utcStamp));
		execute	svc.Parcel$CfmCustomsStatus @slip=@helds, @context=@heldContext, @tenancy=@tenancy, @result=@ignored out;

		declare	@seizedContext  tvp=(select Tvp from tvp.Triad#Make(@seizedActionID, @poa, @utcStamp));
		execute	svc.Parcel$CfmCustomsStatus @slip=@seizeds, @context=@seizedContext, @tenancy=@tenancy, @result=@ignored out;

		declare	@sackMftSlip tvp=(select Tvp from tvp.Duad#Make(@clearedActionID, @utcStamp));
		execute	svc.SackMft$Transit @slip=@sackMftSlip, @context=@sackMftID, @tenancy=@tenancy;

		with cteResult as
		(
			select	Stage, StageCnt=count(*)
			from	core.Matter#PNodeDn(@sackMftID) x
			cross	apply core.Matter#Type()        t
			where	x.Type=t.Parcel
			group	by Stage
		)
		, cte (text) as
		(
			select	[text()]=concat(k.Many, Stage, k.Duad, StageCnt)
			from	cteResult, tvp.Spr#Const() k for xml path(N'')
		)
		select	@result=Tvp from cte cross apply tvp.Spr#Purify(text, default);
	
		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$Verify]...';


GO
/*
@slip    => GoodsInfos.Over(at.Tvp.Many.Join)
@context => MatterID
*/
--PeterHo
CREATE PROCEDURE [svc].[Parcel$Verify](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@refType  E8=(select VerifiedInfo from core.RefInfo#Type());
		declare	@exeSlip tvp=(select Tvp from tvp.Triad#Make(@context, @refType, @slip));
		execute	core.RefInfo#Merge @slip=@exeSlip;

		declare	@matterID  I64=@context;
		declare	@actionID  I32=(select HubVerifyWithTappingGreen from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@context, @actionID=@actionID, @tenancy=@tenancy;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Flight$Transit]...';


GO
/*
@slip    = at.Tvp.Duad.Join(ActionID, at.tvp.Trio.join(UtcTime, UtcOffset, UtcPlaceID))
@context = at.Tvp.Triad.Join(MatterID, ETD, ETA)			
*/
-- Aimee, Smile
CREATE PROCEDURE [svc].[Flight$Transit](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@actionID I32, @utcStamp tvp;
		select	@actionID=v1,  @utcStamp=v2
		from	tvp.Duad#Of(@slip, default);

		declare	@flightID I64, @etd datetime2(2), @eta datetime2(2)
		select	@flightID=v1
		,		@etd=isnull(nullif(v2, ''), dbo.DT@Empty())
		,		@eta=isnull(nullif(v3, ''), dbo.DT@Empty())
		from	tvp.Triad#Of(@context, default) x

		declare	@spec core.TransitionSpec; insert @spec select t.* 
		from	core.Matter#Tobe(@flightID, @roleID, @actionID) t;
		execute	core.Matter#CascadeBySpecWithStamp @spec=@spec, @userID=@userID, @utcStamp=@utcStamp;
		
		with flightCte as
		(
			select	ETD, ETA 
			from	core.Action#ID() k, tms.Flight#Raw() f 
			where	f.ID=@flightID 
			and		@actionID in (k.CfmFlightDepartureDelayed, k.CfmCustomsHeld)
		)
		update	flightCte set ETD=@etd, ETA=@eta ;
	

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Parcel$MergePreCourier]...';


GO
/*
@slip   =Many[Duad<OrderNbr, FirstMilerNbr>]
*/
--Aimee, AaronLiu
CREATE PROCEDURE [svc].[Parcel$MergePreCourier](@slip tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		--1.Merge RefNbr
		declare	@maxStage E32=( select RouteCfmed from core.Stage#ID())
		,		@type     E8=( select PreCourier from core.RefNbr#Type())
		,		@siteID   I32=(select SiteID     from loc.Tenancy#Of(@tenancy))
		,		@clientRefType E8=( select ClientRef from core.RefNbr#Type());
		
		declare	@idSeqs I64Seqs;
		with ctePreNbr as
		(
			select	MatterID=m.ID, Number=cast(x.v2 as varchar(40)), x.Seq
			from	tvp.Duad#Slice(@slip, default, default) x
			cross	apply loc.RefNbr#Cast(x.v1)             r
			join	core.RefNbr#Raw() n on n.Number=r.Number and n.Type=@clientRefType
			join	core.Matter#Raw() m on m.ID=n.MatterID   and m.Stage<@maxStage and m.PosterID=@siteID
		)
		merge	core._RefNbr as r using ctePreNbr as n
		on		(r.MatterID=n.MatterID and r.Type=@type)
		when	matched     and n.Number=N'' then delete
		when	matched     and n.Number>N'' then update set r.Number=n.Number
		when	not matched and n.Number>N'' then insert(MatterID,  Type,   Number)
												values(n.MatterID, @type, n.Number)
		output	inserted.MatterID, n.Seq into @idSeqs;

		--2.find Orphan  TODO: 
		declare	@firstMilerNbrs tvp;
		with	cte(text) as
		(
			select	[text()]=concat(N',', v2)
			from	tvp.Duad#Slice(@slip, default, default)
			for		xml path(N'')
		)
		select	@firstMilerNbrs=Tvp from cte cross apply tvp.Spr#Purify(text, 1);
		execute	shpt.Orphan#Adopt @slip=@firstMilerNbrs, @tenancy=@tenancy;

		--3.return result
		with cteResult (text) as
		(
			select	[text()]=concat(k.Many, x.v1)
			from	tvp.Duad#Slice(@slip, default, default) x
			left	join @idSeqs i on i.Seq=x.Seq
			cross	apply tvp.Spr#Const()   k
			where	i.ID is null
			for		xml path(N'')
		)
		select	@result=Tvp from cteResult cross apply tvp.Spr#Purify(text, default);
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [svc].[Appointment$Complete]...';


GO
/*
@slip		 = Duad<Many<ParcelID>, Triad<Source, StoreSite, Entry[Block<PreCourier, HandWrittenOrderImg>]>>
@context	 = Duad<AppointmentID, HandoverInfo>
HandOverInfo = Duo<HandoverMoney, HandoverImage>
*/
--AaronLiu
CREATE PROCEDURE [svc].[Appointment$Complete](@slip tvp, @context tvp, @tenancy tvp)
--WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 1.	Tranit Appt to Pickedup
		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@appointmentID tvp, @handoverInfo tvp;
		select	@appointmentID =v1, @handoverInfo =v2
		from	tvp.Duad#Of(@context, default);

		declare	@actionID  E32=(select CfmPickedup=17299 from core.Action#ID());	--HACK

		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from core.Matter#TobeVia(@appointmentID, @roleID, @actionID) t
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

		-- 2.	Add HandoverInfo
		declare	@handoverSlip tvp;
		select	@handoverSlip=Tvp
		from	core.RefInfo#Type() t
		cross	apply tvp.Triad#Make(@appointmentID, 14/*HACK*/, @handoverInfo);

		execute	core.RefInfo#Merge @slip=@handoverSlip;

		-- 3.	Init HandWrittenOrders
		declare	@normals tvp, @handWrittens tvp;
		select	@normals =v1, @handWrittens =v2
		from	tvp.Duad#Of(@slip, default);

		declare	@handWrittenSlip  tvp, @handWrittenContext   tvp, @handWrittenResult tvp;
		select	@handWrittenSlip=x.v3, @handWrittenContext=d.Tvp
		from	tvp.Triad#Of(@handWrittens, default) x
		cross	apply tvp.Duad#Make(x.v1, x.v2)		 d

		-- TODO: Refine api.Parcel$InitForHandWrittenOrder
		execute	api.Parcel$InitForHandWrittenOrder @slip=@handWrittenSlip, @context=@handWrittenContext, @tenancy=@tenancy, @result=@handWrittenResult out;

		-- 4.	Link Parcels to Appointment
		with	cte as
		(
			select	m.ID, m.AID
			from	core.Matter#Raw() m, tvp.Pair#Of(@handWrittenResult) p
			cross	apply tvp.Comma#Slice(concat(@normals, N',', p.v2))  x
			where	m.ID=cast(x.Piece as bigint) and m.ID>0
		)
		update	cte set AID=@appointmentID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH 
END
GO
PRINT N'Creating [xpd].[Flight$ImportForXpd]...';


GO
/*
@slip	= Many[Triad<SackNbr, Weight, string.Join(at.Spr.Comma, Mics)>];
@context= Triad<Dozen<POD, ETD, POA, ETA, FlightNbr, AirlineID, BoardedOn>, Dozen<POD, POA, MawbNbr, FlightNbr, OutgatedOn>, ClrMethodID>;
*/
-- Daxia
CREATE PROCEDURE [xpd].[Flight$ImportForXpd](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @site I32;
		select	@userID=UserID, @site=SiteID
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@source E8=(select XPD from core.Source#ID());
		declare	@flightContext tvp, @sackMftContext tvp, @clrMethodID I32;
		select	@flightContext=v1,  @sackMftContext=v2,  @clrMethodID=v3 
		from	tvp.Triad#Of(@context, default);
		
		
		-- 1.	Add Flight
		declare	@flightID I64;
		execute	tms.Flight#Create @id=@flightID out, @source=@source, @context=@flightContext, @tenancy=@tenancy;

		--TODO: BoardedOn

		-- 2.	Add SackMft
		declare	@sackMftID I64;
		execute	shpt.SackMft#CreateForFlight @id=@sackMftID out, @flightID=@flightID, @context=@sackMftContext, @tenancy=@tenancy;

		--TODO: OutgatedOn

		-- 3.1	Add Sack & Upd Parcel
		declare	@sackContext tvp=(select Tvp from tvp.Duad#Make(@sackMftID, @clrMethodID));
		declare	@sackIDTexts tvp;-- Many[Duad<SackID, SackNbr>]
		execute	xpd.Sack$CreateForXpd @slip=@slip, @context=@sackContext, @tenancy=@tenancy, @result=@sackIDTexts out;
		
		-- 3.2	Auto Transloaded : Maybe don't use it.
		-- 3.2	Auto Outgated: where OutgatedOn, When if has not 3.2.

		-- 4.	Result
		--TODO: return invalid parcel mic, and valid mic.
		--select @result=Tvp from tvp.Pair#Make(@sackMftID, @sackIDTexts);
		declare	@validIDs I64Array, @invalidIDs I64Array;
		with cteValid as
		(
			select	p.ID, r.Number
			from	core.Matter#Raw() x cross apply core.RefNbr#Type() k
			join	core.Matter#Raw() p on p.PID=x.ID
			join	core.RefNbr#Raw() r on r.MatterID=p.ID and r.Type=k.MIT
			where	x.PID=@sackMftID
		), cteInvalidText(text) as
		(
			select	[text()]=concat(k.Many, isnull(r.MatterID, 0), k.Duad, i.Piece)
			from	tvp.Spr#Const() k, tvp.Triad#Slice(@slip, default, default) x
			cross	apply tvp.Comma#Slice(x.v3)                                 i
			outer	apply core.RefNbr#ScanOne(i.Piece, default, default)        r
			where	not exists (select * from cteValid c where r.MatterID=c.ID)
			for		xml path(N'')
		), cteValidText(text) as
		(
			select	[text()]=concat(k.Many, x.ID, k.Duad, x.Number)
			from	tvp.Spr#Const() k, cteValid x
			for		xml path(N'')
		)
		select	@result=concat(isnull(stuff(s.text, 1, 3, N''), N''), k.Pair, isnull(stuff(f.text, 1, 3, N''), N''))
		from	cteInvalidText f, cteValidText s, tvp.Spr#Const() k
		;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Creating [api].[Parcel$UnfiledInitByPlatform]...';


GO
/*
@slip    =Trio<NormalParcel, CPSParcel, MPSParcel>
@context = Duad<errorCnt, errors>
@result  =Pair<BatchID, Quad[ClientRef, MIC, Precourier, SvcType)
*/
--Smile
CREATE PROCEDURE [api].[Parcel$UnfiledInitByPlatform](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
--WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@siteID I32=(select SiteID from	loc.Tenancy#Of(@tenancy));
		declare	@errorCnt int, @errors json;
		select	@errorCnt=v1,  @errors=v2
		from	tvp.Duad#Of(@context, default) x;

		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=@errorCnt, @errors=@errors;

		declare	@normal tvp, @cps tvp, @mps tvp;
		select	@normal=v1, @cps=v2, @mps=v3
		from	tvp.Trio#Of(@slip);
		if(@cps>N'')
			execute	shpt.Parcel#UnfiledCPSInitByPlatform    @slip=@cps, @context=@batchID, @tenancy=@tenancy;
		if(@mps>N'')
			execute	shpt.Parcel#UnfiledMPSInitByPlatform    @slip=@mps, @context=@batchID, @tenancy=@tenancy;
		if(@normal>N'')
			execute	shpt.Parcel#UnfiledNormalInitByPlatform @slip=@normal, @context=@batchID, @tenancy=@tenancy;
	
		-- 5.	Result:
		with cteResult(text) as
		(

			select	[text()]=concat(s.Many, r.Number, s.Quad, m.Number, s.Quad, p.Number, s.Quad, x.SvcType)
			from	shpt.Parcel#Base()       x
			cross	apply core.RefNbr#Type() k
			left	join  core.RefNbr#Raw()  r on r.MatterID=x.ID and r.Type=k.ClientRef
			left	join  core.RefNbr#Raw()  p on p.MatterID=x.ID and p.Type=k.PreCourier
			join	core.RefNbr#Raw()        m on m.MatterID=x.ID and m.Type=k.MIT
			cross	apply tvp.Spr#Const()    s
			where	x.BatchID=@batchID
			for		xml path(N'')
		)
		select	@result=r.Tvp 
		from	cteResult 
		cross	apply tvp.Spr#Purify(text, default)  x
		cross	apply tvp.Pair#Make(@batchID, x.Tvp) r
		;
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
-- Refactoring step to update target server with deployed transaction logs

IF OBJECT_ID(N'dbo.__RefactorLog') IS NULL
BEGIN
    CREATE TABLE [dbo].[__RefactorLog] (OperationKey UNIQUEIDENTIFIER NOT NULL PRIMARY KEY)
    EXEC sp_addextendedproperty N'microsoft_database_tools_support', N'refactoring log', N'schema', N'dbo', N'table', N'__RefactorLog'
END
GO
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '4ec8c4e4-a3a8-47b0-8f00-92ecdac9d29b')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('4ec8c4e4-a3a8-47b0-8f00-92ecdac9d29b')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '0522eb71-1862-4a2c-b552-35c85b87f0bb')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('0522eb71-1862-4a2c-b552-35c85b87f0bb')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '943156de-ee18-4f20-9deb-e0a740662407')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('943156de-ee18-4f20-9deb-e0a740662407')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'cde7cfe2-7e77-4312-95ed-c251bac5a494')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('cde7cfe2-7e77-4312-95ed-c251bac5a494')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '53ecf2d5-2a0c-47a9-884f-51ae6a8e57d5')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('53ecf2d5-2a0c-47a9-884f-51ae6a8e57d5')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'e890d6ef-645e-40e0-9869-50bc117e4ab2')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('e890d6ef-645e-40e0-9869-50bc117e4ab2')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '970a8431-f5b6-4312-bd22-e5d827e9eff9')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('970a8431-f5b6-4312-bd22-e5d827e9eff9')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '6de7158f-0689-4f60-b65d-423bfc7addd5')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('6de7158f-0689-4f60-b65d-423bfc7addd5')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '22175198-375c-4cba-8bb0-ecdaa341df32')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('22175198-375c-4cba-8bb0-ecdaa341df32')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'cb481f69-69d0-4728-8569-2de74a4900bf')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('cb481f69-69d0-4728-8569-2de74a4900bf')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'a6680f8f-299f-47d2-90d0-b6f9833ae439')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('a6680f8f-299f-47d2-90d0-b6f9833ae439')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '6341870e-4cf5-4f5c-9c19-413818cd2e6c')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('6341870e-4cf5-4f5c-9c19-413818cd2e6c')

GO

GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
PRINT N'Update complete.';


GO
