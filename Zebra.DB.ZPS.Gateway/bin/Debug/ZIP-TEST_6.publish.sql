/*
Deployment script for ZIP_TEST

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar FLUX_SERVER "FLUXWMSTEST"
:setvar FLUX_WMS "FLUX_WMS"
:setvar DatabaseName "ZIP_TEST"
:setvar DefaultFilePrefix "ZIP_TEST"
:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
PRINT N'Dropping [core].[DF_AddOnSvc_EndedOn]...';


GO
ALTER TABLE [core].[_AddOnSvc] DROP CONSTRAINT [DF_AddOnSvc_EndedOn];


GO
PRINT N'Dropping [core].[DF_AddOnSvc_StartedOn]...';


GO
ALTER TABLE [core].[_AddOnSvc] DROP CONSTRAINT [DF_AddOnSvc_StartedOn];


GO
PRINT N'Dropping [tms].[DF_Flight_ETA]...';


GO
ALTER TABLE [tms].[_Flight] DROP CONSTRAINT [DF_Flight_ETA];


GO
PRINT N'Dropping [tms].[DF_Flight_ETD]...';


GO
ALTER TABLE [tms].[_Flight] DROP CONSTRAINT [DF_Flight_ETD];


GO
PRINT N'Dropping [whse].[PK_RackOrder_CompletedOn]...';


GO
ALTER TABLE [whse].[_RackOrder] DROP CONSTRAINT [PK_RackOrder_CompletedOn];


GO
PRINT N'Dropping [core].[CK_State]...';


GO
ALTER TABLE [core].[_State] DROP CONSTRAINT [CK_State];


GO
PRINT N'Dropping [tms].[CK_SvcType]...';


GO
ALTER TABLE [tms].[_SvcType] DROP CONSTRAINT [CK_SvcType];


GO
PRINT N'Dropping [tms].[CK_SvcType_WeightMethod]...';


GO
ALTER TABLE [tms].[_SvcType] DROP CONSTRAINT [CK_SvcType_WeightMethod];


GO
PRINT N'Dropping [acct].[CK_Invoice_DueBalance]...';


GO
ALTER TABLE [acct].[_Invoice] DROP CONSTRAINT [CK_Invoice_DueBalance];


GO
PRINT N'Dropping [acct].[CK_Invoice_InvoiceAmt]...';


GO
ALTER TABLE [acct].[_Invoice] DROP CONSTRAINT [CK_Invoice_InvoiceAmt];


GO
PRINT N'Dropping [acct].[CK_Ledger_ChargeAmt]...';


GO
ALTER TABLE [acct].[_Ledger] DROP CONSTRAINT [CK_Ledger_ChargeAmt];


GO
PRINT N'Dropping [acct].[CK_Payment_PaidAmt]...';


GO
ALTER TABLE [acct].[_Payment] DROP CONSTRAINT [CK_Payment_PaidAmt];


GO
PRINT N'Dropping [acct].[CK_Vault_Uninvoiced]...';


GO
ALTER TABLE [acct].[_Vault] DROP CONSTRAINT [CK_Vault_Uninvoiced];


GO
PRINT N'Dropping [acct].[CK_Vault_VaultBal]...';


GO
ALTER TABLE [acct].[_Vault] DROP CONSTRAINT [CK_Vault_VaultBal];


GO
PRINT N'Dropping [acct].[CK_VaultXact_XactAmt]...';


GO
ALTER TABLE [acct].[_VaultXact] DROP CONSTRAINT [CK_VaultXact_XactAmt];


GO
PRINT N'Removing schema binding from [dbo].[DT@Anchor]...';


GO
ALTER FUNCTION [dbo].[DT@Anchor]
( )
RETURNS DATE
WITH ENCRYPTION
AS
BEGIN
    RETURN NULL;
END


GO
PRINT N'Removing schema binding from [dbo].[DT@Infinity]...';


GO
ALTER FUNCTION [dbo].[DT@Infinity]
( )
RETURNS DATE
WITH ENCRYPTION
AS
BEGIN
    RETURN NULL;
END


GO
PRINT N'Removing schema binding from [svc].[Account$Ledger]...';


GO
ALTER FUNCTION [svc].[Account$Ledger]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Invoice$ProcessingList]...';


GO
ALTER FUNCTION [svc].[Invoice$ProcessingList]
(@source TINYINT, @vaultTag TINYINT, @partyID INT, @bizUnitID INT, @issueDate DATETIME2 (2))
RETURNS TABLE 
AS
RETURN 
    WITH   cteLedgerGroup
    AS     (SELECT l.PartyID,
                   x.SourceID,
                   p.ContractID,
                   l.CurrencyID,
                   g.VaultTag,
                   IIF (BillingCycle % 7 = 0, cd.BOWeek, cd.BOMonth) AS IssueDate,
                   l.ChargeRaw,
                   isnull(i.LastInvoiceDate, dbo.DT@Empty()) AS LastInvoiceDate,
                   l.TalliedOn,
                   BillingCycle
            FROM   acct.Contract#Raw() AS x CROSS APPLY dbo.Calendar#Of(@issueDate) AS cd
                   INNER JOIN
                   shpt.Parcel#Raw() AS p
                   ON p.ContractID = x.ID
                   INNER JOIN
                   acct.Ledger#Raw() AS l
                   ON l.MatterID = p.ID
                   INNER JOIN
                   acct.Charge#Raw() AS g
                   ON l.ChargeID = g.ID CROSS APPLY acct.Vault#Tag() AS a CROSS APPLY acct.Ledger#Side() AS d OUTER APPLY (SELECT max(IssueDate) AS LastInvoiceDate
                                                                                                                           FROM   acct.Invoice#Raw()
                                                                                                                           WHERE  PartyID = x.TenantID
                                                                                                                                  AND ContractID = x.ID
                                                                                                                                  AND VaultTag = g.VaultTag
                                                                                                                                  AND CurrencyID = l.CurrencyID) AS i
            WHERE  l.InvoiceID = 0
                   AND (NULLIF (@vaultTag, 0) IS NULL
                        OR g.VaultTag = @vaultTag)
                   AND l.LedgerSide = d.AR
                   AND (NULLIF (@bizUnitID, 0) IS NULL
                        OR x.BizUnitID = @bizUnitID)
                   AND (NULLIF (@partyID, 0) IS NULL
                        OR x.TenantID = @partyID)
                   AND (NULLIF (@source, 0) IS NULL
                        OR x.SourceID = @source)
                   AND BillingCycle > 0
                   AND l.TalliedOn < IIF (BillingCycle % 7 = 0, cd.BOWeek, cd.BOMonth)),
           cteInvoiceSummary
    AS     (SELECT PartyID,
                   SourceID,
                   ContractID,
                   CurrencyID,
                   VaultTag,
                   IssueDate,
                   ChargeRaw,
                   DateDiff(day, TalliedOn, dateadd(day, -1, IssueDate)) / BillingCycle AS InvoiceGroup
            FROM   cteLedgerGroup AS x
            WHERE  (BillingCycle IN (7, 14)
                    AND datediff(day, LastInvoiceDate, IssueDate) >= BillingCycle)
                   OR (BillingCycle = 30
                       AND datediff(month, LastInvoiceDate, IssueDate) = 1)),
           cteInvoice
    AS     (SELECT   PartyID,
                     VaultTag,
                     CurrencyID,
                     ContractID,
                     InvoiceGroup,
                     IssueDate,
                     sum(ChargeRaw) AS ChargeRawAmt,
                     count(*) AS LedgerCount
            FROM     cteInvoiceSummary
            GROUP BY PartyID, VaultTag, CurrencyID, ContractID, InvoiceGroup, IssueDate)
    SELECT isnull(row_number() OVER (ORDER BY (SELECT NULL)), 0) AS ID,
           p.Alias AS PartyAlias,
           CurrencyID,
           VaultTag,
           c.Amt AS ChargeAmt,
           t.SourceID,
           IssueDate,
           ContractID,
           InvoiceGroup,
           PartyID,
           isnull(LedgerCount, 0) AS LedgerCount,
           dateadd(day, IIF (VaultTag = k.Duty, DutyTerms, NonDutyTerms), IssueDate) AS DueDate
    FROM   cteInvoice AS x
           INNER JOIN
           core.Party#Raw() AS p
           ON p.ID = x.PartyID CROSS APPLY dbo.Currency#Encode(ChargeRawAmt, CurrencyID) AS c
           INNER JOIN
           acct.Contract#Raw() AS t
           ON t.ID = x.ContractID CROSS APPLY acct.Vault#Tag() AS k



GO
PRINT N'Removing schema binding from [bo].[Account$ExportForDutyInvoice]...';


GO
ALTER FUNCTION [bo].[Account$ExportForDutyInvoice]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT InvoicedOn,
            InvoiceNbr,
            i.PartyID,
            isnull(t.BillingCycle, 0) AS NetDays,
            DueDate,
            c.Tvp AS BillTo,
            l.DutyTvp
     FROM   acct.Invoice#Raw() AS i
            INNER JOIN
            core.Party#Raw() AS p
            ON p.ID = i.PartyID
            INNER JOIN
            acct.Contract#Raw() AS t
            ON t.ID = i.ContractID CROSS APPLY core.Contact#Type() AS k OUTER APPLY core.Contact#TvpFor(i.PartyID, k.Billing) AS c CROSS APPLY acct.Ledger#DutyTvpFor(i.ID) AS l CROSS APPLY acct.Vault#Tag() AS d CROSS APPLY acct.Ledger#Side() AS s
     WHERE  i.DueBalance > 0
            AND i.VaultTag = d.Duty
            AND i.LedgerSide = s.AR
            AND BillingCycle > 0)



GO
PRINT N'Removing schema binding from [bo].[Account$ExportForFreightInvoice]...';


GO
ALTER FUNCTION [bo].[Account$ExportForFreightInvoice]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT InvoicedOn,
            InvoiceNbr,
            i.PartyID,
            isnull(BillingCycle, 0) AS NetDays,
            DueDate,
            c.Tvp AS BillTo,
            l.FreightTvp
     FROM   acct.Invoice#Raw() AS i
            INNER JOIN
            core.Party#Raw() AS p
            ON p.ID = i.PartyID
            INNER JOIN
            acct.Contract#Raw() AS t
            ON t.ID = i.ContractID CROSS APPLY core.Contact#Type() AS k OUTER APPLY core.Contact#TvpFor(i.PartyID, k.Billing) AS c CROSS APPLY acct.Ledger#FreightTvpFor(i.ID) AS l CROSS APPLY acct.Vault#Tag() AS d CROSS APPLY acct.Ledger#Side() AS s
     WHERE  i.DueBalance > 0
            AND i.VaultTag = d.NotDuty
            AND i.LedgerSide = s.AR
            AND BillingCycle > 0)



GO
PRINT N'Removing schema binding from [bo].[Account$IncomeSummary]...';


GO
ALTER FUNCTION [bo].[Account$IncomeSummary]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            TalliedOn,
            x.CurrencyID,
            x.ChargeAmt,
            ChargeID,
            BillingCycle,
            x.PartyID,
            p.Alias AS TenantAlias,
            BizUnitID,
            b.Alias AS BizUnit,
            POA,
            a.Source,
            RefNbrs,
            RefInfos,
            PostedOn,
            RcvHubAlias,
            '' AS Supplement
     FROM   acct.Ledger#Raw() AS x
            INNER JOIN
            core.Tenant#Raw() AS p
            ON p.ID = x.PartyID
            INNER JOIN
            shpt.Parcel#Deep() AS a
            ON a.ID = x.MatterID
            INNER JOIN
            acct.Contract#Raw() AS c
            ON c.ID = a.ContractID
            INNER JOIN
            core.Party#Raw() AS b
            ON b.ID = c.BizUnitID CROSS APPLY core.Source#ID() AS e
     WHERE  a.Source IN (e.eShip, e.eVMI)
            AND x.InvoiceID > -1
     UNION ALL
     SELECT x.ID,
            TalliedOn,
            x.CurrencyID,
            x.ChargeAmt,
            ChargeID,
            BillingCycle,
            x.PartyID,
            p.Alias AS TenantAlias,
            BizUnitID,
            b.Alias AS BizUnit,
            '' AS POA,
            a.Source,
            '' AS RefNbrs,
            '' AS RefInfos,
            PostedOn,
            t.Alias AS RcvHubAlias,
            '' AS Supplement
     FROM   acct.Ledger#Raw() AS x
            INNER JOIN
            core.Tenant#Raw() AS p
            ON p.ID = x.PartyID
            INNER JOIN
            whse.StockInOrder#Base() AS a
            ON a.ID = x.MatterID
            INNER JOIN
            acct.Contract#Raw() AS c
            ON c.ID = a.ContractID
            INNER JOIN
            core.Party#Raw() AS b
            ON b.ID = c.BizUnitID
            INNER JOIN
            core.Tenant#Raw() AS t
            ON t.ID = a.RcvHubID CROSS APPLY core.Source#ID() AS e
     WHERE  a.Source IN (e.eShip, e.eVMI)
            AND x.InvoiceID > -1
     UNION ALL
     SELECT x.ID,
            TalliedOn,
            x.CurrencyID,
            x.ChargeAmt,
            ChargeID,
            BillingCycle,
            x.PartyID,
            p.Alias AS TenantAlias,
            BizUnitID,
            b.Alias AS BizUnit,
            '' AS POA,
            a.Source,
            '' AS RefNbrs,
            '' AS RefInfos,
            PostedOn,
            '' AS RcvHubAlias,
            Supplement
     FROM   acct.Ledger#Raw() AS x
            INNER JOIN
            core.Tenant#Raw() AS p
            ON p.ID = x.PartyID CROSS APPLY core.Matter#Type() AS m
            INNER JOIN
            core.Matter#Raw() AS a
            ON a.ID = x.MatterID CROSS APPLY acct.Contract#For(x.PartyID, a.Source) AS c
            INNER JOIN
            core.Party#Raw() AS b
            ON b.ID = c.BizUnitID CROSS APPLY core.Registry#ID() AS r
            INNER JOIN
            core.Supplement#Raw() AS s
            ON s.RegID = r.Ledger
               AND s.RowID = x.ID CROSS APPLY core.Source#ID() AS e
     WHERE  a.Source IN (e.eShip, e.eVMI)
            AND x.InvoiceID > -1
     UNION ALL
     SELECT x.ID,
            TalliedOn,
            x.CurrencyID,
            x.ChargeAmt,
            ChargeID,
            BillingCycle,
            x.PartyID,
            p.Alias AS TenantAlias,
            BizUnitID,
            b.Alias AS BizUnit,
            '' AS POA,
            a.Source,
            '' AS RefNbrs,
            '' AS RefInfos,
            PostedOn,
            '' AS RcvHubAlias,
            Supplement
     FROM   acct.Ledger#Raw() AS x
            INNER JOIN
            core.Tenant#Raw() AS p
            ON p.ID = x.PartyID CROSS APPLY core.Matter#Type() AS m
            INNER JOIN
            core.Matter#Raw() AS a
            ON a.ID = x.MatterID CROSS APPLY acct.Contract#For(x.PartyID, a.Source) AS c
            INNER JOIN
            core.Party#Raw() AS b
            ON b.ID = c.BizUnitID CROSS APPLY core.Registry#ID() AS r
            INNER JOIN
            core.Supplement#Raw() AS s
            ON s.RegID = r.AssortedFees
               AND s.RowID = a.ID CROSS APPLY core.Source#ID() AS e
     WHERE  a.Source IN (e.eShip, e.eVMI)
            AND x.InvoiceID > -1)



GO
PRINT N'Removing schema binding from [svc].[Account$InvoiceList]...';


GO
ALTER FUNCTION [svc].[Account$InvoiceList]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            CurrencyID,
            DueBalance,
            InvoiceAmt,
            InvoicedOn,
            InvoiceNbr,
            x.VaultTag,
            x.PartyID,
            Alias,
            DueDate,
            datediff(day, getutcdate(), DueDate) AS RemainingDays
     FROM   acct.Invoice#Raw() AS x
            INNER JOIN
            core.Party#Raw() AS p
            ON p.ID = x.PartyID
            INNER JOIN
            acct.Contract#Raw() AS c
            ON c.ID = x.ContractID
     WHERE  x.DueBalance > 0
            AND c.BillingCycle > 0)



GO
PRINT N'Removing schema binding from [svc].[Account$InvoiceSummary]...';


GO
ALTER FUNCTION [svc].[Account$InvoiceSummary]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Account$StockInOrderLedger]...';


GO
ALTER FUNCTION [svc].[Account$StockInOrderLedger]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Account$VaultBalance]...';


GO
ALTER FUNCTION [svc].[Account$VaultBalance]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[SvcContract$For]...';


GO
ALTER FUNCTION [svc].[SvcContract$For]
(@partyID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT SvcType
     FROM   core.Party#Raw() AS p CROSS APPLY acct.Contract#For(P.ID, p.Source) AS x
            INNER JOIN
            tms.SvcContract#Raw() AS s
            ON s.ContractID = x.ID
     WHERE  p.ID = @partyID
            AND x.ID > 0)



GO
PRINT N'Removing schema binding from [svc].[Tenancy$SiteList]...';


GO
ALTER FUNCTION [svc].[Tenancy$SiteList]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.Alias,
            x.PID AS TenantID,
            d.Alias AS TenantAlias,
            x.Source,
            t.UtcPlace,
            t.UtcOffset,
            BizUnitID,
            b.Alias AS BizUnit
     FROM   core.Party#Raw() AS x
            INNER JOIN
            core.Party#Raw() AS d
            ON d.ID = x.PID
            INNER JOIN
            core.Tenant#Raw() AS t
            ON x.ID = t.ID CROSS APPLY acct.Contract#For(d.ID, d.Source) AS c
            INNER JOIN
            core.Party#Raw() AS b
            ON b.ID = c.BizUnitID CROSS APPLY core.Party#Type() AS k
     WHERE  x.Type = k.TenantSite)



GO
PRINT N'Removing schema binding from [svc].[Tenancy$TenantInfoList]...';


GO
ALTER FUNCTION [svc].[Tenancy$TenantInfoList]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.Alias,
            x.Source,
            UtcPlace,
            UtcOffset,
            c.Tvp AS Contact,
            BizUnitID,
            b.Alias AS BizUnit,
            BillingCycle,
            DutyTerms,
            NonDutyTerms,
            isnull(EffectiveOn, '') AS EffectiveOn,
            isnull(ExpiredOn, '') AS ExpiredOn
     FROM   core.Party#Raw() AS x
            INNER JOIN
            core.Tenant#Raw() AS p
            ON p.ID = x.ID CROSS APPLY acct.Contract#For(p.ID, p.Source) AS r
            INNER JOIN
            core.Party#Raw() AS b
            ON b.ID = r.BizUnitID CROSS APPLY core.Contact#Type() AS k OUTER APPLY core.Contact#TvpFor(x.ID, k.Billing) AS c CROSS APPLY core.Party#Type() AS t
     WHERE  x.ID > 0
            AND x.Type = t.Tenant)



GO
PRINT N'Removing schema binding from [svc].[Tenancy$UserInfoList]...';


GO
ALTER FUNCTION [svc].[Tenancy$UserInfoList]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.Alias,
            x.Source,
            Name,
            Email,
            a.ID AS TenantID,
            a.Alias AS TenantAlias,
            IIF (x.AID = x.PID, 0, p.ID) AS SiteID,
            IIF (x.AID = x.PID, N'', p.Alias) AS SiteAlias,
            BizUnitID,
            d.Alias AS BizUnit
     FROM   core.Party#Raw() AS x
            INNER JOIN
            core.Party#Raw() AS p
            ON p.ID = x.PID
            INNER JOIN
            core.Party#Raw() AS a
            ON a.ID = x.AID CROSS APPLY acct.Contract#For(a.ID, a.Source) AS o
            INNER JOIN
            core.Party#Raw() AS d
            ON d.ID = o.BizUnitID CROSS APPLY core.Party#Type() AS k CROSS APPLY core.Contact#Type() AS t
            LEFT OUTER JOIN
            core.Contact#Raw() AS c
            ON c.PartyID = x.ID
               AND c.Type = t.Billing
     WHERE  x.Type = k.Operator)



GO
PRINT N'Removing schema binding from [svc].[VaultXact$Summary]...';


GO
ALTER FUNCTION [svc].[VaultXact$Summary]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [vmi].[SvcContract$For]...';


GO
ALTER FUNCTION [vmi].[SvcContract$For]
(@partyID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT SvcType
     FROM   core.Party#Raw() AS p CROSS APPLY acct.Contract#For(P.ID, p.Source) AS x
            INNER JOIN
            tms.SvcContract#Raw() AS s
            ON s.ContractID = x.ID
     WHERE  p.ID = @partyID
            AND x.ID > 0)



GO
PRINT N'Removing schema binding from [co].[Payment$DetailFor]...';


GO
ALTER FUNCTION [co].[Payment$DetailFor]
(@paymentID BIGINT, @toCurrencyID TINYINT)
RETURNS TABLE 
AS
RETURN 
    (SELECT PaymentNbr,
            PaidAmt,
            ForPayment
     FROM   acct.Payment#Raw() AS x
            INNER JOIN
            svc.CurrencyRate$Summary() AS p
            ON p.ToCurrencyID = @toCurrencyID
               AND p.FmCurrencyID = x.CurrencyID
     WHERE  ID = @paymentID)



GO
PRINT N'Removing schema binding from [acct].[Invoice#Raw]...';


GO
ALTER FUNCTION [acct].[Invoice#Raw]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [acct].[Ledger#DutyTvpFor]...';


GO
ALTER FUNCTION [acct].[Ledger#DutyTvpFor]
(@invoiceID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [acct].[Ledger#FreightTvpFor]...';


GO
ALTER FUNCTION [acct].[Ledger#FreightTvpFor]
(@invoiceID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [rpt].[Dashboard$Summary]...';


GO
ALTER FUNCTION [rpt].[Dashboard$Summary]
(@siteID BIGINT, @timezoneOffset INT=0)
RETURNS TABLE 
AS
RETURN 
    (SELECT isnull(SUM(CASE WHEN cl.DOffset - c.DOffset <= 1 THEN 1 ELSE 0 END), 0) AS LastDayParcel,
            isnull(SUM(CASE WHEN cl.DOffset - c.DOffset <= 7 THEN 1 ELSE 0 END), 0) AS Last7DParcel,
            isnull(SUM(CASE WHEN cl.DOffset - c.DOffset BETWEEN 7 AND 14 THEN 1 ELSE 0 END), 0) AS Pre7DParcel,
            isnull(SUM(CASE WHEN cl.DOffset - c.DOffset <= 30 THEN 1 ELSE 0 END), 0) AS Last30DParcel,
            isnull(SUM(CASE WHEN cl.DOffset - c.DOffset BETWEEN 30 AND 60 THEN 1 ELSE 0 END), 0) AS Pre30DParcel,
            isnull(SUM(CASE WHEN cl.MOffset - c.MOffset = 0 THEN 1 ELSE 0 END), 0) AS LastMonthParcel,
            isnull(SUM(CASE WHEN cl.MOffset - c.MOffset = 1 THEN 1 ELSE 0 END), 0) AS PreMonthParcel,
            isnull(ROUND(SUM(IIF (cl.DOffset - c.DOffset <= 1, r.Sales, 0)), 2), 0) AS LastDaySales,
            isnull(ROUND(SUM(IIF (cl.DOffset - c.DOffset <= 7, r.Sales, 0)), 2), 0) AS Last7DSales,
            isnull(ROUND(SUM(IIF (cl.DOffset - c.DOffset BETWEEN 7 AND 14, r.Sales, 0)), 2), 0) AS Pre7DSales,
            isnull(ROUND(SUM(IIF (cl.DOffset - c.DOffset <= 30, r.Sales, 0)), 2), 0) AS Last30DSales,
            isnull(ROUND(SUM(IIF (cl.DOffset - c.DOffset BETWEEN 30 AND 60, r.Sales, 0)), 2), 0) AS Pre30DSales,
            isnull(ROUND(SUM(IIF (cl.MOffset - c.MOffset = 0, r.Sales, 0)), 2), 0) AS LastMonthSales,
            isnull(ROUND(SUM(IIF (cl.MOffset - c.MOffset = 1, r.Sales, 0)), 2), 0) AS PreMonthSales,
            isnull(ROUND(SUM(IIF (cl.DOffset - c.DOffset <= 1, f.Freight, 0)), 2), 0) AS LastDayFreight,
            isnull(ROUND(SUM(IIF (cl.DOffset - c.DOffset <= 7, f.Freight, 0)), 2), 0) AS Last7DFreight,
            isnull(ROUND(SUM(IIF (cl.DOffset - c.DOffset BETWEEN 7 AND 14, f.Freight, 0)), 2), 0) AS Pre7DFreight,
            isnull(ROUND(SUM(IIF (cl.DOffset - c.DOffset <= 30, f.Freight, 0)), 2), 0) AS Last30DFreight,
            isnull(ROUND(SUM(IIF (cl.DOffset - c.DOffset BETWEEN 30 AND 60, f.Freight, 0)), 2), 0) AS Pre30DFreight,
            isnull(ROUND(SUM(IIF (cl.MOffset - c.MOffset = 0, f.Freight, 0)), 2), 0) AS LastMonthFreight,
            isnull(ROUND(SUM(IIF (cl.MOffset - c.MOffset = 1, f.Freight, 0)), 2), 0) AS PreMonthFreight
     FROM   core.Matter#Raw() AS x CROSS APPLY core.Matter#Type() AS mt CROSS APPLY core.RefInfo#Type() AS rt CROSS APPLY tvp.Spr#Const() AS sp CROSS APPLY dbo.Calendar#Of(DATEADD(HOUR, -@timezoneOffset, GETUTCDATE())) AS cl
            INNER JOIN
            dbo.Calendar#Raw() AS c
            ON CAST (x.PostedOn AS DATE) = c.Value CROSS APPLY (SELECT isnull(sum(m.DecAmt), 0) AS Sales
                                                                FROM   core.RefInfo#Of(x.ID, rt.DeclaredInfo) AS x CROSS APPLY tvp.Quad#Slice(x.Info, DEFAULT, sp.Mucho) AS t CROSS APPLY dbo.Money#Of(t.v3) AS m) AS r CROSS APPLY (SELECT isnull(sum(m.DecAmt), 0) AS Freight
                                                                                                                                                                                                                                     FROM   acct.Ledger#Raw() AS g CROSS APPLY acct.Charge#ID() AS c CROSS APPLY dbo.Money#Of(g.ChargeAmt) AS m
                                                                                                                                                                                                                                     WHERE  g.MatterID = x.ID
                                                                                                                                                                                                                                            AND g.ChargeID = c.Freight) AS f
     WHERE  c.DOffset BETWEEN (cl.DOffset - 60) AND cl.DOffset
            AND x.Type = mt.Parcel
            AND x.PosterID = @siteID)



GO
PRINT N'Removing schema binding from [svc].[Account$AssortedFees]...';


GO
ALTER FUNCTION [svc].[Account$AssortedFees]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Account$StorageFees]...';


GO
ALTER FUNCTION [svc].[Account$StorageFees]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [vmi].[Invoice$SummaryForSasa]...';


GO
ALTER FUNCTION [vmi].[Invoice$SummaryForSasa]
( )
RETURNS TABLE 
AS
RETURN 
    WITH   cte
    AS     (SELECT x.ID,
                   x.PartyID,
                   c.NextBal AS VaultBal,
                   x.CurrencyID,
                   x.TalliedOn,
                   ChargeID,
                   ChargeAmt,
                   N'' AS ClientRefNbr,
                   r.Number AS RefNbr,
                   N'' AS Supplement,
                   c.XactedOn,
                   0 AS SectionWt,
                   0 AS Weight
            FROM   acct.Ledger#Raw() AS x
                   INNER JOIN
                   acct.Vault#Raw() AS v
                   ON x.PartyID = v.PartyID
                      AND x.CurrencyID = v.CurrencyID
                   INNER JOIN
                   acct.VaultXact#Raw() AS c
                   ON c.VaultID = v.ID
                      AND c.InvoiceID = x.InvoiceID CROSS APPLY core.RefNbr#Type() AS k
                   INNER JOIN
                   core.RefNbr#Raw() AS r
                   ON r.MatterID = x.MatterID
                      AND r.Type = k.AsnNbr
            WHERE  x.PartyID IN (10983, 10987)
            UNION ALL
            SELECT x.ID,
                   x.PartyID,
                   c.NextBal AS VaultBal,
                   x.CurrencyID,
                   x.TalliedOn,
                   ChargeID,
                   ChargeAmt,
                   N'' AS ClientRefNbr,
                   N'' AS RefNbr,
                   Supplement,
                   c.XactedOn,
                   0 AS SectionWt,
                   0 AS Weight
            FROM   acct.Ledger#Raw() AS x CROSS APPLY core.Matter#Type() AS k
                   INNER JOIN
                   core.Matter#Raw() AS m
                   ON m.ID = x.MatterID
                      AND m.Type = k.AssortedFees
                   INNER JOIN
                   acct.Vault#Raw() AS v
                   ON x.PartyID = v.PartyID
                      AND x.CurrencyID = v.CurrencyID
                   INNER JOIN
                   acct.VaultXact#Raw() AS c
                   ON c.VaultID = v.ID
                      AND c.InvoiceID = x.InvoiceID CROSS APPLY core.Registry#ID() AS r
                   INNER JOIN
                   core.Supplement#Raw() AS s
                   ON s.RegID = r.AssortedFees
                      AND s.RowID = m.ID
            WHERE  x.PartyID IN (10983, 10987)
            UNION ALL
            SELECT x.ID,
                   x.PartyID,
                   c.NextBal AS VaultBal,
                   x.CurrencyID,
                   x.TalliedOn,
                   ChargeID,
                   ChargeAmt,
                   N'' AS ClientRefNbr,
                   N'' AS RefNbr,
                   Supplement,
                   c.XactedOn,
                   0 AS SectionWt,
                   0 AS Weight
            FROM   acct.Ledger#Raw() AS x CROSS APPLY core.Matter#Type() AS k
                   INNER JOIN
                   core.Matter#Raw() AS m
                   ON m.ID = x.MatterID
                      AND m.Type = k.StorageFee
                   INNER JOIN
                   acct.Vault#Raw() AS v
                   ON x.PartyID = v.PartyID
                      AND x.CurrencyID = v.CurrencyID
                   INNER JOIN
                   acct.VaultXact#Raw() AS c
                   ON c.VaultID = v.ID
                      AND c.InvoiceID = x.InvoiceID CROSS APPLY core.Registry#ID() AS r
                   INNER JOIN
                   core.Supplement#Raw() AS s
                   ON s.RegID = r.Ledger
                      AND s.RowID = x.ID
            WHERE  x.PartyID IN (10983, 10987)
            UNION ALL
            SELECT x.ID,
                   x.PartyID,
                   c.NextBal AS VaultBal,
                   x.CurrencyID,
                   x.TalliedOn,
                   ChargeID,
                   ChargeAmt,
                   r.Number AS ClientRefNbr,
                   p.Number AS RefNbr,
                   N'' AS Supplement,
                   c.XactedOn,
                   Weight AS SectionWt,
                   Weight
            FROM   acct.Ledger#Raw() AS x
                   INNER JOIN
                   shpt.Parcel#Raw() AS m
                   ON m.ID = x.MatterID
                   INNER JOIN
                   acct.Vault#Raw() AS v
                   ON x.PartyID = v.PartyID
                      AND x.CurrencyID = v.CurrencyID
                   INNER JOIN
                   acct.VaultXact#Raw() AS c
                   ON c.VaultID = v.ID
                      AND c.InvoiceID = x.InvoiceID CROSS APPLY core.RefNbr#Type() AS t
                   INNER JOIN
                   core.RefNbr#Raw() AS r
                   ON r.MatterID = m.ID
                      AND r.Type = t.ClientRef
                   LEFT OUTER JOIN
                   core.RefNbr#Raw() AS p
                   ON p.MatterID = m.ID
                      AND p.Type = t.PostCourier
            WHERE  x.PartyID IN (10983, 10987)
            UNION ALL
            SELECT x.ID,
                   x.PartyID,
                   c.NextBal AS VaultBal,
                   x.CurrencyID,
                   x.PaidOn,
                   IIF (x.PaidAmt > 0, g.Deposit, g.Deduct) AS ChargeID,
                   x.PaidAmt AS ChargeAmt,
                   N'' AS ClientRefNbr,
                   N'' AS RefNbr,
                   N'' AS Supplement,
                   c.XactedOn,
                   0 AS SectionWt,
                   0 AS Weight
            FROM   acct.Payment#Raw() AS x
                   INNER JOIN
                   acct.Vault#Raw() AS v
                   ON x.PartyID = v.PartyID
                      AND x.CurrencyID = v.CurrencyID
                   INNER JOIN
                   acct.VaultXact#Raw() AS c
                   ON c.VaultID = v.ID
                      AND c.PaymentID = x.ID CROSS APPLY acct.Charge#ID() AS g
            WHERE  x.PartyID IN (10983, 10987))
    SELECT u.ID,
           d.Alias AS PartyAlias,
           TalliedOn,
           ClientRefNbr,
           CurrencyID,
           XactedOn,
           RefNbr,
           VaultBal,
           ChargeAmt,
           Weight,
           SectionWt,
           ChargeID,
           Supplement
    FROM   core.Party#Raw() AS d
           INNER JOIN
           cte AS u
           ON d.ID = u.PartyID
    WHERE  d.ID IN (10983, 10987)



GO
PRINT N'Removing schema binding from [ic].[Parcel$ForExportActivityInfo]...';


GO
ALTER FUNCTION [ic].[Parcel$ForExportActivityInfo]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            Stage,
            x.Source,
            RcvHubID,
            RcvHubAlias,
            RouteID,
            RouteCode,
            SiteAlias,
            LastMilerAlias,
            PostedOn,
            StatedOn,
            RefNbrs,
            Weight,
            Length,
            Height,
            Width,
            p.PID AS TenantID,
            e.Tvp AS Activities
     FROM   shpt.Parcel#Deep() AS x
            INNER JOIN
            core.Party#Raw() AS p
            ON p.ID = x.SiteID OUTER APPLY (SELECT concat(k.Many, Stage, k.Quad, TalliedOn, k.Quad, t.UtcOffset, k.Quad, p.UtcOffset) AS [text()]
                                            FROM   core.Activity#Raw() AS a
                                                   LEFT OUTER JOIN
                                                   core.Tenant#Raw() AS t
                                                   ON t.ID = x.RcvHubID
                                                   LEFT OUTER JOIN
                                                   core.Port#Raw() AS p
                                                   ON p.Code = x.POA CROSS APPLY core.Stage#Of(a.StateID) AS s CROSS APPLY tvp.Spr#Const() AS k
                                            WHERE  a.MatterID = x.ID
                                            FOR    XML PATH (N'')) AS z(text) CROSS APPLY tvp.Spr#Purify(z.text, DEFAULT) AS e)



GO
PRINT N'Removing schema binding from [ic].[Parcel$WithConcern]...';


GO
ALTER FUNCTION [ic].[Parcel$WithConcern]
(@concernType TINYINT)
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            Stage,
            SvcType,
            Source,
            RouteID,
            RouteCode,
            StatedOn,
            RefNbrs,
            RefInfos,
            Handler,
            HandlerID,
            Concerns
     FROM   shpt.Parcel#Deep() AS x CROSS APPLY core.Concern#Tvp(x.ID) AS t CROSS APPLY svc.User$ContactName(x.HandlerID) AS u
     WHERE  EXISTS (SELECT MatterID
                    FROM   core.Concern#Raw()
                    WHERE  x.ID = MatterID
                           AND (Type = @concernType
                                OR NULLIF (@concernType, 0) IS NULL)))



GO
PRINT N'Removing schema binding from [lc].[Parcel$Sorting]...';


GO
ALTER FUNCTION [lc].[Parcel$Sorting]
(@number VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    WITH   cteParcel
    AS     (SELECT p.ID,
                   p.RcvHubID,
                   p.Stage,
                   p.RouteID,
                   p.RouteCode,
                   p.SvcType,
                   p.POA
            FROM   core.RefNbr#ScanOne(@number, DEFAULT, DEFAULT) AS x
                   INNER JOIN
                   shpt.Parcel#Deep() AS p
                   ON x.MatterID = p.ID),
           cteActivities (text)
    AS     (SELECT concat(k.Many, a.ID, k.Tuplet, u.Alias, k.Tuplet, a.ActionID, k.Tuplet, s.Stage, k.Tuplet, dateadd(hour, t.UtcOffset, TalliedOn)) AS [text()]
            FROM   tvp.Spr#Const() AS k, cteParcel AS x CROSS APPLY core.Matter#PNodeUp(x.ID) AS m
                   INNER JOIN
                   core.Activity#Raw() AS a
                   ON a.MatterID = m.ID
                   INNER JOIN
                   core.Tenant#Raw() AS t
                   ON t.ID = x.RcvHubID
                   INNER JOIN
                   core.State#Raw() AS s
                   ON s.ID = a.StateID
                   INNER JOIN
                   core.Party#Raw() AS u
                   ON u.ID = a.UserID
            FOR    XML PATH (''))
    SELECT x.ID,
           x.Stage,
           x.RouteID,
           x.RouteCode,
           x.SvcType,
           x.POA,
           Tvp AS Activities
    FROM   cteParcel AS x, cteActivities CROSS APPLY tvp.Spr#Purify(text, DEFAULT)



GO
PRINT N'Removing schema binding from [svc].[Batch$ExportForAmazon]...';


GO
ALTER FUNCTION [svc].[Batch$ExportForAmazon]
(@batchIDs NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Parcel$ExceptionList]...';


GO
ALTER FUNCTION [svc].[Parcel$ExceptionList]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.StateID,
            StatedOn,
            Stage,
            Source,
            SvcType,
            POA,
            HandlerID,
            u.Handler,
            RouteID,
            RouteCode,
            RefNbrs,
            RefInfos,
            RoledActions,
            m.Body AS LastMessage
     FROM   shpt.Parcel#Deep() AS x CROSS APPLY core.Registry#ID() AS k CROSS APPLY svc.User$ContactName(x.HandlerID) AS u OUTER APPLY core.Message#BodyOfLast(k.Matter, x.ID) AS m)



GO
PRINT N'Removing schema binding from [svc].[Parcel$ForCreateSackMft]...';


GO
ALTER FUNCTION [svc].[Parcel$ForCreateSackMft]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT ID,
            Source,
            RefNbrs,
            RcvHubID,
            RcvHubAlias,
            POA,
            StateID,
            StatedOn,
            RouteID,
            MftGroup,
            RouteCode,
            BrokerID,
            BrokerAlias,
            RefInfos,
            Weight
     FROM   shpt.Parcel#Deep() AS x CROSS APPLY core.Stage#ID() AS k
     WHERE  x.Stage = k.RouteCfmed)



GO
PRINT N'Removing schema binding from [svc].[Parcel$ForLoadBalance]...';


GO
ALTER FUNCTION [svc].[Parcel$ForLoadBalance]
(@stage INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT ID,
            RefNbrs,
            RcvHubID,
            RcvHubAlias,
            POA,
            StateID,
            StatedOn,
            Source,
            RouteID,
            RouteCode,
            BrokerID,
            BrokerAlias
     FROM   shpt.Parcel#Deep()
     WHERE  Stage = @stage)



GO
PRINT N'Removing schema binding from [svc].[Parcel$ForStage]...';


GO
ALTER FUNCTION [svc].[Parcel$ForStage]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.Source,
            Stage,
            RcvHubID,
            RcvHubAlias,
            RefNbrs,
            StatedOn,
            t.ID AS TenantID,
            t.Alias AS TenantAlias,
            RouteID,
            RouteCode,
            Handler,
            HandlerID
     FROM   core.Party#Type() AS k, shpt.Parcel#Deep() AS x
            INNER JOIN
            core.Party#Raw() AS s
            ON s.ID = x.SiteID
            INNER JOIN
            core.Party#Raw() AS t
            ON t.ID = s.PID CROSS APPLY svc.User$ContactName(x.HandlerID) AS u)



GO
PRINT N'Removing schema binding from [svc].[Parcel$ListForCainiao]...';


GO
ALTER FUNCTION [svc].[Parcel$ListForCainiao]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.RcvHubAlias,
            m.Number AS MIC,
            LastMilerID,
            LastMilerCode,
            x.RouteID,
            isnull(c.Number, N'') AS PostCourier,
            isnull(d.FlightNbr, N'') AS FlightNbr,
            isnull(d.POA, N'') AS POA,
            isnull(d.POD, N'') AS POD
     FROM   shpt.Parcel#Deep() AS x CROSS APPLY core.Matter#Type() AS mk CROSS APPLY core.RefNbr#Type() AS k
            INNER JOIN
            core.RefNbr#Raw() AS m
            ON m.MatterID = x.ID
               AND m.Type = k.MIT
            LEFT OUTER JOIN
            core.RefNbr#Raw() AS c
            ON c.MatterID = x.ID
               AND c.Type = k.PostCourier OUTER APPLY (SELECT ID AS SackMftID
                                                       FROM   core.Matter#PNodeUp(x.ID)
                                                       WHERE  Type = mk.SackMft) AS s
            LEFT OUTER JOIN
            shpt.SackMft#Deep() AS d
            ON d.ID = s.SackMftID)



GO
PRINT N'Removing schema binding from [svc].[Parcel$OutgatedList]...';


GO
ALTER FUNCTION [svc].[Parcel$OutgatedList]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Parcel$ShippingPlanList]...';


GO
ALTER FUNCTION [svc].[Parcel$ShippingPlanList]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            Stage,
            x.Source,
            POA,
            Weight,
            RefNbrs,
            RouteID,
            RouteCode,
            RcvHubID,
            RcvHubAlias,
            RefInfos,
            HandlerID,
            u.Alias AS Handler
     FROM   shpt.Parcel#Deep() AS x
            INNER JOIN
            core.User#Raw() AS u
            ON x.HandlerID = u.ID)



GO
PRINT N'Removing schema binding from [svc].[Parcel$WithChallenge]...';


GO
ALTER FUNCTION [svc].[Parcel$WithChallenge]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.StateID,
            StatedOn,
            Stage,
            Source,
            SvcType,
            POA,
            HandlerID,
            RouteID,
            RouteCode,
            RefNbrs,
            RoledActions,
            c.Body AS ChallengeBody,
            u.Handler
     FROM   shpt.Parcel#Deep() AS x CROSS APPLY core.Challenge#Of(x.ID) AS c CROSS APPLY svc.User$ContactName(x.HandlerID) AS u)



GO
PRINT N'Removing schema binding from [svc].[SackMft$Export]...';


GO
ALTER FUNCTION [svc].[SackMft$Export]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            p.RefNbrs,
            p.RefInfos,
            p.Weight,
            p.RouteID,
            p.PostedOn
     FROM   shpt.SackMft#Raw() AS x
            INNER JOIN
            shpt.Parcel#Deep() AS p
            ON p.PID = x.ID)



GO
PRINT N'Removing schema binding from [svc].[SackMft$ExportForOutgate]...';


GO
ALTER FUNCTION [svc].[SackMft$ExportForOutgate]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.FlightNbr,
            x.MawbNbr,
            x.PostedOn AS MftPostedOn,
            x.BrokerID,
            x.POD,
            x.POA,
            x.HubAlias,
            s.RefNbrs AS SackNbrs,
            p.RefNbrs,
            p.RefInfos,
            p.Weight,
            p.RouteID,
            p.PostedOn
     FROM   shpt.SackMft#Deep() AS x
            INNER JOIN
            shpt.Sack#Base() AS s
            ON s.PID = x.ID
            INNER JOIN
            shpt.Parcel#Deep() AS p
            ON p.PID = s.ID
     UNION
     SELECT x.ID,
            x.FlightNbr,
            x.MawbNbr,
            x.PostedOn AS MftPostedOn,
            x.BrokerID,
            x.POD,
            x.POA,
            x.HubAlias,
            N'' AS SackNbrs,
            p.RefNbrs,
            p.RefInfos,
            p.Weight,
            p.RouteID,
            p.PostedOn
     FROM   shpt.SackMft#Deep() AS x
            INNER JOIN
            shpt.Parcel#Deep() AS p
            ON p.PID = x.ID)



GO
PRINT N'Removing schema binding from [vmi].[Parcel$Detail]...';


GO
ALTER FUNCTION [vmi].[Parcel$Detail]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT ID,
            Source,
            PostedOn,
            Stage,
            StateID,
            StatedOn,
            isnull(OutgatedOn, '') AS OutgatedOn,
            RcvHubID,
            RcvHubAlias,
            SiteID,
            SiteAlias,
            RefNbrs,
            RefInfos,
            SvcType,
            t.CourierCode,
            t.CourierNbr,
            t.Tracks
     FROM   shpt.Parcel#Deep() AS x CROSS APPLY svc.Parcel$Track(x.ID) AS t OUTER APPLY (SELECT TOP (1) TalliedOn AS OutgatedOn
                                                                                         FROM   core.Activity#Raw() AS a
                                                                                                INNER JOIN
                                                                                                core.State#Raw() AS t
                                                                                                ON a.StateID = t.ID CROSS APPLY core.Stage#ID() AS k
                                                                                         WHERE  Stage = k.Outgated
                                                                                                AND MatterID = x.ID) AS c CROSS APPLY core.Source#ID() AS k
     WHERE  x.Source = k.eVMI)



GO
PRINT N'Removing schema binding from [vmi].[Parcel$ForExport]...';


GO
ALTER FUNCTION [vmi].[Parcel$ForExport]
(@siteID INT, @trackingNbr VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    (SELECT ID,
            Weight,
            PostedOn,
            Stage,
            RcvHubAlias,
            CourierAlias,
            SvcType,
            RefNbrs,
            RefInfos,
            Ledgers
     FROM   shpt.Parcel#Deep() AS x CROSS APPLY core.Source#ID() AS k
     WHERE  x.Source = k.eVMI
            AND x.SiteID = @siteID
            AND (NULLIF (@trackingNbr, '') IS NULL
                 OR EXISTS (SELECT MatterID
                            FROM   core.RefNbr#Raw()
                            WHERE  MatterID = x.ID
                                   AND Number = @trackingNbr)))



GO
PRINT N'Removing schema binding from [vmi].[Parcel$List]...';


GO
ALTER FUNCTION [vmi].[Parcel$List]
(@trackingNbr VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    (SELECT ID,
            Weight,
            Source,
            PostedOn,
            Stage,
            StateID,
            StatedOn,
            SvcType,
            SiteID,
            SiteAlias,
            RefNbrs,
            RefInfos,
            Ledgers
     FROM   shpt.Parcel#Deep() AS x CROSS APPLY core.Source#ID() AS k
     WHERE  x.Source = k.eVMI
            AND (NULLIF (@trackingNbr, '') IS NULL
                 OR EXISTS (SELECT MatterID
                            FROM   core.RefNbr#Raw()
                            WHERE  MatterID = x.ID
                                   AND Number = @trackingNbr)))



GO
PRINT N'Removing schema binding from [ic].[SackMft$ForOutgated]...';


GO
ALTER FUNCTION [ic].[SackMft$ForOutgated]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            MawbNbr,
            FlightNbr,
            Stage,
            StatedOn,
            POA,
            POD,
            p.RouteID,
            t.RouteCode,
            isnull(p.TotalParcelCnt, 0) AS [TotalParcelCnt]
     FROM   shpt.SackMft#Deep() AS x CROSS APPLY (SELECT   count(*) AS TotalParcelCnt,
                                                           RouteID
                                                  FROM     core.Matter#Raw() AS m CROSS APPLY core.Matter#Type() AS k
                                                           INNER JOIN
                                                           shpt.Parcel#Base() AS t
                                                           ON t.PID = m.ID
                                                  WHERE    m.PID = x.ID
                                                  GROUP BY t.RouteID) AS p
            INNER JOIN
            tms.Route#Raw() AS t
            ON t.ID = p.RouteID)



GO
PRINT N'Removing schema binding from [svc].[SackMft$List]...';


GO
ALTER FUNCTION [svc].[SackMft$List]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT ID,
            MawbNbr,
            x.PID AS FlightID,
            FlightNbr,
            PostedOn,
            Stage,
            StateID,
            StatedOn,
            HubID,
            HubAlias,
            HubUtcOffset,
            RefStamps,
            RoledActions,
            UnSackedParcelCnt,
            UnTransloadedSackCnt,
            Source,
            POA,
            a.UtcOffset AS [POAUtcOffset],
            a.UtcPlaceID AS [POAUtcPlaceID],
            POD,
            d.UtcOffset AS [PODUtcOffset],
            d.UtcPlaceID AS [PODUtcPlaceID]
     FROM   shpt.SackMft#Deep() AS x
            INNER JOIN
            core.Port#Raw() AS a
            ON x.POA = a.Code
            INNER JOIN
            core.Port#Raw() AS d
            ON x.POD = d.Code CROSS APPLY (SELECT isnull(sum(CASE WHEN m.Type = t.Parcel
                                                                       AND m.Level = 1 THEN 1 ELSE 0 END), 0) AS UnSackedParcelCnt,
                                                  isnull(sum(CASE WHEN m.Type = t.Sack
                                                                       AND m.Stage < s.Transloaded THEN 1 ELSE 0 END), 0) AS UnTransloadedSackCnt
                                           FROM   core.Matter#PNodeDn(x.ID) AS m CROSS APPLY core.Matter#Type() AS t CROSS APPLY core.Stage#ID() AS s) AS n)



GO
PRINT N'Removing schema binding from [svc].[Parcel$DetailVia]...';


GO
ALTER FUNCTION [svc].[Parcel$DetailVia]
(@number VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    (SELECT ID,
            PID,
            AID,
            p.Source,
            PostedOn,
            p.Stage,
            StateID,
            StatedOn,
            BatchID,
            BatchedOn,
            RcvHubID,
            RcvHubAlias,
            RcvHubUtcOffset,
            SiteID,
            SiteAlias,
            RouteID,
            RouteCode,
            CourierID,
            CourierAlias,
            BrokerID,
            BrokerAlias,
            POA,
            SvcType,
            SvcZone,
            SvcClass,
            Weight,
            Length,
            Width,
            Height,
            RefNbrs,
            RefInfos,
            Ledgers,
            Challenges,
            ZoneCode,
            AddOnServices
     FROM   core.RefNbr#ScanOne(@number, DEFAULT, DEFAULT) AS x
            INNER JOIN
            svc.Parcel$Detail() AS p
            ON p.ID = x.MatterID)



GO
PRINT N'Removing schema binding from [svc].[Parcel$Label]...';


GO
ALTER FUNCTION [svc].[Parcel$Label]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT ID,
            PID,
            AID,
            Source,
            PostedOn,
            x.Stage,
            StateID,
            StatedOn,
            BatchID,
            BatchedOn,
            RcvHubID,
            RcvHubAlias,
            SiteID,
            SiteAlias,
            RouteID,
            RouteCode,
            x.CourierID,
            CourierAlias,
            BrokerID,
            BrokerAlias,
            x.POA,
            SvcType,
            SvcZone,
            SvcClass,
            Weight,
            Length,
            Width,
            Height,
            RefNbrs,
            RefInfos,
            Ledgers,
            Challenges,
            AddOnServices,
            ZoneCode,
            isnull(FacilityID % 100, 0) AS FacilityID,
            BarcodeNbr
     FROM   svc.Parcel$Detail() AS x CROSS APPLY core.RefNbr#Type() AS k
            LEFT OUTER JOIN
            core.RefNbr#Raw() AS r
            ON r.MatterID = x.ID
               AND r.Type = k.PostCourier OUTER APPLY tms.SvcFacility#For(x.Source, x.SvcClass, LEFT(x.ZoneCode, 3)) AS f OUTER APPLY tms.BarcodeNbr#Make(x.ZoneCode, r.Number) AS b)



GO
PRINT N'Removing schema binding from [svc].[Parcel$LabelVia]...';


GO
ALTER FUNCTION [svc].[Parcel$LabelVia]
(@number VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    (SELECT ID,
            PID,
            AID,
            Source,
            PostedOn,
            p.Stage,
            StateID,
            StatedOn,
            BatchID,
            BatchedOn,
            RcvHubID,
            RcvHubAlias,
            SiteID,
            SiteAlias,
            RouteID,
            RouteCode,
            p.CourierID,
            CourierAlias,
            BrokerID,
            BrokerAlias,
            p.POA,
            SvcType,
            SvcZone,
            SvcClass,
            Weight,
            Length,
            Width,
            Height,
            RefNbrs,
            RefInfos,
            Ledgers,
            Challenges,
            AddOnServices,
            ZoneCode,
            isnull(FacilityID % 100, 0) AS FacilityID,
            BarcodeNbr
     FROM   core.RefNbr#ScanOne(@number, DEFAULT, DEFAULT) AS x CROSS APPLY core.RefNbr#Type() AS k
            INNER JOIN
            svc.Parcel$Detail() AS p
            ON p.ID = x.MatterID
            LEFT OUTER JOIN
            core.RefNbr#Raw() AS r
            ON r.MatterID = x.MatterID
               AND r.Type = k.PostCourier OUTER APPLY tms.SvcFacility#For(p.Source, p.SvcClass, LEFT(p.ZoneCode, 3)) AS f OUTER APPLY tms.BarcodeNbr#Make(p.ZoneCode, r.Number) AS b)



GO
PRINT N'Removing schema binding from [svc].[Parcel$ListVia]...';


GO
ALTER FUNCTION [svc].[Parcel$ListVia]
(@idsInCsv NVARCHAR (MAX))
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            Source,
            PostedOn,
            Stage,
            StateID,
            StatedOn,
            BatchID,
            RcvHubID,
            SiteID,
            RouteID,
            RouteCode,
            CourierID,
            BrokerID,
            SvcType,
            SvcZone,
            SvcClass,
            CmdyRootID,
            Weight,
            Length,
            Width,
            Height,
            POA,
            RefNbrs,
            RefInfos,
            Ledgers,
            Challenges,
            LastMilerCode,
            HandlerID,
            Handler,
            AddOnServices,
            HasIDNbr,
            HasConcern,
            ZoneCode
     FROM   tvp.I64#Slice(@idsInCsv) AS i, svc.Parcel$List() AS x
     WHERE  i.ID = x.ID)



GO
PRINT N'Removing schema binding from [co].[Payment$Verify]...';


GO
ALTER FUNCTION [co].[Payment$Verify]
(@paymentID BIGINT)
RETURNS TABLE 
AS
RETURN 
    (SELECT XID
     FROM   acct.Payment#Raw()
     WHERE  ID = @paymentID)



GO
PRINT N'Removing schema binding from [acct].[Vault#IdOf]...';


GO
ALTER FUNCTION [acct].[Vault#IdOf]
(@partyID BIGINT, @currencyID TINYINT, @valutType TINYINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [acct].[Vault#Summary]...';


GO
ALTER FUNCTION [acct].[Vault#Summary]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Account$VaultBalFor]...';


GO
ALTER FUNCTION [svc].[Account$VaultBalFor]
(@partyID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Account$VaultSummary]...';


GO
ALTER FUNCTION [svc].[Account$VaultSummary]
(@partyID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT CurrencyID,
            VaultBal,
            VaultType,
            LockCnt
     FROM   acct.Vault#Raw() AS x CROSS APPLY (SELECT count(*) AS LockCnt
                                               FROM   core.Matter#Raw() AS m CROSS APPLY core.State#ID() AS s
                                               WHERE  m.StateID = s.CreditLimitExceeded) AS l CROSS APPLY acct.Vault#Type() AS t
     WHERE  x.VaultType = t.Fund
            AND x.PartyID = @partyID)



GO
PRINT N'Removing schema binding from [vmi].[Account$VaultBalFor]...';


GO
ALTER FUNCTION [vmi].[Account$VaultBalFor]
(@partyID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [vmi].[AccountBal$Verify]...';


GO
ALTER FUNCTION [vmi].[AccountBal$Verify]
(@acctID INT, @svcType INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT v.ID,
            v.CurBal
     FROM   tms.SvcType#For(@svcType, @acctID) AS x
            INNER JOIN
            tms.SvcType#Raw() AS e
            ON e.ID = x.ID CROSS APPLY acct.Vault#Type() AS k
            INNER JOIN
            acct.Vault#Raw() AS v
            ON v.PartyID = @acctID
               AND v.CurrencyID = e.CurrencyID
               AND v.VaultType = k.Fund)



GO
PRINT N'Removing schema binding from [acct].[VaultXact#LastBalFor]...';


GO
ALTER FUNCTION [acct].[VaultXact#LastBalFor]
(@vaultID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [acct].[VaultXact#Raw]...';


GO
ALTER FUNCTION [acct].[VaultXact#Raw]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Parcel$DetailForSubscribe]...';


GO
ALTER FUNCTION [svc].[Parcel$DetailForSubscribe]
(@mic VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    (SELECT x.MatterID AS ID,
            a.RefNbr AS SubscribeNbr
     FROM   api.ActivitySubscription#Raw() AS a, core.RefNbr#ScanOne(@mic, DEFAULT, DEFAULT) AS x
     WHERE  x.MatterID = a.MatterID)



GO
PRINT N'Removing schema binding from [brkg].[BrokerRate#For]...';


GO
ALTER FUNCTION [brkg].[BrokerRate#For]
(@brokerID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Broker$Lookup]...';


GO
ALTER FUNCTION [svc].[Broker$Lookup]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT ID,
            BrokerAlias
     FROM   brkg.Broker#Raw()
     WHERE  ID > 0)



GO
PRINT N'Removing schema binding from [svc].[ClrMethod$BrokerLookup]...';


GO
ALTER FUNCTION [svc].[ClrMethod$BrokerLookup]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT c.CountryCode AS CountryCode,
            b.ID AS BrokerID,
            b.BrokerAlias,
            c.ID AS ClrMethodID,
            c.ClrMethodCode
     FROM   tms.Route#Raw() AS r
            INNER JOIN
            brkg.Broker#Raw() AS b
            ON b.ID = r.BrokerID
            INNER JOIN
            brkg.ClrMethod#Raw() AS c
            ON c.ID = r.ClrMethodID
     WHERE  b.ID > 0
            AND c.ID > 0)



GO
PRINT N'Removing schema binding from [svc].[Parcel$CriteriaForLoadBalance]...';


GO
ALTER FUNCTION [svc].[Parcel$CriteriaForLoadBalance]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [shpt].[Parcel#FreightAndDutyFor]...';


GO
ALTER FUNCTION [shpt].[Parcel#FreightAndDutyFor]
(@parcelIDs [dbo].[I64Array] READONLY)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tms].[SvcRoute#Deep]...';


GO
ALTER FUNCTION [tms].[SvcRoute#Deep]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[ClrMethod$Lookup]...';


GO
ALTER FUNCTION [svc].[ClrMethod$Lookup]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT ID,
            ClrMethodCode,
            CountryCode
     FROM   brkg.ClrMethod#Raw())



GO
PRINT N'Removing schema binding from [svc].[Parcel$VefityDutyCode]...';


GO
ALTER FUNCTION [svc].[Parcel$VefityDutyCode]
(@dutyCodes NVARCHAR (MAX))
RETURNS TABLE 
AS
RETURN 
    (SELECT p.ID,
            x.v2 AS DutyCode,
            isnull(d.ID, 0) AS DutyID,
            isnull(d.DutyRate, 0) AS DutyRate
     FROM   tvp.Duad#Slice(@dutyCodes, DEFAULT, DEFAULT) AS x
            INNER JOIN
            shpt.Parcel#Raw() AS p
            ON p.ID = CAST (x.v1 AS BIGINT)
            INNER JOIN
            tms.Route#Raw() AS t
            ON t.ID = p.RouteID
            INNER JOIN
            brkg.ClrMethod#Raw() AS c
            ON c.ID = t.ClrMethodID
            LEFT OUTER JOIN
            brkg.Duty#Raw() AS d
            ON d.CountryCode = c.CountryCode
               AND d.DutyCode = x.v2)



GO
PRINT N'Removing schema binding from [tms].[SvcType#Deep]...';


GO
ALTER FUNCTION [tms].[SvcType#Deep]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [shpt].[Parcel#LedgerForVmi]...';


GO
ALTER FUNCTION [shpt].[Parcel#LedgerForVmi]
(@parcelIDs [dbo].[I64Array] READONLY)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Sku$DutyList]...';


GO
ALTER FUNCTION [svc].[Sku$DutyList]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.TenantID,
            p.Alias AS TenantAlias,
            x.SkuNbr,
            t.DutyTvp
     FROM   invt.Sku#Raw() AS x
            INNER JOIN
            core.Tenant#Raw() AS p
            ON p.ID = x.TenantID CROSS APPLY invt.SkuDuty#Tvp(x.ID) AS t)



GO
PRINT N'Removing schema binding from [svc].[Commodity$Fuzzy]...';


GO
ALTER FUNCTION [svc].[Commodity$Fuzzy]
(@countryCode CHAR (2))
RETURNS TABLE 
AS
RETURN 
    (SELECT c.ID,
            c.PID,
            c.Name AS [Path],
            c.Surcharge,
            c.DutyID,
            c.DutyRate,
            c.DutyCode
     FROM   brkg.Commodity#Raw() AS x
            INNER JOIN
            brkg.Commodity#Deep() AS c
            ON c.PID = x.ID
     WHERE  x.PID = 0
            AND x.Name = CAST (@countryCode + N'F' AS NVARCHAR (50)))



GO
PRINT N'Removing schema binding from [svc].[Commodity$FuzzyRoot]...';


GO
ALTER FUNCTION [svc].[Commodity$FuzzyRoot]
(@svcType INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT c.ID,
            c.PID,
            Path,
            Surcharge,
            DutyID,
            DutyRate,
            DutyCode
     FROM   tms.SvcType#Raw() AS x CROSS APPLY svc.Commodity$Root(x.CmdyRootID) AS c
     WHERE  x.ID = @svcType)



GO
PRINT N'Removing schema binding from [svc].[Commodity$Node]...';


GO
ALTER FUNCTION [svc].[Commodity$Node]
(@parentID INT)
RETURNS TABLE 
AS
RETURN 
    WITH   cteCmdy
    AS     (SELECT x.ID,
                   x.PID,
                   x.DutyID,
                   x.Surcharge,
                   CAST (x.Name AS NVARCHAR (MAX)) AS Path
            FROM   brkg.Commodity#Raw() AS x
            WHERE  PID = @parentID
                   AND @parentID > 0
            UNION ALL
            SELECT x.ID,
                   x.PID,
                   x.DutyID,
                   x.Surcharge,
                   p.Path + N'	/	' + x.Name AS Path
            FROM   cteCmdy AS p
                   INNER JOIN
                   brkg.Commodity#Raw() AS x
                   ON p.ID = x.PID)
    SELECT isnull(x.ID, 0) AS ID,
           isnull(x.PID, 0) AS PID,
           isnull(x.Path, N'') AS Path,
           isnull(x.Surcharge, 0) AS Surcharge,
           isnull(x.DutyID, 0) AS DutyID,
           d.DutyRate,
           d.DutyCode
    FROM   cteCmdy AS x
           INNER JOIN
           brkg.Duty#Raw() AS d
           ON d.ID = x.DutyID
    WHERE  d.DutyRate >= 0



GO
PRINT N'Removing schema binding from [tms].[Freight#For]...';


GO
ALTER FUNCTION [tms].[Freight#For]
(@svcType INT, @rcvHubID BIGINT, @measuredWt REAL, @brokerageInfo NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [invt].[SkuInfo#ToBrokerage]...';


GO
ALTER FUNCTION [invt].[SkuInfo#ToBrokerage]
(@skuInfos NVARCHAR (MAX), @brokerID BIGINT, @clrMethodID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [co].[Parcel$PendingFor]...';


GO
ALTER FUNCTION [co].[Parcel$PendingFor]
(@days TINYINT, @tenantID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tms].[Route#Check]...';


GO
ALTER FUNCTION [tms].[Route#Check]
(@routeID BIGINT, @svcClass TINYINT, @weight REAL, @length REAL, @tenancy NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [hub].[Activity$Lookup]...';


GO
ALTER FUNCTION [hub].[Activity$Lookup]
(@number VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    (SELECT a.ID,
            u.Alias AS Operator,
            a.ActionID,
            s.Stage,
            isnull(dateadd(hour, t.UtcOffset, TalliedOn), N'0001-01-01') AS OperatedOn
     FROM   core.RefNbr#ScanOne(@number, DEFAULT, DEFAULT) AS x CROSS APPLY core.Matter#PNodeUp(x.MatterID) AS m
            INNER JOIN
            core.Activity#Raw() AS a
            ON a.MatterID = m.ID
            INNER JOIN
            shpt.Parcel#Raw() AS p
            ON p.ID = x.MatterID
            INNER JOIN
            core.Tenant#Raw() AS t
            ON t.ID = p.RcvHubID
            INNER JOIN
            core.State#Raw() AS s
            ON s.ID = a.StateID
            INNER JOIN
            core.Party#Raw() AS u
            ON u.ID = a.UserID)



GO
PRINT N'Removing schema binding from [svc].[Parcel$TrackManyForZPS]...';


GO
ALTER FUNCTION [svc].[Parcel$TrackManyForZPS]
(@numbersInCsv NVARCHAR (MAX), @siteID INT)
RETURNS TABLE 
AS
RETURN 
    WITH   cteMatter
    AS     (SELECT row_number() OVER (ORDER BY (SELECT NULL)) AS SeqID,
                   n.MatterID AS TrackingID,
                   n.Number AS TrackingNbr
            FROM   loc.RefNbr#Slice(@numbersInCsv) AS x CROSS APPLY core.RefNbr#ScanOne(x.Number, DEFAULT, DEFAULT) AS n CROSS APPLY core.Matter#Type() AS m
                   INNER JOIN
                   core.Matter#Raw() AS r
                   ON r.Type = m.Parcel
                      AND r.ID = n.MatterID CROSS APPLY core.RefNbr#Type() AS k
            WHERE  (CASE WHEN n.Type IN (k.ClientRef, k.PreCourier) THEN @siteID ELSE r.PosterID END) = r.PosterID),
           cteMarked
    AS     (SELECT x.TrackingID,
                   x.TrackingNbr,
                   ID,
                   Type,
                   MatterID,
                   StateID,
                   Stage,
                   TalliedOn,
                   UserID,
                   UserAlias,
                   UtcTime,
                   UtcOffset,
                   UtcPlace,
                   UtcPlaceID,
                   lead(ID) OVER (PARTITION BY x.SeqID ORDER BY Stage) AS Marker
            FROM   cteMatter AS x CROSS APPLY core.Activity#Track(x.TrackingID))
    SELECT TrackingID AS ID,
           TrackingNbr,
           Stage,
           UtcTime,
           UtcOffset,
           UtcPlace
    FROM   cteMarked
    WHERE  Marker IS NULL



GO
PRINT N'Removing schema binding from [vmi].[Parcel$TrackMany]...';


GO
ALTER FUNCTION [vmi].[Parcel$TrackMany]
(@numbersInCsv NVARCHAR (MAX), @siteID INT)
RETURNS TABLE 
AS
RETURN 
    WITH   cteMatter
    AS     (SELECT row_number() OVER (ORDER BY (SELECT NULL)) AS SeqID,
                   n.MatterID AS TrackingID,
                   n.Number AS TrackingNbr
            FROM   loc.RefNbr#Slice(@numbersInCsv) AS x CROSS APPLY core.RefNbr#ScanOne(x.Number, DEFAULT, DEFAULT) AS n CROSS APPLY core.Matter#Type() AS m CROSS APPLY core.Source#ID() AS s
                   INNER JOIN
                   core.Matter#Raw() AS r
                   ON r.Type = m.Parcel
                      AND r.ID = n.MatterID
                      AND r.Source = s.eVMI CROSS APPLY core.RefNbr#Type() AS k
            WHERE  r.PosterID = r.PosterID),
           cteMarked
    AS     (SELECT x.TrackingID,
                   x.TrackingNbr,
                   ID,
                   Type,
                   MatterID,
                   StateID,
                   Stage,
                   TalliedOn,
                   UserID,
                   UserAlias,
                   UtcTime,
                   UtcOffset,
                   UtcPlace,
                   UtcPlaceID
            FROM   cteMatter AS x CROSS APPLY core.Activity#Track(x.TrackingID))
    SELECT TrackingID AS ID,
           TrackingNbr,
           Stage,
           UtcTime,
           UtcOffset,
           UtcPlace
    FROM   cteMarked



GO
PRINT N'Removing schema binding from [svc].[Parcel$TrackMany]...';


GO
ALTER FUNCTION [svc].[Parcel$TrackMany]
(@numbersInCsv NVARCHAR (MAX))
RETURNS TABLE 
AS
RETURN 
    (SELECT TrackingID AS ID,
            TrackingNbr,
            Stage,
            UtcTime,
            UtcOffset,
            UtcPlace
     FROM   core.Activity#TrackMany(@numbersInCsv))



GO
PRINT N'Removing schema binding from [svc].[Parcel$TrackForXpd]...';


GO
ALTER FUNCTION [svc].[Parcel$TrackForXpd]
(@numbersInCsv NVARCHAR (MAX), @siteID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT Tracks,
            CourierCode,
            CourierNbr,
            x.Number AS TrackingNbr
     FROM   core.RefNbr#MatchMulti(@numbersInCsv, DEFAULT, DEFAULT) AS x
            INNER JOIN
            core.Matter#Raw() AS p
            ON p.ID = x.MatterID CROSS APPLY svc.Parcel$Track(p.ID)
     WHERE  p.PosterID = @siteID)



GO
PRINT N'Removing schema binding from [svc].[Parcel$TrackOne]...';


GO
ALTER FUNCTION [svc].[Parcel$TrackOne]
(@trackingNbr VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    (SELECT Tracks,
            CourierCode,
            CourierNbr
     FROM   core.RefNbr#ScanOne(@trackingNbr, DEFAULT, DEFAULT) AS x CROSS APPLY svc.Parcel$Track(x.MatterID) AS a)



GO
PRINT N'Removing schema binding from [shpt].[Parcel#Sorting]...';


GO
ALTER FUNCTION [shpt].[Parcel#Sorting]
(@pracelID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [shpt].[SackLoad#Base]...';


GO
ALTER FUNCTION [shpt].[SackLoad#Base]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Appointment$List]...';


GO
ALTER FUNCTION [svc].[Appointment$List]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.SiteID,
            t.ID AS TenantID,
            t.Alias AS TenantAlias,
            x.PostedOn,
            x.Stage,
            x.StateID,
            x.StatedOn,
            x.PickupOn,
            x.EstWeight,
            isnull(Weight, 0) AS Weight,
            x.RefNbrs,
            x.RefInfos
     FROM   shpt.Appointment#Base() AS x
            INNER JOIN
            core.Party#Raw() AS s
            ON s.ID = x.SiteID
            INNER JOIN
            core.Party#Raw() AS t
            ON t.ID = s.PID CROSS APPLY (SELECT isnull(sum(p.Weight), 0) AS Weight
                                         FROM   core.Matter#Type() AS t, core.Matter#ANodeDn(x.ID) AS m
                                                INNER JOIN
                                                shpt.Parcel#Raw() AS p
                                                ON m.ID = p.ID
                                         WHERE  m.Type = t.Parcel) AS c)



GO
PRINT N'Removing schema binding from [hub].[Parcel$CheckForRackIn]...';


GO
ALTER FUNCTION [hub].[Parcel$CheckForRackIn]
(@number VARCHAR (40))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [hub].[Parcel$SortingInfoVia]...';


GO
ALTER FUNCTION [hub].[Parcel$SortingInfoVia]
(@number VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    (SELECT ID,
            p.Stage,
            StateID,
            StatedOn,
            RefNbrs,
            POA AS Port
     FROM   core.RefNbr#ScanOne(@number, DEFAULT, DEFAULT) AS x
            INNER JOIN
            shpt.Parcel#Base() AS p
            ON p.ID = x.MatterID)



GO
PRINT N'Removing schema binding from [ic].[Parcel$ForHandWrittenOrder]...';


GO
ALTER FUNCTION [ic].[Parcel$ForHandWrittenOrder]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.Source,
            Stage,
            StateID,
            StatedOn,
            PostedOn,
            PostedAt,
            RefNbrs,
            RefInfos,
            SiteID AS ShopID,
            SiteAlias AS ShopAlias,
            HandlerID,
            u.Handler
     FROM   core.Source#ID() AS k, shpt.Parcel#Base() AS x CROSS APPLY svc.User$ContactName(x.HandlerID) AS u
     WHERE  x.Source = k.AAE
            AND SvcType = 0)



GO
PRINT N'Removing schema binding from [shpt].[Parcel#LedgerByFactor]...';


GO
ALTER FUNCTION [shpt].[Parcel#LedgerByFactor]
(@parcelIDs [dbo].[I64Array] READONLY, @hubID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Account$ForCreditLimitExceeded]...';


GO
ALTER FUNCTION [svc].[Account$ForCreditLimitExceeded]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Batch$ExportSuccess]...';


GO
ALTER FUNCTION [svc].[Batch$ExportSuccess]
(@batchID BIGINT)
RETURNS TABLE 
AS
RETURN 
    (SELECT n.RefNbrs,
            i.Info AS CneeInfo,
            l.LocalTime AS PostedOn
     FROM   shpt.Parcel#Base() AS x CROSS APPLY core.RefInfo#Type() AS t
            INNER JOIN
            core.RefInfo#Raw() AS i
            ON i.MatterID = x.ID
               AND i.Type = t.CneeInfo CROSS APPLY core.RefNbr#Tvp(x.ID) AS n CROSS APPLY dbo.DT#ToLocal(x.PostedOn, x.SiteUtcOffset) AS l
     WHERE  x.BatchID = @batchID)



GO
PRINT N'Removing schema binding from [svc].[ClientRefNbr$Vefity]...';


GO
ALTER FUNCTION [svc].[ClientRefNbr$Vefity]
(@siteID INT, @numbersInCsv NVARCHAR (MAX))
RETURNS TABLE 
AS
RETURN 
    (SELECT isnull(c.ID, 0) AS ID,
            x.Number AS ClientRefNbr
     FROM   loc.RefNbr#Slice(@numbersInCsv) AS x CROSS APPLY core.RefNbr#Type() AS k CROSS APPLY (SELECT TOP (1) m.ID
                                                                                                  FROM   (SELECT p.ID
                                                                                                          FROM   core.RefNbr#Raw() AS r
                                                                                                                 INNER JOIN
                                                                                                                 shpt.Parcel#Base() AS p
                                                                                                                 ON r.MatterID = p.ID
                                                                                                                    AND p.SiteID = @siteID
                                                                                                          WHERE  r.Number = x.Number
                                                                                                                 AND r.Type = k.ClientRef
                                                                                                          UNION ALL
                                                                                                          SELECT 0) AS m) AS c)



GO
PRINT N'Removing schema binding from [svc].[ClientRefNbr$VefityForPlatform]...';


GO
ALTER FUNCTION [svc].[ClientRefNbr$VefityForPlatform]
(@userID INT, @numbersInCSV NVARCHAR (MAX))
RETURNS TABLE 
AS
RETURN 
    (SELECT isnull(c.ID, 0) AS ID,
            d.Number AS ClientRefNbr
     FROM   tvp.Duad#Slice(@numbersInCSV, DEFAULT, DEFAULT) AS x CROSS APPLY loc.RefNbr#Cast(x.v2) AS d CROSS APPLY core.RefNbr#Type() AS k
            INNER JOIN
            core.Party#Raw() AS n
            ON n.ID = @userID
            LEFT OUTER JOIN
            core.Party#Raw() AS p
            ON p.Source = n.Source
               AND p.Alias = x.v1 CROSS APPLY (SELECT TOP (1) m.ID
                                               FROM   (SELECT b.ID
                                                       FROM   core.RefNbr#Raw() AS r
                                                              INNER JOIN
                                                              shpt.Parcel#Base() AS b
                                                              ON r.MatterID = b.ID
                                                                 AND b.SiteID = p.ID
                                                       WHERE  r.Number = d.Number
                                                              AND r.Type = k.ClientRef
                                                       UNION ALL
                                                       SELECT 0) AS m) AS c)



GO
PRINT N'Removing schema binding from [svc].[Parcel$ClearanceForXpd]...';


GO
ALTER FUNCTION [svc].[Parcel$ClearanceForXpd]
(@idsInCsv NVARCHAR (MAX))
RETURNS TABLE 
AS
RETURN 
    (SELECT p.ID,
            t.MawbNbr,
            f.FlightNbr,
            f.POA,
            f.POD,
            f.ETA,
            f.ETD,
            p.Weight,
            p.RefNbrs,
            p.RefInfos,
            r.BrokerID
     FROM   tvp.I64#Slice(@idsInCsv) AS x
            INNER JOIN
            shpt.SackMft#Base() AS t
            ON x.ID = t.ID
            INNER JOIN
            tms.Flight#Raw() AS f
            ON f.ID = t.PID
            INNER JOIN
            shpt.Sack#Base() AS s
            ON s.PID = x.ID
            INNER JOIN
            shpt.Parcel#Base() AS p
            ON p.PID = s.ID
            INNER JOIN
            tms.Route#Raw() AS r
            ON r.ID = p.RouteID)



GO
PRINT N'Removing schema binding from [svc].[Parcel$ExceptionListFor]...';


GO
ALTER FUNCTION [svc].[Parcel$ExceptionListFor]
(@siteID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.RefInfos,
            RefNbrs,
            Stage,
            StateID,
            StatedOn
     FROM   shpt.Parcel#Base() AS x CROSS APPLY core.Stage#ID() AS s
     WHERE  x.Stage IN (s.PreInterventionNeeded, s.InterventionNeeded, s.PostInterventionNeeded)
            AND x.SiteID = @siteID)



GO
PRINT N'Removing schema binding from [svc].[Parcel$ForArrivedNotice]...';


GO
ALTER FUNCTION [svc].[Parcel$ForArrivedNotice]
(@parcelIDS NVARCHAR (MAX))
RETURNS TABLE 
AS
RETURN 
    (SELECT p.ID,
            SiteAlias,
            p.RefNbrs,
            isnull(f.RefStamps, N'') AS RefStamps
     FROM   shpt.Parcel#Base() AS p
            INNER JOIN
            shpt.Sack#Base() AS s
            ON s.ID = p.PID
            INNER JOIN
            shpt.SackMft#Base() AS m
            ON m.ID = s.PID
            INNER JOIN
            tms.Flight#Base() AS f
            ON f.ID = m.PID
     WHERE  p.ID IN (SELECT ID
                     FROM   tvp.I64#Slice(@parcelIDS)))



GO
PRINT N'Removing schema binding from [svc].[Parcel$ForMeasureNotice]...';


GO
ALTER FUNCTION [svc].[Parcel$ForMeasureNotice]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.PID,
            x.AID,
            x.Source,
            x.Type,
            x.Stage,
            x.StateID,
            x.SvcType,
            RcvHubID,
            t.Alias AS RcvHubAlias,
            t.UtcOffset,
            t.UtcPlace,
            Weight,
            Length,
            Width,
            Height,
            RefNbrs,
            isnull(r.Number, N'') AS ClientRefNbr
     FROM   shpt.Parcel#Base() AS x
            LEFT OUTER JOIN
            core.Matter#Raw() AS m
            ON m.ID = x.AID CROSS APPLY core.RefNbr#Type() AS k
            LEFT OUTER JOIN
            core.RefNbr#Raw() AS r
            ON r.MatterID = m.ID
               AND r.Type = k.ClientRef
            INNER JOIN
            core.Tenant#Raw() AS t
            ON t.ID = x.RcvHubID)



GO
PRINT N'Removing schema binding from [svc].[Parcel$ForOnboardedNotice]...';


GO
ALTER FUNCTION [svc].[Parcel$ForOnboardedNotice]
(@idInCsv NVARCHAR (MAX))
RETURNS TABLE 
AS
RETURN 
    (SELECT p.ID,
            SiteAlias,
            p.RefNbrs,
            m.RefStamps
     FROM   tvp.I64#Slice(@idInCsv) AS x
            INNER JOIN
            shpt.SackMft#Base() AS m
            ON m.ID = x.ID
            LEFT OUTER JOIN
            shpt.Sack#Base() AS s
            ON s.PID = x.ID
            INNER JOIN
            shpt.Parcel#Base() AS p
            ON p.PID = s.ID
               OR p.PID = x.ID)



GO
PRINT N'Removing schema binding from [svc].[Parcel$ForPlatform]...';


GO
ALTER FUNCTION [svc].[Parcel$ForPlatform]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            SiteAlias,
            x.Source,
            RefNbrs,
            Stage,
            PostedOn,
            StatedOn,
            CourierAlias
     FROM   shpt.Parcel#Base() AS x
            INNER JOIN
            tms.Courier#Raw() AS c
            ON c.ID = x.LastMilerID)



GO
PRINT N'Removing schema binding from [svc].[Parcel$ForUploadIDPicture]...';


GO
ALTER FUNCTION [svc].[Parcel$ForUploadIDPicture]
( )
RETURNS TABLE 
AS
RETURN 
    WITH   cteCneeInfo
    AS     (SELECT MatterID,
                   c.v1 AS Name,
                   c.v2 AS Phone
            FROM   core.RefInfo#Type() AS k, core.RefInfo#Raw() AS x CROSS APPLY tvp.Dozen#Of(x.Info, DEFAULT) AS c
            WHERE  x.Type = k.CneeInfo)
    SELECT p.ID,
           Name,
           Phone,
           p.RefInfos
    FROM   cteCneeInfo AS x
           INNER JOIN
           shpt.Parcel#Base() AS p
           ON p.ID = x.MatterID
              AND p.StateID IN (38336, 17250)



GO
PRINT N'Removing schema binding from [svc].[Parcel$ListForRef]...';


GO
ALTER FUNCTION [svc].[Parcel$ListForRef]
(@siteID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT ID,
            RefNbrs,
            RefInfos,
            Stage
     FROM   shpt.Parcel#Base()
     WHERE  SiteID = @siteID)



GO
PRINT N'Removing schema binding from [svc].[Parcel$RefInfoFor]...';


GO
ALTER FUNCTION [svc].[Parcel$RefInfoFor]
(@number VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    (SELECT ID,
            m.Stage,
            SiteAlias,
            RefInfos,
            RefNbrs
     FROM   core.RefNbr#ScanOne(@number, DEFAULT, DEFAULT) AS x
            INNER JOIN
            shpt.Parcel#Base() AS m
            ON m.ID = x.MatterID)



GO
PRINT N'Removing schema binding from [svc].[Parcel$ScanOneForApp]...';


GO
ALTER FUNCTION [svc].[Parcel$ScanOneForApp]
(@number VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    (SELECT p.ID,
            p.Stage
     FROM   core.RefNbr#ScanOne(@number, DEFAULT, DEFAULT) AS x
            INNER JOIN
            shpt.Parcel#Base() AS p
            ON p.ID = x.MatterID)



GO
PRINT N'Removing schema binding from [vmi].[ClientRefNbr$Vefity]...';


GO
ALTER FUNCTION [vmi].[ClientRefNbr$Vefity]
(@siteID INT, @numbersInCsv NVARCHAR (MAX))
RETURNS TABLE 
AS
RETURN 
    (SELECT isnull(c.ID, 0) AS ID,
            x.Number AS ClientRefNbr
     FROM   loc.RefNbr#Slice(@numbersInCsv) AS x CROSS APPLY core.RefNbr#Type() AS k CROSS APPLY (SELECT TOP (1) m.ID
                                                                                                  FROM   (SELECT p.ID
                                                                                                          FROM   core.RefNbr#Raw() AS r
                                                                                                                 INNER JOIN
                                                                                                                 shpt.Parcel#Base() AS p
                                                                                                                 ON r.MatterID = p.ID
                                                                                                                    AND p.SiteID = @siteID
                                                                                                          WHERE  r.Number = x.Number
                                                                                                                 AND r.Type = k.ClientRef
                                                                                                          UNION ALL
                                                                                                          SELECT 0) AS m) AS c)



GO
PRINT N'Removing schema binding from [vmi].[Parcel$Summary]...';


GO
ALTER FUNCTION [vmi].[Parcel$Summary]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            Stage,
            x.Source,
            SvcType,
            RcvHubID,
            h.Alias AS RcvHubAlias,
            t.ID AS TenantID,
            t.Alias AS TenantAlias,
            RefNbrs,
            RefInfos
     FROM   shpt.Parcel#Base() AS x
            INNER JOIN
            core.Party#Raw() AS h
            ON h.ID = x.RcvHubID
            INNER JOIN
            core.Party#Raw() AS p
            ON p.ID = x.SiteID
            INNER JOIN
            core.Party#Raw() AS t
            ON t.ID = p.PID CROSS APPLY core.Source#ID() AS k
     WHERE  x.Source = k.eVMI)



GO
PRINT N'Removing schema binding from [vmi].[Parcel$SummaryVia]...';


GO
ALTER FUNCTION [vmi].[Parcel$SummaryVia]
(@idsInCsv NVARCHAR (MAX))
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            Stage,
            x.Source,
            SvcType,
            RcvHubID,
            h.Alias AS RcvHubAlias,
            t.ID AS TenantID,
            t.Alias AS TenantAlias,
            RefNbrs,
            RefInfos,
            x.PostedOn
     FROM   tvp.I64#Slice(@idsInCsv) AS i
            INNER JOIN
            shpt.Parcel#Base() AS x
            ON x.ID = i.ID
            INNER JOIN
            core.Party#Raw() AS h
            ON h.ID = x.RcvHubID
            INNER JOIN
            core.Party#Raw() AS p
            ON p.ID = x.SiteID
            INNER JOIN
            core.Party#Raw() AS t
            ON t.ID = p.PID CROSS APPLY core.Source#ID() AS k
     WHERE  x.Source = k.eVMI)



GO
PRINT N'Removing schema binding from [hub].[Sack$DetailForPrint]...';


GO
ALTER FUNCTION [hub].[Sack$DetailForPrint]
(@sackID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [shpt].[SackMft#LedgerByCharge]...';


GO
ALTER FUNCTION [shpt].[SackMft#LedgerByCharge]
(@sackMftID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[SackMft$MawbInfo]...';


GO
ALTER FUNCTION [svc].[SackMft$MawbInfo]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT ID,
            MawbNbr,
            POA,
            p.UtcOffset,
            p.UtcPlaceID
     FROM   shpt.SackMft#Base() AS x
            INNER JOIN
            core.Port#Raw() AS p
            ON p.Code = x.POA CROSS APPLY core.Stage#ID() AS k
     WHERE  x.Stage = k.Arrived)



GO
PRINT N'Removing schema binding from [svc].[Flight$List]...';


GO
ALTER FUNCTION [svc].[Flight$List]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [vmi].[AsnNbr$Verify]...';


GO
ALTER FUNCTION [vmi].[AsnNbr$Verify]
(@siteID INT, @asnNbrs NVARCHAR (MAX))
RETURNS TABLE 
AS
RETURN 
    (SELECT IIF (r.MatterID IS NULL, -1, isnull(b.ID, 0)) AS ID,
            x.Piece AS AsnNbr
     FROM   tvp.Many#Slice(@asnNbrs) AS x CROSS APPLY loc.RefNbr#Cast(x.Piece) AS n CROSS APPLY core.RefNbr#Type() AS k CROSS APPLY core.State#ID() AS s
            LEFT OUTER JOIN
            core.RefNbr#Raw() AS r
            ON r.Number = n.Number
               AND r.Type = k.AsnNbr
            LEFT OUTER JOIN
            whse.StockInOrder#Base() AS b
            ON b.ID = r.MatterID
               AND b.StateID = s.AsnNbrGenerated
               AND b.SiteID = @siteID)



GO
PRINT N'Removing schema binding from [vmi].[StockInOrder$Summary]...';


GO
ALTER FUNCTION [vmi].[StockInOrder$Summary]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Matter#MaybeVia]...';


GO
ALTER FUNCTION [core].[Matter#MaybeVia]
(@idsInCsv NVARCHAR (MAX), @roleID INT, @actionID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [shpt].[Parcel#Maybe]...';


GO
ALTER FUNCTION [shpt].[Parcel#Maybe]
(@id BIGINT, @roleID INT, @actionID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [shpt].[Parcel#MaybeVia]...';


GO
ALTER FUNCTION [shpt].[Parcel#MaybeVia]
(@idsInCsv NVARCHAR (MAX), @roleID INT, @actionID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Message$List]...';


GO
ALTER FUNCTION [svc].[Message$List]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [hub].[Challenge$List]...';


GO
ALTER FUNCTION [hub].[Challenge$List]
(@number VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    (SELECT x.MatterID AS ID,
            Messages,
            Challenges
     FROM   core.MIC#IdOf(@number) AS x CROSS APPLY core.Message#Tvp(x.MatterID) CROSS APPLY core.Challenge#Tvp(x.MatterID))



GO
PRINT N'Removing schema binding from [core].[Concern#Tvp]...';


GO
ALTER FUNCTION [core].[Concern#Tvp]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [co].[Tenancy$UserList]...';


GO
ALTER FUNCTION [co].[Tenancy$UserList]
(@tenantID INT)
RETURNS TABLE 
AS
RETURN 
    WITH   cteSubType
    AS     (SELECT t.ID,
                   t.PID,
                   Alias,
                   t.Type,
                   Name,
                   Email
            FROM   svc.Tenancy$Subtype(@tenantID, DEFAULT, DEFAULT) AS t CROSS APPLY core.Contact#Type() AS c
                   LEFT OUTER JOIN
                   core.Contact#Raw() AS o
                   ON o.PartyID = t.ID
                      AND o.Type = c.Billing)
    SELECT x.ID,
           x.Alias,
           Name,
           Email,
           isnull(p.ID, 0) AS SiteID,
           isnull(p.Alias, N'') AS SiteAlias
    FROM   cteSubType AS x CROSS APPLY core.Party#Type() AS k
           LEFT OUTER JOIN
           core.Party#Raw() AS p
           ON p.ID = x.PID
              AND p.Type = k.TenantSite
    WHERE  x.Type = k.Operator
           AND x.ID > 0



GO
PRINT N'Removing schema binding from [svc].[User$List]...';


GO
ALTER FUNCTION [svc].[User$List]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            RoleID,
            Name,
            Email
     FROM   core.User#Raw() AS x
            INNER JOIN
            core.UserRole#Raw() AS u
            ON u.UserID = x.ID CROSS APPLY core.Contact#Type() AS k
            LEFT OUTER JOIN
            core.Contact#Raw() AS c
            ON c.PartyID = x.ID
               AND c.Type = k.Billing)



GO
PRINT N'Removing schema binding from [svc].[User$Summary]...';


GO
ALTER FUNCTION [svc].[User$Summary]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Contact#TvpForRefInfo]...';


GO
ALTER FUNCTION [core].[Contact#TvpForRefInfo]
(@partyID INT, @refInfoType TINYINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Tenancy$SiteInfoList]...';


GO
ALTER FUNCTION [svc].[Tenancy$SiteInfoList]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.Alias,
            x.Source,
            x.PID AS TenantID,
            d.Alias AS TenantAlias,
            UtcPlace,
            UtcOffset,
            s.Tvp AS Shipping,
            r.Tvp AS Returning
     FROM   core.Party#Raw() AS x
            INNER JOIN
            core.Party#Raw() AS d
            ON d.ID = x.PID
            INNER JOIN
            core.Tenant#Raw() AS t
            ON x.ID = t.ID CROSS APPLY core.Contact#Type() AS k OUTER APPLY core.Contact#TvpFor(x.ID, k.Shipping) AS s OUTER APPLY core.Contact#TvpFor(x.ID, k.Returning) AS r CROSS APPLY core.Party#Type() AS p
     WHERE  x.Type = p.TenantSite
            AND x.ID > 0)



GO
PRINT N'Removing schema binding from [core].[Matter#ANodeDn]...';


GO
ALTER FUNCTION [core].[Matter#ANodeDn]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Matter#ANodeUp]...';


GO
ALTER FUNCTION [core].[Matter#ANodeUp]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Matter#NodeDn]...';


GO
ALTER FUNCTION [core].[Matter#NodeDn]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [shpt].[SackMft#HawbCntRateCalc]...';


GO
ALTER FUNCTION [shpt].[SackMft#HawbCntRateCalc]
(@sackMftID BIGINT, @rate REAL, @minimum REAL, @limitCnt INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [api].[MIC$VefityForPlatform]...';


GO
ALTER FUNCTION [api].[MIC$VefityForPlatform]
(@userID INT, @micsInCsv NVARCHAR (MAX))
RETURNS TABLE 
AS
RETURN 
    (SELECT isnull(b.ID, 0) AS ID,
            d.Number AS ClientRefNbr
     FROM   tvp.Duad#Slice(@micsInCsv, DEFAULT, DEFAULT) AS x CROSS APPLY loc.RefNbr#Cast(x.v2) AS d CROSS APPLY core.RefNbr#Type() AS k
            LEFT OUTER JOIN
            core.RefNbr#Raw() AS r
            ON r.Number = d.Number
               AND r.Type = k.MIT
            INNER JOIN
            core.Party#Raw() AS n
            ON n.ID = @userID
            LEFT OUTER JOIN
            core.Party#Raw() AS p
            ON p.Source = n.Source
               AND p.Alias = x.v1 CROSS APPLY core.Stage#ID() AS s
            LEFT OUTER JOIN
            core.Matter#Raw() AS b
            ON r.MatterID = b.ID
               AND b.PosterID = p.ID)



GO
PRINT N'Removing schema binding from [co].[Parcel$SummaryByStage]...';


GO
ALTER FUNCTION [co].[Parcel$SummaryByStage]
(@tenantID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT isnull(sum(CASE WHEN x.Stage BETWEEN 100 AND 9999 THEN 1 ELSE 0 END), 0) AS ParcelAwaiting,
            isnull(sum(CASE WHEN x.Stage BETWEEN 10000 AND 19999 THEN 1 ELSE 0 END), 0) AS ParcelProcessing,
            isnull(sum(CASE WHEN x.Stage BETWEEN 20000 AND 24999 THEN 1 ELSE 0 END), 0) AS ParcelShipped
     FROM   core.Matter#Raw() AS x CROSS APPLY core.Matter#Type() AS t
     WHERE  x.Type = t.Parcel
            AND x.PosterID IN (SELECT ID
                               FROM   core.Party#Raw() AS p CROSS APPLY core.Party#Type() AS k
                               WHERE  p.PID = @tenantID
                                      AND p.Type = k.TenantSite))



GO
PRINT N'Removing schema binding from [hub].[Parcel$CheckForRackOut]...';


GO
ALTER FUNCTION [hub].[Parcel$CheckForRackOut]
(@number VARCHAR (40), @orderID INT, @userID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [rpt].[Dashboard$ParcelSummary]...';


GO
ALTER FUNCTION [rpt].[Dashboard$ParcelSummary]
(@siteID BIGINT, @startDate DATETIME, @endDate DATETIME, @timezoneOffset INT=0)
RETURNS TABLE 
AS
RETURN 
    (SELECT   c.Value AS [Date],
              isnull(count(*), 0) AS Parcel,
              round(sum(isnull(s.Sales, 0)), 2) AS Sales
     FROM     core.Matter#Raw() AS x CROSS APPLY core.Matter#Type() AS mt CROSS APPLY core.RefInfo#Type() AS rt CROSS APPLY tvp.Spr#Const() AS sp CROSS APPLY dbo.Calendar#Of(DATEADD(HOUR, -@timezoneOffset, @startDate)) AS sd CROSS APPLY dbo.Calendar#Of(DATEADD(HOUR, -@timezoneOffset, @endDate)) AS ed
              INNER JOIN
              dbo.Calendar#Raw() AS c
              ON CAST (x.PostedOn AS DATE) = c.Value CROSS APPLY (SELECT isnull(sum(m.DecAmt), 0) AS Sales
                                                                  FROM   core.RefInfo#Of(x.ID, rt.DeclaredInfo) AS i CROSS APPLY tvp.Quad#Slice(i.Info, DEFAULT, sp.Mucho) AS t CROSS APPLY dbo.Money#Of(t.v3) AS m) AS s
     WHERE    c.DOffset BETWEEN sd.DOffset AND ed.DOffset
              AND x.Type = mt.Parcel
              AND x.PosterID = @siteID
     GROUP BY c.Value)



GO
PRINT N'Removing schema binding from [rpt].[Dashboard$StageSummary]...';


GO
ALTER FUNCTION [rpt].[Dashboard$StageSummary]
(@siteID BIGINT)
RETURNS TABLE 
AS
RETURN 
    (SELECT isnull(sum(CASE WHEN x.Stage BETWEEN 100 AND 24999 THEN 1 ELSE 0 END), 0) AS ParcelTotal,
            isnull(sum(CASE WHEN x.Stage BETWEEN 100 AND 9999 THEN 1 ELSE 0 END), 0) AS ParcelAwaiting,
            isnull(sum(CASE WHEN x.Stage BETWEEN 10000 AND 19999 THEN 1 ELSE 0 END), 0) AS ParcelProcessing,
            isnull(sum(CASE WHEN x.Stage BETWEEN 20000 AND 24999 THEN 1 ELSE 0 END), 0) AS ParcelShipped,
            isnull(sum(CASE WHEN x.Stage IN (500, 10500, 20500) THEN 1 ELSE 0 END), 0) AS ExcptionTotal,
            isnull(sum(CASE WHEN x.Stage = 500 THEN 1 ELSE 0 END), 0) AS ExcptionAwaiting,
            isnull(sum(CASE WHEN x.Stage = 10500 THEN 1 ELSE 0 END), 0) AS ExcptionProcessing,
            isnull(sum(CASE WHEN x.Stage = 20500 THEN 1 ELSE 0 END), 0) AS ExcptionShipped
     FROM   core.Matter#Raw() AS x CROSS APPLY core.Matter#Type() AS t
     WHERE  x.Type = t.Parcel
            AND x.PosterID = @siteID)



GO
PRINT N'Removing schema binding from [shpt].[Sack#SeqNbrOf]...';


GO
ALTER FUNCTION [shpt].[Sack#SeqNbrOf]
(@sackID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Parcel$ForBrokerage]...';


GO
ALTER FUNCTION [svc].[Parcel$ForBrokerage]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            m.PID,
            AID,
            m.Source,
            Type,
            LockCnt,
            Stage,
            m.StateID,
            StatedOn,
            PostedOn,
            RcvHubID,
            c.Alias AS RcvHubAlias,
            RouteID,
            RouteCode,
            BrokerID,
            CourierID,
            ClrMethodID,
            POA,
            SvcType,
            SvcZone,
            SvcClass,
            Weight,
            Length,
            Width,
            Height,
            RefNbrs,
            i.RefInfos AS RefInfos,
            e.Tvp AS Endorsement
     FROM   shpt.Parcel#Raw() AS x
            INNER JOIN
            core.Matter#Raw() AS m
            ON m.ID = x.ID
            INNER JOIN
            tms.Route#Raw() AS r
            ON r.ID = x.RouteID
            INNER JOIN
            core.Tenant#Raw() AS c
            ON c.ID = x.RcvHubID CROSS APPLY core.RefInfo#Tvp(x.ID) AS i CROSS APPLY core.RefInfo#Type() AS t CROSS APPLY core.RefNbr#Tvp(x.ID) AS rn CROSS APPLY (SELECT i.v2 AS Info
                                                                                                                                                                   FROM   tvp.Duad#Slice(i.RefInfos, DEFAULT, DEFAULT) AS i
                                                                                                                                                                   WHERE  i.v1 = t.BrokerageInfo) AS ri CROSS APPLY (SELECT concat(k.Many, b.SkuID, k.Triad, mt.v3, k.Triad, e.v2) AS [text()]
                                                                                                                                                                                                                     FROM   tvp.Spr#Const() AS k, tvp.Mucho#Slice(ri.Info) AS m CROSS APPLY tvp.Triad#Of(m.Piece, DEFAULT) AS mt
                                                                                                                                                                                                                            INNER JOIN
                                                                                                                                                                                                                            invt.SkuBrokerage#Raw() AS b
                                                                                                                                                                                                                            ON b.SkuID = CAST (mt.v1 AS INT)
                                                                                                                                                                                                                               AND b.BrokerID = r.BrokerID
                                                                                                                                                                                                                               AND b.ClrMethodID = r.ClrMethodID CROSS APPLY tvp.Pair#Of(b.Endorsement) AS e
                                                                                                                                                                                                                     FOR    XML PATH (N'')) AS z(text) CROSS APPLY tvp.Spr#Purify(z.text, DEFAULT) AS e)



GO
PRINT N'Removing schema binding from [svc].[RefNbr$SearchFor]...';


GO
ALTER FUNCTION [svc].[RefNbr$SearchFor]
(@number VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    WITH   cteMatched
    AS     (SELECT MatterID,
                   Type,
                   Number
            FROM   core.RefNbr#Raw()
            WHERE  Number = @number),
           cteStaged
    AS     (SELECT x.MatterID,
                   x.Type,
                   x.Number,
                   m.Stage
            FROM   cteMatched AS x
                   INNER JOIN
                   core.Matter#Raw() AS m
                   ON m.ID = x.MatterID)
    SELECT MatterID AS ID,
           Number AS RefNbr,
           Type,
           Stage
    FROM   cteStaged



GO
PRINT N'Removing schema binding from [vmi].[Parcel$SummaryByStage]...';


GO
ALTER FUNCTION [vmi].[Parcel$SummaryByStage]
(@siteID BIGINT)
RETURNS TABLE 
AS
RETURN 
    (SELECT isnull(sum(CASE WHEN x.Stage >= 10000
                                 AND x.Stage < 12600 THEN 1 END), 0) AS AwaitingAudit,
            isnull(sum(CASE WHEN x.Stage >= 12600
                                 AND x.Stage < 20000 THEN 1 END), 0) AS AwaitingOutgate,
            isnull(sum(CASE WHEN x.Stage >= 20000
                                 AND x.Stage < 25000 THEN 1 END), 0) AS AwaitingDoorDelivery
     FROM   core.Matter#Raw() AS x CROSS APPLY core.Matter#Type() AS t CROSS APPLY core.Source#ID() AS k
     WHERE  x.Type = t.Parcel
            AND x.PosterID = @siteID
            AND x.Source = k.eVMI)



GO
PRINT N'Removing schema binding from [xpd].[Parcel$Verify]...';


GO
ALTER FUNCTION [xpd].[Parcel$Verify]
(@micsInCsv NVARCHAR (MAX), @siteID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT m.MatterID AS ID,
            x.Number,
            Stage
     FROM   loc.RefNbr#Slice(@micsInCsv) AS x CROSS APPLY core.MIC#IdOf(x.Number) AS m
            INNER JOIN
            core.Matter#Raw() AS r
            ON r.ID = m.MatterID
     WHERE  r.PosterID = @siteID)



GO
PRINT N'Removing schema binding from [xpd].[Sack$Verify]...';


GO
ALTER FUNCTION [xpd].[Sack$Verify]
(@numbersInCsv NVARCHAR (MAX), @siteID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT isnull(m.ID, 0) AS ID,
            x.Number AS SackNbr
     FROM   loc.RefNbr#Slice(@numbersInCsv) AS x
            INNER JOIN
            core.RefNbr#Raw() AS r
            ON r.Number = x.Number
            INNER JOIN
            core.Matter#Raw() AS m
            ON m.ID = r.MatterID
     WHERE  m.PosterID = @siteID)



GO
PRINT N'Removing schema binding from [xpd].[SackMft$Verify]...';


GO
ALTER FUNCTION [xpd].[SackMft$Verify]
(@mawbNbr CHAR (11), @siteID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT   TOP (1) s.ID,
                      MawbNbr
     FROM     shpt.SackMft#Raw() AS s
              INNER JOIN
              core.Matter#Raw() AS m
              ON m.PID = s.ID
     WHERE    s.MawbNbr = @mawbNbr
              AND m.PosterID = @siteID
     ORDER BY s.ID DESC)



GO
PRINT N'Removing schema binding from [svc].[Parcel$ScanOne]...';


GO
ALTER FUNCTION [svc].[Parcel$ScanOne]
(@number VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    (SELECT r.Number
     FROM   core.RefNbr#MatchOne(@number, 1, 25500) AS x CROSS APPLY core.RefNbr#Type() AS t
            INNER JOIN
            core.RefNbr#Raw() AS r
            ON r.MatterID = x.MatterID
               AND r.Type = t.MIT
     WHERE  MatchedCnt = 1)



GO
PRINT N'Removing schema binding from [core].[RefNbr#ScanMulti]...';


GO
ALTER FUNCTION [core].[RefNbr#ScanMulti]
(@numbersInCsv NVARCHAR (MAX), @minStage INT, @maxStage INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [hub].[Parcel$ShippingPlanInfo]...';


GO
ALTER FUNCTION [hub].[Parcel$ShippingPlanInfo]
(@number VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    (SELECT x.MatterID AS ID,
            b.Seq AS Seq,
            b.Piece AS ParcelItem
     FROM   core.RefNbr#ScanOne(@number, DEFAULT, DEFAULT) AS x CROSS APPLY core.RefInfo#Type() AS t CROSS APPLY core.RefInfo#Of(x.MatterID, t.ShippingPlanInfo) AS i CROSS APPLY tvp.Bag#Slice(i.Info) AS b)



GO
PRINT N'Removing schema binding from [hub].[Parcel$ShippingPlanVia]...';


GO
ALTER FUNCTION [hub].[Parcel$ShippingPlanVia]
(@number VARCHAR (40))
RETURNS TABLE 
AS
RETURN 
    (SELECT x.MatterID AS ID,
            x.Number,
            i.Info AS ShippingPlan
     FROM   core.RefNbr#ScanOne(@number, DEFAULT, DEFAULT) AS x CROSS APPLY core.RefInfo#Type() AS t CROSS APPLY core.RefInfo#Of(x.MatterID, t.ShippingPlanInfo) AS i CROSS APPLY core.Matter#Type() AS mt
     WHERE  x.Type = mt.Parcel)



GO
PRINT N'Removing schema binding from [shpt].[Parcel#Tobe]...';


GO
ALTER FUNCTION [shpt].[Parcel#Tobe]
(@id BIGINT, @roleID INT, @actionID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [shpt].[Parcel#TobeVia]...';


GO
ALTER FUNCTION [shpt].[Parcel#TobeVia]
(@idsInCsv NVARCHAR (MAX), @roleID INT, @actionID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Matter#TobeVia]...';


GO
ALTER FUNCTION [core].[Matter#TobeVia]
(@idsInCsv NVARCHAR (MAX), @roleID INT, @actionID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Message#BodyOfLast]...';


GO
ALTER FUNCTION [core].[Message#BodyOfLast]
(@regID INT, @rowID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Message#Tvp]...';


GO
ALTER FUNCTION [core].[Message#Tvp]
(@matterID BIGINT)
RETURNS TABLE 
AS
RETURN 
    WITH   cte (text)
    AS     (SELECT concat(k.Many, x.AuxID, k.Quad, x.PosterAlias, k.Quad, x.PostedOn, k.Quad, x.Body) AS [text()]
            FROM   core.Registry#ID() AS m CROSS APPLY core.Message#Of(m.Matter, @matterID, DEFAULT) AS x CROSS APPLY tvp.Spr#Const() AS k
            FOR    XML PATH (N''))
    SELECT Tvp AS Messages
    FROM   cte CROSS APPLY tvp.Spr#Purify(text, DEFAULT)



GO
PRINT N'Removing schema binding from [core].[MIC#Emit]...';


GO
ALTER FUNCTION [core].[MIC#Emit]
(@matterID BIGINT, @source TINYINT, @type TINYINT, @postedOn DATE)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[MIC#IdOf]...';


GO
ALTER FUNCTION [core].[MIC#IdOf]
(@number VARCHAR (40))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[BizUnit$Lookup]...';


GO
ALTER FUNCTION [svc].[BizUnit$Lookup]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[SalesRep$Lookup]...';


GO
ALTER FUNCTION [svc].[SalesRep$Lookup]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Party#PNodeUp]...';


GO
ALTER FUNCTION [core].[Party#PNodeUp]
(@partyID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Account$Lookup]...';


GO
ALTER FUNCTION [svc].[Account$Lookup]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[CustomerCode$Vefity]...';


GO
ALTER FUNCTION [svc].[CustomerCode$Vefity]
(@userID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT isnull(p.ID, 0) AS ID,
            p.Alias
     FROM   core.Party#Raw() AS x CROSS APPLY core.Party#Type() AS k
            INNER JOIN
            core.Party#Raw() AS p
            ON p.Source = x.Source
               AND p.Type = k.TenantSite
     WHERE  x.ID = @userID)



GO
PRINT N'Removing schema binding from [svc].[Ramper$List]...';


GO
ALTER FUNCTION [svc].[Ramper$List]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.Alias
     FROM   core.Party#Type() AS t, core.User#Raw() AS x
            INNER JOIN
            core.Party#Raw() AS p
            ON x.ID = p.ID
     WHERE  p.Type = t.Ramper)



GO
PRINT N'Removing schema binding from [svc].[Sku$Verify]...';


GO
ALTER FUNCTION [svc].[Sku$Verify]
(@siteID INT, @svcType INT, @skuNbrs NVARCHAR (MAX))
RETURNS TABLE 
AS
RETURN 
    (SELECT isnull(CAST (d.SkuID AS BIGINT), 0) AS ID,
            c.SkuNbr
     FROM   tvp.Many#Slice(@skuNbrs) AS x CROSS APPLY loc.SkuNbr#Cast(x.Piece) AS c
            INNER JOIN
            core.Party#Raw() AS p
            ON p.ID = @siteID
            LEFT OUTER JOIN
            invt.Sku#Raw() AS t
            ON t.TenantID = p.PID
               AND t.SkuNbr = c.SkuNbr CROSS APPLY tms.SvcType#For(@svcType, @siteID) AS s CROSS APPLY tms.SvcRoute#For(s.ID, s.FallbackPOA) AS r
            INNER JOIN
            tms.Route#Raw() AS a
            ON a.ID = r.RouteID OUTER APPLY (SELECT TOP (1) SkuID
                                             FROM   invt.SkuBrokerage#Raw()
                                             WHERE  SkuID = t.ID
                                                    AND ClrMethodID = a.ClrMethodID
                                                    AND BrokerID = a.BrokerID) AS d)



GO
PRINT N'Removing schema binding from [svc].[Sku$VerifyForPlatform]...';


GO
ALTER FUNCTION [svc].[Sku$VerifyForPlatform]
(@userID INT, @skus NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Tenancy$For]...';


GO
ALTER FUNCTION [svc].[Tenancy$For]
(@userID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT concat(p.ID, k.Quad, p.PID, k.Quad, p.AID, k.Quad, x.Alias, k.Duad, r.RoleIDs) AS Tvp
     FROM   tvp.Spr#Const() AS k, core.User#Raw() AS x
            INNER JOIN
            core.Party#Raw() AS p
            ON p.ID = x.ID CROSS APPLY core.RoleID#Tvp(x.ID) AS r
     WHERE  x.ID = @userID)



GO
PRINT N'Removing schema binding from [svc].[Tenancy$SiteVerify]...';


GO
ALTER FUNCTION [svc].[Tenancy$SiteVerify]
(@siteID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT isnull(ID, 0) AS SiteID
     FROM   core.Party#Type() AS k, core.Party#Raw() AS x
     WHERE  x.Type = k.TenantSite
            AND x.ID = @siteID)



GO
PRINT N'Removing schema binding from [svc].[Tenancy$Subtype]...';


GO
ALTER FUNCTION [svc].[Tenancy$Subtype]
(@parentID BIGINT, @typeToMatch INT, @levelToBreak INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Tenancy$TenantLookup]...';


GO
ALTER FUNCTION [svc].[Tenancy$TenantLookup]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Tenancy$ZebraHubLookup]...';


GO
ALTER FUNCTION [svc].[Tenancy$ZebraHubLookup]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Tenancy$ZebraStoreLookup]...';


GO
ALTER FUNCTION [svc].[Tenancy$ZebraStoreLookup]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tms].[SvcCharge#For]...';


GO
ALTER FUNCTION [tms].[SvcCharge#For]
(@siteID INT, @brokerID INT, @poa CHAR (3), @chargeID INT, @vendorID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tms].[SvcType#For]...';


GO
ALTER FUNCTION [tms].[SvcType#For]
(@svcType INT, @siteID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [vmi].[Tenancy$For]...';


GO
ALTER FUNCTION [vmi].[Tenancy$For]
(@userID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT concat(p.ID, k.Quad, p.PID, k.Quad, p.AID, k.Quad, t.Alias, k.Duad, r.RoleIDs) AS Tvp
     FROM   tvp.Spr#Const() AS k, core.User#Raw() AS x
            INNER JOIN
            core.Party#Raw() AS p
            ON p.ID = x.ID
            INNER JOIN
            core.Tenant#Raw() AS t
            ON t.ID = p.AID CROSS APPLY core.RoleID#Tvp(x.ID) AS r
     WHERE  x.ID = @userID)



GO
PRINT N'Removing schema binding from [whse].[StorageRate#For]...';


GO
ALTER FUNCTION [whse].[StorageRate#For]
(@rcvHubID INT, @siteID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Port$List]...';


GO
ALTER FUNCTION [svc].[Port$List]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT Code,
            UtcOffset,
            UtcPlaceID
     FROM   core.Port#Raw())



GO
PRINT N'Removing schema binding from [core].[Source#Rectify]...';


GO
ALTER FUNCTION [core].[Source#Rectify]
(@source TINYINT, @queueType TINYINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefInfo#ToShippingPlan]...';


GO
ALTER FUNCTION [core].[RefInfo#ToShippingPlan]
(@matterID BIGINT, @spec NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefNbr#DecodeMulti]...';


GO
ALTER FUNCTION [core].[RefNbr#DecodeMulti]
(@numbersInCsv NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefNbr#IdOfFirst]...';


GO
ALTER FUNCTION [core].[RefNbr#IdOfFirst]
(@number VARCHAR (40), @type TINYINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefNbr#IdOfLast]...';


GO
ALTER FUNCTION [core].[RefNbr#IdOfLast]
(@number VARCHAR (40), @type TINYINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[MIC$Vefity]...';


GO
ALTER FUNCTION [svc].[MIC$Vefity]
(@micsInCsv NVARCHAR (MAX))
RETURNS TABLE 
AS
RETURN 
    (SELECT isnull(r.MatterID, 0) AS ID,
            x.Number AS MIC
     FROM   loc.RefNbr#Slice(@micsInCsv) AS x CROSS APPLY core.RefNbr#Type() AS k
            LEFT OUTER JOIN
            core.RefNbr#Raw() AS r
            ON r.Number = x.Number
               AND r.Type = k.MIT)



GO
PRINT N'Removing schema binding from [core].[RefParty#Of]...';


GO
ALTER FUNCTION [core].[RefParty#Of]
(@matterID BIGINT, @partyRole TINYINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RoleID#Tvp]...';


GO
ALTER FUNCTION [core].[RoleID#Tvp]
(@userID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [zeb].[Matter$TobeVia]...';


GO
ALTER FUNCTION [zeb].[Matter$TobeVia]
(@idsInCsv NVARCHAR (MAX), @roleID INT, @actionID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Batch$ExportError]...';


GO
ALTER FUNCTION [svc].[Batch$ExportError]
(@batchID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Batch$Summary]...';


GO
ALTER FUNCTION [svc].[Batch$Summary]
(@siteID INT)
RETURNS TABLE 
AS
RETURN 
    WITH   cteSummary
    AS     (SELECT   x.ID,
                     x.BatchedOn,
                     x.ErrorCnt,
                     t.UtcOffset,
                     isnull(count(CASE WHEN p.SvcZone = 0 THEN 1 END), 0) AS FailureCnt,
                     isnull(count(CASE WHEN p.SvcZone > 0 THEN 1 END), 0) AS SuccessCnt
            FROM     shpt.Batch#Raw() AS x
                     INNER JOIN
                     core.Tenant#Raw() AS t
                     ON t.ID = x.SiteID
                     INNER JOIN
                     shpt.Parcel#Raw() AS p
                     ON p.BatchID = x.ID
            WHERE    x.SiteID = @siteID
            GROUP BY x.ID, x.ErrorCnt, x.BatchedOn, t.UtcOffset)
    SELECT ID,
           ErrorCnt,
           FailureCnt,
           SuccessCnt,
           l.LocalTime AS BatchedOn
    FROM   cteSummary CROSS APPLY dbo.DT#ToLocal(BatchedOn, UtcOffset) AS l



GO
PRINT N'Removing schema binding from [svc].[Sku$ForEndorsement]...';


GO
ALTER FUNCTION [svc].[Sku$ForEndorsement]
(@clrMethodID INT, @brokerID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Todo#For]...';


GO
ALTER FUNCTION [core].[Todo#For]
(@userID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Transition#Debug]...';


GO
ALTER FUNCTION [core].[Transition#Debug]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[UserRole#Tvp]...';


GO
ALTER FUNCTION [core].[UserRole#Tvp]
(@userID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [dbo].[Bit#On]...';


GO
ALTER FUNCTION [dbo].[Bit#On]
(@value BIGINT, @size TINYINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [dbo].[Bit#Wise]...';


GO
ALTER FUNCTION [dbo].[Bit#Wise]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [dbo].[DT#Of]...';


GO
ALTER FUNCTION [dbo].[DT#Of]
(@value DATETIME2 (2), @against DATETIME2 (2))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [dbo].[Calendar#Emit]...';


GO
ALTER FUNCTION [dbo].[Calendar#Emit]
(@dayCount INT, @anchorOffset INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [dbo].[Calendar#Today]...';


GO
ALTER FUNCTION [dbo].[Calendar#Today]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [dbo].[Money#Sum]...';


GO
ALTER FUNCTION [dbo].[Money#Sum]
(@amtA BIGINT, @amtB BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [loc].[TotalSkuQty#For]...';


GO
ALTER FUNCTION [loc].[TotalSkuQty#For]
(@declaredInfo NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [dbo].[Money#CNY]...';


GO
ALTER FUNCTION [dbo].[Money#CNY]
(@decAmt FLOAT (53))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tms].[SvcCost#ByFactor]...';


GO
ALTER FUNCTION [tms].[SvcCost#ByFactor]
(@contractID INT, @hubID INT, @toZoneCode3 CHAR (3), @toPlus2 CHAR (2), @svcClass TINYINT, @measuredWt REAL)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [dbo].[DT@Empty]...';


GO
ALTER FUNCTION [dbo].[DT@Empty]
( )
RETURNS DATE
WITH ENCRYPTION
AS
BEGIN
    RETURN NULL;
END


GO
PRINT N'Removing schema binding from [dbo].[Nbr#Mod10]...';


GO
ALTER FUNCTION [dbo].[Nbr#Mod10]
(@numerics VARCHAR (21))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [dbo].[Nbr#Range]...';


GO
ALTER FUNCTION [dbo].[Nbr#Range]
(@start INT, @end INT, @step INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tms].[TrackingNbr#Make]...';


GO
ALTER FUNCTION [tms].[TrackingNbr#Make]
(@svcCode CHAR (3), @mailerID CHAR (9), @mailerSeq INT, @errorSeq BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Pcs#Left]...';


GO
ALTER FUNCTION [tvp].[Pcs#Left]
(@value NVARCHAR (MAX), @separator NVARCHAR (255), @sprIndex INT, @keepTrailingSpr BIT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Pcs#Mid]...';


GO
ALTER FUNCTION [tvp].[Pcs#Mid]
(@value NVARCHAR (MAX), @separator NVARCHAR (255), @pieceIndex INT, @keepSurroundingSpr BIT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Pcs#Right]...';


GO
ALTER FUNCTION [tvp].[Pcs#Right]
(@value NVARCHAR (MAX), @separator NVARCHAR (255), @sprIndex INT, @keepLeadingSpr BIT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [hub].[RackOutOrder$ListFor]...';


GO
ALTER FUNCTION [hub].[RackOutOrder$ListFor]
(@userID INT, @orderID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [hub].[Trucker$List]...';


GO
ALTER FUNCTION [hub].[Trucker$List]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [invt].[SkuInfo#ToDeclared]...';


GO
ALTER FUNCTION [invt].[SkuInfo#ToDeclared]
(@skuInfos NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Sku$VerifyForEndorsement]...';


GO
ALTER FUNCTION [svc].[Sku$VerifyForEndorsement]
(@skuIDs NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [loc].[Contact#Of]...';


GO
ALTER FUNCTION [loc].[Contact#Of]
(@slip NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [loc].[GoodsInfo#Of]...';


GO
ALTER FUNCTION [loc].[GoodsInfo#Of]
(@info NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [loc].[Tenancy#As]...';


GO
ALTER FUNCTION [loc].[Tenancy#As]
(@tenancy NVARCHAR (MAX), @tobeRole INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [loc].[Tenancy#Of]...';


GO
ALTER FUNCTION [loc].[Tenancy#Of]
(@slip NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[CourierAlias$Verify]...';


GO
ALTER FUNCTION [svc].[CourierAlias$Verify]
(@aliasInCsv NVARCHAR (MAX))
RETURNS TABLE 
AS
RETURN 
    (SELECT c.CourierID AS ID,
            x.Piece AS CourierAlias
     FROM   tvp.Comma#Slice(@aliasInCsv) AS x CROSS APPLY tms.Courier#IdOfAlias(x.Piece) AS c)



GO
PRINT N'Removing schema binding from [svc].[MftGroup$Lookup]...';


GO
ALTER FUNCTION [svc].[MftGroup$Lookup]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT   MftGroup
     FROM     tms.Route#Raw() AS r
     WHERE    r.ID > 0
     GROUP BY MftGroup)



GO
PRINT N'Removing schema binding from [tms].[SvcClass#For]...';


GO
ALTER FUNCTION [tms].[SvcClass#For]
(@svcType INT, @weight REAL)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tms].[SvcRoute#For]...';


GO
ALTER FUNCTION [tms].[SvcRoute#For]
(@svcType INT, @poa CHAR (3))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tms].[SvcFacility#For]...';


GO
ALTER FUNCTION [tms].[SvcFacility#For]
(@source TINYINT, @svcClass TINYINT, @zip3 CHAR (3))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tms].[SvcZone#For]...';


GO
ALTER FUNCTION [tms].[SvcZone#For]
(@source TINYINT, @svcClass TINYINT, @onZip3 CHAR (3), @toZip3 CHAR (3))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tms].[SvcFacility#ZoneCode]...';


GO
ALTER FUNCTION [tms].[SvcFacility#ZoneCode]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tms].[TrackingNbr#Slice]...';


GO
ALTER FUNCTION [tms].[TrackingNbr#Slice]
(@slip NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Bag#Slice]...';


GO
ALTER FUNCTION [tvp].[Bag#Slice]
(@source NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Block#At]...';


GO
ALTER FUNCTION [tvp].[Block#At]
(@index INT, @source NVARCHAR (MAX), @blockSpr NVARCHAR (255), @sourceSpr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Block#Fold]...';


GO
ALTER FUNCTION [tvp].[Block#Fold]
(@index INT, @master NVARCHAR (MAX), @house NVARCHAR (MAX), @masterSpr NVARCHAR (255), @houseSpr NVARCHAR (255), @blockSpr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Block#FoldA]...';


GO
ALTER FUNCTION [tvp].[Block#FoldA]
(@index INT, @master [dbo].[I64AutoSeqs] READONLY, @house NVARCHAR (MAX), @houseSpr NVARCHAR (255), @blockSpr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Block#FoldT]...';


GO
ALTER FUNCTION [tvp].[Block#FoldT]
(@index INT, @master [dbo].[I64Seqs] READONLY, @house NVARCHAR (MAX), @houseSpr NVARCHAR (255), @blockSpr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Cell#Slice]...';


GO
ALTER FUNCTION [tvp].[Cell#Slice]
(@source NVARCHAR (MAX), @colSpr NVARCHAR (255), @rowSpr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Dozen#Slice]...';


GO
ALTER FUNCTION [tvp].[Dozen#Slice]
(@source NVARCHAR (MAX), @valueSpr NVARCHAR (255), @sourceSpr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Duad#Slice]...';


GO
ALTER FUNCTION [tvp].[Duad#Slice]
(@source NVARCHAR (MAX), @valueSpr NVARCHAR (255), @sourceSpr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Duo#Of]...';


GO
ALTER FUNCTION [tvp].[Duo#Of]
(@value NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Newline#OfDuad]...';


GO
ALTER FUNCTION [tvp].[Newline#OfDuad]
(@value NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Pair#Of]...';


GO
ALTER FUNCTION [tvp].[Pair#Of]
(@value NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Referring#Of]...';


GO
ALTER FUNCTION [tvp].[Referring#Of]
(@tvp NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Trio#Of]...';


GO
ALTER FUNCTION [tvp].[Trio#Of]
(@value NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Newline#OfQuad]...';


GO
ALTER FUNCTION [tvp].[Newline#OfQuad]
(@value NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Quad#Slice]...';


GO
ALTER FUNCTION [tvp].[Quad#Slice]
(@source NVARCHAR (MAX), @valueSpr NVARCHAR (255), @sourceSpr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Newline#OfTriad]...';


GO
ALTER FUNCTION [tvp].[Newline#OfTriad]
(@value NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Field#Slice]...';


GO
ALTER FUNCTION [tvp].[Field#Slice]
(@source NVARCHAR (MAX), @valueSpr NVARCHAR (255), @sourceSpr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[I32#Join]...';


GO
ALTER FUNCTION [tvp].[I32#Join]
(@array [dbo].[I32Array] READONLY)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[I32#Slice]...';


GO
ALTER FUNCTION [tvp].[I32#Slice]
(@source NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[I64#Join]...';


GO
ALTER FUNCTION [tvp].[I64#Join]
(@array [dbo].[I64Array] READONLY)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[I64#Slice]...';


GO
ALTER FUNCTION [tvp].[I64#Slice]
(@source NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[I64Seqs#Join]...';


GO
ALTER FUNCTION [tvp].[I64Seqs#Join]
(@idSeqs [dbo].[I64Seqs] READONLY)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Many#Slice]...';


GO
ALTER FUNCTION [tvp].[Many#Slice]
(@source NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Mucho#Slice]...';


GO
ALTER FUNCTION [tvp].[Mucho#Slice]
(@source NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Newline#Slice]...';


GO
ALTER FUNCTION [tvp].[Newline#Slice]
(@source NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Pcs#SliceV]...';


GO
ALTER FUNCTION [tvp].[Pcs#SliceV]
(@index INT, @source NVARCHAR (MAX), @blockSpr NVARCHAR (255), @sourceSpr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Quire#Slice]...';


GO
ALTER FUNCTION [tvp].[Quire#Slice]
(@source NVARCHAR (MAX), @valueSpr NVARCHAR (255), @sourceSpr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Tuplet#Slice]...';


GO
ALTER FUNCTION [tvp].[Tuplet#Slice]
(@source NVARCHAR (MAX), @valueSpr NVARCHAR (255), @sourceSpr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Pcs#SliceR]...';


GO
ALTER FUNCTION [tvp].[Pcs#SliceR]
(@source NVARCHAR (MAX), @spr NVARCHAR (255), @upto INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Pcs#SliceT]...';


GO
ALTER FUNCTION [tvp].[Pcs#SliceT]
(@source NVARCHAR (MAX), @spr NVARCHAR (255), @upto INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [acct].[Contract#For]...';


GO
ALTER FUNCTION [acct].[Contract#For]
(@partyID BIGINT, @sourceID TINYINT)
RETURNS TABLE 
AS
RETURN 
    WITH   cteContract
    AS     (SELECT c.ID,
                   BillingCycle,
                   DutyTerms,
                   NonDutyTerms,
                   BizUnitID,
                   EffectiveOn,
                   ExpiredOn,
                   Lead(c.ID) OVER (ORDER BY (SELECT 0)) AS Marker
            FROM   core.Party#Raw() AS x
                   INNER JOIN
                   acct.Contract#Raw() AS c
                   ON c.TenantID = x.PID
            WHERE  x.ID = @partyID
                   AND SourceID = @sourceID
                   AND getutcdate() >= EffectiveOn
            UNION ALL
            SELECT ID,
                   BillingCycle,
                   DutyTerms,
                   NonDutyTerms,
                   BizUnitID,
                   EffectiveOn,
                   ExpiredOn,
                   Lead(x.ID) OVER (ORDER BY (SELECT 0)) AS Marker
            FROM   acct.Contract#Raw() AS x
            WHERE  x.TenantID = @partyID
                   AND SourceID = @sourceID
                   AND getutcdate() >= EffectiveOn
            UNION ALL
            SELECT 0,
                   0,
                   0,
                   0,
                   0,
                   '0001-01-01',
                   '0001-01-01',
                   NULL)
    SELECT TOP (1) ID,
                   BillingCycle,
                   DutyTerms,
                   NonDutyTerms,
                   BizUnitID,
                   EffectiveOn,
                   ExpiredOn
    FROM   cteContract
    WHERE  Marker IS NULL



GO
PRINT N'Removing schema binding from [svc].[CurrencyRate$Summary]...';


GO
ALTER FUNCTION [svc].[CurrencyRate$Summary]
( )
RETURNS TABLE 
AS
RETURN 
    WITH   cteCurrencyRate
    AS     (SELECT FmCurrencyID,
                   ToCurrencyID,
                   EffectiveOn,
                   ForPayment,
                   ForDeclaration,
                   Lead(FmCurrencyID) OVER (PARTITION BY FmCurrencyID, ToCurrencyID ORDER BY (SELECT 0)) AS Marker
            FROM   acct.CurrencyRate#Raw())
    SELECT FmCurrencyID,
           ToCurrencyID,
           EffectiveOn,
           ForPayment,
           ForDeclaration
    FROM   cteCurrencyRate
    WHERE  Marker IS NULL



GO
PRINT N'Removing schema binding from [shpt].[SackMft#Deep]...';


GO
ALTER FUNCTION [shpt].[SackMft#Deep]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Parcel$Detail]...';


GO
ALTER FUNCTION [svc].[Parcel$Detail]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            PID,
            AID,
            x.Source,
            PostedOn,
            Stage,
            StateID,
            StatedOn,
            BatchID,
            BatchedOn,
            RcvHubID,
            RcvHubAlias,
            t.UtcOffset AS RcvHubUtcOffset,
            SiteID,
            SiteAlias,
            RouteID,
            RouteCode,
            CourierID,
            CourierAlias,
            BrokerID,
            BrokerAlias,
            POA,
            SvcType,
            SvcZone,
            SvcClass,
            Weight,
            Length,
            Width,
            Height,
            RefNbrs,
            RefInfos,
            Ledgers,
            Challenges,
            ZoneCode,
            AddOnServices
     FROM   shpt.Parcel#Deep() AS x
            INNER JOIN
            core.Tenant#Raw() AS t
            ON t.ID = x.RcvHubID)



GO
PRINT N'Removing schema binding from [svc].[Parcel$List]...';


GO
ALTER FUNCTION [svc].[Parcel$List]
( )
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            x.Source,
            PostedOn,
            Stage,
            StateID,
            StatedOn,
            BatchID,
            RcvHubID,
            SiteID,
            RouteID,
            RouteCode,
            CourierID,
            BrokerID,
            SvcType,
            SvcZone,
            SvcClass,
            CmdyRootID,
            Weight,
            Length,
            Width,
            Height,
            POA,
            RefNbrs,
            RefInfos,
            Ledgers,
            Challenges,
            LastMilerCode,
            HandlerID,
            u.Handler,
            AddOnServices,
            HasIDNbr,
            HasConcern,
            ZoneCode
     FROM   shpt.Parcel#Deep() AS x CROSS APPLY svc.User$ContactName(x.HandlerID) AS u CROSS APPLY core.Concern#Exists(x.ID) AS e CROSS APPLY shpt.IDNbr#Exists(x.ID) AS i)



GO
PRINT N'Removing schema binding from [acct].[Vault#Raw]...';


GO
ALTER FUNCTION [acct].[Vault#Raw]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [brkg].[BrokerageFee#For]...';


GO
ALTER FUNCTION [brkg].[BrokerageFee#For]
(@routeID INT, @brokerageInfo NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [brkg].[DutyRate#For]...';


GO
ALTER FUNCTION [brkg].[DutyRate#For]
(@partyID INT, @clrMethodID INT, @brokerageInfo NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [invt].[SkuDuty#Tvp]...';


GO
ALTER FUNCTION [invt].[SkuDuty#Tvp]
(@skuID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Commodity$Root]...';


GO
ALTER FUNCTION [svc].[Commodity$Root]
(@cmdyRootID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT c.ID,
            c.PID,
            c.Name AS [Path],
            c.Surcharge,
            c.DutyID,
            c.DutyRate,
            c.DutyCode
     FROM   brkg.Commodity#Raw() AS x
            INNER JOIN
            brkg.Commodity#Deep() AS c
            ON c.PID = x.ID
     WHERE  x.PID = 0
            AND x.ID = @cmdyRootID)



GO
PRINT N'Removing schema binding from [core].[Activity#TrackMany]...';


GO
ALTER FUNCTION [core].[Activity#TrackMany]
(@numbersInCsv NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[Parcel$Track]...';


GO
ALTER FUNCTION [svc].[Parcel$Track]
(@parcelID BIGINT)
RETURNS TABLE 
AS
RETURN 
    WITH   cteTvp (text)
    AS     (SELECT concat(k.Many, ID, k.Tuplet, Stage, k.Tuplet, UserID, k.Tuplet, UserAlias, k.Tuplet, UtcPlace, k.Tuplet, UtcTime, k.Tuplet, UtcOffset) AS [text()]
            FROM   core.Activity#Track(@parcelID), tvp.Spr#Const() AS k
            FOR    XML PATH (N''))
    SELECT Tvp AS Tracks,
           l.CourierCode,
           isnull(c.Number, N'') AS CourierNbr
    FROM   cteTvp CROSS APPLY tvp.Spr#Purify(text, DEFAULT)
           INNER JOIN
           shpt.Parcel#Raw() AS p
           ON p.ID = @parcelID
           INNER JOIN
           tms.Courier#Raw() AS l
           ON l.ID = p.LastMilerID OUTER APPLY (SELECT Number
                                                FROM   core.RefNbr#Raw() AS n CROSS APPLY core.RefNbr#Type() AS t
                                                WHERE  n.MatterID = @parcelID
                                                       AND n.Type = t.PostCourier) AS c



GO
PRINT N'Removing schema binding from [shpt].[Parcel#PreSorting]...';


GO
ALTER FUNCTION [shpt].[Parcel#PreSorting]
(@pracelID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [shpt].[Appointment#Base]...';


GO
ALTER FUNCTION [shpt].[Appointment#Base]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [shpt].[Sack#Base]...';


GO
ALTER FUNCTION [shpt].[Sack#Base]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [shpt].[SackMft#Base]...';


GO
ALTER FUNCTION [shpt].[SackMft#Base]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tms].[Flight#Base]...';


GO
ALTER FUNCTION [tms].[Flight#Base]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [whse].[StockInOrder#Base]...';


GO
ALTER FUNCTION [whse].[StockInOrder#Base]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Matter#Maybe]...';


GO
ALTER FUNCTION [core].[Matter#Maybe]
(@matterID BIGINT, @roleID INT, @actionID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Challenge#Exists]...';


GO
ALTER FUNCTION [core].[Challenge#Exists]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Challenge#Of]...';


GO
ALTER FUNCTION [core].[Challenge#Of]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Concern#Exists]...';


GO
ALTER FUNCTION [core].[Concern#Exists]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [svc].[User$ContactName]...';


GO
ALTER FUNCTION [svc].[User$ContactName]
(@userID INT)
RETURNS TABLE 
AS
RETURN 
    (SELECT x.ID,
            isnull(Name, N'') AS Name,
            concat('(', x.ID, ') ', Name) AS Handler
     FROM   core.User#Raw() AS x CROSS APPLY core.Contact#Type() AS k
            LEFT OUTER JOIN
            core.Contact#Raw() AS c
            ON c.PartyID = x.ID
               AND c.Type = k.Billing
     WHERE  x.ID = @userID)



GO
PRINT N'Removing schema binding from [core].[Contact#TvpFor]...';


GO
ALTER FUNCTION [core].[Contact#TvpFor]
(@partyID INT, @contactType TINYINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Matter#PNodeDn]...';


GO
ALTER FUNCTION [core].[Matter#PNodeDn]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefNbr#MatchMulti]...';


GO
ALTER FUNCTION [core].[RefNbr#MatchMulti]
(@numbersInCsv NVARCHAR (MAX), @minStage INT, @maxStage INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefNbr#ScanOne]...';


GO
ALTER FUNCTION [core].[RefNbr#ScanOne]
(@number VARCHAR (40), @minStage INT, @maxStage INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Matter#Tobe]...';


GO
ALTER FUNCTION [core].[Matter#Tobe]
(@matterID BIGINT, @roleID INT, @actionID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Message#Of]...';


GO
ALTER FUNCTION [core].[Message#Of]
(@regID INT, @rowID BIGINT, @auxID TINYINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Party#PNodeDn]...';


GO
ALTER FUNCTION [core].[Party#PNodeDn]
(@partyID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefInfo#VerifiedOrDeclared]...';


GO
ALTER FUNCTION [core].[RefInfo#VerifiedOrDeclared]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [shpt].[IDNbr#Exists]...';


GO
ALTER FUNCTION [shpt].[IDNbr#Exists]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Transition#Tobe]...';


GO
ALTER FUNCTION [core].[Transition#Tobe]
(@onStateID INT, @roleID INT, @actionID INT, @rejoinID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [dbo].[Calendar#Of]...';


GO
ALTER FUNCTION [dbo].[Calendar#Of]
(@value DATE)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [loc].[LineInfo#Of]...';


GO
ALTER FUNCTION [loc].[LineInfo#Of]
(@info NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [dbo].[Money#USD]...';


GO
ALTER FUNCTION [dbo].[Money#USD]
(@decAmt FLOAT (53))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [dbo].[Nbr#Yield]...';


GO
ALTER FUNCTION [dbo].[Nbr#Yield]
(@count INT, @seed INT, @step INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tms].[CheckDigit#For]...';


GO
ALTER FUNCTION [tms].[CheckDigit#For]
(@pic CHAR (21))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Pcs#Tally]...';


GO
ALTER FUNCTION [tvp].[Pcs#Tally]
(@source NVARCHAR (MAX), @spr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [loc].[CmdyInfo#Of]...';


GO
ALTER FUNCTION [loc].[CmdyInfo#Of]
(@info NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [loc].[RefNbr#Slice]...';


GO
ALTER FUNCTION [loc].[RefNbr#Slice]
(@numbersInCsv NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Comma#Slice]...';


GO
ALTER FUNCTION [tvp].[Comma#Slice]
(@source NVARCHAR (MAX))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Dozen#Of]...';


GO
ALTER FUNCTION [tvp].[Dozen#Of]
(@value NVARCHAR (MAX), @spr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Quad#Of]...';


GO
ALTER FUNCTION [tvp].[Quad#Of]
(@value NVARCHAR (MAX), @spr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Triad#Slice]...';


GO
ALTER FUNCTION [tvp].[Triad#Slice]
(@source NVARCHAR (MAX), @valueSpr NVARCHAR (255), @sourceSpr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Field#Of]...';


GO
ALTER FUNCTION [tvp].[Field#Of]
(@value NVARCHAR (MAX), @spr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Quire#Of]...';


GO
ALTER FUNCTION [tvp].[Quire#Of]
(@value NVARCHAR (MAX), @spr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Tuplet#Of]...';


GO
ALTER FUNCTION [tvp].[Tuplet#Of]
(@value NVARCHAR (MAX), @spr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Pcs#Slice]...';


GO
ALTER FUNCTION [tvp].[Pcs#Slice]
(@source NVARCHAR (MAX), @spr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [shpt].[Parcel#Deep]...';


GO
ALTER FUNCTION [shpt].[Parcel#Deep]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tms].[Route#Deep]...';


GO
ALTER FUNCTION [tms].[Route#Deep]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [brkg].[ClrMethodRate#For]...';


GO
ALTER FUNCTION [brkg].[ClrMethodRate#For]
(@tenantID INT, @clrMethodID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [brkg].[Commodity#Deep]...';


GO
ALTER FUNCTION [brkg].[Commodity#Deep]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Activity#Track]...';


GO
ALTER FUNCTION [core].[Activity#Track]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[AddOnSvc#Exists]...';


GO
ALTER FUNCTION [core].[AddOnSvc#Exists]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [shpt].[Parcel#Base]...';


GO
ALTER FUNCTION [shpt].[Parcel#Base]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Contact#Tvp]...';


GO
ALTER FUNCTION [core].[Contact#Tvp]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Matter#PNodeUp]...';


GO
ALTER FUNCTION [core].[Matter#PNodeUp]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefNbr#MatchOne]...';


GO
ALTER FUNCTION [core].[RefNbr#MatchOne]
(@number VARCHAR (40), @minStage INT, @maxStage INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefInfo#Of]...';


GO
ALTER FUNCTION [core].[RefInfo#Of]
(@matterID BIGINT, @type TINYINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefStamp#Of]...';


GO
ALTER FUNCTION [core].[RefStamp#Of]
(@matterID BIGINT, @stateID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Triad#Of]...';


GO
ALTER FUNCTION [tvp].[Triad#Of]
(@value NVARCHAR (MAX), @spr NVARCHAR (255))
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [acct].[Ledger#Tvp]...';


GO
ALTER FUNCTION [acct].[Ledger#Tvp]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [brkg].[ClrMethod#Raw]...';


GO
ALTER FUNCTION [brkg].[ClrMethod#Raw]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Matter#Deep]...';


GO
ALTER FUNCTION [core].[Matter#Deep]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Challenge#Tvp]...';


GO
ALTER FUNCTION [core].[Challenge#Tvp]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefParty#Tvp]...';


GO
ALTER FUNCTION [core].[RefParty#Tvp]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefInfo#Tvp]...';


GO
ALTER FUNCTION [core].[RefInfo#Tvp]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefNbr#Tvp]...';


GO
ALTER FUNCTION [core].[RefNbr#Tvp]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefStamp#Tvp]...';


GO
ALTER FUNCTION [core].[RefStamp#Tvp]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[Transition#Todo]...';


GO
ALTER FUNCTION [core].[Transition#Todo]
(@onStateID INT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [dbo].[Money#Make]...';


GO
ALTER FUNCTION [dbo].[Money#Make]
(@decAmt FLOAT (53), @currency TINYINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [acct].[Ledger#Raw]...';


GO
ALTER FUNCTION [acct].[Ledger#Raw]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[AddOnSvc#Tvp]...';


GO
ALTER FUNCTION [core].[AddOnSvc#Tvp]
(@matterID BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefParty#Deep]...';


GO
ALTER FUNCTION [core].[RefParty#Deep]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [core].[RefStamp#Deep]...';


GO
ALTER FUNCTION [core].[RefStamp#Deep]
( )
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [dbo].[Currency#Encode]...';


GO
ALTER FUNCTION [dbo].[Currency#Encode]
(@amt BIGINT, @currencyID TINYINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [dbo].[Money#Of]...';


GO
ALTER FUNCTION [dbo].[Money#Of]
(@amt BIGINT)
RETURNS TABLE 
WITH ENCRYPTION
AS
RETURN 
    SELECT NULL AS [NullColumn]



GO
PRINT N'Removing schema binding from [tvp].[Pcs#TallyT]...';


GO
ALTER FUNCTION [tvp].[Pcs#TallyT]
(@source NVARCHAR (MAX), @spr NVARCHAR (255), @upto INT)
RETURNS 
    @GeneratedTableName TABLE (
        [Seq]   INT NOT NULL,
        [Start] INT NOT NULL,
        [Stop]  INT NOT NULL,
        PRIMARY KEY CLUSTERED ([Seq] ASC, [Start] ASC, [Stop] ASC))
WITH ENCRYPTION
AS
BEGIN
    RETURN;
END


GO
PRINT N'Creating [core].[CK_State]...';


GO
ALTER TABLE [core].[_State] WITH NOCHECK
    ADD CONSTRAINT [CK_State] CHECK (ID<10 or ID between 10000 and 999999);


GO
PRINT N'Creating [tms].[CK_SvcType]...';


GO
ALTER TABLE [tms].[_SvcType] WITH NOCHECK
    ADD CONSTRAINT [CK_SvcType] CHECK (ID between 0 and 99999999);


GO
PRINT N'Creating [tms].[CK_SvcType_WeightMethod]...';


GO
ALTER TABLE [tms].[_SvcType] WITH NOCHECK
    ADD CONSTRAINT [CK_SvcType_WeightMethod] CHECK (WeightMethod between 1 and 3);


GO
PRINT N'Altering [dbo].[Bit@IsSingle]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Bit@IsSingle](@value bigint)
RETURNS bit
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return iif(@value > 0 and (@value & (@value - 1)) = 0, 1, 0);
END
GO
PRINT N'Altering [dbo].[Currency@Check]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Currency@Check](@amt bigint, @currencyID tinyint)
RETURNS bit
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return iif(@amt=0 or abs(@amt)%100=@currencyID, 1, 0)
END
GO
PRINT N'Creating [acct].[CK_Invoice_DueBalance]...';


GO
ALTER TABLE [acct].[_Invoice] WITH NOCHECK
    ADD CONSTRAINT [CK_Invoice_DueBalance] CHECK (dbo.Currency@Check(DueBalance, CurrencyID)=1);


GO
PRINT N'Creating [acct].[CK_Invoice_InvoiceAmt]...';


GO
ALTER TABLE [acct].[_Invoice] WITH NOCHECK
    ADD CONSTRAINT [CK_Invoice_InvoiceAmt] CHECK (dbo.Currency@Check(InvoiceAmt, CurrencyID)=1);


GO
PRINT N'Creating [acct].[CK_Ledger_ChargeAmt]...';


GO
ALTER TABLE [acct].[_Ledger] WITH NOCHECK
    ADD CONSTRAINT [CK_Ledger_ChargeAmt] CHECK (dbo.Currency@Check(ChargeAmt, CurrencyID)=1);


GO
PRINT N'Creating [acct].[CK_Payment_PaidAmt]...';


GO
ALTER TABLE [acct].[_Payment] WITH NOCHECK
    ADD CONSTRAINT [CK_Payment_PaidAmt] CHECK (dbo.Currency@Check(PaidAmt, CurrencyID)=1);


GO
PRINT N'Creating [acct].[CK_Vault_Uninvoiced]...';


GO
ALTER TABLE [acct].[_Vault] WITH NOCHECK
    ADD CONSTRAINT [CK_Vault_Uninvoiced] CHECK (dbo.Currency@Check(UninvoicedAmt, CurrencyID)=1);


GO
PRINT N'Creating [acct].[CK_Vault_VaultBal]...';


GO
ALTER TABLE [acct].[_Vault] WITH NOCHECK
    ADD CONSTRAINT [CK_Vault_VaultBal] CHECK (dbo.Currency@Check(VaultBal,      CurrencyID)=1);


GO
PRINT N'Altering [dbo].[Currency@Equal]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Currency@Equal](@amtA bigint, @amtB bigint)
RETURNS bit
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return iif(@amtA=0 or @amtB=0, 1, iif(abs(@amtA)%100=abs(@amtB)%100, 1, 0))
END
GO
PRINT N'Creating [acct].[CK_VaultXact_XactAmt]...';


GO
ALTER TABLE [acct].[_VaultXact] WITH NOCHECK
    ADD CONSTRAINT [CK_VaultXact_XactAmt] CHECK (dbo.Currency@Equal(PrevBal, XactAmt)=1);


GO
PRINT N'Altering [tvp].[Bag@Count]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Bag@Count](@src nvarchar(max))
RETURNS bigint
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return	iif(@src is null, 0
	,		((datalength(@src) - datalength(replace(@src, N'	{	', N''))) / 6) + 1);
END
GO
PRINT N'Altering [tvp].[Comma@Count]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Comma@Count](@src nvarchar(max))
RETURNS bigint
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return iif(@src is null, 0
	,		((datalength(@src) - datalength(replace(@src, N',', N''))) / 2) + 1);
END
GO
PRINT N'Altering [tvp].[Entry@Count]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Entry@Count](@src nvarchar(max))
RETURNS bigint
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return	iif(@src is null, 0
	,		((datalength(@src) - datalength(replace(@src, N'	;	', N''))) / 6) + 1);
END
GO
PRINT N'Altering [tvp].[Many@Count]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Many@Count](@src nvarchar(max))
RETURNS bigint
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return	iif(@src is null, 0
	,		((datalength(@src) - datalength(replace(@src, N'	,	', N''))) / 6) + 1);
END
GO
PRINT N'Altering [tvp].[Mucho@Count]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Mucho@Count](@src nvarchar(max))
RETURNS bigint
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return	iif(@src is null, 0
	,		((datalength(@src) - datalength(replace(@src, N'	[	', N''))) / 6) + 1);
END
GO
PRINT N'Altering [tvp].[Pcs@Count]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Pcs@Count](@src nvarchar(max), @spr nvarchar(255)=N'	;	')
RETURNS bigint
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return	iif(@src is null, 0, iif(datalength(@spr) > 0
	,		((datalength(@src) - datalength(replace(@src, @spr, N'')))  / datalength(@spr)) + 1, 1));
END
GO
PRINT N'Altering [tvp].[Spr@Count]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Spr@Count](@src nvarchar(max), @spr nvarchar(255)=N'	;	')
RETURNS bigint
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return	iif(@src is null, 0, iif(datalength(@spr)>0
	,		(datalength(@src) - datalength(replace(@src, @spr, N'')))  / datalength(@spr),	0));
END
GO
PRINT N'Altering [acct].[Charge#Raw]...';


GO
-- PeterHo
ALTER FUNCTION [acct].[Charge#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Code, APCoa, ARCoa, VaultTag, VaultType
	from	[acct].[_Charge]
)
GO
PRINT N'Altering [acct].[Contract#Raw]...';


GO
-- Smile
ALTER FUNCTION [acct].[Contract#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, TenantID, SourceID,  BizUnitID,    SalesDeptID=BizUnitID--ToBeDropped
	,		BillingCycle, DutyTerms, NonDutyTerms, EffectiveOn, ExpiredOn   
	from	[acct].[_Contract]
)
GO
PRINT N'Altering [acct].[Currency#Raw]...';


GO
-- PeterHo: For Integrity Only.
ALTER FUNCTION [acct].[Currency#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Code
	from	[acct].[_Currency]
)
GO
PRINT N'Altering [acct].[CurrencyRate#Raw]...';


GO
-- PeterHo: For Integrity Only.
ALTER FUNCTION [acct].[CurrencyRate#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	FmCurrencyID, ToCurrencyID, EffectiveOn, ForPayment, ForDeclaration
	from	[acct].[_CurrencyRate]
)
GO
PRINT N'Adding schema binding to [svc].[CurrencyRate$Summary]...';


GO
--Smile
ALTER FUNCTION [svc].[CurrencyRate$Summary]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with	cteCurrencyRate as
	(
		select	FmCurrencyID, ToCurrencyID, EffectiveOn, ForPayment, ForDeclaration
		,		Marker=Lead(FmCurrencyID) over (partition by FmCurrencyID, ToCurrencyID order by (select 0))
		from	acct.CurrencyRate#Raw()
	)
	select	FmCurrencyID, ToCurrencyID, EffectiveOn, ForPayment, ForDeclaration
	from	cteCurrencyRate
	where	Marker is null
)
GO
PRINT N'Altering [acct].[Ledger#Side]...';


GO
-- PeterHo
ALTER FUNCTION [acct].[Ledger#Side] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1 as [AP]
	,		2 as [AR]
	,		3 as [XP] -- Void AP
	,		4 as [XR] -- Void AR
)
GO
PRINT N'Altering [acct].[Payment#Raw]...';


GO
-- PeterHo
ALTER FUNCTION [acct].[Payment#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, XID, LedgerSide, CurrencyID, PartyID, PayMethod, PaidAmt, PaidOn
	,		PaymentNbr=isnull(cast(ID as varchar(15)), 0)
	from	[acct].[_Payment]
)
GO
PRINT N'Adding schema binding to [co].[Payment$Verify]...';


GO
-- Ken
ALTER FUNCTION [co].[Payment$Verify](@paymentID bigint)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	select	XID 
	from	acct.Payment#Raw()
	where	ID=@paymentID
)
GO
PRINT N'Altering [acct].[Terms#Raw]...';


GO
-- Smile
ALTER FUNCTION [acct].[Terms#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	PartyID, VaultTag, NetDays
	from	[acct].[_Terms] 
)
GO
PRINT N'Altering [acct].[Vault#Tag]...';


GO
-- PeterHo
ALTER FUNCTION [acct].[Vault#Tag] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [Duty]
	,		2	as [NotDuty]
)
GO
PRINT N'Altering [acct].[Vault#Type]...';


GO
-- PeterHo
ALTER FUNCTION [acct].[Vault#Type] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [Fund]
	,		2	as [Cash]
	,		3	as [Bonus]
	,		4	as [Reward]
	,		5	as [Credit]
	,		6	as [CreditMemo]
	---------------------------
	,		11	as [Freight]
	,		12	as [Commission]
	,		13	as [Operation]
	,		14	as [Tax]
	,		15	as [Duty]
	---------------------------
)
GO
PRINT N'Altering [api].[ActivitySubscription#Raw]...';


GO
-- AaronLiu
ALTER FUNCTION [api].[ActivitySubscription#Raw]()
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, RefNbr
	from	api._ActivitySubscription
)
GO
PRINT N'Altering [brkg].[@-----------------#brkg]...';


GO
-- PeterHo
ALTER FUNCTION [brkg].[@-----------------#brkg]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN (select null as [Nil])
GO
PRINT N'Altering [brkg].[Broker#Raw]...';


GO
--PeterHo
ALTER FUNCTION [brkg].[Broker#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, FlatRate, PercentRate, ApiToken, ApiUrl, BrokerAlias=Alias
	from	brkg._Broker
)
GO
PRINT N'Adding schema binding to [brkg].[BrokerRate#For]...';


GO
--Smile
ALTER FUNCTION [brkg].[BrokerRate#For](@brokerID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with	brokerRate as
	(
		select	top(1)	FlatRate, PercentRate
		from	brkg.Broker#Raw()
		where	ID=@brokerID
		union	all
		select	0, 0
	)
	select	top(1)	FlatRate, PercentRate
	from	brokerRate
)
GO
PRINT N'Adding schema binding to [svc].[Broker$Lookup]...';


GO
--Smile
ALTER FUNCTION [svc].[Broker$Lookup]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, BrokerAlias
	from	brkg.Broker#Raw()
	where	ID>0
)
GO
PRINT N'Altering [brkg].[ClrMethodRate#Raw]...';


GO
--PeterHo
ALTER FUNCTION [brkg].[ClrMethodRate#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	TenantID, ClrMethodID, FlatRate, PercentRate
	from	brkg._ClrMethodRate
)
GO
PRINT N'Altering [brkg].[Commodity#Raw]...';


GO
--PeterHo
ALTER FUNCTION [brkg].[Commodity#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, PID, DutyID, Name, Surcharge
	from	brkg._Commodity
)
GO
PRINT N'Altering [brkg].[Duty#Raw]...';


GO
--PeterHo
ALTER FUNCTION [brkg].[Duty#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, CountryCode, DutyCode, DutyRate, CustomsValue, CommodityUoM
	from	brkg._Duty
)
GO
PRINT N'Altering [core].[Action#ID]...';


GO
--PeterHo
ALTER FUNCTION [core].[Action#ID]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	11100	as HubCheckIn
	,		11200	as HubMeasure
	,		11202	as HubMeasureMPS    
	,		11203	as HubMeasureCPS    
	,		11204	as HubMeasureOrphan  
	,		11210	as HubRemeasure
	,		11220	as ImportAsn
	,		11230	as CfmAsnHubVerified
	,		11240	as CfmAsnRacked
	,		11245	as VoidAsn
	,		11310	as QueueRakedIn
	,		11320	as Cart
	,		11330	as Rack
	,		11340	as QueueRackOut
	,		11355	as RackingMissing
	,		11410	as Unify
	,		17106	as TranslateForBrokerage
	,		17099	as CompleteParcelInfo
--	,		11500	as HubVerify
	,		11505	as HubVerifyWithTappingRed
	,		11510	as HubVerifyWithTappingGreen
	,		11560	as ComplyWithShippingPlan
	,		11860	as CloseSack
	,		11865	as VoidSack
	,		11866	as AddParcelToSack
	,		11867	as RemoveParcelFromSack
	,		11868	as AddToSackMft
	,		11872	as AddToSackLoad
	,		11873	as RemoveFromSackLoad
	,		11900	as ImportHubManifest
	,		11950	as CfmTransload
	,		11951	as ImportOutgateManifest
	,		11952	as EndOfDay
	--------------------------------------------
	,		16005	as Adopt 
	--------------------------------------------
	,		17000	as InitParcel
	,		17005	as VoidParcel
	,		17015	as FlagForReturn
	,		17098	as ConfirmIDInfo
	,		17500	as FallbackShipping
	,		17102	as UpdateIDNumber
	,		17103	as RequestIDPicture
	,		17104	as UpdateIDPicture
	,		17105   as DetermineCmdy
	,		17100	as UpdateParcelInfo
	,		17155	as ReportOverThreshold
	,		17180	as RouteToUSPS
	,		17200	as ConfirmRoute
	,		17203	as ReportSvcRateNotFound
	,		17204	as ReportCreditLimitExceeded
	,		17206	as CfmPayment
	,		17207	as ImportSvcRate
	,		17210	as SourceConfirm
	,		17212	as ShipperRelease
	,		17211	as SourceConcur
	,		17220	as ReceiveBrkgAcceptance
	,		17221	as RequeueBrkgApi
	,		17225	as ReceiveBrkgRejection
	,		17270	as VoidPickup
	,		17275	as CallOffDriver
	,		17276	as DriverStartOff
	,		17277	as CancelStartOff
	,		17284	as Dispatch
	,		17299	as CfmPickedup
	,		17300	as ICManifest
	,		17605	as Bounce
	--------------------------------------------
	,		17170	as PromoteToShippingPlan
	,		17176	as ComposeShippingPlan
	--------------------------------------------
	,		18845	as CfmFlightDepartureDelayed	
	,		18855	as CfmFlightArrivalDelayed	 
	,		18865	as CfmCustomsHeld
	,		18870	as CfmCustomsCleared
	,		18895	as CfmCustomsSeized
	,		18897	as CfmSurrenderByImport
	,		18899	as CfmSurrendered

	--------------------------------------------
	,		58540	as WMSProvideOutgoingWeight
)
GO
PRINT N'Altering [core].[Action#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[Action#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, ActionName=Name, LoopEntryID
	from	core._Action
)
GO
PRINT N'Altering [core].[Activity#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[Activity#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, MatterID, StateID, ActionID, UserID, TalliedOn
	from	core._Activity
)
GO
PRINT N'Altering [core].[AddOnSvc#Raw]...';


GO
--Eason
ALTER FUNCTION [core].[AddOnSvc#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[ID], [MatterID], [Type], [OperatorID], [StartedOn], [EndedOn]
	from	[core].[_AddOnSvc]
)
GO
PRINT N'Altering [core].[AddOnSvc#Type]...';


GO
--Eason
ALTER FUNCTION [core].[AddOnSvc#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
		select
		10  as TakePhoto,           -- 内件拍照
		11  as Inventory,           -- 内件数量核对
		51  as [Return],            -- 退货
		101 as ChangeLabel,         -- 换单
		102 as ReinforcePackaging,  -- 内件加固
		103 as Consolidation,       -- 合并包裹
		104 as RemoveInvoice,       -- 取出单证
		105 as AdditionalPackaging, -- 加运输包装操作费（PAK袋）
		106	as OverLabel,
		200 as CustomizedService
)
GO
PRINT N'Altering [core].[Attachment#Raw]...';


GO
--HeBaiDong
ALTER	FUNCTION [core].[Attachment#Raw]()
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, RegID, RowID, AuxID, PostedOn, PosterID, FileBankID
	from	core._Attachment
)
GO
PRINT N'Altering [core].[Attachment#Type]...';


GO
--Smile
ALTER FUNCTION [core].[Attachment#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	31	as Mawb
	----------------------------
	,		101	as SalesContract
	,		102	as SvcRate
	----------------------------
	,		255	as Other
)
GO
PRINT N'Altering [core].[Challenge#Borderline]...';


GO
--PeterHo, Smile
ALTER FUNCTION [core].[Challenge#Borderline](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	MinStage=cast(min(BoundStage) as int)
		from	core._Challenge where MatterID=@matterID
	)
	select	Borderline=isnull(MinStage, 30000) from cte
)
GO
PRINT N'Altering [core].[Challenge#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[Challenge#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, Type, BoundStage
	from	core._Challenge
)
GO
PRINT N'Altering [core].[Challenge#Type]...';


GO
--PeterHo
ALTER FUNCTION [core].[Challenge#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as VaultBalance
	----------------------------
	,		101	as Instruction
	,		102	as Audition
	----------------------------
	,		201	as TobeHeld
	,		202	as TobeReturned
	,		203	as TobeDisposed
)
GO
PRINT N'Altering [core].[Concern#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[Concern#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, Type
	from	core._Concern
)
GO
PRINT N'Altering [core].[Concern#Type]...';


GO
--Smile, PeterHo
ALTER FUNCTION [core].[Concern#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as NameAbnormal
	,		2	as PhoneAbnormal
	,		3	as BalanceInsufficient
	,		4	as AddressIncomplete
	,		5	as ValueTransfinite
	,		11	as PreCouierDuplicate
	,		15	as PreCheckIncomplete
)
GO
PRINT N'Altering [core].[Contact#Raw]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Contact#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID,      PartyID,  Type,       IsDefault
	,		Name,    Phone,    Email,      Company
	,		Street1, Street2,  Street3,    District
	,		City,    Province, PostalCode, CountryCode
	from	core._Contact
)
GO
PRINT N'Adding schema binding to [core].[Contact#Tvp]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Contact#Tvp] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID,      PartyID, Type, IsDefault,   Name,    CountryCode, [Tvp]=concat
	(		Name,    k.Dozen, Phone,    k.Dozen, Email,       k.Dozen, Company,    k.Dozen
	,		Street1, k.Dozen, Street2,  k.Dozen, Street3,     k.Dozen, District,   k.Dozen
	,		City,    k.Dozen, Province, k.Dozen, PostalCode,  k.Dozen, CountryCode
	)from	core.Contact#Raw() cross apply tvp.Spr#Const() k
)
GO
PRINT N'Altering [svc].[Contact$List]...';


GO
--AaronLiu
ALTER FUNCTION [svc].[Contact$List]()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ID, PartyID, Type, IsDefault, Tvp
	from	core.Contact#Tvp()
)
GO
PRINT N'Altering [core].[Contact#Type]...';


GO
--PeterHo, Aaron
ALTER FUNCTION [core].[Contact#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as Billing
	,		2	as Shipping
	,		3	as Cnee
	,		4	as Returning
)
GO
PRINT N'Altering [zeb].[Contact$Type]...';


GO
-- Eva
ALTER FUNCTION [zeb].[Contact$Type] ()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Billing
	,		Shipping
	,		Returning
	from	core.Contact#Type()
)
GO
PRINT N'Altering [core].[LoopStack#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[LoopStack#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, MatterID, ReturnID
	,		Marker=lead(ID) over (partition by MatterID order by ID)
	from	core._LoopStack
)
GO
PRINT N'Altering [core].[Matter#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[Matter#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID,    PID,     AID,      Source,   Type,     LockCnt
	,		Stage, StateID, StatedOn, PosterID, PostedOn, HandlerID
	,		RejoinID -- ToBeDropped --
	from	core._Matter
)
GO
PRINT N'Refreshing [shpt].[Siblings#Cnt]...';


GO
EXECUTE sp_refreshsqlmodule N'[shpt].[Siblings#Cnt]';


GO
PRINT N'Altering [zeb].[Matter$Raw]...';


GO
-- Eva
ALTER FUNCTION [zeb].[Matter$Raw]()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	m.*
	from	core.Matter#Raw() m
)
GO
PRINT N'Altering [core].[Matter#Type]...';


GO
--PeterHo
ALTER FUNCTION [core].[Matter#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [Parcel]
	------------------------------------
	,		2	as [Zack]
	,		3	as [Sack]
	,		4	as [ZackMft]
	,		5	as [SackMft]
	,		6	as [ZackLoad]
	,		7	as [SackLoad]
	,		8	as [Flight]
	,		9	as [Vessel]
	------------------------------------
	,		11	as [ShippingPlan]
	,		12	as [MasterParcel] -- MPS
	,		13	as [HouseParcel]  -- MPS
	,		14	as [UnityParcel]  -- CPS
	,		15	as [MediumParcel] -- CPS
	,		16	as [OrphanParcel]
	,		17	as [PIP]
	,		18	as [Appointment]
	------------------------------------
	,		21	as [StockInOrder]
	,		22	as [StorageFee]
	,		25	as [AssortedFees]
	------------------------------------
	--  AppType start from 51 ~ 99    --
	------------------------------------
)
GO
PRINT N'Altering [zeb].[Matter$Type]...';


GO
-- Eva
ALTER FUNCTION [zeb].[Matter$Type] ()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Parcel
	,		Sack
	,		SackMft
	,		Zack
	,		ZackMft
	,		ShippingPlan
	from	core.Matter#Type()
)
GO
PRINT N'Altering [core].[Message#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[Message#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	RegID, RowID, AuxID, PostedOn, PosterID, Body
	from	core._Message
)
GO
PRINT N'Altering [core].[Party#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[Party#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, PID, AID, Type, Source, Alias
	from	core._Party
)
GO
PRINT N'Adding schema binding to [svc].[Account$Lookup]...';


GO
-- Smile, PeterHo
ALTER FUNCTION [svc].[Account$Lookup]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	AID from core.Party#Raw()
		where	AID>1 group by AID
	)
	select	ID, Source, Type, Alias
	from	cte x join core.Party#Raw() p on p.ID=x.AID
	where	p.AID>1    -- eliminate Zebra's Hubs
	and		p.Source>0 -- eliminate Virtuals (Port, ...)
	
/*
	select	ID=p.AID, y.Alias
	from	core.Party#Raw()  p
	join	core.Party#Raw()  y on y.ID=p.AID
	cross	apply core.Party#Boundary() b
	where	p.AID>0 and p.Type between 	b.UserMin and b.Tenant
*/
)
GO
PRINT N'Adding schema binding to [svc].[Tenancy$Subtype]...';


GO
-- Smile
ALTER FUNCTION [svc].[Tenancy$Subtype]
(
	@parentID bigint, @typeToMatch int=0, @levelToBreak int=0
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteParty as
	(
		select	Level=0, x.ID, x.PID, x.Type, x.Alias, x.Source
		from	core.Party#Raw() x
		where	x.ID=@parentID
		UNION	ALL
		select	Level+1, c.ID, c.PID, c.Type, c.Alias, c.Source
		from	cteParty p join core.Party#Raw() c on c.PID=p.ID
		where	(@typeToMatch =0 or c.Type=@typeToMatch)
		and		(@levelToBreak=0 or Level<=@levelToBreak)
	)
	select	ID    =isnull(ID, 0),    Alias=isnull(Alias, ''), PID=isnull(PID, 0)
	,		Type  =isnull(Type, 0),  Level=isnull(Level, 0)
	,		Source=isnull(Source, 0)
	from	cteParty where ID<>@parentID
)
GO
PRINT N'Altering [core].[Party#Role]...';


GO
--PeterHo
ALTER FUNCTION [core].[Party#Role]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	8	as [PreCourier]
	,		9	as [PostCourier]
	------------------------------
	,		20	as [Client]
	,		21	as [ClientAgent]
	,		22	as [ClientSite]
	------------------------------
	,		10	as [InfoCenter]
	,		11	as [ReceivingHub]
	,		12	as [TransitingHub]
	,		13	as [CollectingHub]
	,		19	as [BackOffice]
	------------------------------

	,		101	as [Ramper]
	--,		91	as [ExportBroker]
	--,		92	as [ImportBroker]
	--,		93	as [ExportCustoms]
	--,		94	as [ImportCustoms]
	-- App roles use 100+ --------
)
GO
PRINT N'Altering [core].[Party#Type]...';


GO
--PeterHo
ALTER FUNCTION [core].[Party#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [Staff]
	,		2	as [Member]
	,		3	as [Operator]
	,		4	as [Associate]
	,		5	as [Ramper]
	,		9	as [SalesRep]
	---------------------------
	,		10	as [ZebraRegion]
	,		11	as [ZebraHub]
	,		12	as [ZebraStore]
	,		15	as [ZebraIC]
	,		17	as [ZebraDiv]
	,		19	as [ZebraDept]
	---------------------------
	,		21	as [AgentStore]
	,		22	as [TenantSite]
	,		80	as [Port]
	,		99	as [Platform]
	---------------------------
	,		100	as [Customer]
	,		101	as [Tenant]
	---------------------------
	,		200	as [Vendor]
	,		201	as [Broker]
	,		202	as [Trucker]
	,		203	as [Courier]
	,		204	as [Customs]
)
GO
PRINT N'Altering [zeb].[Party$Type]...';


GO
-- Eva
ALTER FUNCTION [zeb].[Party$Type] ()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Staff
	,		Member
	,		Operator
	,		Facility=ZebraDiv
	,		AgentStore
	,		Associate
	,		Broker
	,		Courier
	,		Customer
	,		Customs
	,		Port
	,		Tenant
	,		TenantSite
	,		Trucker
	,		ZebraStore
	from	core.Party#Type()
)
GO
PRINT N'Altering [core].[Port#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[Port#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Code, Type, Country, UtcOffset, UtcPlaceID
	from	core._Port
)
GO
PRINT N'Adding schema binding to [svc].[Port$List]...';


GO
--Smile
ALTER	FUNCTION [svc].[Port$List]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	Code, UtcOffset, UtcPlaceID
	from	core.Port#Raw()
)
GO
PRINT N'Altering [core].[Port#Type]...';


GO
--PeterHo
ALTER FUNCTION [core].[Port#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [Airport]
	,		2	as [Seaport]
	,		4	as [Landport]
)
GO
PRINT N'Altering [core].[Queue#OutboundQ]...';


GO
--PeterHo
ALTER FUNCTION [core].[Queue#OutboundQ]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ToSource, QueueType, QueuedOn, MatterID, StateID
	from	core._OutboundQ
)
GO
PRINT N'Altering [core].[Queue#OutboundX]...';


GO
--PeterHo
ALTER FUNCTION [core].[Queue#OutboundX]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	QueuedOn, ToSource, QueueType, MatterID, StateID
	from	core._OutboundX
)
GO
PRINT N'Altering [core].[Queue#Type]...';


GO
--PeterHo
ALTER FUNCTION [core].[Queue#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as StateChanged
	,		2	as Challenge
	,		3	as Reminder
	,		11	as SubscribeCallback
	,		12	as PolyCallback
	,		13	as ReadyForRelease

	--[App]----------------------
	,		101	as MeasureReady
	,		102 as ShippingPlanReady
	,		103 as ShippingPlanComplied

	--[Api: for InfoPath only]---
	,		201	as BrokerApi
	,		202	as PreCourierApi
	,		203	as PostCourierApi
	,		205 as IDInfoRequired 
	,		206 as IDInfoReview
	,		211	as MftBrokerAPI
	,		213	as MftPostCourierAPI
)
GO
PRINT N'Altering [zeb].[Queue$Type]...';


GO
-- Eva
ALTER FUNCTION [zeb].[Queue$Type]()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	StateChanged
	,		MeasureReady
	,		ShippingPlanReady
	,		ShippingPlanComplied
	,		BrokerApi
	,		Challenge
	,		PostCourierApi
	,		PreCourierApi
	,		Reminder
	from	core.Queue#Type()
)
GO
PRINT N'Altering [core].[RefInfo#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefInfo#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, Type, Info
	from	core._RefInfo
)
GO
PRINT N'Altering [core].[RefInfo#Type]...';


GO
--PeterHo, Smile
ALTER FUNCTION [core].[RefInfo#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [ShprInfo]
	,		2	as [CneeInfo]
	,		3	as [DeclaredInfo]
	,		4	as [VerifiedInfo]
	,		5	as [IDInfo]
	------------------------------
--	,		6	as []
	,		7	as [BrokerageInfo]
	,		8	as [ShippingLabelInfo]
	,		9	as [ShippingPlanInfo]
	,		10	as [ConcurredInfo]
	------------------------------
	,		11	as [ReturnInfo]
	,		12	as [RemarkInfo]
	,		13	as [PickupInfo]
	,		14	as [AuxiliaryOrderInfo]
	,		15  as [VoidInfo]
	,		20	as [AddOnSvcInfo]
	,		25	as [HandWrittenOrderImgInfo]
	,		30	as [SnapshotInfo]
)
GO
PRINT N'Altering [zeb].[RefInfo$Type]...';


GO
--Eva
ALTER FUNCTION [zeb].[RefInfo$Type]()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ShprInfo
	,		CneeInfo
	,		ReturnInfo
	,		IDInfo
	,		DeclaredInfo
	,		VerifiedInfo
	,		BrokerageInfo
	,		ShippingLabelInfo
	,		ShippingPlanInfo
	,		ConcurredInfo
	from	core.RefInfo#Type()
)
GO
PRINT N'Altering [core].[RefNbr#Decode]...';


GO
--Aaron
ALTER FUNCTION [core].[RefNbr#Decode](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteDecoded as
	(
		select	Number=right(@number, 22)
		where	len(@number)=30 and left(@number, 3)='420'  -- USPS & FedEx SmartPost
		union	all
		select	Number=right(@number, 12)
		where	len(@number)=34 and left(@number, 1)='9'    -- FedEx Ground
	)
	select	top(1) Number from cteDecoded
)
GO
PRINT N'Altering [core].[RefNbr#DecodeOne]...';


GO
--Aaron
ALTER FUNCTION [core].[RefNbr#DecodeOne](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteDecoded as
	(
		select	Number=right(@number, 22)
		where	len(@number)=30 and left(@number, 3)='420'  -- FedEx SmartPost / USPS
		union	all
		select	Number=right(@number, 12)
		where	len(@number)=34 and left(@number, 1)='9'    -- FedEx Ground
	)
	select	top(1) Number
	from	cteDecoded
)
GO
PRINT N'Altering [core].[RefNbr#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefNbr#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, Type, Number
	from	core._RefNbr
)
GO
PRINT N'Altering [zeb].[RefNbr$Of]...';


GO
--Eva
ALTER FUNCTION [zeb].[RefNbr$Of](@matterID I64, @type E8)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Number
	from	core.RefNbr#Raw()
	where	MatterID=@matterID and Type=@type
)
GO
PRINT N'Altering [core].[RefNbr#Type]...';


GO
--PeterHo, James
ALTER FUNCTION [core].[RefNbr#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [MIT] -- DO NOT CHANGE!!
--	,		2	as [ZEB]
	,		8	as [PreCourier]
	,		9	as [PostCourier]
	----------------------------
	,		10	as [BookingNbr]
	,		11	as [VenderRef]
	,		18	as [PostCourierPrevious]
	,		19	as [PostCourierOriginal]
	,		21	as [MawbNbr]
	,		31	as [MblNbr]
	----------------------------
	,		101	as [ClientRef]
	,		114	as [RackLabel]

	----------------------------
	,		201	as [AsnNbr]
)
GO
PRINT N'Altering [zeb].[RefNbr$Type]...';


GO
-- Eva
ALTER FUNCTION [zeb].[RefNbr$Type] ()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	MIT
	,		ClientRef
	,		PreCourier
	,		PostCourier
	,		MawbNbr
	,		MblNbr
	,		VenderRef
	from	core.RefNbr#Type()
)
GO
PRINT N'Altering [core].[RefParty#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefParty#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, PartyRole, PartyID
	from	core._RefParty
)
GO
PRINT N'Altering [core].[RefStamp#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefStamp#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, StateID, UtcTime, UtcOffset, UtcPlaceID
	from	core._RefStamp
)
GO
PRINT N'Altering [core].[Role#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[Role#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Name--, PID
	from	core._Role
)
GO
PRINT N'Altering [core].[Setting#Raw]...';


GO
--Eason
ALTER FUNCTION [core].[Setting#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Name, Value, Description
	from	core._Setting
)
GO
PRINT N'Refreshing [svc].[Setting$ByName]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Setting$ByName]';


GO
PRINT N'Altering [core].[Source#ID]...';


GO
--PeterHo
ALTER FUNCTION [core].[Source#ID]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [InfoPath]
	,		2	as [ZEB]
	,		3	as [eShip]
	,		4	as [eForward]
	,		5	as [eVMI_Legacy]
	,		6	as [ZPD]
	,		7	as [XPD]
	,		8	as [USD]
	,		9	as [AAE]
	,		11	as [eVMI]
)
GO
PRINT N'Altering [core].[Stage#Of]...';


GO
--PeterHo
ALTER FUNCTION [core].[Stage#Of](@stateID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Stage from core._State where ID=@stateID
)
GO
PRINT N'Altering [core].[State#ID]...';


GO
--PeterHo
ALTER FUNCTION [core].[State#ID]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	10101	as HubAccepted -- Marker
	---------------------------------------- 
	,		11210	as AsnNbrGenerated
	,		11310	as TobeRackedIn
	,		11320	as Carted
	,		11330	as RackingRackedIn
	,		11340	as TobeRackedOut
	---------------------------------------- 
	,		16100	as OrphanCreated 
	,		17061	as ParcelRetired
	,		17150	as CreditLimitExceeded
	,		17271	as PickupRequested
	,		17281	as ThirdPtyPickupRequested
	,		18710	as FlightBooked
--	,		18781	as SackClosed
	,		18771	as SackCreated
	,		18773	as SackManifested
	,		18779	as SackTransloaded
	,		18791	as SackLoadCreated
	,		18800	as SackMftCreated
	,		18830	as SackMftTransloaded
	,		18840	as SackMftOnboarded
	,		18850	as SackMftDeparted
	,		18860	as SackMftArrived
	,		18870	as SackMftCustomsCleared
	,		18899	as SackMftSurrendered
	----------------------------------------
	,		38070	as InfoPictureReceived
	--,		38700	as Outgated
	,		38010	as CustomsSeized
	,		38661	as CfmOutGated
	,		38855	as CustomsHeld
	,		38870	as CustomsCleared
	,		58500	as HubManifested
	,		58540	as AwaitingMeasurement
)
GO
PRINT N'Altering [core].[State#IdOfVoid]...';


GO
--PeterHo
ALTER FUNCTION [core].[State#IdOfVoid](@onStateID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	VoidID=(@onStateID/1000)*1000
)
GO
PRINT N'Altering [core].[State#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[State#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Stage, Name, IsInternal
	from	core._State
)
GO
PRINT N'Altering [core].[Supplement#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[Supplement#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	RegID, RowID, Supplement
	from	core._Supplement
)
GO
PRINT N'Adding schema binding to [svc].[Batch$ExportError]...';


GO
--Smile, PeterHo
ALTER FUNCTION [svc].[Batch$ExportError](@batchID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) [Errors]=s.Supplement
	from	core.Registry#ID() r, core.Supplement#Raw() s
	where	s.RegID=r.ParcelBatch and s.RowID=@batchID
)
GO
PRINT N'Altering [core].[Tenant#IdOf]...';


GO
--PeterHo
ALTER FUNCTION [core].[Tenant#IdOf](@source tinyint, @alias nvarchar(40))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID
	from	core._Tenant
	where	Source=@source and Alias=@alias
)
GO
PRINT N'Altering [core].[Tenant#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[Tenant#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Source, Alias, UtcPlace, UtcOffset, SalesRepID, NoLogo
	from	core._Tenant
)
GO
PRINT N'Altering [core].[Todo#Raw]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Todo#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID, RoleID, ActionID, ToSource, DueOn
	from	core._Todo
)
GO
PRINT N'Altering [core].[Transition#Raw]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Transition#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, OnStateID, RoleID, ActionID, ToStateID, TodoHours, OutboundQ
	from	core._Transition
)
GO
PRINT N'Altering [core].[User#Raw]...';


GO
--PeterHo
ALTER FUNCTION [core].[User#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Alias
	from	core._User
)
GO
PRINT N'Altering [core].[User#Role]...';


GO
--PeterHo
ALTER FUNCTION [core].[User#Role]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	100 as [ClientAdmin]
	,		101	as [ClientOP]
	,		102 as [ClientMgr]
	----------------------------
	,		110 as [HubAdmin]
	,		111 as [HubOP]
	,		112 as [HubMgr]
	,		115 as [HubDriver]
	----------------------------
	,		120 as [ICAdmin]
	,		121	as [ICOP]
	,		122	as [ICMgr]
	----------------------------
	,		130 as [BOAdmin]
	,		131	as [BOOP]
	,		132	as [BOMgr]
	----------------------------
	,		140	as [StoreAdmin]
	,		141 as [StoreOP]
	,		142	as [StoreMgr]
	----------------------------
	,		150	as [AcctAdmin]
	,		151 as [AcctOP]
	,		152	as [AcctMgr]
)
GO
PRINT N'Altering [zeb].[User$Role]...';


GO
-- Eva
ALTER FUNCTION [zeb].[User$Role] ()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	AcctAdmin
	,		AcctMgr
	,		AcctOP
	,		BOAdmin
	,		BOMgr
	,		BOOP
	,		ClientAdmin
	,		ClientMgr
	,		ClientOP
	,		HubAdmin
	,		HubDriver
	,		HubMgr
	,		HubOP
	,		ICAdmin
	,		ICMgr
	,		ICOP
	,		StoreAdmin
	,		StoreMgr
	,		StoreOP
	from	core.User#Role() r
)
GO
PRINT N'Altering [core].[UserRole#Raw]...';


GO
--Smile
ALTER FUNCTION [core].[UserRole#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	UserID, RoleID
	from	core._UserRole
)
GO
PRINT N'Altering [dbo].[Bool#Const]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Bool#Const] ()
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select [true]=isnull(cast(1 as bit), 0), [false]=isnull(cast(0 as bit), 0)
)
GO
PRINT N'Altering [dbo].[Calendar#Raw]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Calendar#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Value
	,		Year,    Quarter, Month,   Week,    Day,Dow
	,		YOffset, QOffset, MOffset, WOffset, DOffset
	from	dbo._Calendar
)
GO
PRINT N'Altering [dbo].[Currency#Decode]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Currency#Decode](@amt bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[CurrencyID]=isnull(cast(abs(@amt)%100 as tinyint), 0)
)
GO
PRINT N'Adding schema binding to [dbo].[Money#Of]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Money#Of](@amt bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	c.CurrencyID
	,		[RawAmt]=isnull((@amt/100)*100, 0)
	,		[DecAmt]=isnull(cast((@amt/100) as float)/100.0, 0.0)
	from	[dbo].Currency#Decode(@amt) c
)
GO
PRINT N'Adding schema binding to [dbo].[Currency#Encode]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Currency#Encode](@amt bigint, @currencyID tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[Amt]=isnull(isnull(nullif(sign(@amt), 0), 1) * (m.RawAmt + (@currencyID % 100)), 0)
	from	[dbo].Money#Of(abs(@amt)) m
)
GO
PRINT N'Adding schema binding to [dbo].[Money#Sum]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Money#Sum](@amtA bigint, @amtB bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	c.Amt
	from	[dbo].Money#Of(@amtA) a
	cross	apply [dbo].Money#Of(@amtB) b
	cross	apply [dbo].Currency#Encode(a.RawAmt+b.RawAmt, a.CurrencyID) c
)
GO
PRINT N'Adding schema binding to [dbo].[Money#Make]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Money#Make](@decAmt float, @currency tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with	cteRaw as
	(
	--	select RawAmt=cast(round(@decAmt, 2)*100 as bigint)*100
		select RawAmt=cast(cast(@decAmt as numeric(27,9))*100 as bigint)*100
	)
	select	Amt, RawAmt from cteRaw
	cross	apply [dbo].Currency#Encode(RawAmt, @currency)
)
GO
PRINT N'Altering [dbo].[Currency#ID]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Currency#ID]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	USD=1
	,		CNY=2
	,		EUR=3
	,		GBP=4
	,		JPY=5
	--------------
	,		TWD=11
	,		HKD=12
)
GO
PRINT N'Altering [dbo].[DT#Const]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[DT#Const] ()
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[Now]     = isnull(cast(getutcdate() as datetime2(2)), '')
	,		[Today]   = isnull(cast(getutcdate() as date), '')
	,		[Empty]   = isnull(cast('0001-01-01' as date), '')
	,		[Anchor]  = isnull(cast('2001-01-01' as date), '')
	,		[Infinity]= isnull(cast('9999-12-31' as date), '')
	,		[NilTick] = -2147483648
)
GO
PRINT N'Adding schema binding to [dbo].[DT@Anchor]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[DT@Anchor] ()
RETURNS date
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return (select Anchor from dbo.DT#Const());
END
GO
PRINT N'Adding schema binding to [dbo].[DT@Empty]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[DT@Empty] ()
RETURNS date
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return (select Empty from dbo.DT#Const());
END
GO
PRINT N'Adding schema binding to [dbo].[DT@Infinity]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[DT@Infinity] ()
RETURNS date
WITH SCHEMABINDING, ENCRYPTION
AS
BEGIN
	return (select Infinity from dbo.DT#Const());
END
GO
PRINT N'Creating [core].[DF_AddOnSvc_EndedOn]...';


GO
ALTER TABLE [core].[_AddOnSvc]
    ADD CONSTRAINT [DF_AddOnSvc_EndedOn] DEFAULT (dbo.DT@Empty()) FOR [EndedOn];


GO
PRINT N'Creating [core].[DF_AddOnSvc_StartedOn]...';


GO
ALTER TABLE [core].[_AddOnSvc]
    ADD CONSTRAINT [DF_AddOnSvc_StartedOn] DEFAULT (dbo.DT@Empty()) FOR [StartedOn];


GO
PRINT N'Creating [tms].[DF_Flight_ETA]...';


GO
ALTER TABLE [tms].[_Flight]
    ADD CONSTRAINT [DF_Flight_ETA] DEFAULT (dbo.DT@Empty()) FOR [ETA];


GO
PRINT N'Creating [tms].[DF_Flight_ETD]...';


GO
ALTER TABLE [tms].[_Flight]
    ADD CONSTRAINT [DF_Flight_ETD] DEFAULT (dbo.DT@Empty()) FOR [ETD];


GO
PRINT N'Creating [whse].[PK_RackOrder_CompletedOn]...';


GO
ALTER TABLE [whse].[_RackOrder]
    ADD CONSTRAINT [PK_RackOrder_CompletedOn] DEFAULT (dbo.DT@Empty()) FOR [CompletedOn];


GO
PRINT N'Altering [dbo].[DT#ToLocal]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[DT#ToLocal](@utcTime datetime2(2), @utcOffset smallint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	LocalTime=isnull(dateadd(hour, @utcOffset, @utcTime), '0001')
)
GO
PRINT N'Altering [dbo].[Nbr#Emit]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Nbr#Emit] (@count int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with E1 (N) as
	(
		select	0 UNION ALL select 0 UNION ALL select 0 UNION ALL select 0
				  UNION ALL select 0 UNION ALL select 0 UNION ALL select 0
				  UNION ALL select 0 UNION ALL select 0 UNION ALL select 0
	)
	, E2 (N) as (select 0 from E1 a, E1 b) -- 10E+2
	, E4 (N) as (select 0 from E2 a, E2 b) -- 10E+4
	, E6 (N) as (select 0 from E4 a, E2 b) -- 10E+6
	, E8 (N) as (select 0 from E6 a, E2 b) -- 10E+8
	, EX (N) as (select 0 from E8 a, E2 b) -- 10E+10
	select	top(isnull(@count, 0))
			[Nbr]=isnull(row_number() over (order by (select 0)), 0) from EX
)
GO
PRINT N'Adding schema binding to [dbo].[Nbr#Mod10]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Nbr#Mod10] (@numerics varchar(21))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteValue as
	(
		select	x.Nbr, Value=cast(substring(@numerics, x.Nbr, 1) as tinyint)
		from	dbo.Nbr#Emit(len(@numerics)) x
	)
	, cteSumToModTen as
	(
		select	ModTen=(sum(case when Nbr%2<>0 then Value end)  * 3
					   +sum(case when Nbr%2=0  then Value end)) % 10
		from	cteValue
	)
	, cteCheckDigit as
	(
		select	CheckDigit=char(iif(ModTen=0, 0, 10 - ModTen) + 48)
		from	cteSumToModTen
	)
	select	EncodedNbr=@numerics + CheckDigit, CheckDigit
	from	cteCheckDigit
)
GO
PRINT N'Adding schema binding to [dbo].[Nbr#Yield]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Nbr#Yield] (@count int, @seed int, @step int=1)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[Nbr]=isnull(@seed + ((Nbr-1) * @step), 0)
	from	dbo.Nbr#Emit(@count)
)
GO
PRINT N'Adding schema binding to [tms].[CheckDigit#For]...';


GO
-- PeterHo
ALTER FUNCTION [tms].[CheckDigit#For](@pic char(21))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteValue as
	(
		select	x.Nbr, Value=cast(substring(@pic, x.Nbr, 1) as tinyint)
		from	dbo.Nbr#Emit(len(@pic)) x
	)
	, cteSumToModTen as
	(
		select	ModTen=(sum(case when Nbr%2<>0 then Value end)  * 3
					   +sum(case when Nbr%2=0  then Value end)) % 10
		from	cteValue
	)
	select	CheckDigit=char(iif(ModTen=0, 0, 10 - ModTen) + 48)
	from	cteSumToModTen
)
GO
PRINT N'Adding schema binding to [tvp].[Pcs#Tally]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Pcs#Tally](@source nvarchar(max), @spr nvarchar(255)=N'	;	')
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteTally (Start) as
	(
		select	1 UNION ALL select Nbr+(datalength(@spr)/2)
		from	dbo.Nbr#Emit(datalength(@source)/2)
		where	datalength(@spr)>0 and substring(@source, Nbr, datalength(@spr)/2)=@spr
	)
	, cteBoundary (Start, Stop) as
	(
		select	Start, isnull(nullif(charindex(@spr, @source, Start), 0), (datalength(@source)/2)+1)
		from	cteTally
	)
	select	[Seq]=row_number() over (order by (select 0)), Start, Stop
	from	cteBoundary where datalength(@source)>0
)
GO
PRINT N'Adding schema binding to [dbo].[Nbr#Range]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Nbr#Range](@start int, @end int, @step int=1)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select Nbr from dbo.Nbr#Yield
	(
		(abs(@end - @start) + 1) / abs(@step), @start, iif(@end >= @start, abs(@step), -abs(@step))
	)
)
GO
PRINT N'Adding schema binding to [tms].[TrackingNbr#Make]...';


GO
-- PeterHo
ALTER FUNCTION [tms].[TrackingNbr#Make]
(
	@svcCode char(3), @mailerID char(9), @mailerSeq int, @errorSeq bigint
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePic as
	(
		select	Pic=iif(@mailerSeq=0
		,		format(@errorSeq, '0000000000000000000000')
		,		concat('92', @svcCode, @mailerID, cast(format(@mailerSeq, '0000000') as char(7))))
	)
	select	TrackingNbr=isnull(cast(x.Pic+c.CheckDigit as char(22)), '')
	from	ctePic x cross apply tms.CheckDigit#For(x.Pic) c
)
GO
PRINT N'Adding schema binding to [tvp].[Pcs#Left]...';


GO
 --PeterHo: 4/1
ALTER FUNCTION [tvp].[Pcs#Left]
(
	@value           nvarchar(max)
,   @separator       nvarchar(255)
,   @sprIndex        int
,   @keepTrailingSpr bit
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select  [Piece]=isnull(substring(@value, 0,
			iif(@keepTrailingSpr=1, Stop+(datalength(@separator)/2), Stop)), N'')
	from    tvp.Pcs#Tally(@value, @separator)
	order	by (select null)
	offset	iif(@sprIndex>0, @sprIndex-1, 0) rows
	fetch	next 1 rows only
)
GO
PRINT N'Adding schema binding to [tvp].[Pcs#Mid]...';


GO
 --PeterHo: 4/1
ALTER FUNCTION [tvp].[Pcs#Mid]
(
	@value              nvarchar(max)
,   @separator          nvarchar(255)
,   @pieceIndex         int
,   @keepSurroundingSpr bit
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[Piece]=isnull(substring(@value
			,		iif(@keepSurroundingSpr=1,    Start-(datalength(@separator)/2),      Start)
			,		iif(@keepSurroundingSpr=1, (Stop-Start)+datalength(@separator), Stop-Start)), N'')
	from	tvp.Pcs#Tally(@value, @separator)
	order	by (select null)
	offset	iif(@pieceIndex>0, @pieceIndex-1, 0) rows
	fetch	next 1 rows only
)
GO
PRINT N'Adding schema binding to [tvp].[Pcs#Right]...';


GO
 --PeterHo: 4/1
ALTER FUNCTION [tvp].[Pcs#Right]
(
	@value          nvarchar(max)
,   @separator      nvarchar(255)
,   @sprIndex       int
,   @keepLeadingSpr bit
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[Piece]=isnull(substring(@value,
		    iif(@keepLeadingSpr=1, Stop, Stop+(datalength(@separator)/2)), datalength(@value)), N'')
	from	tvp.Pcs#Tally(@value, @separator)
	order	by (select null)
	offset	iif(@sprIndex>0, @sprIndex-1, 0) rows
	fetch	next 1 rows only
)
GO
PRINT N'Altering [invt].[Sku#Raw]...';


GO
--PeterHo
ALTER FUNCTION [invt].[Sku#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, TenantID, SkuNbr, FiledInfo
	from	invt._Sku
)
GO
PRINT N'Altering [invt].[SkuBrokerage#Raw]...';


GO
--PeterHo
ALTER FUNCTION [invt].[SkuBrokerage#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	SkuID, ClrMethodID, BrokerID, DutyID, Endorsement
	from	invt._SkuBrokerage
)
GO
PRINT N'Altering [loc].[Country#Raw]...';


GO
--PeterHo
ALTER FUNCTION [loc].[Country#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Code, Code3, CodeN
	from	[loc]._Country
)
GO
PRINT N'Altering [loc].[RefNbr#Cast]...';


GO
--PeterHo
ALTER FUNCTION [loc].[RefNbr#Cast](@number nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Number=cast(@number as varchar(40))
)
GO
PRINT N'Altering [loc].[SkuNbr#Cast]...';


GO
--PeterHo
ALTER FUNCTION [loc].[SkuNbr#Cast](@skuNbr nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	SkuNbr=cast(@skuNbr as varchar(40))
)
GO
PRINT N'Altering [loc].[TenantAlias#Encode]...';


GO
--Smile.Wang
ALTER FUNCTION [loc].[TenantAlias#Encode](@alias varchar(40) )
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	TenantAlias=concat(@alias, ' (Admin)')
)
GO
PRINT N'Altering [loc].[TenantAlias#Rectify]...';


GO
--Smile
ALTER FUNCTION [loc].[TenantAlias#Rectify](@alias varchar(40))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	TenantAlias=replace(@alias, ' (Admin)', '')
)
GO
PRINT N'Altering [shpt].[Appointment#Raw]...';


GO
-- AaronLiu
ALTER FUNCTION [shpt].[Appointment#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, PickupOn, EstWeight
	from	shpt._Appointment
)
GO
PRINT N'Altering [shpt].[Batch#Raw]...';


GO
--PeterHo
ALTER FUNCTION [shpt].[Batch#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, SiteID, BatchedOn, ErrorCnt
	from	shpt._Batch
)
GO
PRINT N'Altering [shpt].[Parcel#Raw]...';


GO
--PeterHo
ALTER FUNCTION [shpt].[Parcel#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, BatchID, RcvHubID, RouteID, LastMilerID
	,		ContractID,  SvcType,  SvcZone, SvcClass, POA
	,		Length,   Width,   Height, DeclaredWt, ZoneCode
	,		Weight=iif(nullif(Weight, 0) is null, DeclaredWt, Weight)
	from	shpt._Parcel
)
GO
PRINT N'Altering [shpt].[RackXact#Raw]...';


GO
--Smile
ALTER FUNCTION [shpt].[RackXact#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ParcelID, RackID, OrderInID, OrderOutID
	from	shpt._RackXact
)
GO
PRINT N'Altering [shpt].[Sack#Raw]...';


GO
--PeterHo
ALTER FUNCTION [shpt].[Sack#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, POA, SackWt, BrokerID, ClrMethodID
	from	shpt._Sack
)
GO
PRINT N'Altering [shpt].[SackLoad#Raw]...';


GO
-- AaronLiu
ALTER FUNCTION [shpt].[SackLoad#Raw]()
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, TruckerID
	from	shpt._SackLoad
)
GO
PRINT N'Altering [shpt].[SackMft#MawbWtRateCalc]...';


GO

--Daxia
ALTER FUNCTION [shpt].[SackMft#MawbWtRateCalc](@rate real, @mawbWt float, @pecentKgWt float, @minimum real)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MawbWtAmt=iif(cast((@rate * (@mawbWt/(@pecentKgWt*1000.0))) as real)>@minimum, cast((@rate * (@mawbWt/1000.0)) as real), @minimum)
)
GO
PRINT N'Altering [shpt].[SackMft#Raw]...';


GO
--PeterHo
ALTER FUNCTION [shpt].[SackMft#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, POD, POA, MawbNbr, FlightNbr, BrokerID, MawbWt
	from	shpt._SackMft
)
GO
PRINT N'Altering [svc].[Announcement$For]...';


GO
--PeterHo
ALTER	FUNCTION [svc].[Announcement$For](@source tinyint)
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, SourceID, Body
	from	core._Announcement
	where	SourceID=0
	and		EffectiveOn>=GETUTCDATE() and ExpiredOn<GETUTCDATE()
	UNION	ALL
	select	ID, SourceID, Body
	from	core._Announcement
	where	SourceID>0 and SourceID=@source
	and		EffectiveOn>=GETUTCDATE() and ExpiredOn<GETUTCDATE()
)
GO
PRINT N'Altering [tms].[Airline#Raw]...';


GO
-- AaronLiu
ALTER FUNCTION [tms].[Airline#Raw]()
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Alias
	from	tms._Airline
)
GO
PRINT N'Altering [tms].[BarcodeNbr#Make]...';


GO
-- PeterHo
ALTER FUNCTION [tms].[BarcodeNbr#Make](@zip5 char(5), @trackingNbr char(22))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	BarcodeNbr=concat('420', @zip5, @trackingNbr)
)
GO
PRINT N'Altering [tms].[Courier#IdOfAlias]...';


GO
--PeterHo
ALTER FUNCTION [tms].[Courier#IdOfAlias](@alias nvarchar(30))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	CourierID from tms._CourierAlias where Alias=@alias
		UNION	ALL
		select	ID from tms._Courier where Alias=@alias
		UNION	ALL
		select	0
	)
	select	top(1) CourierID from cte
)
GO
PRINT N'Altering [tms].[Courier#Raw]...';


GO
--PeterHo
ALTER FUNCTION [tms].[Courier#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, CourierCode=Code, CourierAlias=Alias
	from	tms._Courier
)
GO
PRINT N'Altering [tms].[Flight#Raw]...';


GO
-- AaronLiu
ALTER FUNCTION [tms].[Flight#Raw]()
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, POD, ETD, POA, ETA, FlightNbr, AirlineID
	from	tms._Flight
)
GO
PRINT N'Altering [tms].[Route#Raw]...';


GO
--PeterHo
ALTER FUNCTION [tms].[Route#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID,       MftGroup,  RouteCode
	,		BrokerID, CourierID, ClrMethodID, CmdyRootID, MaxSkuCnt, MaxWeight
	from	tms._Route
)
GO
PRINT N'Adding schema binding to [svc].[MftGroup$Lookup]...';


GO
--Ken
ALTER FUNCTION [svc].[MftGroup$Lookup]()
RETURNS TABLE
WITH SCHEMABINDING--,ENCRYPTION
AS RETURN
(
	select	MftGroup from tms.Route#Raw() r
	where	r.ID>0   group by MftGroup
)
GO
PRINT N'Altering [tms].[RouteRole#For]...';


GO
--PeterHo
ALTER FUNCTION [tms].[RouteRole#For](@routeID int, @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteBranch as
	(
		select	RoleID=AltRoleID from tms._RouteBranch
		where	RouteID=@routeID and  ActionID=@actionID
		UNION	ALL
		select	@roleID
	)
	select	top(1) RoleID from cteBranch
)
GO
PRINT N'Altering [tms].[SvcCharge#Raw]...';


GO
--Daxia
ALTER FUNCTION [tms].[SvcCharge#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	TenantID, BrokerID, POA,  ChargeID
	,		VendorID, Minimum,  Rate, CurrencyID
	from	tms._SvcCharge
)
GO
PRINT N'Altering [tms].[SvcClass#Raw]...';


GO
--PeterHo
ALTER FUNCTION [tms].[SvcClass#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, ClassCode, ClassAbbr, CourierID, MaxWeight
	from	tms._SvcClass
)
GO
PRINT N'Altering [tms].[SvcContract#Raw]...';


GO
--KEN
ALTER FUNCTION [tms].[SvcContract#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ContractID, SvcType 
	from	[tms].[_SvcContract]
)
GO
PRINT N'Altering [tms].[SvcFacility#Raw]...';


GO
-- Daxia
ALTER FUNCTION [tms].[SvcFacility#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, CourierID,  MailerID
	,		ImportZoneCode, POA,     SourceID
	,		[ImportZip3]=cast(LEFT(ImportZoneCode, 3) as char(3))
	,		FacilityInfo,  ShprInfo, CneeInfo, ReturnInfo
	,		[TokenID]=concat(POA, cast(CourierID as varchar(20)), cast(right('00'+cast(SourceID as varchar(2)), 2) as varchar(2)))
	from	[tms].[_SvcFacility]
)
GO
PRINT N'Altering [tms].[SvcFacZoneCode#Raw]...';


GO
-- Daxia
ALTER FUNCTION [tms].[SvcFacZoneCode#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	CourierID, FacilityID, ZoneCode
	from	tms._SvcFacZoneCode
)
GO
PRINT N'Altering [tms].[SvcRate#For]...';


GO
--PeterHo
ALTER FUNCTION [tms].[SvcRate#For](@svcType int, @rcvHubID bigint, @measuredWt real)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) SvcRate, SectionWt from tms._SvcRate
	where	(SvcType=@svcType and RcvHubID=@rcvHubID and SectionWt>=@measuredWt)
)
GO
PRINT N'Altering [tms].[SvcRoute#Raw]...';


GO
--PeterHo
ALTER FUNCTION [tms].[SvcRoute#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	SvcType, POA, Priority, RouteID
	from	tms._SvcRoute
)
GO
PRINT N'Altering [tms].[SvcToken#ID]...';


GO
-- PeterHo
ALTER FUNCTION [tms].[SvcToken#ID] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[LAX901607]='LAX901607'
	,		[LAX901608]='LAX901608'
	,		[JFK901607]='JFK901607'
	,		[JFK901608]='JFK901608'
)
GO
PRINT N'Altering [tms].[SvcType#Major]...';


GO
--PeterHo
ALTER FUNCTION [tms].[SvcType#Major](@svcType int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteMajor as
	(
		select	Major=iif(@svcType<10000, @svcType, @svcType/10000)*10000
	)
	select	Major, Upto=Major+9999 from cteMajor
)
GO
PRINT N'Altering [tms].[SvcType#Raw]...';


GO
--PeterHo
ALTER FUNCTION [tms].[SvcType#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, TenantID, CurrencyID, DutyCurrencyID, FallbackPOA, InitStateID, InitQueue, ClrMethodID, CmdyRootID, UseFactor, UsePreCheck
	from	tms._SvcType
)
GO
PRINT N'Altering [tms].[TrackingNbr#Cast]...';


GO
-- PeterHo
ALTER FUNCTION [tms].[TrackingNbr#Cast](@number varchar(30))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	TrackingNbr=cast(right(rtrim(@number), 22) as char(22))
)
GO
PRINT N'Altering [tms].[Trucker#Raw]...';


GO
-- AaronLiu
ALTER FUNCTION [tms].[Trucker#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Alias
	from	tms._Trucker
)
GO
PRINT N'Altering [tms].[WeightMethod#Type]...';


GO
--Smile
ALTER FUNCTION [tms].[WeightMethod#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
		select	1	as VolumetricWt,
				2	as ZebraHalfVolumetricWt,
				3	as MeasuredWt 
)
GO
PRINT N'Altering [tms].[ZoneCode#For]...';


GO
--Daxia
ALTER FUNCTION [tms].[ZoneCode#For](@zoneCode varchar(10))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ZoneCode=@zoneCode
	,		Zip3=left(@zoneCode, 3)
	,		Plus2=substring(@zoneCode, 4, 2)
)
GO
PRINT N'Altering [tvp].[Duad#Make]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Duad#Make](@v1 nvarchar(max), @v2 nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[Tvp]=concat(@v1, k.Duad, @v2) from tvp.Spr#Const() k
)
GO
PRINT N'Altering [tvp].[Duad#Of]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Duad#Of](@value nvarchar(max),  @spr nvarchar(255)=N'	^	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	with	cteTally as (select [idx]=nullif(charindex(@spr, @value, 1), 0))
	select	[v1]=isnull(substring(@value, 1, idx-1),  isnull(@value,   N''))
	,		[v2]=isnull(substring(@value, idx+len(@spr), len(@value)), N'')
	from	cteTally
)
GO
PRINT N'Adding schema binding to [tvp].[Duo#Of]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Duo#Of](@value nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	d.v1, d.v2
	from	tvp.Spr#Const() k
	cross	apply tvp.Duad#Of(@value, k.Duo) d
)
GO
PRINT N'Adding schema binding to [tvp].[Newline#OfDuad]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Newline#OfDuad](@value nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	v1, v2
	from	tvp.Duad#Of(@value, cast(char(13)+char(10) as nvarchar(255)))
)
GO
PRINT N'Adding schema binding to [tvp].[Pair#Of]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Pair#Of](@value nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	d.v1, d.v2
	from	tvp.Spr#Const() k
	cross	apply tvp.Duad#Of(@value, k.Pair) d
)
GO
PRINT N'Adding schema binding to [tvp].[Referring#Of]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Referring#Of](@tvp nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[ID]=cast(v1 as bigint), [Text]=v2 from tvp.Duad#Of(@tvp, N'	@	')
)
GO
PRINT N'Adding schema binding to [tvp].[Triad#Of]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Triad#Of](@value nvarchar(max),  @spr nvarchar(255)=N'	|	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.v1, [v2]=p.v1, [v3]=p.v2
	from	tvp.Duad#Of(@value, @spr) x
	cross	apply tvp.Duad#Of(x.v2, @spr) p
)
GO
PRINT N'Adding schema binding to [tvp].[Trio#Of]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Trio#Of](@value nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.v1, [v2]=p.v1, [v3]=p.v2
	from	tvp.Spr#Const() k
	cross	apply tvp.Duad#Of(@value,k.Trio) x
	cross	apply tvp.Duad#Of(x.v2, k.Trio)  p
)
GO
PRINT N'Adding schema binding to [tvp].[Newline#OfTriad]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Newline#OfTriad](@value nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	v1, v2, v3
	from	tvp.Triad#Of(@value, cast(char(13)+char(10) as nvarchar(255)))
)
GO
PRINT N'Altering [tvp].[Duo#Make]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Duo#Make](@v1 nvarchar(max), @v2 nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[Tvp]=concat(@v1, k.Duo, @v2) from tvp.Spr#Const() k
)
GO
PRINT N'Altering [tvp].[Pair#Make]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Pair#Make](@v1 nvarchar(max), @v2 nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[Tvp]=concat(@v1, k.Pair, @v2) from tvp.Spr#Const() k
)
GO
PRINT N'Altering [tvp].[Pcs#At]...';


GO
 --PeterHo: 4/1
ALTER FUNCTION [tvp].[Pcs#At]
(
	@index int, @source nvarchar(max), @spr nvarchar(255)=N'	;	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Piece
	from	tvp.NAX#Slice(@source, @spr)
	order	by (select null)
	offset	iif(@index>0, @index-1, 0) rows
	fetch	next 1 rows only
)
GO
PRINT N'Altering [tvp].[Pcs#Of]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Pcs#Of](@count int, @value nvarchar(max), @spr nvarchar(255))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	with ctePiece as
	(
		select	top(@count % 100) Seq=row_number() over (order by (select null)), Piece
		from	tvp.NAX#Slice(iif(datalength(@value)<>0, @value, @spr), @spr)
	)
	select	 top(1)
			 [v1]=isnull( [1], N''),  [v2]=isnull( [2], N''),  [v3]=isnull( [3], N''),  [v4]=isnull( [4], N''),
			 [v5]=isnull( [5], N''),  [v6]=isnull( [6], N''),  [v7]=isnull( [7], N''),  [v8]=isnull( [8], N''),
			 [v9]=isnull( [9], N''), [v10]=isnull([10], N''), [v11]=isnull([11], N''), [v12]=isnull([12], N''),
			[v13]=isnull([13], N''), [v14]=isnull([14], N''), [v15]=isnull([15], N''), [v16]=isnull([16], N''),
			[v17]=isnull([17], N''), [v18]=isnull([18], N''), [v19]=isnull([19], N''), [v20]=isnull([20], N''),
			[v21]=isnull([21], N''), [v22]=isnull([22], N''), [v23]=isnull([23], N''), [v24]=isnull([24], N''),
			[v25]=isnull([25], N''), [v26]=isnull([26], N''), [v27]=isnull([27], N''), [v28]=isnull([28], N''),
			[v29]=isnull([29], N''), [v30]=isnull([30], N''), [v31]=isnull([31], N''), [v32]=isnull([32], N''),
			[v33]=isnull([33], N''), [v34]=isnull([34], N''), [v35]=isnull([35], N''), [v36]=isnull([36], N''),
			[v37]=isnull([37], N''), [v38]=isnull([38], N''), [v39]=isnull([39], N''), [v40]=isnull([40], N''),
			[v41]=isnull([41], N''), [v42]=isnull([42], N''), [v43]=isnull([43], N''), [v44]=isnull([44], N''),
			[v45]=isnull([45], N''), [v46]=isnull([46], N''), [v47]=isnull([47], N''), [v48]=isnull([48], N''),
			[v49]=isnull([49], N''), [v50]=isnull([50], N''), [v51]=isnull([51], N''), [v52]=isnull([52], N''),
			[v53]=isnull([53], N''), [v54]=isnull([54], N''), [v55]=isnull([55], N''), [v56]=isnull([56], N''),
			[v57]=isnull([57], N''), [v58]=isnull([58], N''), [v59]=isnull([59], N''), [v60]=isnull([60], N''),
			[v61]=isnull([61], N''), [v62]=isnull([62], N''), [v63]=isnull([63], N''), [v64]=isnull([64], N''),
			[v65]=isnull([65], N''), [v66]=isnull([66], N''), [v67]=isnull([67], N''), [v68]=isnull([68], N''),
			[v69]=isnull([69], N''), [v70]=isnull([70], N''), [v71]=isnull([71], N''), [v72]=isnull([72], N''),
			[v73]=isnull([73], N''), [v74]=isnull([74], N''), [v75]=isnull([75], N''), [v76]=isnull([76], N''),
			[v77]=isnull([77], N''), [v78]=isnull([78], N''), [v79]=isnull([79], N''), [v80]=isnull([80], N''),
			[v81]=isnull([81], N''), [v82]=isnull([82], N''), [v83]=isnull([83], N''), [v84]=isnull([84], N''),
			[v85]=isnull([85], N''), [v86]=isnull([86], N''), [v87]=isnull([87], N''), [v88]=isnull([88], N''),
			[v89]=isnull([89], N''), [v90]=isnull([90], N''), [v91]=isnull([91], N''), [v92]=isnull([92], N''),
			[v93]=isnull([93], N''), [v94]=isnull([94], N''), [v95]=isnull([95], N''), [v96]=isnull([96], N''),
			[v97]=isnull([97], N''), [v98]=isnull([98], N''), [v99]=isnull([99], N'')
	from	(select Seq, Piece from ctePiece) raw pivot (max(Piece) for Seq in
	(
		 [1],  [2],  [3],  [4],  [5],  [6],  [7],  [8],  [9], [10], [11], [12], [13], [14], [15], [16],
		[17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32],
		[33], [34], [35], [36], [37], [38], [39], [40], [41], [42], [43], [44], [45], [46], [47], [48],
		[49], [50], [51], [52], [53], [54], [55], [56], [57], [58], [59], [60], [61], [62], [63], [64],
		[65], [66], [67], [68], [69], [70], [71], [72], [73], [74], [75], [76], [77], [78], [79], [80],
		[81], [82], [83], [84], [85], [86], [87], [88], [89], [90], [91], [92], [93], [94], [95], [96],
		[97], [98], [99]
	)) x
)
GO
PRINT N'Adding schema binding to [tvp].[Quire#Of]...';


GO
--PeterHo: 4/1
ALTER FUNCTION [tvp].[Quire#Of](@value nvarchar(max), @spr nvarchar(255)=N'	#	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select  v1,   v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9, v10, v11, v12,
			v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24
	from    tvp.Pcs#Of(24, @value, @spr)
)
GO
PRINT N'Adding schema binding to [tvp].[Tuplet#Of]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Tuplet#Of](@value nvarchar(max), @spr nvarchar(255)=N'	*	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select  v1, v2, v3, v4, v5, v6, v7, v8, v9
	from    tvp.Pcs#Of(9, @value, @spr)
)
GO
PRINT N'Altering [tvp].[Pcs#Slice]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Pcs#Slice](@source nvarchar(max), @spr nvarchar(255)=N'	;	')
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select  top(tvp.Pcs@Count(@source, @spr))
			Seq=row_number() over (order by (select null)), Piece
	from    tvp.NAX#Slice(@source, @spr)

--	select  Seq=row_number() over (order by (select null)), Piece
--	from    tvp.NAX#Slice(@source, @spr)
)
GO
PRINT N'Adding schema binding to [tvp].[Pcs#Slice]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Pcs#Slice](@source nvarchar(max), @spr nvarchar(255)=N'	;	')
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select  top(tvp.Pcs@Count(@source, @spr))
			Seq=row_number() over (order by (select null)), Piece
	from    tvp.NAX#Slice(@source, @spr)

--	select  Seq=row_number() over (order by (select null)), Piece
--	from    tvp.NAX#Slice(@source, @spr)
)
GO
PRINT N'Altering [tvp].[Pcs#TallyR]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Pcs#TallyR](@source nvarchar(max), @spr nvarchar(255)=N'	;	', @upto int=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteTally as
	(
		select	[Seq]=case when datalength(@source)<>0 then 1 else 0 end
		,		[Start]=1
		,		[Stop] =cast(charindex(isnull(@spr, N''), @source, 1) as int)
		UNION	ALL
		select	Seq+1
		,		[Start]=Stop + (datalength(@spr)/2)
		,		[Stop] =cast(charindex(@spr, @source, Stop+1) as int)
		from	cteTally
		where	(Stop > 0 and Stop < datalength(@source)/2) and (@upto=0 or @upto>Seq)
	)
	select	Seq, Start
	,		[Stop] =isnull(nullif(Stop, 0), isnull(cast((datalength(@source)/2)+1 as int), 0))
	from	cteTally where Seq<>0
--	option	(maxrecursion 0)
)
GO
PRINT N'Altering [tvp].[Quad#Make]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Quad#Make]
(
	@v1 nvarchar(max), @v2 nvarchar(max), @v3 nvarchar(max), @v4 nvarchar(max)
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[Tvp]=concat(@v1, k.Quad, @v2, k.Quad, @v3, k.Quad, @v4)
	from	tvp.Spr#Const() k
)
GO
PRINT N'Altering [tvp].[Referring#Make]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Referring#Make](@id bigint, @text nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[Tvp]=concat(@id, N'	@	', @text)
)
GO
PRINT N'Altering [tvp].[Spr#Purify]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Spr#Purify] (@tvp nvarchar(max), @sprLength tinyint=3)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Tvp=isnull(stuff(@tvp, 1, @sprLength, N''), cast(N'' as nvarchar(max)))
)
GO
PRINT N'Altering [tvp].[Triad#Make]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Triad#Make](@v1 nvarchar(max), @v2 nvarchar(max), @v3 nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[Tvp]=concat(@v1, N'	|	', @v2, N'	|	', @v3)
)
GO
PRINT N'Altering [tvp].[Trio#Make]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Trio#Make](@v1 nvarchar(max), @v2 nvarchar(max), @v3 nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	[Tvp]=concat(@v1, k.Trio, @v2, k.Trio, @v3)
	from	tvp.Spr#Const() k
)
GO
PRINT N'Altering [whse].[Order#Type]...';


GO
--Smile
ALTER FUNCTION [whse].[Order#Type]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	1	as [RackIn]
	,		2	as [RackOut]
)
GO
PRINT N'Altering [whse].[Rack#Raw]...';


GO
--Smile
ALTER FUNCTION [whse].[Rack#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, HubID, Code
	from	whse._Rack
)
GO
PRINT N'Altering [whse].[RackOrder#Raw]...';


GO
--Smile
ALTER FUNCTION [whse].[RackOrder#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, RackerID, OrderType, CreatedOn, CompletedOn
	from	whse._RackOrder
)
GO
PRINT N'Altering [whse].[StockInOrder#Raw]...';


GO
--Smile
ALTER FUNCTION [whse].[StockInOrder#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, RcvHubID, TotalSkuQty, ContractID
	from	whse._StockInOrder
)
GO
PRINT N'Altering [whse].[StorageRate#Raw]...';


GO
--Smile
ALTER FUNCTION [whse].[StorageRate#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	RcvHubID, TenantID, CurrencyID, RcvSkuFee, OutPkgFee
	,		OverWeightFee, WeightLimit, ExcessItemsFee, ItemsQtyLimit
	,		StorageCbmFee30Day, StorageCbmFee60Day, StorageCbmFeeOther
	from	whse._StorageRate
)
GO
PRINT N'Altering [zeb].[Stage$ID]...';


GO
-- AaronLiu
ALTER FUNCTION [zeb].[Stage$ID]()
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	HubCheckedIn
	from	core.Stage#ID()
)
GO
PRINT N'Adding schema binding to [acct].[Contract#For]...';


GO
--Peter, Smile
ALTER FUNCTION [acct].[Contract#For](@partyID bigint, @sourceID tinyint)
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN
(
	with cteContract as
	(
		select	c.ID, BillingCycle, DutyTerms, NonDutyTerms, BizUnitID, EffectiveOn, ExpiredOn
		,		Marker=Lead(c.ID) over(order by (select 0))
		from	core.Party#Raw()    x
		join	acct.Contract#Raw() c on c.TenantID=x.PID
		where	x.ID=@partyID and SourceID=@sourceID
		and		getutcdate() >= EffectiveOn 
		UNION	ALL
		select	ID, BillingCycle, DutyTerms, NonDutyTerms, BizUnitID, EffectiveOn, ExpiredOn
		,		Marker=Lead(x.ID) over(order by (select 0))
		from	acct.Contract#Raw() x 
		where	x.TenantID=@partyID and SourceID=@sourceID
		and		getutcdate() >= EffectiveOn 
		UNION	ALL
		select	0, 0, 0, 0, 0, '0001-01-01', '0001-01-01', null
	)
	select	top(1) ID, BillingCycle, DutyTerms, NonDutyTerms, BizUnitID, EffectiveOn, ExpiredOn
	from	cteContract     
	where	Marker is null
)
GO
PRINT N'Refreshing [svc].[Payment$Summary]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Payment$Summary]';


GO
PRINT N'Adding schema binding to [svc].[SvcContract$For]...';


GO
--Ken, Smile
ALTER FUNCTION [svc].[SvcContract$For](@partyID int)
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	SvcType
	from	core.Party#Raw()                        p
	cross	apply acct.Contract#For(P.ID, p.Source) x
	join	tms.SvcContract#Raw()                   s on s.ContractID=x.ID
	where	p.ID=@partyID and x.ID>0

)
GO
PRINT N'Adding schema binding to [svc].[Tenancy$SiteList]...';


GO
--Smile
ALTER FUNCTION [svc].[Tenancy$SiteList]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, x.Alias, TenantID=x.PID, TenantAlias=d.Alias, x.Source, t.UtcPlace, t.UtcOffset
	,		BizUnitID, BizUnit=b.Alias
	from	core.Party#Raw()         x
	join	core.Party#Raw()         d on d.ID=x.PID
	join	core.Tenant#Raw()        t on x.ID=t.ID
	cross	apply acct.Contract#For(d.ID, d.Source) c 
	join	core.Party#Raw()         b on b.ID=c.BizUnitID
	cross	apply core.Party#Type()  k
	where	x.Type=k.TenantSite
)
GO
PRINT N'Adding schema binding to [svc].[Tenancy$UserInfoList]...';


GO
--Smile
ALTER FUNCTION [svc].[Tenancy$UserInfoList]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, x.Alias, x.Source, Name, Email, TenantID=a.ID, TenantAlias=a.Alias
	,		SiteID=iif(x.AID=x.PID, 0, p.ID), SiteAlias=iif(x.AID=x.PID, N'', p.Alias)
	,		BizUnitID, BizUnit=d.Alias
	from	core.Party#Raw()          x 
	join	core.Party#Raw()          p on p.ID=x.PID
	join	core.Party#Raw()          a on a.ID=x.AID
	cross	apply acct.Contract#For(a.ID, a.Source) o
	join	core.Party#Raw()          d on d.ID=o.BizUnitID
	cross	apply core.Party#Type()   k
	cross	apply core.Contact#Type() t
	left	join core.Contact#Raw()   c on c.PartyID=x.ID and c.Type=t.Billing
	where	x.Type=k.Operator
)
GO
PRINT N'Adding schema binding to [vmi].[SvcContract$For]...';


GO
--Smile
ALTER FUNCTION [vmi].[SvcContract$For](@partyID int)
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	SvcType
	from	core.Party#Raw()                        p
	cross	apply acct.Contract#For(P.ID, p.Source) x
	join	tms.SvcContract#Raw()                   s on s.ContractID=x.ID
	where	p.ID=@partyID and x.ID>0

)
GO
PRINT N'Adding schema binding to [co].[Payment$DetailFor]...';


GO
-- Ken
ALTER FUNCTION [co].[Payment$DetailFor](@paymentID bigint,@toCurrencyID tinyint)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	select PaymentNbr, PaidAmt, ForPayment
	from   acct.Payment#Raw()         x
	join   svc.CurrencyRate$Summary() p on p.ToCurrencyID=@toCurrencyID and p.FmCurrencyID=x.CurrencyID
	where  ID= @paymentID
)
GO
PRINT N'Altering [acct].[Invoice#Raw]...';


GO
-- PeterHo
ALTER FUNCTION [acct].[Invoice#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, PartyID, VaultTag, LedgerSide, x.CurrencyID, DueDate, IssueDate, InvoicedOn
	,		DueBalance, DueBalanceRaw=m.RawAmt, DueBalanceDec=m.DecAmt
	,		InvoiceAmt, InvoiceRawAmt=i.RawAmt, InvoiceDecAmt=i.DecAmt
	,		InvoiceNbr, ContractID	
	from	[acct].[_Invoice]                x
	cross	apply dbo.Money#Of(x.DueBalance) m
	cross	apply dbo.Money#Of(x.InvoiceAmt) i
)
GO
PRINT N'Adding schema binding to [acct].[Invoice#Raw]...';


GO
-- PeterHo
ALTER FUNCTION [acct].[Invoice#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, PartyID, VaultTag, LedgerSide, x.CurrencyID, DueDate, IssueDate, InvoicedOn
	,		DueBalance, DueBalanceRaw=m.RawAmt, DueBalanceDec=m.DecAmt
	,		InvoiceAmt, InvoiceRawAmt=i.RawAmt, InvoiceDecAmt=i.DecAmt
	,		InvoiceNbr, ContractID	
	from	[acct].[_Invoice]                x
	cross	apply dbo.Money#Of(x.DueBalance) m
	cross	apply dbo.Money#Of(x.InvoiceAmt) i
)
GO
PRINT N'Altering [acct].[Ledger#Raw]...';


GO
-- PeterHo
ALTER FUNCTION [acct].[Ledger#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID,  PartyID, MatterID,   ChargeID,  ChargeAmt
	,		x.CurrencyID,  LedgerSide, TalliedOn, InvoiceID
	,		ChargeRaw=m.RawAmt, ChargeDec=m.DecAmt
	from	[acct].[_Ledger]              x
	cross	apply dbo.Money#Of(x.ChargeAmt) m
)
GO
PRINT N'Adding schema binding to [acct].[Ledger#Raw]...';


GO
-- PeterHo
ALTER FUNCTION [acct].[Ledger#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID,  PartyID, MatterID,   ChargeID,  ChargeAmt
	,		x.CurrencyID,  LedgerSide, TalliedOn, InvoiceID
	,		ChargeRaw=m.RawAmt, ChargeDec=m.DecAmt
	from	[acct].[_Ledger]              x
	cross	apply dbo.Money#Of(x.ChargeAmt) m
)
GO
PRINT N'Adding schema binding to [acct].[Ledger#Tvp]...';


GO
--PeterHo
ALTER FUNCTION [acct].[Ledger#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat
		(
			k.Many,	  PartyID,    k.Tuplet, ChargeID,   k.Tuplet, ChargeAmt,
			k.Tuplet, CurrencyID, k.Tuplet, LedgerSide, k.Tuplet, TalliedOn,
			k.Tuplet, InvoiceID
		)
		from	tvp.Spr#Const() k, acct.Ledger#Raw()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	Ledgers=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Adding schema binding to [svc].[Account$AssortedFees]...';


GO
-- Ken
ALTER FUNCTION [svc].[Account$AssortedFees]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, TenantID=p.ID, Alias, m.Source, Supplement
	,		ChargeAmt, TalliedOn, ChargeID, CurrencyID, ClientRefNbr=b.Number 
	from	acct.Ledger#Raw()          x
	cross	apply core.Matter#Type()   k
	join	core.Matter#Raw()          m on m.ID=x.MatterID and m.Type=k.AssortedFees
	join	core.Tenant#Raw()          p on p.ID=x.PartyID
	cross	apply core.RefNbr#Type()   t
	join	core.RefNbr#Raw()          b on b.MatterID=m.ID and b.Type=t.ClientRef
	cross	apply core.Registry#ID()   r 
	join	core.Supplement#Raw()      s on s.RegID=r.AssortedFees and s.RowID=m.ID

)
GO
PRINT N'Adding schema binding to [svc].[Account$StorageFees]...';


GO
-- Ken
ALTER FUNCTION [svc].[Account$StorageFees]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, m.Source, TenantID=p.ID, PartyAlias=Alias
	,		Supplement, TalliedOn, ChargeAmt, CurrencyID, ChargeID 
	from	acct.Ledger#Raw()          x
	cross	apply core.Matter#Type()   k
	join	core.Matter#Raw()          m on m.ID=x.MatterID and m.Type=k.StorageFee
	join	core.Tenant#Raw()          p on p.ID=x.PartyID
	cross	apply core.Registry#ID()   r 
	join	core.Supplement#Raw() s on s.RegID=r.Ledger and s.RowID=x.ID

)
GO
PRINT N'Altering [acct].[Vault#Raw]...';


GO
-- PeterHo, Smile
ALTER FUNCTION [acct].[Vault#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, PartyID,   x.SourceID, x.CurrencyID, VaultType,    TalliedOn
	,		VaultBal,      RawBal=v.RawAmt,          DecBal        =v.DecAmt
	,		CreditLimit,   CreditLimitRaw=c.RawAmt,  CreditLimitDec=c.DecAmt
	,		InvoicedAmt,   InvoicedRaw   =i.RawAmt,  InvoicedDec   =i.DecAmt
	,		UninvoicedAmt, UninvoicedRaw =u.RawAmt,  UninvoicedDec =u.DecAmt
	,		CurBalRaw=(v.RawAmt + c.RawAmt - u.RawAmt -i.RawAmt),  CurBal=b.Amt
	from	[acct].[_Vault]                    x 
	cross	apply dbo.Money#Of(VaultBal)       v
	cross	apply dbo.Money#Of(CreditLimit)    c
	cross	apply dbo.Money#Of(UninvoicedAmt)  u
	cross	apply dbo.Money#Of(InvoicedAmt)    i
	cross	apply dbo.Currency#Encode(v.RawAmt+c.RawAmt-u.RawAmt-i.RawAmt, x.CurrencyID) b
)
GO
PRINT N'Adding schema binding to [acct].[Vault#Raw]...';


GO
-- PeterHo, Smile
ALTER FUNCTION [acct].[Vault#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, PartyID,   x.SourceID, x.CurrencyID, VaultType,    TalliedOn
	,		VaultBal,      RawBal=v.RawAmt,          DecBal        =v.DecAmt
	,		CreditLimit,   CreditLimitRaw=c.RawAmt,  CreditLimitDec=c.DecAmt
	,		InvoicedAmt,   InvoicedRaw   =i.RawAmt,  InvoicedDec   =i.DecAmt
	,		UninvoicedAmt, UninvoicedRaw =u.RawAmt,  UninvoicedDec =u.DecAmt
	,		CurBalRaw=(v.RawAmt + c.RawAmt - u.RawAmt -i.RawAmt),  CurBal=b.Amt
	from	[acct].[_Vault]                    x 
	cross	apply dbo.Money#Of(VaultBal)       v
	cross	apply dbo.Money#Of(CreditLimit)    c
	cross	apply dbo.Money#Of(UninvoicedAmt)  u
	cross	apply dbo.Money#Of(InvoicedAmt)    i
	cross	apply dbo.Currency#Encode(v.RawAmt+c.RawAmt-u.RawAmt-i.RawAmt, x.CurrencyID) b
)
GO
PRINT N'Adding schema binding to [acct].[Vault#Summary]...';


GO
-- PeterHo
ALTER FUNCTION [acct].[Vault#Summary] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteVault as
	(
		select	PartyID,   CurrencyID
		,		RawTotal   =sum  (RawBal)
		,		LastOn     =max  (TalliedOn)
		,		TypeCnt    =count(VaultType)
--		,		Outstanding=sum  (Outstanding)
		from	acct.Vault#Raw()
		group	by PartyID, CurrencyID
	)
	select	PartyID,  x.CurrencyID
	,		RawTotal, DecTotal=m.DecAmt, TypeCnt, LastOn
	from	cteVault x cross apply dbo.Money#Of(RawTotal) m
)
GO
PRINT N'Adding schema binding to [svc].[Account$VaultBalFor]...';


GO
-- Smile
ALTER FUNCTION [svc].[Account$VaultBalFor](@partyID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID=PartyID, VaultBal, InvoicedAmt, UninvoicedAmt, CurrencyID, VaultType, CurBal, CreditLimit
	from	acct.Vault#Raw()  x
	where	x.PartyID=@partyID 
)
GO
PRINT N'Adding schema binding to [svc].[Account$VaultSummary]...';


GO
-- Smile
ALTER FUNCTION [svc].[Account$VaultSummary](@partyID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	select	CurrencyID, VaultBal, VaultType, LockCnt
	from	acct.Vault#Raw() x
	cross	apply(
					select	LockCnt=count(*)
					from	core.Matter#Raw()     m
					cross	apply core.State#ID() s
					where	m.StateID=s.CreditLimitExceeded
				 ) l
	cross	apply acct.Vault#Type() t
	where	x.VaultType=t.Fund and x.PartyID=@partyID
)
GO
PRINT N'Adding schema binding to [vmi].[Account$VaultBalFor]...';


GO
-- Smile
ALTER FUNCTION [vmi].[Account$VaultBalFor](@partyID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID=PartyID, VaultBal, InvoicedAmt, UninvoicedAmt, CurrencyID, VaultType, CurBal, CreditLimit
	from	acct.Vault#Raw()  x
	where	x.PartyID=@partyID 
)
GO
PRINT N'Altering [acct].[VaultXact#Raw]...';


GO
-- PeterHo
ALTER FUNCTION [acct].[VaultXact#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, XactAmt, XactedOn,  PrevBal, [NextBal]=n.Amt
	,		PaymentID,   InvoiceID, VaultID
	from	[acct].[_VaultXact]
	cross	apply [dbo].Money#Sum(XactAmt, PrevBal) n
)
GO
PRINT N'Adding schema binding to [acct].[VaultXact#Raw]...';


GO
-- PeterHo
ALTER FUNCTION [acct].[VaultXact#Raw] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, XactAmt, XactedOn,  PrevBal, [NextBal]=n.Amt
	,		PaymentID,   InvoiceID, VaultID
	from	[acct].[_VaultXact]
	cross	apply [dbo].Money#Sum(XactAmt, PrevBal) n
)
GO
PRINT N'Altering [brkg].[ClrMethod#Raw]...';


GO
--PeterHo
ALTER FUNCTION [brkg].[ClrMethod#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, ClrMethodCode, CountryCode, CurrencyID
	,		IDRequirement, Exemption, ExemptionRaw=m.RawAmt
	from	brkg._ClrMethod        x
	cross	apply dbo.Money#Make(x.Exemption, x.CurrencyID) m
)
GO
PRINT N'Adding schema binding to [brkg].[ClrMethod#Raw]...';


GO
--PeterHo
ALTER FUNCTION [brkg].[ClrMethod#Raw]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, ClrMethodCode, CountryCode, CurrencyID
	,		IDRequirement, Exemption, ExemptionRaw=m.RawAmt
	from	brkg._ClrMethod        x
	cross	apply dbo.Money#Make(x.Exemption, x.CurrencyID) m
)
GO
PRINT N'Adding schema binding to [brkg].[ClrMethodRate#For]...';


GO
--Smile
ALTER FUNCTION [brkg].[ClrMethodRate#For](@tenantID int, @clrMethodID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(	
	with cteRate as
	(
		select	top(1)	CurrencyID, FlatRateRaw=m.RawAmt, PercentRate
		from	brkg.ClrMethodRate#Raw() x
		join	brkg.ClrMethod#Raw()     d on d.ID=@clrMethodID
		cross	apply dbo.Money#Make(x.FlatRate, d.CurrencyID) m
		where	TenantID=@tenantID and ClrMethodID=@clrMethodID	
		union all
		select	0, 0, 0
	)
	select	top(1) CurrencyID, FlatRateRaw, PercentRate
	from	cteRate
)
GO
PRINT N'Adding schema binding to [invt].[SkuDuty#Tvp]...';


GO
--PeterHo, Smile
ALTER FUNCTION [invt].[SkuDuty#Tvp](@skuID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteDuty(text) AS
	(
		select	[text()]=concat(k.Many, c.ClrMethodCode, k.Triad, d.DutyRate, k.Triad, d.DutyCode)
		from	tvp.Spr#Const()      k, invt.SkuBrokerage#Raw() x
		join	brkg.Duty#Raw()      d on d.ID=x.DutyID
		join	brkg.ClrMethod#Raw() c on c.ID=x.ClrMethodID
		where	x.SkuID=@skuID
		for		xml path(N'')
	)
	select	DutyTvp=Tvp from cteDuty cross apply tvp.Spr#Purify(text, default) 
/*
	with cteSkuDuty(text) as
	(
		select	[text()]=concat(k.Many, m.ClrMethodCode, k.Triad, x.DutyRate, k.Triad, x.CmdyCode)
		from	tvp.Spr#Const() k,   invt.TenantSku#Duty() x
		join	brkg.ClrMethod#Raw() m on m.ID=x.ClrMethodID
		where	x.TenantSkuID=@tenantSkuID
		for xml path(N'')
	)
	select	DutyTvp=Tvp from cteSkuDuty cross apply tvp.Spr#Purify(text, default)
*/
)
GO
PRINT N'Adding schema binding to [svc].[ClrMethod$Lookup]...';


GO
--Sam
ALTER FUNCTION [svc].[ClrMethod$Lookup]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, ClrMethodCode, CountryCode
	from	brkg.ClrMethod#Raw()
)
GO
PRINT N'Adding schema binding to [tms].[SvcType#Deep]...';


GO
--PeterHo
ALTER FUNCTION [tms].[SvcType#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,         TenantID,         TenantAlias=t.Alias
	,		x.CurrencyID, x.DutyCurrencyID, x.CmdyRootID
	,		ClrMethodID,  m.ClrMethodCode,  m.CountryCode
	from	tms.SvcType#Raw()    x
	join	core.Tenant#Raw()    t on t.ID=x.TenantID
	join	brkg.ClrMethod#Raw() m on m.ID=x.ClrMethodID
)
GO
PRINT N'Adding schema binding to [svc].[Sku$DutyList]...';


GO
--PeterHo, Aimee
ALTER FUNCTION [svc].[Sku$DutyList]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, x.TenantID, TenantAlias=p.Alias, x.SkuNbr, t.DutyTvp
	from	invt.Sku#Raw()    x
	join	core.Tenant#Raw() p on p.ID= x.TenantID
	cross	apply invt.SkuDuty#Tvp(x.ID) t
)
GO
PRINT N'Altering [brkg].[Commodity#Deep]...';


GO
--PeterHo
ALTER FUNCTION [brkg].[Commodity#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,          PID, Name,      Surcharge
	,		DutyID,        d.DutyCode,     d.DutyRate
	,		d.CountryCode, d.CommodityUoM, d.CustomsValue
	from	brkg.Commodity#Raw() x
	join	brkg.Duty#Raw() d on d.ID=x.DutyID
)
GO
PRINT N'Adding schema binding to [brkg].[Commodity#Deep]...';


GO
--PeterHo
ALTER FUNCTION [brkg].[Commodity#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,          PID, Name,      Surcharge
	,		DutyID,        d.DutyCode,     d.DutyRate
	,		d.CountryCode, d.CommodityUoM, d.CustomsValue
	from	brkg.Commodity#Raw() x
	join	brkg.Duty#Raw() d on d.ID=x.DutyID
)
GO
PRINT N'Adding schema binding to [svc].[Commodity$Fuzzy]...';


GO
--PeterHo
ALTER FUNCTION [svc].[Commodity$Fuzzy](@countryCode char(2))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	c.ID, c.PID, [Path]=c.Name
	,		c.Surcharge, c.DutyID, c.DutyRate, c.DutyCode
	from	brkg.Commodity#Raw()   x
	join	brkg.Commodity#Deep()  c on c.PID=x.ID
	where	x.PID=0 and x.Name=cast(@countryCode + N'F' as nvarchar(50))
)
GO
PRINT N'Adding schema binding to [svc].[Commodity$Root]...';


GO
--PeterHo
ALTER FUNCTION [svc].[Commodity$Root](@cmdyRootID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	c.ID, c.PID, [Path]=c.Name
	,		c.Surcharge, c.DutyID, c.DutyRate, c.DutyCode
	from	brkg.Commodity#Raw()   x
	join	brkg.Commodity#Deep()  c on c.PID=x.ID
	where	x.PID=0 and x.ID=@cmdyRootID
)
GO
PRINT N'Adding schema binding to [svc].[Commodity$FuzzyRoot]...';


GO
--Daxia
ALTER FUNCTION [svc].[Commodity$FuzzyRoot](@svcType int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	c.ID, c.PID, Path
	,		Surcharge,   DutyID, DutyRate, DutyCode
	from	tms.SvcType#Raw()    x
	cross	apply svc.Commodity$Root(x.CmdyRootID) c
	where	x.ID=@svcType
)
GO
PRINT N'Adding schema binding to [svc].[Commodity$Node]...';


GO
--PeterHo
ALTER FUNCTION [svc].[Commodity$Node](@parentID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with cteCmdy as
	(
		select	x.ID, x.PID, x.DutyID, x.Surcharge
		,		Path=cast(x.Name as nvarchar(max))
		from	brkg.Commodity#Raw()   x
		where	PID=@parentID and @parentID>0
		UNION	ALL
		select	x.ID, x.PID, x.DutyID, x.Surcharge
		,		Path=p.Path + N'	/	' + x.Name
		from	cteCmdy p join brkg.Commodity#Raw() x
		on		p.ID=x.PID
	)
	select	ID    =isnull(x.ID,     0), PID      =isnull(x.PID,       0)
	,		Path  =isnull(x.Path, N''), Surcharge=isnull(x.Surcharge, 0)
	,		DutyID=isnull(x.DutyID, 0), d.DutyRate,      d.DutyCode
	from	cteCmdy  x join brkg.Duty#Raw() d on d.ID=x.DutyID
	where	d.DutyRate>=0
)
GO
PRINT N'Altering [core].[AddOnSvc#Exists]...';


GO
--PeterHo
ALTER FUNCTION [core].[AddOnSvc#Exists](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	HasAddOnSvc=iif(exists(select 0 from core._AddOnSvc where MatterID=@matterID and OperatorID=0), true, false)
	from	dbo.Bool#Const()
)
GO
PRINT N'Adding schema binding to [core].[AddOnSvc#Exists]...';


GO
--PeterHo
ALTER FUNCTION [core].[AddOnSvc#Exists](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	HasAddOnSvc=iif(exists(select 0 from core._AddOnSvc where MatterID=@matterID and OperatorID=0), true, false)
	from	dbo.Bool#Const()
)
GO
PRINT N'Altering [core].[AddOnSvc#TotalUnfinished]...';


GO
-- Smile
ALTER	FUNCTION [core].[AddOnSvc#TotalUnfinished](@matterID bigint)
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	TotalUnfinished=count(*)
		from	core.AddOnSvc#Raw()
		where	MatterID=@matterID and EndedOn=dbo.DT@Empty()	
		union	all
		select	0
	)
	select	top(1) TotalUnfinished from cte
)
GO
PRINT N'Adding schema binding to [core].[AddOnSvc#Tvp]...';


GO
--EASON
ALTER FUNCTION [core].[AddOnSvc#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat
		(
			k.Many,  ID,        k.Dozen, Type, k.Dozen, OperatorID,  
			k.Dozen, StartedOn, k.Dozen, EndedOn
		)
		from	tvp.Spr#Const() k, core.AddOnSvc#Raw()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	AddOnServices=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Altering [core].[Challenge#Exists]...';


GO
--PeterHo
ALTER FUNCTION [core].[Challenge#Exists](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	HasChallenge=iif(exists(select 0 from core._Concern where MatterID=@matterID), true, false)
	from	dbo.Bool#Const()
)
GO
PRINT N'Adding schema binding to [core].[Challenge#Exists]...';


GO
--PeterHo
ALTER FUNCTION [core].[Challenge#Exists](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	HasChallenge=iif(exists(select 0 from core._Concern where MatterID=@matterID), true, false)
	from	dbo.Bool#Const()
)
GO
PRINT N'Adding schema binding to [core].[Challenge#Tvp]...';


GO
--PeterHo
ALTER FUNCTION [core].[Challenge#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
	/*
		select	[text()]=concat
		(
			k.Many, Type
		,	k.Duad,	BoundStage, k.Quad, Body, k.Quad, PostedOn
		,	k.Quad, PosterID,   k.Referring,  PosterAlias
		)
		from	tvp.Spr#Const() k, core.Challenge#Of(@matterID)
	*/
		select	[text()]=concat(k.Many, Type, k.Duad, BoundStage)
		from	tvp.Spr#Const() k, core.Challenge#Raw()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	Challenges=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Altering [zeb].[Challenge$Tvp]...';


GO
-- Eva
ALTER FUNCTION [zeb].[Challenge$Tvp](@matterID bigint)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Challenges from core.Challenge#Tvp(@matterID)
)
GO
PRINT N'Altering [core].[Concern#Exists]...';


GO
--PeterHo
ALTER FUNCTION [core].[Concern#Exists](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	HasConcern=iif(exists(select 0 from core._Concern where MatterID=@matterID), true, false)
	from	dbo.Bool#Const()
)
GO
PRINT N'Adding schema binding to [core].[Concern#Exists]...';


GO
--PeterHo
ALTER FUNCTION [core].[Concern#Exists](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	HasConcern=iif(exists(select 0 from core._Concern where MatterID=@matterID), true, false)
	from	dbo.Bool#Const()
)
GO
PRINT N'Adding schema binding to [core].[Concern#Tvp]...';


GO
--PeterHo
ALTER FUNCTION [core].[Concern#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, Type, k.Duad)
		from	tvp.Spr#Const() k, core.Concern#Raw()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	Concerns=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Adding schema binding to [co].[Tenancy$UserList]...';


GO
-- Smile
ALTER FUNCTION [co].[Tenancy$UserList](@tenantID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	with	cteSubType as
	(
		select	t.ID, t.PID, Alias, t.Type, Name, Email
		from	svc.Tenancy$Subtype(@tenantID,default, default) t
		cross	apply core.Contact#Type() c
		left	join  core.Contact#Raw()  o on o.PartyID=t.ID and o.Type=c.Billing
	)
	select	x.ID, x.Alias, Name, Email, SiteID=isnull(p.ID, 0), SiteAlias=isnull(p.Alias, N'')
	from	cteSubType               x
	cross	apply core.Party#Type()  k
	left	join  core.Party#Raw()   p on p.ID=x.PID and p.Type=k.TenantSite
	where	x.Type=k.Operator and x.ID>0
)
GO
PRINT N'Adding schema binding to [svc].[User$ContactName]...';


GO
--Daxia
ALTER FUNCTION [svc].[User$ContactName](@userID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, Name=isnull(Name, N''),  Handler=concat('(', x.ID, ') ', Name)
	from	core.User#Raw()           x 
	cross	apply core.Contact#Type() k
	left	join core.Contact#Raw()   c on c.PartyID=x.ID and c.Type=k.Billing
	where	x.ID=@userID
)
GO
PRINT N'Adding schema binding to [svc].[User$List]...';


GO
--Simile
ALTER FUNCTION [svc].[User$List]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, RoleID, Name, Email
	from	core.User#Raw()           x
	join	core.UserRole#Raw()       u on u.UserID=x.ID
	cross	apply core.Contact#Type() k
	left	join core.Contact#Raw()   c on c.PartyID=x.ID and c.Type=k.Billing
)
GO
PRINT N'Adding schema binding to [core].[Contact#TvpFor]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Contact#TvpFor](@partyID int, @contactType tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteContact as
	(
		select	Tvp from core.Contact#Tvp()
		where	PartyID=@partyID and Type=@contactType
		UNION	ALL
		select	Tvp from core.Contact#Tvp() cross apply core.Contact#Type() k
		where	PartyID=@partyID and Type=k.Billing
	)
	select	top(1) Tvp from cteContact
)
GO
PRINT N'Adding schema binding to [core].[Contact#TvpForRefInfo]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Contact#TvpForRefInfo](@partyID int, @refInfoType tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteType as
	(
		select	ContactType=case @refInfoType
				when i.ShprInfo   then c.Shipping
				when i.CneeInfo   then c.Shipping
				when i.ReturnInfo then c.Returning
				else c.Billing    end
		from	core.RefInfo#Type() i, core.Contact#Type() c
	)
	select	Tvp from cteType cross apply core.Contact#TvpFor(@partyID, ContactType)
)
GO
PRINT N'Adding schema binding to [svc].[Tenancy$SiteInfoList]...';


GO
--Smile
ALTER FUNCTION [svc].[Tenancy$SiteInfoList]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, x.Alias, x.Source, TenantID=x.PID, TenantAlias=d.Alias
	,		UtcPlace, UtcOffset, Shipping=s.Tvp, Returning=r.Tvp
	from	core.Party#Raw()           x 
	join	core.Party#Raw()           d on d.ID=x.PID
	join	core.Tenant#Raw()          t on x.ID=t.ID
	cross	apply core.Contact#Type()  k
	outer	apply core.Contact#TvpFor(x.ID, k.Shipping)  s
	outer	apply core.Contact#TvpFor(x.ID, k.Returning) r 
	cross	apply core.Party#Type()    p
	where	x.Type=p.TenantSite and x.ID>0
)
GO
PRINT N'Altering [core].[Hub#ByPOA]...';


GO
-- Daxia
ALTER FUNCTION [core].[Hub#ByPOA](@poa char(3))
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ID, PID, AID, Type, Source, Alias
	from	core.Party#Raw() x
	cross	apply core.Party#Type() t
	where	x.Type=t.ZebraHub and x.Alias=@poa
)
GO
PRINT N'Altering [core].[Matter#ANodeDn]...';


GO
-- AaronLiu
ALTER FUNCTION [core].[Matter#ANodeDn](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePNode as
	(
		select	Level=0,       x.ID, x.AID, x.Type, x.Source, x.Stage, x.StateID
		from	core.Matter#Raw() x
		where	x.ID=@matterID and @matterID>0
		UNION	ALL
		select	Level=Level+1, x.ID, x.AID, x.Type, x.Source, x.Stage, x.StateID
		from	ctePNode p join core.Matter#Raw() x
		on		x.AID=p.ID
	)
	select	Level, ID, AID, Type, Source, Stage, StateID from ctePNode
)
GO
PRINT N'Adding schema binding to [core].[Matter#ANodeDn]...';


GO
-- AaronLiu
ALTER FUNCTION [core].[Matter#ANodeDn](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePNode as
	(
		select	Level=0,       x.ID, x.AID, x.Type, x.Source, x.Stage, x.StateID
		from	core.Matter#Raw() x
		where	x.ID=@matterID and @matterID>0
		UNION	ALL
		select	Level=Level+1, x.ID, x.AID, x.Type, x.Source, x.Stage, x.StateID
		from	ctePNode p join core.Matter#Raw() x
		on		x.AID=p.ID
	)
	select	Level, ID, AID, Type, Source, Stage, StateID from ctePNode
)
GO
PRINT N'Altering [core].[Matter#ANodeUp]...';


GO
--PeterHo
ALTER FUNCTION [core].[Matter#ANodeUp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteNode as
	(
		select	Level=0, x.ID, x.AID, x.Type
		from	core.Matter#Raw() x
		where	x.ID=@matterID
		UNION	ALL
		select	Level=Level-1, x.ID, x.AID, x.Type
		from	cteNode c join core.Matter#Raw() x
		on		(c.AID>0 and c.AID=x.ID)
	)
	select	Level, ID, Type from cteNode
)
GO
PRINT N'Adding schema binding to [core].[Matter#ANodeUp]...';


GO
--PeterHo
ALTER FUNCTION [core].[Matter#ANodeUp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteNode as
	(
		select	Level=0, x.ID, x.AID, x.Type
		from	core.Matter#Raw() x
		where	x.ID=@matterID
		UNION	ALL
		select	Level=Level-1, x.ID, x.AID, x.Type
		from	cteNode c join core.Matter#Raw() x
		on		(c.AID>0 and c.AID=x.ID)
	)
	select	Level, ID, Type from cteNode
)
GO
PRINT N'Altering [core].[Matter#NodeDn]...';


GO
-- AaronLiu, PeterHo
ALTER FUNCTION [core].[Matter#NodeDn](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePNode as
	(
		select	Level=0,       x.ID, x.AID, x.PID, x.Type, x.Source, x.Stage, x.StateID, x.RejoinID
		from	core.Matter#Raw() x
		where	x.ID=@matterID and @matterID>0
		UNION	ALL
		select	Level=Level+1, x.ID, x.AID, x.PID, x.Type, x.Source, x.Stage, x.StateID, x.RejoinID
		from	ctePNode p join core.Matter#Raw() x
		on		x.AID=p.ID
		UNION	ALL
		select	Level=Level+1, x.ID, x.AID, x.PID, x.Type, x.Source, x.Stage, x.StateID, x.RejoinID
		from	ctePNode p join core.Matter#Raw() x
		on		x.PID=p.ID
	)
	select	Level, ID, AID, PID, Type, Source, Stage, StateID, RejoinID from ctePNode
)
GO
PRINT N'Adding schema binding to [core].[Matter#NodeDn]...';


GO
-- AaronLiu, PeterHo
ALTER FUNCTION [core].[Matter#NodeDn](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePNode as
	(
		select	Level=0,       x.ID, x.AID, x.PID, x.Type, x.Source, x.Stage, x.StateID, x.RejoinID
		from	core.Matter#Raw() x
		where	x.ID=@matterID and @matterID>0
		UNION	ALL
		select	Level=Level+1, x.ID, x.AID, x.PID, x.Type, x.Source, x.Stage, x.StateID, x.RejoinID
		from	ctePNode p join core.Matter#Raw() x
		on		x.AID=p.ID
		UNION	ALL
		select	Level=Level+1, x.ID, x.AID, x.PID, x.Type, x.Source, x.Stage, x.StateID, x.RejoinID
		from	ctePNode p join core.Matter#Raw() x
		on		x.PID=p.ID
	)
	select	Level, ID, AID, PID, Type, Source, Stage, StateID, RejoinID from ctePNode
)
GO
PRINT N'Altering [core].[Matter#PNodeDn]...';


GO
--PeterHo
ALTER FUNCTION [core].[Matter#PNodeDn](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePNode as
	(
		select	Level=0,       x.ID, x.PID, x.Type, x.Source, x.Stage, x.StateID, x.RejoinID
		from	core.Matter#Raw() x
		where	x.ID=@matterID and @matterID>0
		UNION	ALL
		select	Level=Level+1, x.ID, x.PID, x.Type, x.Source, x.Stage, x.StateID, x.RejoinID
		from	ctePNode p join core.Matter#Raw() x
		on		x.PID=p.ID
	)
	select	Level, ID, PID, Type, Source, Stage, StateID, RejoinID from ctePNode
)
GO
PRINT N'Adding schema binding to [core].[Matter#PNodeDn]...';


GO
--PeterHo
ALTER FUNCTION [core].[Matter#PNodeDn](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePNode as
	(
		select	Level=0,       x.ID, x.PID, x.Type, x.Source, x.Stage, x.StateID, x.RejoinID
		from	core.Matter#Raw() x
		where	x.ID=@matterID and @matterID>0
		UNION	ALL
		select	Level=Level+1, x.ID, x.PID, x.Type, x.Source, x.Stage, x.StateID, x.RejoinID
		from	ctePNode p join core.Matter#Raw() x
		on		x.PID=p.ID
	)
	select	Level, ID, PID, Type, Source, Stage, StateID, RejoinID from ctePNode
)
GO
PRINT N'Refreshing [hub].[Sack#Parcels]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[Sack#Parcels]';


GO
PRINT N'Adding schema binding to [shpt].[SackMft#HawbCntRateCalc]...';


GO
--Daxia
ALTER FUNCTION [shpt].[SackMft#HawbCntRateCalc](@sackMftID bigint, @rate real, @minimum real, @limitCnt int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
		with cte as
		(
			select	ParcelCnt=count(*)
			from	core.Matter#PNodeDn(@sackMftID) x
			cross	apply core.Matter#Type() k
			where	x.Type=k.Parcel
		)
		select	HawbAmt=iif(ParcelCnt>@limitCnt,(ParcelCnt-@limitCnt)*@rate+@limitCnt*@minimum, ParcelCnt*@minimum)
		from	cte
)
GO
PRINT N'Altering [core].[Matter#PNodeUp]...';


GO
--PeterHo
ALTER FUNCTION [core].[Matter#PNodeUp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteNode as
	(
		select	Level=0, x.ID, x.PID, x.Type, x.Stage, x.StateID
		from	core.Matter#Raw() x
		where	x.ID=@matterID
		UNION	ALL
		select	Level=Level-1, x.ID, x.PID, x.Type, x.Stage, x.StateID
		from	cteNode c join core.Matter#Raw() x
		on		(c.PID>0 and c.PID=x.ID)
	)
	select	Level, ID, Type, Stage, StateID from cteNode
)
GO
PRINT N'Adding schema binding to [core].[Matter#PNodeUp]...';


GO
--PeterHo
ALTER FUNCTION [core].[Matter#PNodeUp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteNode as
	(
		select	Level=0, x.ID, x.PID, x.Type, x.Stage, x.StateID
		from	core.Matter#Raw() x
		where	x.ID=@matterID
		UNION	ALL
		select	Level=Level-1, x.ID, x.PID, x.Type, x.Stage, x.StateID
		from	cteNode c join core.Matter#Raw() x
		on		(c.PID>0 and c.PID=x.ID)
	)
	select	Level, ID, Type, Stage, StateID from cteNode
)
GO
PRINT N'Adding schema binding to [co].[Parcel$SummaryByStage]...';


GO
-- Smile
ALTER FUNCTION [co].[Parcel$SummaryByStage](@tenantID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	select	isnull(sum(case when x.Stage between 100   and  9999 then 1 else 0 end),0) as ParcelAwaiting
	,		isnull(sum(case when x.Stage between 10000 and 19999 then 1 else 0 end),0) as ParcelProcessing
	,		isnull(sum(case when x.Stage between 20000 and 24999 then 1 else 0 end),0) as ParcelShipped	
	from	core.Matter#Raw()        x
	cross	apply core.Matter#Type() t
	where	x.Type=t.Parcel 
	and		x.PosterID in 
	(
		select	ID 
		from	core.Party#Raw()        p
		cross	apply core.Party#Type() k
		where	p.PID=@tenantID and     p.Type=k.TenantSite
	)	
)
GO
PRINT N'Adding schema binding to [core].[RefNbr#MatchOne]...';


GO
--PeterHo, Aaron
ALTER FUNCTION [core].[RefNbr#MatchOne]
(
	@number varchar(40), @minStage int=100, @maxStage int=25500
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteMatched as
	(
		select	MatterID, Type, Number
		,		Marker=row_number() over(partition by MatterID order by Type)
		from	core.RefNbr#Raw()
		where	Number=@number
	)
	, cteStaged as
	(
		select	x.MatterID, x.Type, x.Number, m.Stage
		from	cteMatched        x
		join	core.Matter#Raw() m on m.ID=x.MatterID
		where	Marker=1 and (m.Stage between @minStage and @maxStage)
	)
	select	top(1) MatchedCnt=count(*) over()
	,		MatterID, Type, Number, Stage
	from	cteStaged
)
GO
PRINT N'Adding schema binding to [rpt].[Dashboard$StageSummary]...';


GO
-- Eason
ALTER FUNCTION [rpt].[Dashboard$StageSummary](@siteID bigint)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	select	isnull(sum(case when x.Stage between 100   and 24999 then 1 else 0 end),0) as ParcelTotal
	,		isnull(sum(case when x.Stage between 100   and  9999 then 1 else 0 end),0) as ParcelAwaiting
	,		isnull(sum(case when x.Stage between 10000 and 19999 then 1 else 0 end),0) as ParcelProcessing
	,		isnull(sum(case when x.Stage between 20000 and 24999 then 1 else 0 end),0) as ParcelShipped
	,		isnull(sum(case when x.Stage in (500,10500,20500)    then 1 else 0 end),0) as ExcptionTotal
	,		isnull(sum(case when x.Stage = 500                   then 1 else 0 end),0) as ExcptionAwaiting
	,		isnull(sum(case when x.Stage = 10500                 then 1 else 0 end),0) as ExcptionProcessing
	,		isnull(sum(case when x.Stage = 20500                 then 1 else 0 end),0) as ExcptionShipped
	from	core.Matter#Raw()        x
	cross	apply core.Matter#Type() t
	where	x.Type=t.Parcel and x.PosterID=@siteID
)
GO
PRINT N'Adding schema binding to [shpt].[Sack#SeqNbrOf]...';


GO
--PeterHo
ALTER FUNCTION [shpt].[Sack#SeqNbrOf](@sackID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteSack as
	(
		select	SeqDate=cast(cast(PostedOn as date) as datetime2(2))
		from	core.Matter#Raw()
		where	ID=@sackID
	)
	select	SeqNbr=count(*)%10000
	from	cteSack            x
	,		core.Matter#Type() t
	,		core.Matter#Raw()  m
	where	m.Type=t.Sack and m.ID<=@sackID
	and		m.PostedOn>=x.SeqDate and m.PostedOn<DATEADD(day, 1, x.SeqDate)
)
GO
PRINT N'Refreshing [shpt].[Siblings#CntInRack]...';


GO
EXECUTE sp_refreshsqlmodule N'[shpt].[Siblings#CntInRack]';


GO
PRINT N'Adding schema binding to [svc].[RefNbr$SearchFor]...';


GO
-- Daxia, AaronLiu
ALTER FUNCTION [svc].[RefNbr$SearchFor](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with cteMatched as
	(
		select	MatterID, Type, Number
		from	core.RefNbr#Raw()
		where	Number=@number
	)
	, cteStaged as
	(
		select	x.MatterID, x.Type, x.Number, m.Stage
		from	cteMatched        x
		join	core.Matter#Raw() m on m.ID=x.MatterID
	)
	select	ID=MatterID, RefNbr=Number, Type, Stage
	from	cteStaged

	/*
	select	ID=MatterID, RefNbr=Number, Type, Stage
	from	core.RefNbr#ScanOne(@number, default, default)
	*/
)
GO
PRINT N'Adding schema binding to [vmi].[Parcel$SummaryByStage]...';


GO
-- Smile
ALTER FUNCTION [vmi].[Parcel$SummaryByStage](@siteID bigint)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	select	isnull(sum(case when x.Stage >=10000 and x.Stage<12600 then 1  end),0) as AwaitingAudit
	,		isnull(sum(case when x.Stage >=12600 and x.Stage<20000 then 1  end),0) as AwaitingOutgate
	,		isnull(sum(case when x.Stage >=20000 and x.Stage<25000 then 1  end),0) as AwaitingDoorDelivery
	from	core.Matter#Raw()        x
	cross	apply core.Matter#Type() t
	cross	apply core.Source#ID()   k
	where	x.Type=t.Parcel and x.PosterID=@siteID and x.Source=k.eVMI
)
GO
PRINT N'Adding schema binding to [xpd].[SackMft$Verify]...';


GO
--	Aimee
ALTER	FUNCTION [xpd].[SackMft$Verify](@mawbNbr char(11), @siteID int)
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	top(1) s.ID, MawbNbr 
	from	shpt.SackMft#Raw() s
	join	core.Matter#Raw()  m on m.PID=s.ID
	where	s.MawbNbr=@mawbNbr and  m.PosterID=@siteID
	order	by s.ID desc
)
GO
PRINT N'Adding schema binding to [core].[RefNbr#ScanOne]...';


GO
--PeterHo, Aaron
ALTER FUNCTION [core].[RefNbr#ScanOne]
(
	@number varchar(40), @minStage int=100, @maxStage int=25500
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteScaned as
	(
		select	Number,   MatterID, Type, Stage
		from	core.RefNbr#MatchOne(@number, @minStage, @maxStage)
		where	MatchedCnt=1
		union	all
		select	n.Number, MatterID, Type, Stage
		from	core.RefNbr#DecodeOne(@number) x
		cross	apply core.RefNbr#MatchOne(x.Number, @minStage, @maxStage) n
		where	MatchedCnt=1
	)
	select	top(1) Number,   MatterID, Type, Stage
	from	cteScaned
/*
	select	top(1) Number, MatterID, Type, Stage
	from	core.RefNbr#MatchOne(@number, @minStage, @maxStage)
	where	MatchedCnt=1
*/
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$ScanOne]...';


GO
-- Eason
ALTER FUNCTION [svc].[Parcel$ScanOne](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	r.Number
	from	core.RefNbr#MatchOne(@number, 1, 25500) x 
	cross	apply core.RefNbr#Type()              t
	join	core.RefNbr#Raw()                     r on r.MatterID=x.MatterID and r.Type=t.MIT
	where	MatchedCnt=1
)
GO
PRINT N'Altering [hub].[Parcel$ScanOneForTearOff]...';


GO
-- AaronLiu
ALTER FUNCTION [hub].[Parcel$ScanOneForTearOff](@number varchar(40))
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ID=MatterID, Type, Stage
	from	core.RefNbr#ScanOne(@number, default, default)
)
GO
PRINT N'Altering [zeb].[Parcel$ScanOne]...';


GO
-- AaronLiu
ALTER FUNCTION [zeb].[Parcel$ScanOne](@number varchar(40))
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Number, MatterID, Type, Stage
	from	core.RefNbr#ScanOne(@number, default, default)
)
GO
PRINT N'Altering [core].[Message#BodyOfLast]...';


GO
--Smile
ALTER FUNCTION [core].[Message#BodyOfLast](@regID int, @rowID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) Body=last_value(Body) over(order by (select 0)) 
	from	core.Message#Raw()
	where	RegID=@regID and RowID=@rowID
)
GO
PRINT N'Adding schema binding to [core].[Message#BodyOfLast]...';


GO
--Smile
ALTER FUNCTION [core].[Message#BodyOfLast](@regID int, @rowID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) Body=last_value(Body) over(order by (select 0)) 
	from	core.Message#Raw()
	where	RegID=@regID and RowID=@rowID
)
GO
PRINT N'Altering [core].[Message#Of]...';


GO
--PeterHo
ALTER FUNCTION [core].[Message#Of](@regID int, @rowID bigint, @auxID tinyint=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID=isnull(row_number() over (order by (select 0)), 0)
	,		RegID,    RowID,    AuxID,      Body
	,		PostedOn, PosterID, PosterAlias=u.Alias
	from	core.Message#Raw() x
	join	core.User#Raw()    u on u.ID=x.PosterID
	where	x.RegID=@regID and x.RowID=@rowID and (nullif(@auxID, 0) is null or x.AuxID=@auxID)
)
GO
PRINT N'Adding schema binding to [core].[Message#Of]...';


GO
--PeterHo
ALTER FUNCTION [core].[Message#Of](@regID int, @rowID bigint, @auxID tinyint=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID=isnull(row_number() over (order by (select 0)), 0)
	,		RegID,    RowID,    AuxID,      Body
	,		PostedOn, PosterID, PosterAlias=u.Alias
	from	core.Message#Raw() x
	join	core.User#Raw()    u on u.ID=x.PosterID
	where	x.RegID=@regID and x.RowID=@rowID and (nullif(@auxID, 0) is null or x.AuxID=@auxID)
)
GO
PRINT N'Adding schema binding to [core].[Message#Tvp]...';


GO
-- Aimee
ALTER FUNCTION core.Message#Tvp(@matterID bigint)
RETURNS TABLE
--, ENCRYPTION
WITH SCHEMABINDING
AS RETURN 
(
	with	cte(text) as
	(
		select	[text()] = concat(k.Many, x.AuxID, k.Quad, x.PosterAlias, k.Quad, x.PostedOn, k.Quad, x.Body)
		from	core.Registry#ID()    m
		cross	apply core.Message#Of(m.Matter, @matterID, default) x
		cross	apply tvp.Spr#Const() k
		for		xml path(N'')
	)
	select	Messages=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Altering [core].[Party#PNodeDn]...';


GO
--PeterHo
ALTER FUNCTION [core].[Party#PNodeDn](@partyID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePNode as
	(
		select	Level=0,       x.ID, x.PID, x.Type, x.Source, Alias=cast(x.Alias as nvarchar(max))
		from	core.Party#Raw() x
		where	x.ID=@partyID and @partyID>0
		UNION	ALL
		select	Level=Level+1, x.ID, x.PID, x.Type, x.Source, p.Alias + N'	/	' + x.Alias
		from	ctePNode p join core.Party#Raw() x
		on		x.PID=p.ID
	)
	select	Level =isnull(Level,   0)
	,		ID    =isnull(ID,      0)
	,		PID   =isnull(PID,     0)
	,		Type  =isnull(Type,    0)
	,		Source=isnull(Source,  0)
	,		Alias =isnull(Alias, N'')
	from	ctePNode
)
GO
PRINT N'Adding schema binding to [core].[Party#PNodeDn]...';


GO
--PeterHo
ALTER FUNCTION [core].[Party#PNodeDn](@partyID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePNode as
	(
		select	Level=0,       x.ID, x.PID, x.Type, x.Source, Alias=cast(x.Alias as nvarchar(max))
		from	core.Party#Raw() x
		where	x.ID=@partyID and @partyID>0
		UNION	ALL
		select	Level=Level+1, x.ID, x.PID, x.Type, x.Source, p.Alias + N'	/	' + x.Alias
		from	ctePNode p join core.Party#Raw() x
		on		x.PID=p.ID
	)
	select	Level =isnull(Level,   0)
	,		ID    =isnull(ID,      0)
	,		PID   =isnull(PID,     0)
	,		Type  =isnull(Type,    0)
	,		Source=isnull(Source,  0)
	,		Alias =isnull(Alias, N'')
	from	ctePNode
)
GO
PRINT N'Adding schema binding to [svc].[BizUnit$Lookup]...';


GO
--PeterHo
ALTER FUNCTION [svc].[BizUnit$Lookup]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Level, ID, PID, Type,  Source, Alias
	from	core.Party#Type()      k
	,		core.Party#PNodeDn(1)  x -- 1: Zebra HQ
	where	x.Type in (k.ZebraDiv, k.ZebraDept)
)
GO
PRINT N'Adding schema binding to [svc].[SalesRep$Lookup]...';


GO
--PeterHo
ALTER FUNCTION [svc].[SalesRep$Lookup]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Level, ID, PID, Type,  Source, Alias
	from	core.Party#Type()      k
	,		core.Party#PNodeDn(1)  x -- 1: Zebra HQ
	where	x.Type=k.SalesRep
)
GO
PRINT N'Altering [core].[Party#PNodeUp]...';


GO
--Smile
ALTER FUNCTION [core].[Party#PNodeUp](@partyID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePNode as
	(
		select	Level=0,       x.ID, x.PID, x.Type, x.Source, x.Alias 
		from	core.Party#Raw() x
		where	x.ID=@partyID and @partyID>0
		UNION	ALL
		select	Level=Level-1, x.ID, x.PID, x.Type, x.Source, x.Alias 
		from	ctePNode p join core.Party#Raw() x
		on		(p.PID>0 and x.ID=p.PID)
	)
	select	Level, ID, PID, Type, Source, Alias from ctePNode
)
GO
PRINT N'Adding schema binding to [core].[Party#PNodeUp]...';


GO
--Smile
ALTER FUNCTION [core].[Party#PNodeUp](@partyID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePNode as
	(
		select	Level=0,       x.ID, x.PID, x.Type, x.Source, x.Alias 
		from	core.Party#Raw() x
		where	x.ID=@partyID and @partyID>0
		UNION	ALL
		select	Level=Level-1, x.ID, x.PID, x.Type, x.Source, x.Alias 
		from	ctePNode p join core.Party#Raw() x
		on		(p.PID>0 and x.ID=p.PID)
	)
	select	Level, ID, PID, Type, Source, Alias from ctePNode
)
GO
PRINT N'Adding schema binding to [core].[RefParty#Deep]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefParty#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.MatterID,     x.PartyRole,    x.PartyID,        PartyAlias=p.Alias
	,		PartyPID=p.PID, PartyAID=p.AID, PartyType=p.Type, PartySource=p.Source
	from	core.RefParty#Raw() x join core.Party#Raw() p on p.ID=x.PartyID
)
GO
PRINT N'Adding schema binding to [svc].[CustomerCode$Vefity]...';


GO
--Smile
ALTER	FUNCTION [svc].[CustomerCode$Vefity](@userID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID=isnull(p.ID,0), p.Alias
	from	core.Party#Raw()        x
	cross	apply core.Party#Type() k
	join	core.Party#Raw()        p on p.Source=x.Source and p.Type=k.TenantSite
	where	x.ID=@userID
)
GO
PRINT N'Adding schema binding to [svc].[Ramper$List]...';


GO
--AaronLiu
ALTER FUNCTION [svc].[Ramper$List]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, x.Alias
	from	core.Party#Type() t, core.User#Raw() x
	join	core.Party#Raw()  p on x.ID=p.ID
	where	p.Type=t.Ramper
)
GO
PRINT N'Adding schema binding to [svc].[Tenancy$SiteVerify]...';


GO
--Aimee, Smile, Irene
ALTER FUNCTION [svc].[Tenancy$SiteVerify](@siteID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	SiteID=isnull(ID, 0)
	from	core.Party#Type() k, core.Party#Raw() x
	where	x.Type=k.TenantSite and x.ID=@siteID
)
GO
PRINT N'Adding schema binding to [svc].[Tenancy$TenantLookup]...';


GO
--Sam
ALTER FUNCTION [svc].[Tenancy$TenantLookup]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	p.ID, p.PID, p.AID, p.Type, p.Source, p.Alias 
	from	core.Party#Raw() p, core.Party#Type() t
	where	p.Type=t.Tenant
)
GO
PRINT N'Adding schema binding to [svc].[Tenancy$ZebraHubLookup]...';


GO
--Smile
ALTER FUNCTION [svc].[Tenancy$ZebraHubLookup]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	p.ID, p.PID, p.AID, p.Type, p.Source, p.Alias 
	from	core.Party#Raw() p, core.Party#Type() t
	where	p.Type=t.ZebraHub
)
GO
PRINT N'Adding schema binding to [svc].[Tenancy$ZebraStoreLookup]...';


GO
--Aimee
ALTER FUNCTION [svc].[Tenancy$ZebraStoreLookup]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	p.ID, p.PID, p.AID, p.Type, p.Source, p.Alias 
	from	core.Party#Raw() p, core.Party#Type() t
	where	p.Type=t.ZebraStore
)
GO
PRINT N'Adding schema binding to [tms].[SvcCharge#For]...';


GO
-- Daxia
ALTER FUNCTION [tms].[SvcCharge#For]
(
	@siteID     int, 
	@brokerID   int, 
	@poa        char(3),
	@chargeID   int,
	@vendorID   int=0
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	TenantID, BrokerID, POA,  ChargeID
		,		VendorID, Minimum,  Rate, CurrencyID
		from	tms.SvcCharge#Raw() x
		join	core.Party#Raw() p on p.ID=@siteID
		where	TenantID=p.PID and BrokerID=@brokerID and POA=@poa
		and		ChargeID=@chargeID and VendorID=@vendorID
		UNION	ALL
		select	TenantID, BrokerID, POA,  ChargeID
		,		VendorID, Minimum,  Rate, CurrencyID
		from	tms.SvcCharge#Raw()
		where	TenantID=0 and BrokerID=@brokerID and POA=@poa
		and		ChargeID=@chargeID and VendorID=@vendorID
	)
	select	top(1)    TenantID, BrokerID, POA,  ChargeID
	,		VendorID, Minimum,  Rate,     CurrencyID
	from	cte
)
GO
PRINT N'Adding schema binding to [tms].[SvcType#For]...';


GO
--PeterHo
ALTER FUNCTION [tms].[SvcType#For](@svcType int, @siteID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteMajor as
	(
		select	Major, Upto from tms.SvcType#Major(@svcType)
	)
	, cteCandidate as
	(
		select	t.ID, InitStateID, InitQueue, ClrMethodID, FallbackPOA
		from	cteMajor k, core.Party#Raw() x
		join	tms.SvcType#Raw() t on t.TenantID=x.PID
		where	x.ID=@siteID
		and		t.ID between k.Major and k.Upto
		UNION	ALL
		select	ID, InitStateID, InitQueue, ClrMethodID, FallbackPOA
		from	cteMajor k, tms.SvcType#Raw()
		where	ID=k.Major
	)
	select	top(1) ID, InitStateID, InitQueue, ClrMethodID, FallbackPOA from cteCandidate
)
/*
CREATE FUNCTION [tms].[SvcType#For](@svcType int, @tenantID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteMajor as
	(
		select	Major, Upto from tms.SvcType#Major(@svcType)
	)
	, cteCandidate as
	(
		select	ID, InitStateID, ClrMethodID, FallbackPOA
		from	cteMajor k, tms.SvcType#Raw()
		where	ID=@tenantID and ID between k.Major and k.Upto
		UNION	ALL
		select	ID, InitStateID, ClrMethodID, FallbackPOA
		from	cteMajor k, tms.SvcType#Raw()
		where	ID=k.Major
	)
	select	top(1) ID, InitStateID, ClrMethodID, FallbackPOA from cteCandidate
)
*/
GO
PRINT N'Adding schema binding to [whse].[StorageRate#For]...';


GO
--Smile
ALTER FUNCTION [whse].[StorageRate#For](@rcvHubID int, @siteID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	RcvHubID, TenantID, CurrencyID, RcvSkuFee, OutPkgFee
		,		OverWeightFee, WeightLimit, ExcessItemsFee, ItemsQtyLimit
		,		StorageCbmFee30Day, StorageCbmFee60Day, StorageCbmFeeOther
		from	core.Party#Raw()       x
		join	whse.StorageRate#Raw() t on t.TenantID=x.PID
		where	x.ID=@siteID
		UNION ALL
		select	RcvHubID, TenantID, CurrencyID, RcvSkuFee, OutPkgFee
		,		OverWeightFee, WeightLimit, ExcessItemsFee, ItemsQtyLimit
		,		StorageCbmFee30Day, StorageCbmFee60Day, StorageCbmFeeOther
		from	whse.StorageRate#Raw()
		where	RcvHubID=@rcvHubID 
	)
	select	top(1) RcvHubID, TenantID, CurrencyID, RcvSkuFee, OutPkgFee
	,		OverWeightFee, WeightLimit, ExcessItemsFee, ItemsQtyLimit
	,		StorageCbmFee30Day, StorageCbmFee60Day, StorageCbmFeeOther
	from	cte
)
GO
PRINT N'Adding schema binding to [core].[RefParty#Tvp]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefParty#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, PartyRole, k.Triad, PartyID, k.Triad, PartyAlias)
		from	tvp.Spr#Const() k, core.RefParty#Deep()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	RefParties=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Adding schema binding to [core].[Source#Rectify]...';


GO
--PeterHo
ALTER FUNCTION [core].[Source#Rectify](@source tinyint, @queueType tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Source=iif(@queueType>=t.BrokerApi, s.InfoPath, @source)
	from	core.Source#ID() s, core.Queue#Type() t
)
GO
PRINT N'Altering [core].[RefInfo#Of]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefInfo#Of](@matterID bigint, @type tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) Info
	from	core.RefInfo#Raw()
	where	MatterID=@matterID and Type=@type
)
GO
PRINT N'Adding schema binding to [core].[RefInfo#Of]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefInfo#Of](@matterID bigint, @type tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) Info
	from	core.RefInfo#Raw()
	where	MatterID=@matterID and Type=@type
)
GO
PRINT N'Adding schema binding to [core].[RefInfo#VerifiedOrDeclared]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefInfo#VerifiedOrDeclared](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) x.Info
	from	core.RefInfo#Type() k
	cross	apply
	(
		select	Info from core.RefInfo#Of(@matterID, k.VerifiedInfo)
		UNION	ALL
		select	Info from core.RefInfo#Of(@matterID, k.DeclaredInfo)
	) x
)
GO
PRINT N'Altering [zeb].[RefInfo$Of]...';


GO
-- Eva
ALTER FUNCTION [zeb].[RefInfo$Of](@matterID bigint, @type tinyint)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Info from core.RefInfo#Of(@matterID, @type)
)
GO
PRINT N'Adding schema binding to [core].[RefInfo#Tvp]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefInfo#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, Type, k.Duad, Info)
		from	tvp.Spr#Const() k, core.RefInfo#Raw()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	RefInfos=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Adding schema binding to [shpt].[IDNbr#Exists]...';


GO
--Smile
ALTER FUNCTION [shpt].[IDNbr#Exists](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteIDInfo as
	(
		select	IDNbr=t.v1
		from	core.RefInfo#Type() k, core.RefInfo#Raw() i
		cross	apply tvp.Tuplet#Of(i.Info, default)      t
		where	i.MatterID=@matterID and i.Type=k.IDInfo
	)
	select	HasIDNbr=iif(exists(select 0 from cteIDInfo where nullif(IDNbr, N'') is not null), true, false)
	from	dbo.Bool#Const()
)
GO
PRINT N'Altering [zeb].[RefInfo$Tvp]...';


GO
-- Eva
ALTER FUNCTION [zeb].[RefInfo$Tvp](@matterID bigint)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	RefInfos from core.RefInfo#Tvp(@matterID)
)
GO
PRINT N'Altering [core].[RefNbr#IdOfFirst]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefNbr#IdOfFirst](@number varchar(40), @type tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) MatterID
	from	core.RefNbr#Raw()
	where	Number=@number and Type=@type
)
GO
PRINT N'Adding schema binding to [core].[RefNbr#IdOfFirst]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefNbr#IdOfFirst](@number varchar(40), @type tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) MatterID
	from	core.RefNbr#Raw()
	where	Number=@number and Type=@type
)
GO
PRINT N'Altering [core].[RefNbr#IdOfLast]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefNbr#IdOfLast](@number varchar(40), @type tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) MatterID=last_value(MatterID) over (order by (select 0))
	from	core.RefNbr#Raw()
	where	Number=@number and Type=@type
)
GO
PRINT N'Adding schema binding to [core].[RefNbr#IdOfLast]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefNbr#IdOfLast](@number varchar(40), @type tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) MatterID=last_value(MatterID) over (order by (select 0))
	from	core.RefNbr#Raw()
	where	Number=@number and Type=@type
)
GO
PRINT N'Altering [core].[RefNbr#Of]...';


GO
-- AaronLiu
ALTER FUNCTION [core].[RefNbr#Of](@matterID I64, @type E8)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Number
	from	core.RefNbr#Raw()
	where	MatterID=@matterID and Type=@type
)
GO
PRINT N'Adding schema binding to [core].[RefNbr#Tvp]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefNbr#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, Type, k.Duad, Number)
		from	tvp.Spr#Const() k, core.RefNbr#Raw()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	RefNbrs=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Altering [zeb].[RefNbr$Tvp]...';


GO
-- Eva
ALTER FUNCTION [zeb].[RefNbr$Tvp](@matterID bigint)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	RefNbrs from core.RefNbr#Tvp(@matterID)
)
GO
PRINT N'Altering [core].[RefParty#Of]...';


GO
--AaronLiu
ALTER FUNCTION [core].[RefParty#Of](@matterID bigint, @partyRole tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) PartyID
	from	core.RefParty#Raw()
	where	MatterID=@matterID and PartyRole=@partyRole
)
GO
PRINT N'Adding schema binding to [core].[RefParty#Of]...';


GO
--AaronLiu
ALTER FUNCTION [core].[RefParty#Of](@matterID bigint, @partyRole tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) PartyID
	from	core.RefParty#Raw()
	where	MatterID=@matterID and PartyRole=@partyRole
)
GO
PRINT N'Altering [core].[RefStamp#Deep]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefStamp#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID,   StateID
	,		UtcTime,    x.UtcOffset
	,		UtcPlaceID, t.UtcPlace
	from	core.RefStamp#Raw() x
	join	core.Tenant#Raw()   t on t.ID=x.UtcPlaceID
)
GO
PRINT N'Adding schema binding to [core].[RefStamp#Deep]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefStamp#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID,   StateID
	,		UtcTime,    x.UtcOffset
	,		UtcPlaceID, t.UtcPlace
	from	core.RefStamp#Raw() x
	join	core.Tenant#Raw()   t on t.ID=x.UtcPlaceID
)
GO
PRINT N'Adding schema binding to [core].[RefStamp#Of]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefStamp#Of](@matterID bigint, @stateID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) UtcTime, UtcOffset, UtcPlaceID, UtcPlace
	from	core.RefStamp#Deep()
	where	MatterID=@matterID and StateID=@stateID
)
GO
PRINT N'Adding schema binding to [core].[RefStamp#Tvp]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefStamp#Tvp](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, StateID, k.Duad
		,		UtcTime, k.Trio, UtcOffset, k.Trio, UtcPlaceID, k.Duo, UtcPlace)
		from	tvp.Spr#Const() k, core.RefStamp#Deep()
		where	MatterID=@matterID
		for		xml path(N'')
	)
	select	RefStamps=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Altering [core].[RoleID#Tvp]...';


GO
-- Eva, PeterHo
ALTER FUNCTION [core].[RoleID#Tvp](@userID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte (text) as
	(
		select	[text()]=concat(N',', RoleID)
		from	core._UserRole
		where	UserID=@userID
		for		xml path(N'')
	)
	select	RoleIDs=Tvp from cte cross apply tvp.Spr#Purify(text, 1)
)
GO
PRINT N'Adding schema binding to [core].[RoleID#Tvp]...';


GO
-- Eva, PeterHo
ALTER FUNCTION [core].[RoleID#Tvp](@userID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte (text) as
	(
		select	[text()]=concat(N',', RoleID)
		from	core._UserRole
		where	UserID=@userID
		for		xml path(N'')
	)
	select	RoleIDs=Tvp from cte cross apply tvp.Spr#Purify(text, 1)
)
GO
PRINT N'Adding schema binding to [core].[Transition#Tobe]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Transition#Tobe](@onStateID int, @roleID int, @actionID int, @rejoinID int=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteTransition as
	(
		select	ToStateID=iif(ToStateID=-1, @rejoinID, ToStateID), TodoHours, OutboundQ
		from	core.Transition#Raw()
		where	(OnStateID=@onStateID and RoleID=@roleID and ActionID=@actionID)
	)
	select	ToStage=s.Stage, ToStateID, TodoHours, OutboundQ
	from	cteTransition x join core.State#Raw() s on s.ID=x.ToStateID
/*
	select	ToStage=s.Stage, ToStateID, TodoHours, OutboundQ
	from	core.Transition#Raw() x
	join	core.State#Raw() s on s.ID=x.ToStateID
	where	(OnStateID=@onStateID and RoleID=@roleID and ActionID=@actionID)
*/
)
GO
PRINT N'Adding schema binding to [svc].[Batch$Summary]...';


GO
--PeterHo
ALTER FUNCTION [svc].[Batch$Summary](@siteID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with cteSummary as
	(
		select	x.ID, x.BatchedOn, x.ErrorCnt, t.UtcOffset
		,		FailureCnt=isnull(count(case when p.SvcZone=0 then 1        end), 0)
	--	,		FailureWt =isnull(sum  (case when p.SvcZone=0 then p.Weight end), 0)
		,		SuccessCnt=isnull(count(case when p.SvcZone>0 then 1        end), 0)
	--	,		SuccessWt =isnull(sum  (case when p.SvcZone>0 then p.Weight end), 0)
		from	shpt.Batch#Raw()  x
		join	core.Tenant#Raw() t on t.ID=x.SiteID
		join	shpt.Parcel#Raw() p on p.BatchID=x.ID
		where	x.SiteID=@siteID
		group	by x.ID, x.ErrorCnt, x.BatchedOn, t.UtcOffset
	)
	select	ID, ErrorCnt, FailureCnt, SuccessCnt, BatchedOn=l.LocalTime
	from	cteSummary cross apply dbo.DT#ToLocal(BatchedOn, UtcOffset) l
)
GO
PRINT N'Adding schema binding to [svc].[Sku$ForEndorsement]...';


GO
--SmileWang, PeterHo
ALTER FUNCTION [svc].[Sku$ForEndorsement](@clrMethodID int, @brokerID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, TenantID, Alias, SkuNbr, FiledInfo
	,		IsEndorsed=iif(d.DutyID is null, 0, 1)
	from	invt.Sku#Raw()    x
	join	core.Tenant#Raw() t on t.ID=x.TenantID
	left	join invt.SkuBrokerage#Raw() d
	on		d.SkuID=x.ID and d.ClrMethodID=@clrMethodID and d.BrokerID=@brokerID
)
GO
PRINT N'Altering [core].[Todo#For]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Todo#For](@userID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	t.RoleID, ActionID, ToSource
	,		FirstDue=min(DueOn)
	,		TotalCnt=isnull(count(distinct MatterID), 0)
	from	core._UserRole  x
	join	core.Todo#Raw() t on t.RoleID=x.RoleID
	where	x.UserID=@userID
	group	by t.RoleID, ActionID, ToSource
)
GO
PRINT N'Adding schema binding to [core].[Todo#For]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Todo#For](@userID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	t.RoleID, ActionID, ToSource
	,		FirstDue=min(DueOn)
	,		TotalCnt=isnull(count(distinct MatterID), 0)
	from	core._UserRole  x
	join	core.Todo#Raw() t on t.RoleID=x.RoleID
	where	x.UserID=@userID
	group	by t.RoleID, ActionID, ToSource
)
GO
PRINT N'Altering [core].[Transition#Debug]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Transition#Debug]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	OnStateID, OnState=o.Name
	,		RoleID,    Role   =r.Name
	,		ActionID,  Action =a.Name, LoopEntryID
	,		ToStateID, ToState=t.Name
	,		OutboundQ, TodoHours
	from	core.Transition#Raw() x
	join	core._State  o on o.ID=x.OnStateID
	join	core._State  t on t.ID=x.ToStateID
	join	core._Action a on a.ID=x.ActionID
	join	core._Role   r on r.ID=x.RoleID
)
GO
PRINT N'Adding schema binding to [core].[Transition#Debug]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Transition#Debug]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	OnStateID, OnState=o.Name
	,		RoleID,    Role   =r.Name
	,		ActionID,  Action =a.Name, LoopEntryID
	,		ToStateID, ToState=t.Name
	,		OutboundQ, TodoHours
	from	core.Transition#Raw() x
	join	core._State  o on o.ID=x.OnStateID
	join	core._State  t on t.ID=x.ToStateID
	join	core._Action a on a.ID=x.ActionID
	join	core._Role   r on r.ID=x.RoleID
)
GO
PRINT N'Adding schema binding to [core].[Transition#Todo]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Transition#Todo](@onStateID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, RoleID, k.Duad, ActionID)
		from	tvp.Spr#Const() k, core.Transition#Raw()
		where	OnStateID=@onStateID and RoleID>0
		for		xml path(N'')
	)
	select	RoledActions=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Adding schema binding to [core].[UserRole#Tvp]...';


GO
-- Smile
ALTER FUNCTION [core].[UserRole#Tvp](@userID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteTvp(text) as
	(
		select	[text()]=concat( N',', x.RoleID)
		from	core.UserRole#Raw() x
		where	x.UserID=@userID
		for	xml path(N'')
	)
	select	Tvp from cteTvp cross apply tvp.Spr#Purify(text, 1)
)
GO
PRINT N'Altering [dbo].[Bit#Wise]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Bit#Wise]()
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS
RETURN 
(
	select	[Bit]=isnull(cast(Nbr as tinyint), 0)
	,		[Val]=isnull(power(cast(2 as bigint), cast(Nbr-1 as float)), cast(0 as bigint))
	from	dbo.Nbr#Emit(63)
)
GO
PRINT N'Adding schema binding to [dbo].[Bit#Wise]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Bit#Wise]()
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS
RETURN 
(
	select	[Bit]=isnull(cast(Nbr as tinyint), 0)
	,		[Val]=isnull(power(cast(2 as bigint), cast(Nbr-1 as float)), cast(0 as bigint))
	from	dbo.Nbr#Emit(63)
)
GO
PRINT N'Adding schema binding to [dbo].[DT#Of]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[DT#Of](@value datetime2(2), @against datetime2(2)='')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	with cteArg  as
	(
		select	[Value]  =nullif(@value,   '1900-01-01')
		,		[Against]=nullif(@against, '1900-01-01')
	)
	, cteFact as
	(
		select	[Value]  =isnull(Value, Empty)
		,		[Date]   =isnull(cast(Value as date), Empty)
		,		[Time]   =isnull(cast(Value as time(0)), '')
		,		[Against]=isnull(Against, Now)
		,		Now, Today, Empty, Infinity, NilTick
		from	cteArg, dbo.DT#Const()
	)
	, ctePredicate as
	(
		select	Value, Date, Time
		,		[IsPM]      =iif(Time>'12:00:00', true, false)
		,		[IsEmpty]   =iif(Date=Empty,      true, false)
		,		[IsInfinity]=iif(Date=Infinity,   true, false)
		,		[IsTruthy]  =iif(Date=Empty or Date=Infinity, false, true)
		,		Now, Today, Empty, Infinity, NilTick, Against
		from	cteFact, dbo.Bool#Const()
	)
	, cteAged as
	(
		select	Value, Date, Time, IsPM, IsEmpty, IsInfinity, IsTruthy
		,		[DayAge] =isnull(iif(IsTruthy=0, 0, datediff(dd, Value, Against)), 0)
		,		[HourAge]=isnull(iif(IsTruthy=0, 0, datediff(hh, Value, Against)), 0)
		,		Now, Today, Empty, Infinity, NilTick, Against
		from	ctePredicate
	)
	select	Value, Date, Time, IsPM, IsEmpty, IsInfinity, IsTruthy, DayAge, HourAge
	,		[DaySpan] =isnull(HourAge / 24, 0)
	,		[HourSpan]=isnull(HourAge % 24, 0)
	,		[FallbackNow]     =iif(IsTruthy=0, Now,      Value)
	,		[FallbackToday]   =iif(IsTruthy=0, Today,    Value)
	,		[FallbackAgainst] =iif(IsTruthy=0, Against,  Value)
	,		[FallbackInfinity]=iif(IsTruthy=0, Infinity, Value)
	,		Now, Today, Empty, Infinity, NilTick
	from	cteAged
)
GO
PRINT N'Altering [dbo].[Calendar#Of]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Calendar#Of] (@value date)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
    with cteArg as (select [Value]=isnull(@value, Anchor), Anchor from dbo.DT#Const())
    , cteOffset as
    (
        select	Value,   Anchor
        ,		[Year]   =isnull(  datepart(yy, Value), 0)
        ,		[Quarter]=isnull(  datepart(qq, Value), 0)
        ,		[Month]  =isnull(  datepart(mm, Value), 0)
        ,       [Week]   =isnull(  datepart(ww, Value), 0)
        ,		[Day]    =isnull(  datepart(dd, Value), 0)
        ,		[Dow]    =isnull(((datepart(dw, Value)+5)%7)+1, 0)
        ,		[YOffset]=isnull(  datediff(yy, Anchor, Value), 0)
        ,		[QOffset]=isnull(  datediff(qq, Anchor, Value), 0)
        ,		[MOffset]=isnull(  datediff(mm, Anchor, Value), 0)
        ,		[WOffset]=isnull(  datediff(ww, Anchor, Value), 0)
        ,		[DOffset]=isnull(  datediff(dd, Anchor, Value), 0)
        from	cteArg
    )
    , cteRange as
    (
        select	Value
        ,		Year,    Quarter, Month,   Week,    Day,Dow
        ,		YOffset, QOffset, MOffset, WOffset, DOffset
        ,		[BOMonth]=isnull(dateadd(mm, MOffset, Anchor), '')
        ,		[BOWeek] =isnull(dateadd(ww, WOffset, Anchor), '')
        from	cteOffset
    )
    select	Value
    ,		Year,    Quarter, Month,   Week,    Day,Dow
    ,		YOffset, QOffset, MOffset, WOffset, DOffset
    ,		BOMonth, [EOMonth]=isnull(dateadd(dd, -1, dateadd(mm, 1, BOMonth)), '')
    ,		BOWeek,  [EOWeek] =isnull(dateadd(dd,  6, BOWeek), '')
    ,		[BONextMonth]=isnull(dateadd(mm, 1, BOMonth), '')
    ,		[BONextWeek] =isnull(dateadd(dd, 7, BOWeek),  '')
    from	cteRange
)
GO
PRINT N'Adding schema binding to [dbo].[Calendar#Of]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Calendar#Of] (@value date)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
    with cteArg as (select [Value]=isnull(@value, Anchor), Anchor from dbo.DT#Const())
    , cteOffset as
    (
        select	Value,   Anchor
        ,		[Year]   =isnull(  datepart(yy, Value), 0)
        ,		[Quarter]=isnull(  datepart(qq, Value), 0)
        ,		[Month]  =isnull(  datepart(mm, Value), 0)
        ,       [Week]   =isnull(  datepart(ww, Value), 0)
        ,		[Day]    =isnull(  datepart(dd, Value), 0)
        ,		[Dow]    =isnull(((datepart(dw, Value)+5)%7)+1, 0)
        ,		[YOffset]=isnull(  datediff(yy, Anchor, Value), 0)
        ,		[QOffset]=isnull(  datediff(qq, Anchor, Value), 0)
        ,		[MOffset]=isnull(  datediff(mm, Anchor, Value), 0)
        ,		[WOffset]=isnull(  datediff(ww, Anchor, Value), 0)
        ,		[DOffset]=isnull(  datediff(dd, Anchor, Value), 0)
        from	cteArg
    )
    , cteRange as
    (
        select	Value
        ,		Year,    Quarter, Month,   Week,    Day,Dow
        ,		YOffset, QOffset, MOffset, WOffset, DOffset
        ,		[BOMonth]=isnull(dateadd(mm, MOffset, Anchor), '')
        ,		[BOWeek] =isnull(dateadd(ww, WOffset, Anchor), '')
        from	cteOffset
    )
    select	Value
    ,		Year,    Quarter, Month,   Week,    Day,Dow
    ,		YOffset, QOffset, MOffset, WOffset, DOffset
    ,		BOMonth, [EOMonth]=isnull(dateadd(dd, -1, dateadd(mm, 1, BOMonth)), '')
    ,		BOWeek,  [EOWeek] =isnull(dateadd(dd,  6, BOWeek), '')
    ,		[BONextMonth]=isnull(dateadd(mm, 1, BOMonth), '')
    ,		[BONextWeek] =isnull(dateadd(dd, 7, BOWeek),  '')
    from	cteRange
)
GO
PRINT N'Adding schema binding to [dbo].[Calendar#Today]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Calendar#Today] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Value
	,		Year,    Quarter, Month,   Week,    Day,Dow
	,		YOffset, QOffset, MOffset, WOffset, DOffset
	from	dbo.Calendar#Of(getutcdate())
)
GO
PRINT N'Adding schema binding to [dbo].[Money#CNY]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Money#CNY](@decAmt float)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	CurrencyID=CNY, Amt, RawAmt
	from	dbo.Currency#ID()
	cross	apply dbo.Money#Make(@decAmt, CNY)
)
GO
PRINT N'Adding schema binding to [dbo].[Money#USD]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Money#USD](@decAmt float)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	CurrencyID=USD, Amt, RawAmt
	from	dbo.Currency#ID()
	cross	apply dbo.Money#Make(@decAmt, USD)
)
GO
PRINT N'Adding schema binding to [tms].[SvcCost#ByFactor]...';


GO
--Daxia
ALTER FUNCTION [tms].[SvcCost#ByFactor]
(
	@contractID    int,
	--@onZoneCode3   char(3), 
	@hubID         int,
	@toZoneCode3   char(3), 
	@toPlus2       char(2), 
	@svcClass      tinyint, 
	@measuredWt    real
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
		with cteRate as
		(
			select	DecAmt=iif(@measuredWt>453.592, x.HandlingFeeLB, x.HandlingFeeOZ)
					+(c.Cost * (1 + x.FuelSurchargeRatio)
							 * (1 + choose(z.Zone
								, x.Factor1, x.Factor2, x.Factor3
								, x.Factor4, x.Factor5, x.Factor6
								, x.Factor7, x.Factor8, x.Factor9)))
					+(isnull(a.AreaSurcharge, 0) * (1 + x.FuelSurchargeRatio))
			from	tms._SvcFactor     x
			join	tms.SvcClass#Raw() s on s.ID=x.SvcClass
			join	tms._SvcZone       z on z.OnZoneCode3=x.OnZoneCode3 and z.ToZoneCode3=@toZoneCode3 and z.CourierID=s.CourierID
			cross	apply
			(
				select	top(1) Cost=SvcCost from tms._SvcCost
				where	SvcClass=@svcClass and Zone=z.Zone and SectionWt>=@measuredWt
			) c
			outer	apply
			(
				select	AreaSurcharge from tms._AreaSurcharge
				where	ZoneCode=cast(@toZoneCode3+@toPlus2 as char(5))
			) a
			where	x.ContractID=@contractID and SvcClass=@svcClass and x.RcvHubID=@hubID
		)
		select	m.CurrencyID, m.Amt, m.RawAmt, x.DecAmt
		from	cteRate x cross apply dbo.Money#USD(x.DecAmt) m
)
GO
PRINT N'Altering [hub].[RackOutOrder$ListFor]...';


GO
-- Smile
ALTER FUNCTION [hub].[RackOutOrder$ListFor](@userID int, @orderID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	ID=ParcelID, ParcelNbr=format(ParcelID %1000000, '000000')
	,		RackID,      RackCode=a.Code
	from	whse.RackOrder#Raw() x
	join	shpt.RackXact#Raw()  r on x.ID=r.OrderOutID
	join	whse.Rack#Raw()      a on a.ID=r.RackID
	where	x.RackerID=@userID and x.ID=@orderID

)
GO
PRINT N'Adding schema binding to [hub].[RackOutOrder$ListFor]...';


GO
-- Smile
ALTER FUNCTION [hub].[RackOutOrder$ListFor](@userID int, @orderID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	ID=ParcelID, ParcelNbr=format(ParcelID %1000000, '000000')
	,		RackID,      RackCode=a.Code
	from	whse.RackOrder#Raw() x
	join	shpt.RackXact#Raw()  r on x.ID=r.OrderOutID
	join	whse.Rack#Raw()      a on a.ID=r.RackID
	where	x.RackerID=@userID and x.ID=@orderID

)
GO
PRINT N'Altering [hub].[Trucker$List]...';


GO
-- AaronLiu
ALTER FUNCTION [hub].[Trucker$List]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Alias
	from	tms.Trucker#Raw()
)
GO
PRINT N'Adding schema binding to [hub].[Trucker$List]...';


GO
-- AaronLiu
ALTER FUNCTION [hub].[Trucker$List]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, Alias
	from	tms.Trucker#Raw()
)
GO
PRINT N'Altering [loc].[GoodsInfo#Of]...';


GO
-- PeterHo
ALTER FUNCTION [loc].[GoodsInfo#Of](@info nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Name       =v1
	,		Brand      =v2
	,		Model      =v3
	,		Spec       =v4
	,		Sku        =v5 
	,		SkuBatch   =v6
	,		Condition  =v7, v8, v9
	from	tvp.Tuplet#Of(@info, default)
)
GO
PRINT N'Adding schema binding to [loc].[GoodsInfo#Of]...';


GO
-- PeterHo
ALTER FUNCTION [loc].[GoodsInfo#Of](@info nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Name       =v1
	,		Brand      =v2
	,		Model      =v3
	,		Spec       =v4
	,		Sku        =v5 
	,		SkuBatch   =v6
	,		Condition  =v7, v8, v9
	from	tvp.Tuplet#Of(@info, default)
)
GO
PRINT N'Adding schema binding to [tms].[SvcClass#For]...';


GO
-- Eason, Smile
ALTER FUNCTION [tms].[SvcClass#For](@svcType int, @weight real)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	SvcType, SvcClass=c.ID
		from	tms.SvcType#Raw()  x
		join	tms.SvcRoute#Raw() s on s.SvcType=x.ID
		join	tms.Route#Raw()    r on r.ID=s.RouteID
		join	tms.SvcClass#Raw() c on c.CourierID=r.CourierID
		where	SvcType=@svcType and @weight<c.MaxWeight and UseFactor=1
		UNION	ALL
		select	isnull(@svcType, 0), 0
	)
	select	top(1) SvcType, SvcClass from cte	
)
GO
PRINT N'Adding schema binding to [tms].[SvcRoute#For]...';


GO
--PeterHo
ALTER FUNCTION [tms].[SvcRoute#For](@svcType int, @poa char(3))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	top(1) POA, Priority, RouteID, r.CourierID
	from	tms.SvcType#Major(@svcType) m
	,		tms.SvcRoute#Raw() s
	join	tms.Route#Raw()    r on r.ID=s.RouteID
	where	SvcType=m.Major and POA=@poa
)
GO
PRINT N'Adding schema binding to [tms].[SvcFacility#ZoneCode]...';


GO
-- Daxia
ALTER FUNCTION [tms].[SvcFacility#ZoneCode] ()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ZoneCode,       x.FacilityID,   f.CourierID, f.SourceID
	,		f.ImportZoneCode, f.ImportZip3,   f.POA
	,		f.MailerID,       f.FacilityInfo, f.TokenID
	,		f.ShprInfo,       f.CneeInfo,     f.ReturnInfo
	from	tms.SvcFacZoneCode#Raw() x
	join	tms.SvcFacility#Raw()   f on f.ID=x.FacilityID
)
GO
PRINT N'Altering [tvp].[Bag#Slice]...';


GO
--PeterHo:
ALTER FUNCTION [tvp].[Bag#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, Piece from tvp.Pcs#Slice(@source, N'	{	')
)
GO
PRINT N'Adding schema binding to [tvp].[Bag#Slice]...';


GO
--PeterHo:
ALTER FUNCTION [tvp].[Bag#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, Piece from tvp.Pcs#Slice(@source, N'	{	')
)
GO
PRINT N'Altering [tvp].[Cell#Slice]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Cell#Slice]
(
	@source nvarchar(max)
,	@colSpr nvarchar(255)=N'	%	'
,	@rowSpr nvarchar(255)=N'	;	'
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[Col]=c.Seq, [Row]=r.Seq, [Val]=c.Piece
	from	tvp.Pcs#Slice(@source, @rowSpr)       r
	cross	apply tvp.Pcs#Slice(r.Piece, @colSpr) c
)
GO
PRINT N'Adding schema binding to [tvp].[Cell#Slice]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Cell#Slice]
(
	@source nvarchar(max)
,	@colSpr nvarchar(255)=N'	%	'
,	@rowSpr nvarchar(255)=N'	;	'
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	[Col]=c.Seq, [Row]=r.Seq, [Val]=c.Piece
	from	tvp.Pcs#Slice(@source, @rowSpr)       r
	cross	apply tvp.Pcs#Slice(r.Piece, @colSpr) c
)
GO
PRINT N'Altering [tvp].[Comma#Slice]...';


GO
--PeterHo: 4/1
ALTER FUNCTION [tvp].[Comma#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, Piece from tvp.Pcs#Slice(@source, N',')
)
GO
PRINT N'Adding schema binding to [tvp].[Comma#Slice]...';


GO
--PeterHo: 4/1
ALTER FUNCTION [tvp].[Comma#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, Piece from tvp.Pcs#Slice(@source, N',')
)
GO
PRINT N'Altering [tvp].[Dozen#Of]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Dozen#Of] (@value nvarchar(max), @spr nvarchar(255)=N'	+	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select  v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
	from    tvp.Pcs#Of(12, @value, @spr)
)
GO
PRINT N'Adding schema binding to [tvp].[Dozen#Of]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Dozen#Of] (@value nvarchar(max), @spr nvarchar(255)=N'	+	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select  v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
	from    tvp.Pcs#Of(12, @value, @spr)
)
GO
PRINT N'Adding schema binding to [tvp].[Dozen#Slice]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Dozen#Slice]
(
	@source nvarchar(max), @valueSpr nvarchar(255)=N'	+	', @sourceSpr nvarchar(255)=N'	,	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
	from	tvp.Pcs#Slice(@source, @sourceSpr)
	cross   apply tvp.Dozen#Of(Piece, @valueSpr)
)
GO
PRINT N'Adding schema binding to [tvp].[Duad#Slice]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Duad#Slice]
(
	@source nvarchar(max), @valueSpr nvarchar(255)=N'	^	', @sourceSpr nvarchar(255)=N'	,	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Seq, v1, v2
	from	tvp.Pcs#Slice(@source, @sourceSpr)
	cross	apply tvp.Duad#Of(Piece, @valueSpr)
)
GO
PRINT N'Adding schema binding to [tvp].[Quad#Of]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Quad#Of](@value nvarchar(max),  @spr nvarchar(255)=N'	-	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.v1, x.v2, [v3]=p.v1, [v4]=p.v2
	from	tvp.Triad#Of(@value, @spr) x
	cross	apply tvp.Duad#Of(x.v3, @spr) p
)
GO
PRINT N'Adding schema binding to [tvp].[Newline#OfQuad]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Newline#OfQuad](@value nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	v1, v2, v3, v4
	from	tvp.Quad#Of(@value, cast(char(13)+char(10) as nvarchar(255)))
)
GO
PRINT N'Adding schema binding to [tvp].[Quad#Slice]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Quad#Slice]
(
	@source nvarchar(max), @valueSpr nvarchar(255)=N'	-	', @sourceSpr nvarchar(255)=N'	,	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Seq, v1, v2, v3, v4
	from	tvp.Pcs#Slice(@source, @sourceSpr)
	cross	apply tvp.Quad#Of(Piece, @valueSpr)
)
GO
PRINT N'Adding schema binding to [tvp].[Triad#Slice]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Triad#Slice]
(
	@source nvarchar(max), @valueSpr nvarchar(255)=N'	|	', @sourceSpr nvarchar(255)=N'	,	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Seq, v1, v2, v3
	from	tvp.Pcs#Slice(@source, @sourceSpr)
	cross	apply tvp.Triad#Of(Piece, @valueSpr)
)
GO
PRINT N'Altering [tvp].[Field#Of]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Field#Of](@value nvarchar(max), @spr nvarchar(255)=N'	$	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	 v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9, v10, v11, v12, v13, v14, v15, v16,
			v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32,
			v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48,
			v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64,
			v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80,
			v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95, v96,
			v97, v98, v99
	from    tvp.Pcs#Of(99, @value, @spr)
)
GO
PRINT N'Adding schema binding to [tvp].[Field#Of]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Field#Of](@value nvarchar(max), @spr nvarchar(255)=N'	$	')
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	 v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9, v10, v11, v12, v13, v14, v15, v16,
			v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32,
			v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48,
			v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64,
			v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80,
			v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95, v96,
			v97, v98, v99
	from    tvp.Pcs#Of(99, @value, @spr)
)
GO
PRINT N'Adding schema binding to [tvp].[Field#Slice]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Field#Slice]
(
	@source nvarchar(max), @valueSpr nvarchar(255)=N'	$	', @sourceSpr nvarchar(255)=N'	;	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq
	,		 v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9, v10, v11, v12, v13, v14, v15, v16
	,		v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32
	,		v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48
	,		v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64
	,		v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80
	,		v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95, v96
	,		v97, v98, v99
	from	tvp.Pcs#Slice(@source, @sourceSpr)
	cross	apply tvp.Field#Of(Piece, @valueSpr)
)
GO
PRINT N'Altering [tvp].[I32#Join]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[I32#Join] (@array dbo.I32Array readonly)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(N',', ID) from @array for xml path(N'')
	)
	select	Tvp from cte cross apply tvp.Spr#Purify(text, 1)
)
GO
PRINT N'Adding schema binding to [tvp].[I32#Join]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[I32#Join] (@array dbo.I32Array readonly)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(N',', ID) from @array for xml path(N'')
	)
	select	Tvp from cte cross apply tvp.Spr#Purify(text, 1)
)
GO
PRINT N'Altering [tvp].[I32#Slice]...';


GO
--PeterHo: 4/1
ALTER FUNCTION [tvp].[I32#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, [ID]=cast(Piece as int)
	from	tvp.Pcs#Slice(@source, N',')
)
GO
PRINT N'Adding schema binding to [tvp].[I32#Slice]...';


GO
--PeterHo: 4/1
ALTER FUNCTION [tvp].[I32#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, [ID]=cast(Piece as int)
	from	tvp.Pcs#Slice(@source, N',')
)
GO
PRINT N'Altering [tvp].[I64#Join]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[I64#Join] (@array dbo.I64Array readonly)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(N',', ID) from @array for xml path(N'')
	)
	select	Tvp from cte cross apply tvp.Spr#Purify(text, 1)
)
GO
PRINT N'Adding schema binding to [tvp].[I64#Join]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[I64#Join] (@array dbo.I64Array readonly)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(N',', ID) from @array for xml path(N'')
	)
	select	Tvp from cte cross apply tvp.Spr#Purify(text, 1)
)
GO
PRINT N'Altering [tvp].[I64#Slice]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[I64#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, ID=cast(Piece as bigint)
	from	tvp.Pcs#Slice(@source, N',')
)
GO
PRINT N'Adding schema binding to [tvp].[I64#Slice]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[I64#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, ID=cast(Piece as bigint)
	from	tvp.Pcs#Slice(@source, N',')
)
GO
PRINT N'Altering [tvp].[I64Seqs#Join]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[I64Seqs#Join] (@idSeqs dbo.I64Seqs readonly)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, Seq, k.Duad, ID)
		from	tvp.Spr#Const() k, @idSeqs
		for xml path(N'')
	)
	select	Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Adding schema binding to [tvp].[I64Seqs#Join]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[I64Seqs#Join] (@idSeqs dbo.I64Seqs readonly)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, Seq, k.Duad, ID)
		from	tvp.Spr#Const() k, @idSeqs
		for xml path(N'')
	)
	select	Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Altering [tvp].[Many#Slice]...';


GO
--PeterHo: 4/1
ALTER FUNCTION [tvp].[Many#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, Piece from tvp.Pcs#Slice(@source, N'	,	')
)
GO
PRINT N'Adding schema binding to [tvp].[Many#Slice]...';


GO
--PeterHo: 4/1
ALTER FUNCTION [tvp].[Many#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, Piece from tvp.Pcs#Slice(@source, N'	,	')
)
GO
PRINT N'Altering [tvp].[Mucho#Slice]...';


GO
--PeterHo:
ALTER FUNCTION [tvp].[Mucho#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, Piece from tvp.Pcs#Slice(@source, N'	[	')
)
GO
PRINT N'Adding schema binding to [tvp].[Mucho#Slice]...';


GO
--PeterHo:
ALTER FUNCTION [tvp].[Mucho#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, Piece from tvp.Pcs#Slice(@source, N'	[	')
)
GO
PRINT N'Refreshing [loc].[Declared$ToBrokerage]...';


GO
EXECUTE sp_refreshsqlmodule N'[loc].[Declared$ToBrokerage]';


GO
PRINT N'Altering [tvp].[Newline#Slice]...';


GO
--PeterHo: 4/1
ALTER FUNCTION [tvp].[Newline#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, Piece
	from	tvp.Pcs#Slice(@source, cast(char(13)+char(10) as nvarchar(255)))
)
GO
PRINT N'Adding schema binding to [tvp].[Newline#Slice]...';


GO
--PeterHo: 4/1
ALTER FUNCTION [tvp].[Newline#Slice](@source NVARCHAR (MAX))
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, Piece
	from	tvp.Pcs#Slice(@source, cast(char(13)+char(10) as nvarchar(255)))
)
GO
PRINT N'Adding schema binding to [tvp].[Pcs#SliceV]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Pcs#SliceV]
(
	@index		int,
	@source		nvarchar(max),
	@blockSpr	nvarchar(255)=N'	%	',
	@sourceSpr	nvarchar(255)=N'	;	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select  Seq, b.Piece
	from	tvp.Pcs#Slice(@source, @sourceSpr) s
	cross	apply tvp.Pcs#At(@index, s.Piece, @blockSpr) b

--	select  Seq=row_number() over (order by (select null)), b.Piece
--	from	tvp.NAX#Slice(@source, @sourceSpr) s
--	cross	apply tvp.Pcs#At(@index, s.Piece, @blockSpr) b
)
GO
PRINT N'Adding schema binding to [tvp].[Quire#Slice]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Quire#Slice]
(
	@source nvarchar(max), @valueSpr nvarchar(255)=N'	#	', @sourceSpr nvarchar(255)=N'	,	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq
	,		 v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9, v10, v11, v12
	,		v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24
	from	tvp.Pcs#Slice(@source, @sourceSpr)
	cross	apply tvp.Quire#Of(Piece, @valueSpr)
)
GO
PRINT N'Adding schema binding to [tvp].[Tuplet#Slice]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Tuplet#Slice]
(
	@source nvarchar(max), @valueSpr nvarchar(255)=N'	*	', @sourceSpr nvarchar(255)=N'	,	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	Seq, v1, v2, v3, v4, v5, v6, v7, v8, v9
	from	tvp.Pcs#Slice(@source, @sourceSpr)
	cross	apply tvp.Tuplet#Of(Piece, @valueSpr)
)
GO
PRINT N'Altering [tvp].[Pcs#SliceR]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Pcs#SliceR](@source nvarchar(max), @spr nvarchar(255)=N'	;	', @upto int=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Seq, Start, Stop
	,		[Length]=isnull(Stop-Start, 0) 
	,		[Piece] =isnull(substring(@source, Start, Stop-Start), cast(N'' as nvarchar(max)))
	from	tvp.Pcs#TallyR(@source, @spr, @upto)
--	option	(maxrecursion 0)
)
GO
PRINT N'Adding schema binding to [tvp].[Pcs#SliceR]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Pcs#SliceR](@source nvarchar(max), @spr nvarchar(255)=N'	;	', @upto int=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Seq, Start, Stop
	,		[Length]=isnull(Stop-Start, 0) 
	,		[Piece] =isnull(substring(@source, Start, Stop-Start), cast(N'' as nvarchar(max)))
	from	tvp.Pcs#TallyR(@source, @spr, @upto)
--	option	(maxrecursion 0)
)
GO
PRINT N'Adding schema binding to [svc].[Invoice$ProcessingList]...';


GO
--Smile
ALTER FUNCTION [svc].[Invoice$ProcessingList](@source tinyint, @vaultTag tinyint, @partyID int, @bizUnitID int, @issueDate datetime2(2))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with	cteLedgerGroup as
	(
		select	l.PartyID, x.SourceID, p.ContractID, l.CurrencyID, g.VaultTag
		,		IssueDate=iif(BillingCycle%7=0, cd.BOWeek, cd.BOMonth)
		,		l.ChargeRaw, LastInvoiceDate=isnull(i.LastInvoiceDate, dbo.DT@Empty())
		,		l.TalliedOn, BillingCycle
		from	acct.Contract#Raw()               x
		cross	apply dbo.Calendar#Of(@issueDate) cd
		join	shpt.Parcel#Raw()                 p on p.ContractID=x.ID
		join	acct.Ledger#Raw()                 l on l.MatterID=p.ID
		join	acct.Charge#Raw()                 g on l.ChargeID=g.ID
		cross	apply acct.Vault#Tag()            a
		cross	apply acct.Ledger#Side()          d
		outer	apply (
						select  LastInvoiceDate=max(IssueDate)
						from	acct.Invoice#Raw()
						where	PartyID=x.TenantID
						and		ContractID=x.ID
						and		VaultTag=g.VaultTag
						and		CurrencyID=l.CurrencyID
					  )                           i           
		where	l.InvoiceID=0
		and		(nullif(@vaultTag,0) is null or g.VaultTag=@vaultTag)
		and		l.LedgerSide=d.AR
		and		(nullif(@bizUnitID,0) is null or x.BizUnitID=@bizUnitID)
		and		(nullif(@partyID, 0) is null or x.TenantID=@partyID)
		and		(nullif(@source,  0) is null or x.SourceID=@source)
		and		BillingCycle>0
		and	    l.TalliedOn<iif(BillingCycle%7=0, cd.BOWeek, cd.BOMonth)
	), cteInvoiceSummary as
	(
		select	PartyID, SourceID, ContractID, CurrencyID, VaultTag
		,		IssueDate, ChargeRaw
		,		InvoiceGroup=DateDiff(day, TalliedOn, dateadd(day, -1,IssueDate))/BillingCycle
		from	cteLedgerGroup               x
		where	(BillingCycle in(7,14) and datediff(day, LastInvoiceDate, IssueDate)>=BillingCycle)
		or		(BillingCycle=30 and datediff(month, LastInvoiceDate, IssueDate)=1)
	), cteInvoice as
	(
		select	PartyID, VaultTag, CurrencyID, ContractID, InvoiceGroup, IssueDate
		,		ChargeRawAmt=sum(ChargeRaw), LedgerCount=count(*)
		from	cteInvoiceSummary  
		group	by PartyID, VaultTag, CurrencyID, ContractID, InvoiceGroup, IssueDate
	)
	select	ID=isnull(row_number() over(order by (select null)), 0), PartyAlias=p.Alias, CurrencyID, VaultTag, ChargeAmt=c.Amt
	,		t.SourceID, IssueDate, ContractID, InvoiceGroup, PartyID, LedgerCount=isnull(LedgerCount, 0)
	,		DueDate=dateadd(day, iif(VaultTag=k.Duty, DutyTerms, NonDutyTerms), IssueDate)
	from	cteInvoice             x
	join	core.Party#Raw()       p on p.ID=x.PartyID
	cross	apply dbo.Currency#Encode(ChargeRawAmt, CurrencyID)  c
	join	acct.Contract#Raw()    t on t.ID=x.ContractID
	cross	apply acct.Vault#Tag() k
)
GO
PRINT N'Adding schema binding to [svc].[Account$InvoiceList]...';


GO
--Ken, PeterHo, Smile
ALTER FUNCTION [svc].[Account$InvoiceList]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID,	    CurrencyID, DueBalance,  InvoiceAmt
	,		InvoicedOn, InvoiceNbr, x.VaultTag, x.PartyID, Alias
	,		DueDate, RemainingDays=datediff(day, getutcdate(), DueDate)
	from	acct.Invoice#Raw()       x
	join	core.Party#Raw()         p  on p.ID = x.PartyID
	join	acct.Contract#Raw()      c on c.ID=x.ContractID
	where	x.DueBalance>0  and c.BillingCycle>0
)
GO
PRINT N'Adding schema binding to [svc].[Account$InvoiceSummary]...';


GO
-- Smile
ALTER FUNCTION [svc].[Account$InvoiceSummary]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, PartyID, PartyAlias=p.Alias, InvoiceNbr, CurrencyID, VaultTag
	,		InvoiceAmt=isnull(InvoiceAmt,0), DueBalance=isnull(DueBalance,0)
	,		InvoicedOn=isnull(InvoicedOn, '0001-01-01'), BizUnitID
	,		BizUnit=b.Alias
	from	acct.Invoice#Raw()  x
	join	core.Party#Raw()    p on x.PartyID=p.ID
	join	acct.Contract#Raw() c on c.ID=x.ContractID
	join	core.Party#Raw()    b on b.ID=c.BizUnitID
	where	x.ID>0	and x.DueBalance>0 and c.BillingCycle>0
)
GO
PRINT N'Adding schema binding to [svc].[Account$VaultBalance]...';


GO
-- Smile
ALTER FUNCTION [svc].[Account$VaultBalance]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID=PartyID, TenantAlias=a.Alias, VaultBal, InvoicedAmt, UninvoicedAmt, CurrencyID, VaultType, CurBal, CreditLimit
	,		BizUnitID=ISNULL(BizUnitID, 0), BizUnit=ISNULL(p.Alias, N''), BillingCycle
	from	acct.Vault#Raw()         x
	join	core.Party#Raw()         a on a.ID=x.PartyID
	cross	apply acct.Contract#For(x.PartyID, a.Source) c
	join	core.Party#Raw()         p on p.ID=c.BizUnitID
)
GO
PRINT N'Adding schema binding to [svc].[Tenancy$TenantInfoList]...';


GO
--Smile
ALTER FUNCTION [svc].[Tenancy$TenantInfoList]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, x.Alias, x.Source, UtcPlace, UtcOffset, Contact=c.Tvp
	,		BizUnitID, BizUnit=b.Alias, BillingCycle, DutyTerms, NonDutyTerms
	,		EffectiveOn=isnull(EffectiveOn, ''), ExpiredOn=isnull(ExpiredOn, '')
	from	core.Party#Raw()           x 
	join	core.Tenant#Raw()          p on p.ID=x.ID
	cross	apply acct.Contract#For(p.ID, p.Source) r
	join	core.Party#Raw()           b on b.ID=r.BizUnitID
	cross	apply core.Contact#Type()  k
	outer	apply core.Contact#TvpFor( x.ID, k.Billing) c 
	cross	apply core.Party#Type()    t
	where	x.ID>0 and x.Type=t.Tenant
)
GO
PRINT N'Adding schema binding to [svc].[VaultXact$Summary]...';


GO
-- Smile
ALTER FUNCTION [svc].[VaultXact$Summary]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,      PartyID=p.ID, PartyAlias=p.Alias, BizUnitID, BizUnit=b.Alias
	,		PaymentID, v.CurrencyID,   XactAmt, PrevBal, NextBal, XactedOn,  Supplement
	from	acct.Vault#Raw()           v	
	join	acct.VaultXact#Raw()       x on x.VaultID=v.ID
	join	core.Party#Raw()           p on p.ID=v.PartyID
	cross	apply acct.Contract#For(p.ID, p.Source) c
	join	core.Party#Raw()           b on b.ID=c.BizUnitID
	cross	apply core.Registry#ID()   k
	left	join acct.Payment#Raw()    m on m.ID=x.PaymentID
	left	join core.Supplement#Raw() s on s.RegID =k.Payment and s.RowID=m.ID
)
GO
PRINT N'Adding schema binding to [rpt].[Dashboard$Summary]...';


GO
-- Eason
ALTER FUNCTION [rpt].[Dashboard$Summary](@siteID bigint, @timezoneOffset int=0)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	
	select	LastDayParcel   =isnull(SUM(case when cl.DOffset - c.DOffset <=1               then 1 else 0 end), 0)
	,		Last7DParcel    =isnull(SUM(case when cl.DOffset - c.DOffset <=7               then 1 else 0 end), 0)
	,		Pre7DParcel     =isnull(SUM(case when cl.DOffset - c.DOffset between 7 and 14  then 1 else 0 end), 0)
	,		Last30DParcel   =isnull(SUM(case when cl.DOffset - c.DOffset <=30              then 1 else 0 end), 0)
	,		Pre30DParcel    =isnull(SUM(case when cl.DOffset - c.DOffset between 30 and 60 then 1 else 0 end), 0)
	,		LastMonthParcel =isnull(SUM(case when cl.MOffset - c.MOffset =0                then 1 else 0 end), 0)
	,		PreMonthParcel  =isnull(SUM(case when cl.MOffset - c.MOffset =1                then 1 else 0 end), 0)

	,       LastDaySales    =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset <=1               , r.Sales, 0)),2), 0)
	,		Last7DSales     =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset <=7               , r.Sales, 0)),2), 0)
	,		Pre7DSales      =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset between 7 and 14  , r.Sales, 0)),2), 0)
	,		Last30DSales    =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset <=30              , r.Sales, 0)),2), 0)
	,		Pre30DSales     =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset between 30 and 60 , r.Sales, 0)),2), 0)
	,		LastMonthSales  =isnull(ROUND(SUM(iif(cl.MOffset - c.MOffset =0                , r.Sales, 0)),2), 0)
	,		PreMonthSales   =isnull(ROUND(SUM(iif(cl.MOffset - c.MOffset =1                , r.Sales, 0)),2), 0)

	,       LastDayFreight  =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset <=1               , f.Freight, 0)), 2), 0)
	,		Last7DFreight   =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset <=7               , f.Freight, 0)), 2), 0)
	,		Pre7DFreight    =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset between 7 and 14  , f.Freight, 0)), 2), 0)
	,		Last30DFreight  =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset <=30              , f.Freight, 0)), 2), 0)
	,		Pre30DFreight   =isnull(ROUND(SUM(iif(cl.DOffset - c.DOffset between 30 and 60 , f.Freight, 0)), 2), 0)
	,		LastMonthFreight=isnull(ROUND(SUM(iif(cl.MOffset - c.MOffset =0                , f.Freight, 0)), 2), 0)
	,		PreMonthFreight =isnull(ROUND(SUM(iif(cl.MOffset - c.MOffset =1                , f.Freight, 0)), 2), 0)

	from	core.Matter#Raw()         x
	cross	apply core.Matter#Type()  mt
	cross	apply core.RefInfo#Type() rt
	cross	apply tvp.Spr#Const()     sp
	cross   apply dbo.Calendar#Of(DATEADD(HOUR,  -@timezoneOffset, GETUTCDATE())) cl
	join	dbo.Calendar#Raw() c on cast(x.PostedOn as Date)=c.Value
	cross	apply
	(
			select	Sales=isnull(sum(m.DecAmt), 0)
			from	core.RefInfo#Of(x.ID,rt.DeclaredInfo)           x
			cross	apply tvp.Quad#Slice(x.Info, default, sp.Mucho) t 
			cross	apply dbo.Money#Of(t.v3) m
	) r
	cross	apply
	(
			select	Freight=isnull(sum(m.DecAmt), 0)
			from	acct.Ledger#Raw()               g
			cross	apply acct.Charge#ID()          c
			cross	apply dbo.Money#Of(g.ChargeAmt) m
			where	g.MatterID=x.ID and g.ChargeID=c.Freight
	) f
	where	c.DOffset between (cl.DOffset - 60) and cl.DOffset 
	and		x.Type=mt.Parcel
	and		x.PosterID=@siteID
)
GO
PRINT N'Adding schema binding to [vmi].[Invoice$SummaryForSasa]...';


GO

--Smile
ALTER FUNCTION [vmi].[Invoice$SummaryForSasa]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with cte as
	(
			select	x.ID, x.PartyID, VaultBal=c.NextBal, x.CurrencyID, x.TalliedOn, ChargeID, ChargeAmt
			,		ClientRefNbr=N'', RefNbr=r.Number, Supplement=N'', c.XactedOn
			,		SectionWt=0, Weight=0
			from	acct.Ledger#Raw()        x
			join	acct.Vault#Raw()         v on x.PartyID=v.PartyID and x.CurrencyID=v.CurrencyID
			join	acct.VaultXact#Raw()     c on c.VaultID=v.ID and c.InvoiceID=x.InvoiceID
			cross	apply core.RefNbr#Type() k
			join	core.RefNbr#Raw()        r on r.MatterID=x.MatterID and r.Type=k.AsnNbr
			where	x.PartyID in (10983, 10987)
			union all
			select	x.ID, x.PartyID, VaultBal=c.NextBal, x.CurrencyID, x.TalliedOn, ChargeID, ChargeAmt
			,		ClientRefNbr=N'', RefNbr=N'', Supplement, c.XactedOn
			,		SectionWt=0, Weight=0
			from	acct.Ledger#Raw()          x
			cross	apply core.Matter#Type()   k
			join	core.Matter#Raw()          m on m.ID=x.MatterID and m.Type =k.AssortedFees
			join	acct.Vault#Raw()           v on x.PartyID=v.PartyID and x.CurrencyID=v.CurrencyID
			join	acct.VaultXact#Raw()       c on c.VaultID=v.ID and c.InvoiceID=x.InvoiceID
			cross	apply core.Registry#ID()   r 
			join	core.Supplement#Raw()      s on s.RegID =r.AssortedFees and s.RowID=m.ID
			where	x.PartyID in (10983, 10987)
			union all
			select	x.ID, x.PartyID, VaultBal=c.NextBal, x.CurrencyID, x.TalliedOn, ChargeID, ChargeAmt
			,		ClientRefNbr=N'', RefNbr=N'', Supplement, c.XactedOn
			,		SectionWt=0, Weight=0
			from	acct.Ledger#Raw()          x
			cross	apply core.Matter#Type()   k
			join	core.Matter#Raw()          m on m.ID=x.MatterID and m.Type =k.StorageFee
			join	acct.Vault#Raw()           v on x.PartyID=v.PartyID and x.CurrencyID=v.CurrencyID
			join	acct.VaultXact#Raw() c on c.VaultID=v.ID and c.InvoiceID=x.InvoiceID
			cross	apply core.Registry#ID()   r 
			join	core.Supplement#Raw()      s on s.RegID =r.Ledger and s.RowID=x.ID
			where	x.PartyID in (10983, 10987)
			union all
			select	x.ID, x.PartyID, VaultBal=c.NextBal, x.CurrencyID, x.TalliedOn, ChargeID, ChargeAmt
			,		ClientRefNbr=r.Number, RefNbr=p.Number, Supplement=N'', c.XactedOn
			,		SectionWt=Weight, Weight
			from	acct.Ledger#Raw()          x					
			join	shpt.Parcel#Raw()          m on m.ID=x.MatterID 
			join	acct.Vault#Raw()           v on x.PartyID=v.PartyID and x.CurrencyID=v.CurrencyID
			join	acct.VaultXact#Raw()       c on c.VaultID=v.ID and c.InvoiceID=x.InvoiceID
			cross	apply core.RefNbr#Type()   t
			join	core.RefNbr#Raw()          r on r.MatterID=m.ID and r.Type=t.ClientRef
			left	join core.RefNbr#Raw()     p on p.MatterID=m.ID and p.Type=t.PostCourier
			where	x.PartyID in (10983, 10987)
			union all
			select	x.ID, x.PartyID, VaultBal=c.NextBal, x.CurrencyID, x.PaidOn, ChargeID=iif(x.PaidAmt>0, g.Deposit, g.Deduct)
			,		ChargeAmt=x.PaidAmt
			,		ClientRefNbr=N'', RefNbr=N'', Supplement=N'', c.XactedOn
			,		SectionWt=0, Weight=0
			from	acct.Payment#Raw()   x
			join	acct.Vault#Raw()     v on x.PartyID=v.PartyID and x.CurrencyID=v.CurrencyID
			join	acct.VaultXact#Raw() c on c.VaultID=v.ID and c.PaymentID=x.ID
			cross	apply acct.Charge#ID() g
			where	x.PartyID in (10983, 10987)		
				
	)
	select	u.ID, PartyAlias=d.Alias, TalliedOn, ClientRefNbr, CurrencyID, XactedOn
	,		RefNbr, VaultBal, ChargeAmt, Weight, SectionWt,  ChargeID, Supplement	
	from	core.Party#Raw() d
	join	cte              u on d.ID=u.PartyID
	where	d.ID in (10983, 10987)


)
GO
PRINT N'Altering [acct].[Vault#IdOf]...';


GO
-- PeterHo
ALTER FUNCTION [acct].[Vault#IdOf](@partyID bigint, @currencyID tinyint, @valutType tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID from acct.Vault#Raw()
	where	(PartyID=@partyID and CurrencyID=@currencyID and VaultType=@valutType)
)
GO
PRINT N'Adding schema binding to [acct].[Vault#IdOf]...';


GO
-- PeterHo
ALTER FUNCTION [acct].[Vault#IdOf](@partyID bigint, @currencyID tinyint, @valutType tinyint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID from acct.Vault#Raw()
	where	(PartyID=@partyID and CurrencyID=@currencyID and VaultType=@valutType)
)
GO
PRINT N'Adding schema binding to [vmi].[AccountBal$Verify]...';


GO
--Smile
ALTER FUNCTION [vmi].[AccountBal$Verify](@acctID int, @svcType int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	v.ID, v.CurBal
	from	tms.SvcType#For(@svcType, @acctID) x
	join	tms.SvcType#Raw()                  e on e.ID=x.ID
	cross	apply acct.Vault#Type()            k
	join	acct.Vault#Raw()                   v on v.PartyID=@acctID 
												and v.CurrencyID=e.CurrencyID 
												and v.VaultType=k.Fund

)
GO
PRINT N'Altering [acct].[VaultXact#LastBalFor]...';


GO
--Smile.Wang
ALTER FUNCTION [acct].[VaultXact#LastBalFor](@vaultID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, PrevBalRaw=x.RawAmt
	from	acct.VaultXact#Raw()                  v
	cross	apply dbo.Money#Sum(PrevBal, XactAmt) p	
	cross	apply dbo.Money#Of(p.Amt)             x
	where	ID=
	           (select	top(1) ID=last_value(ID) over (order by (select 0))	
				from	acct.VaultXact#Raw()		
				where	VaultID=@vaultID
			   )
	
)
GO
PRINT N'Adding schema binding to [acct].[VaultXact#LastBalFor]...';


GO
--Smile.Wang
ALTER FUNCTION [acct].[VaultXact#LastBalFor](@vaultID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, PrevBalRaw=x.RawAmt
	from	acct.VaultXact#Raw()                  v
	cross	apply dbo.Money#Sum(PrevBal, XactAmt) p	
	cross	apply dbo.Money#Of(p.Amt)             x
	where	ID=
	           (select	top(1) ID=last_value(ID) over (order by (select 0))	
				from	acct.VaultXact#Raw()		
				where	VaultID=@vaultID
			   )
	
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$DetailForSubscribe]...';


GO
-- AaronLiu
ALTER FUNCTION [svc].[Parcel$DetailForSubscribe](@mic varchar(40))
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	ID=x.MatterID, SubscribeNbr=a.RefNbr
	from	api.ActivitySubscription#Raw() a, core.RefNbr#ScanOne(@mic, default, default) x
	where	x.MatterID=a.MatterID
)
GO
PRINT N'Adding schema binding to [svc].[ClrMethod$BrokerLookup]...';


GO
--Sam
ALTER FUNCTION [svc].[ClrMethod$BrokerLookup]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	c.CountryCode	as CountryCode
		,	b.ID			as BrokerID
		,	b.BrokerAlias	
		,	c.ID			as ClrMethodID
		,	c.ClrMethodCode 
	from	tms.Route#Raw()      r
	join	brkg.Broker#Raw()    b	on b.ID = r.BrokerID
	join	brkg.ClrMethod#Raw() c	on c.ID = r.ClrMethodID
	Where	b.ID > 0 and c.ID > 0
)
GO
PRINT N'Adding schema binding to [tms].[Route#Deep]...';


GO
--PeterHo
ALTER FUNCTION [tms].[Route#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,        MftGroup,        RouteCode
	,		ClrMethodID, m.ClrMethodCode, m.CountryCode
	,		BrokerID,    b.FlatRate,      b.PercentRate, b.BrokerAlias, b.ApiToken, b.ApiUrl
	,		CourierID,   c.CourierAlias,  c.CourierCode, CmdyRootID,    MaxSkuCnt,  MaxWeight
	from	tms.Route#Raw()      x
	join	brkg.ClrMethod#Raw() m on m.ID=x.ClrMethodID
	join	brkg.Broker#Raw()    b on b.ID=BrokerID
	join	tms.Courier#Raw()    c on c.ID=CourierID
)
GO
PRINT N'Adding schema binding to [tms].[SvcRoute#Deep]...';


GO
--PeterHo
ALTER FUNCTION [tms].[SvcRoute#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	SvcType, POA,  Priority, MaxSkuCnt, MaxWeight
	,		RouteID,       r.RouteCode
	,		r.ClrMethodID, r.ClrMethodCode, r.CountryCode
	,		r.BrokerID,    r.BrokerAlias
	,		r.CourierID,   r.CourierAlias,  r.CourierCode
	from	tms.SvcRoute#Raw() x
	join	tms.Route#Deep()   r on r.ID=x.RouteID
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$VefityDutyCode]...';


GO
--Smile
ALTER	FUNCTION [svc].[Parcel$VefityDutyCode](@dutyCodes nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	p.ID, DutyCode=x.v2, DutyID=isnull(d.ID, 0), DutyRate=isnull(d.DutyRate, 0)
	from	tvp.Duad#Slice(@dutyCodes, default, default) x
	join	shpt.Parcel#Raw()                            p on p.ID=cast(x.v1 as bigint)
	join	tms.Route#Raw()                              t on t.ID=p.RouteID
	join	brkg.ClrMethod#Raw()                         c on c.ID=t.ClrMethodID
	left	join brkg.Duty#Raw()                         d on d.CountryCode=c.CountryCode and d.DutyCode=x.v2
)
GO
PRINT N'Adding schema binding to [invt].[SkuInfo#ToBrokerage]...';


GO
/*
@skuInfos: Mucho[Triad<SkuID, LineQty,  LineTotal>]
@result:   Mucho[Triad<SkuID, CmdyInfo, LineInfo> ] : BrokerageInfo
*/
--PeterHo, AaronLiu
ALTER FUNCTION [invt].[SkuInfo#ToBrokerage]
(
	@skuInfos nvarchar(max), @brokerID bigint, @clrMethodID int
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat
		(
			k.Mucho,      t.v1, k.Triad
		,	/*CmdyHeadID*/N'0', k.Quad, /*CmdyTailID*/N'0', k.Quad,        d.DutyCode, k.Quad, d.DutyRate
		,	k.Triad,      e.v1, k.Quad, /*LineQty   */t.v2, k.Quad, /*LineTotal*/t.v3, k.Quad, /*CmdyID*/N'0'
		)
		from	tvp.Mucho#Slice(@skuInfos)           x
		cross	apply tvp.Triad#Of(x.Piece, default) t
		join	invt.SkuBrokerage#Raw() b on
		(
			b.SkuID=cast(t.v1 as int) and b.ClrMethodID=@clrMethodID and b.BrokerID=@brokerID
		)
		join	brkg.Duty#Raw()   d on d.ID=b.DutyID
		cross	apply tvp.Pair#Of(b.Endorsement) e
		cross	apply tvp.Spr#Const() k 
		order	by x.Seq for xml path (N'')
	)
	select Info=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Adding schema binding to [core].[Activity#Track]...';


GO
--PeterHo
ALTER FUNCTION [core].[Activity#Track](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteBase as
	(
		select	a.ID, x.Type, a.MatterID
		,		a.StateID,    s.Stage,  s.IsInternal
		,		a.UserID,     UserAlias=p.Alias
		,		a.TalliedOn,  UtcPartyID=p.PID
		from	core.Matter#PNodeUp(@matterID) x
		join	core.Activity#Raw() a on a.MatterID=x.ID
		join	core.State#Raw()    s on s.ID=a.StateID
		join	core.Party#Raw()    p on p.ID=a.UserID
	)
	, cteMarked as
	(
		select	x.ID,     x.Type,      x.MatterID, x.StateID,   x.Stage,    x.TalliedOn
		,		x.UserID, x.UserAlias, z.UtcTime,  z.UtcOffset, z.UtcPlace, z.UtcPlaceID
		,		Marker=lead(ID) over (partition by x.Stage order by z.UtcTime)
		from	cteBase x cross apply
		(
			select	top(1) UtcTime,  UtcOffset, UtcPlace, UtcPlaceID from
			(
				select	UtcTime,     UtcOffset, UtcPlace, UtcPlaceID
				from	core.RefStamp#Of(x.MatterID, x.StateID)
				UNION	ALL
				select	x.TalliedOn, UtcOffset, UtcPlace, UtcPartyID
				from	core.Tenant#Raw() where ID=x.UtcPartyID
			) y
		) z
		where	x.IsInternal=0
	)
	select	ID,     Type,      MatterID, StateID,   Stage,    TalliedOn
	,		UserID, UserAlias, UtcTime,  UtcOffset, UtcPlace, UtcPlaceID--, Marker
	from	cteMarked where Marker is null
)
GO
PRINT N'Refreshing [core].[Activity#TrackSpecific]...';


GO
EXECUTE sp_refreshsqlmodule N'[core].[Activity#TrackSpecific]';


GO
PRINT N'Adding schema binding to [hub].[Activity$Lookup]...';


GO
--AaronLiu
ALTER FUNCTION [hub].[Activity$Lookup](@number varchar(40))
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	a.ID, Operator=u.Alias, a.ActionID, s.Stage
	,		OperatedOn=isnull(dateadd(hour, t.UtcOffset, TalliedOn), N'0001-01-01')
	from	core.RefNbr#ScanOne(@number, default, default) x
	cross	apply core.Matter#PNodeUp(x.MatterID) m
	join	core.Activity#Raw() a on a.MatterID=m.ID
	join	shpt.Parcel#Raw()	p on p.ID=x.MatterID
	join	core.Tenant#Raw()	t on t.ID=p.RcvHubID
	join	core.State#Raw()    s on s.ID=a.StateID
	join	core.Party#Raw()    u on u.ID=a.UserID
)
GO
PRINT N'Altering [zeb].[Matter$LatestStage]...';


GO
/*
	TODO: refine this, with offset cannot use calendar offset
*/
-- AaronLiu
ALTER FUNCTION [zeb].[Matter$LatestStage](@matterID I64, @startDate DT, @endDate DT)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	LatestStage=isnull(max(s.Stage),0)
	from	core.Matter#PNodeUp(@matterID) x
	join	core.Activity#Raw() a on a.MatterID=x.ID
	join	core.State#Raw()    s on s.ID=a.StateID
--	join	dbo.Calendar#Raw()  d on d.Value=cast(a.TalliedOn as Date)
--	cross   apply dbo.Calendar#Of(@startDate) sd
--	cross   apply dbo.Calendar#Of(@endDate  ) ed
--	where	d.DOffset   between sd.DOffset and  ed.DOffset
	where	a.TalliedOn between @startDate and @endDate
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$Track]...';


GO
--PeterHo
ALTER FUNCTION [svc].[Parcel$Track](@parcelID bigint)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with cteTvp(text) as
	(
		select	[text()]=concat(k.Many
		,		ID,       k.Tuplet, Stage,     k.Tuplet
		,		UserID,   k.Tuplet, UserAlias, k.Tuplet
		,		UtcPlace, k.Tuplet, UtcTime,   k.Tuplet, UtcOffset)
		from	core.Activity#Track(@parcelID)
		,		tvp.Spr#Const() k for xml path(N'')
	)
	select	Tracks=Tvp, l.CourierCode, CourierNbr=isnull(c.Number, N'')
	from	cteTvp cross apply tvp.Spr#Purify(text, default)
	join	shpt.Parcel#Raw() p on p.ID=@parcelID
	join	tms.Courier#Raw() l on l.ID=p.LastMilerID
--	join	tms.Route#Deep()  r on r.ID=p.RouteID -- dropped on 2017-08-19
	outer	apply
	(
		select	Number from	core.RefNbr#Raw() n
		cross	apply  core.RefNbr#Type()     t
		where	n.MatterID=@parcelID and n.Type=t.PostCourier
	) c
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$TrackOne]...';


GO
--PeterHo
ALTER FUNCTION [svc].[Parcel$TrackOne](@trackingNbr varchar(40))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	Tracks, CourierCode, CourierNbr
	from	core.RefNbr#ScanOne(@trackingNbr, default, default) x
	cross	apply svc.Parcel$Track(x.MatterID) a

/*
	select	ID, a.Stage, UserID,  UserAlias
	,		UtcPlace,    UtcTime, UtcOffset
	from	core.RefNbr#ScanOne(@trackingNbr, default, default) x
	cross	apply svc.Parcel$Track(x.MatterID) a
*/
)
GO
PRINT N'Adding schema binding to [shpt].[Parcel#PreSorting]...';


GO
--AaronLiu
ALTER FUNCTION [shpt].[Parcel#PreSorting](@pracelID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with	cteScaned as
	(
		select	x.ID,		  x.Stage
		,		r.HasConcern, r.HasChallenge, r.HasAddOnSvc
		from	whse.Ramp#Routing() r, core.Matter#Raw() x
		where	x.ID=@pracelID
	),	cteSorting as
	(
		select	Code=NotFound
		from	whse.Ramp#Routing()
		where	@pracelID is null
		union	all
		select	Code=x.HasConcern
		from	cteScaned x
		cross	apply core.Concern#Exists(x.ID) c
		where	c.HasConcern=1
		union	all
		select	Code=x.HasChallenge
		from	cteScaned x
		cross	apply core.Challenge#Exists(x.ID) c
		where	c.HasChallenge=1
		union	all
		select	Code=x.HasAddOnSvc
		from	cteScaned x
		cross	apply core.AddOnSvc#Exists(x.ID) a
		where	a.HasAddOnSvc=1
	)
	select	top(1) Code from cteSorting
)
GO
PRINT N'Adding schema binding to [shpt].[Parcel#Sorting]...';


GO
--AaronLiu
ALTER FUNCTION [shpt].[Parcel#Sorting](@pracelID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with	cteScaned as
	(
		select	x.ID,				  x.Stage
		,		r.HasOverthrehold,	  r.HasFlaggedForReturn,  r.HasMeasured,			 r.HasShippingPlan
		,		r.ShouldRackIn,		  r.HasOutgated,		  r.HasOutboundLocked,		 r.ShouldOutbound
		,		r.UndefinedEX,		  r.UndefinedHR
		,		s.HubMeasured,		  s.Racking,			  b.PostMin,				 b.CurMin
--------------------------------------------------------------------------------------------------------------------HACK Add below to Stage#ID()
		,		Overthreshold=10545,  FlaggedForReturn=10550, ShippingPlanCocured=11900, ToRacking=11410
		,		OutboundLocked=18000, OutboundStart=14000
--------------------------------------------------------------------------------------------------------------------HACK Add above to Stage#ID()
		from	core.Matter#Raw()			x
		cross	apply core.Stage#ID()		s
		cross	apply whse.Ramp#Routing()	r
		cross	apply core.Stage#Boundary() b
		where	x.ID=@pracelID
	),	cteSorting as
	(
		select	Code					 from shpt.Parcel#PreSorting(@pracelID)
		union	all
		select	Code=HasOverthrehold	 from cteScaned where Stage=Overthreshold
		union	all						 
		select	Code=HasFlaggedForReturn from cteScaned where Stage=FlaggedForReturn
		union	all						 
		select	Code=HasMeasured		 from cteScaned where Stage=HubMeasured
		union	all						 
		select	Code=HasShippingPlan	 from cteScaned where Stage=ShippingPlanCocured
		union	all						 
		select	Code=ShouldRackIn		 from cteScaned where Stage=ToRacking
		union	all						 
		select	Code=HasOutgated		 from cteScaned where Stage>PostMin
		union	all						 
		select	Code=HasOutboundLocked	 from cteScaned where Stage>OutboundLocked
		union	all						 
		select	Code=ShouldOutbound		 from cteScaned where Stage>OutboundStart
		union	all						 
		select	Code=UndefinedHR		 from cteScaned where Stage>CurMin
		union	all						 
		select	Code=UndefinedEX		 from cteScaned
	)
	select	top(1) Code from cteSorting
)
GO
PRINT N'Adding schema binding to [core].[Matter#Deep]...';


GO
--PeterHo
ALTER FUNCTION [core].[Matter#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,      PID, AID,   x.Source,    Type, LockCnt,       Stage, StateID, StatedOn,  HandlerID
	,		PosterID,  PosterAlias=t.Alias,     PostedAt=t.UtcPlace, PostedOn,       t.UtcOffset
	,		n.RefNbrs, i.RefInfos, s.RefStamps, p.RefParties,        o.RoledActions, c.Challenges, a.AddOnServices
	from	core.Matter#Raw() x
	join	core.Tenant#Raw() t on t.ID=x.PosterID
	outer	apply core.Transition#Todo(x.StateID) o
	outer	apply core.RefNbr#Tvp   (x.ID) n
	outer	apply core.RefInfo#Tvp  (x.ID) i
	outer	apply core.RefStamp#Tvp (x.ID) s
	outer	apply core.RefParty#Tvp (x.ID) p
	outer	apply core.Challenge#Tvp(x.ID) c
	outer	apply core.AddOnSvc#Tvp (x.ID) a
)
GO
PRINT N'Adding schema binding to [shpt].[Appointment#Base]...';


GO
--AaronLiu
ALTER FUNCTION [shpt].[Appointment#Base]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, PID, AID, Source,  Type,	   LockCnt,	 Stage, StateID, StatedOn,	SiteID=m.PosterID
	,		SiteAlias=m.PosterAlias, PostedAt, PostedOn, SiteUtcOffset=m.UtcOffset, PickupOn
	,		EstWeight,  HandlerID,	 RefNbrs,  RefInfos, RefStamps, RefParties,		RoledActions
	,		Challenges, AddOnServices
	from	shpt.Appointment#Raw() x
	join	core.Matter#Deep()	   m on m.ID=x.ID
)
GO
PRINT N'Adding schema binding to [shpt].[Parcel#Base]...';


GO
--PeterHo
ALTER FUNCTION [shpt].[Parcel#Base]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, PID, AID,    Source, Type, LockCnt,    Stage,    StateID,  StatedOn, BatchID
	,		SiteID=m.PosterID, SiteAlias=m.PosterAlias,  PostedAt, PostedOn, SiteUtcOffset=m.UtcOffset
	,		RcvHubID, RouteID, LastMilerID,  ContractID, POA, HandlerID
	,		SvcType, SvcZone,  SvcClass,     Weight,     Length, Width, Height,     ZoneCode
	,		RefNbrs,  RefInfos, RefStamps,   RefParties, RoledActions,  Challenges, AddOnServices
	from	shpt.Parcel#Raw()  x
	join	core.Matter#Deep() m on m.ID=x.ID
)
GO
PRINT N'Adding schema binding to [shpt].[Sack#Base]...';


GO
-- AaronLiu
ALTER FUNCTION [shpt].[Sack#Base]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, m.PID, m.AID, m.Source,    m.Type,      m.LockCnt,   m.HandlerID
	,		m.Stage, m.StateID, m.StatedOn,  x.BrokerID,  ClrMethodID, SackWt
	,		HubID=m.PosterID,   HubAlias=m.PosterAlias,   PostedAt
	,		m.PostedOn,         HubUtcOffset=m.UtcOffset
	,		POD=isnull(s.POD, ''), POA=isnull(x.POA, '')
	,		RefNbrs, RefStamps, RefParties
	,		RoledActions,       Challenges,  FlightID=isnull(f.PID, 0)
	from	shpt.Sack#Raw()    x
	join	core.Matter#Deep() m on x.ID=m.ID
	left	join shpt.SackMft#Raw() s on s.ID=m.PID
	left	join core.Matter#Raw()  f on s.ID=f.ID
)
GO
PRINT N'Adding schema binding to [shpt].[SackLoad#Base]...';


GO
-- AaronLiu
ALTER FUNCTION [shpt].[SackLoad#Base]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,	   PID, AID, Source,   Type,    LockCnt,    Stage,        StateID
	,		StatedOn,  PostedAt, PostedOn, RefNbrs, RefParties, RoledActions, Challenges
	,		TruckerID, Trucker=t.Alias,    HubID= m.PosterID
	from	shpt.SackLoad#Raw() x
	join	core.Matter#Deep()  m on m.ID=x.ID
	join	tms.Trucker#Raw()   t on x.TruckerID=t.ID
)
GO
PRINT N'Adding schema binding to [shpt].[SackMft#Base]...';


GO
--PeterHo
ALTER FUNCTION [shpt].[SackMft#Base]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,   PID, AID,  Source,  Type, LockCnt, Stage,     StateID,    StatedOn,    BrokerID
	,		HubID=m.PosterID,  HubAlias=m.PosterAlias, PostedAt,  PostedOn,   HubUtcOffset=m.UtcOffset
	,		POD, POA, MawbNbr, FlightNbr, RefNbrs,     RefStamps, RefParties, RoledActions, Challenges
	,		MawbWt
	from	shpt.SackMft#Raw() x
	join	core.Matter#Deep() m on m.ID=x.ID
)
GO
PRINT N'Adding schema binding to [tms].[Flight#Base]...';


GO
-- AaronLiu
ALTER FUNCTION [tms].[Flight#Base]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,	    PID, AID,     Source, Type, LockCnt, Stage, StateID,   StatedOn
	,		PostedAt,   PostedOn,     POD,    ETD,  POA,	 ETA,   FlightNbr, RefStamps
	,		RefParties, RoledActions, Challenges
	from	tms.Flight#Raw()   x
	join	core.Matter#Deep() m on m.ID=x.ID
)
GO
PRINT N'Adding schema binding to [whse].[StockInOrder#Base]...';


GO
--Smile
ALTER FUNCTION [whse].[StockInOrder#Base]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, PID, AID,     Source, Type, LockCnt,    Stage,    StateID,  StatedOn,	RcvHubID, ContractID
	,		SiteID=m.PosterID,  SiteAlias=m.PosterAlias,  PostedAt, PostedOn, SiteUtcOffset=m.UtcOffset
	,		RefNbrs,  RefInfos, RefStamps,   RefParties, RoledActions,  Challenges, AddOnServices, TotalSkuQty
	from	whse.StockInOrder#Raw() x
	join	core.Matter#Deep()      m on m.ID=x.ID
)
GO
PRINT N'Adding schema binding to [svc].[Appointment$List]...';


GO
--AaronLiu
ALTER FUNCTION [svc].[Appointment$List]()
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	x.ID,		x.SiteID,	TenantID=t.ID, TenantAlias=t.Alias,		x.PostedOn, x.Stage, x.StateID
	,		x.StatedOn, x.PickupOn, x.EstWeight,   Weight=isnull(Weight,0), x.RefNbrs,  x.RefInfos
	from	shpt.Appointment#Base() x
	join	core.Party#Raw()  s on s.ID=x.SiteID
	join	core.Party#Raw()  t on t.ID=s.PID
	cross	apply (
		select	Weight=isnull(sum(p.Weight),0)
		from	core.Matter#Type() t, core.Matter#ANodeDn(x.ID) m
		join	shpt.Parcel#Raw()  p on m.ID=p.ID
		where	m.Type=t.Parcel
	) c
)
GO
PRINT N'Refreshing [svc].[Appointment$ListForRamper]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Appointment$ListForRamper]';


GO
PRINT N'Adding schema binding to [hub].[Parcel$CheckForRackIn]...';


GO
-- Smile
ALTER FUNCTION [hub].[Parcel$CheckForRackIn](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	p.ID
	from	core.RefNbr#ScanOne(@number, default, default) x
	join	shpt.Parcel#Base() p on p.ID=x.MatterID
	cross	apply core.State#ID() k
	where	p.StateID=k.Carted
)
GO
PRINT N'Refreshing [hub].[Parcel$ListForMedium]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[Parcel$ListForMedium]';


GO
PRINT N'Adding schema binding to [hub].[Parcel$SortingInfoVia]...';


GO
-- Eva
ALTER FUNCTION [hub].[Parcel$SortingInfoVia](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING
--, ENCRYPTION
AS RETURN 
(
	select	ID, p.Stage, StateID, StatedOn, RefNbrs, Port=POA--?
	from	core.RefNbr#ScanOne(@number, default, default) x
	join	shpt.Parcel#Base() p on p.ID=x.MatterID
)
GO
PRINT N'Refreshing [hub].[Parcel$UnityInfoVia]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[Parcel$UnityInfoVia]';


GO
PRINT N'Adding schema binding to [ic].[Parcel$ForHandWrittenOrder]...';


GO
--Aimee, bd.he, Daxia
ALTER FUNCTION [ic].[Parcel$ForHandWrittenOrder]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID,    x.Source, Stage, StateID, StatedOn, PostedOn,  PostedAt
	,		RefNbrs, RefInfos, ShopID=SiteID,  ShopAlias=SiteAlias, HandlerID, u.Handler
	from	core.Source#ID()   k, shpt.Parcel#Base() x
	cross	apply svc.User$ContactName(x.HandlerID)  u
	where	x.Source=k.AAE and SvcType=0
)
GO
PRINT N'Refreshing [lc].[Parcel$ShippingPlanVia]...';


GO
EXECUTE sp_refreshsqlmodule N'[lc].[Parcel$ShippingPlanVia]';


GO
PRINT N'Adding schema binding to [svc].[Account$ForCreditLimitExceeded]...';


GO
-- Smile
ALTER FUNCTION [svc].[Account$ForCreditLimitExceeded]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteSummary as
	(
		select	a.ID, a.Alias, x.HandlerID, ParcelCnt=count(*), MinStatedOn=min(x.StatedOn)
		from	core.State#ID() k, shpt.Parcel#Base() x
		join	core.Party#Raw()   p on x.ID=p.ID
		join	core.Party#Raw()   a on a.ID=p.AID
		where	x.StateID=k.CreditLimitExceeded
		group	by a.ID, a.Alias, x.HandlerID
	)
	select	x.ID, TenantAlias=x.Alias, HandlerID, Handler=u.Alias, Name, Phone, Email
	,		ParcelCnt=isnull(ParcelCnt, 0), MinStatedOn
	from	cteSummary                x
	join	core.User#Raw()           u on u.ID=x.HandlerID
	cross	apply core.Contact#Type() t
	join	core.Contact#Raw()   c on c.PartyID=x.ID and c.Type=t.Billing

)
GO
PRINT N'Adding schema binding to [svc].[Batch$ExportSuccess]...';


GO
--Simile, PeterHo
ALTER FUNCTION [svc].[Batch$ExportSuccess](@batchID bigint)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	n.RefNbrs, CneeInfo=i.Info, PostedOn=l.LocalTime
	from	shpt.Parcel#Base()          x
	cross	apply core.RefInfo#Type()   t
	join	core.RefInfo#Raw()          i on i.MatterID=x.ID and i.Type=t.CneeInfo
	cross	apply core.RefNbr#Tvp(x.ID) n
	cross	apply dbo.DT#ToLocal(x.PostedOn, x.SiteUtcOffset) l
	where	x.BatchID=@batchID
)
GO
PRINT N'Adding schema binding to [svc].[ClientRefNbr$VefityForPlatform]...';


GO
/*
@numbersInCSV =Duad[Alias, ClientRefNbr]
*/
--Smile
ALTER	FUNCTION [svc].[ClientRefNbr$VefityForPlatform](@userID int, @numbersInCSV nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	
	select	ID=isnull(c.ID, 0), ClientRefNbr=d.Number
	from	tvp.Duad#Slice(@numbersInCSV, default, default) x
	cross	apply loc.RefNbr#Cast(x.v2)                     d
	cross	apply core.RefNbr#Type()                        k
	join	core.Party#Raw()                                n on n.ID=@userID
	left	join  core.Party#Raw()                          p on p.Source=n.Source and p.Alias=x.v1
	cross	apply(
						select top(1) m.ID 
						from(
								select	b.ID from core.RefNbr#Raw()  r
								join	shpt.Parcel#Base()           b on r.MatterID=b.ID  and b.SiteID=p.ID 
								where	r.Number=d.Number and r.Type=k.ClientRef
								union all
								select	0
						) m
		) c
			
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$ClearanceForXpd]...';


GO
--bd.he, Smile
ALTER FUNCTION [svc].[Parcel$ClearanceForXpd](@idsInCsv nvarchar(max))
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	p.ID, t.MawbNbr, f.FlightNbr, f.POA, f.POD, f.ETA, f.ETD, p.Weight
    ,		p.RefNbrs, p.RefInfos, r.BrokerID
	from	tvp.I64#Slice(@idsInCsv) x
	join	shpt.SackMft#Base()	     t on x.ID=t.ID
	join	tms.Flight#Raw()	     f on f.ID=t.PID
	join    shpt.Sack#Base()	     s on s.PID=x.ID
	join	shpt.Parcel#Base()	     p on p.PID=s.ID
	join	tms.Route#Raw()          r on r.ID=p.RouteID
	
)--HACK: should move to schema xpd
GO
PRINT N'Adding schema binding to [svc].[Parcel$ExceptionListFor]...';


GO
--Ken, Aimee
ALTER FUNCTION [svc].[Parcel$ExceptionListFor](@siteID int)
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	x.ID, x.RefInfos, RefNbrs, Stage, StateID, StatedOn
	from	shpt.Parcel#Base()    x
	cross	apply core.Stage#ID() s
	where	x.Stage in (s.PreInterventionNeeded, s.InterventionNeeded, s.PostInterventionNeeded)
	and		x.SiteID=@siteID 
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$ForArrivedNotice]...';


GO
-- For eForward Notice
-- Daxia
ALTER FUNCTION [svc].[Parcel$ForArrivedNotice](@parcelIDS nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	p.ID,      SiteAlias
	,		p.RefNbrs, RefStamps=isnull(f.RefStamps, N'')
	from	shpt.Parcel#Base()      p 
	join	shpt.Sack#Base()        s on s.ID=p.PID	
	join	shpt.SackMft#Base()     m on m.ID=s.PID
	join	tms.Flight#Base()       f on f.ID=m.PID
	where	p.ID in (select ID from tvp.I64#Slice(@parcelIDS))
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$ForMeasureNotice]...';


GO
-- Daxia
ALTER FUNCTION [svc].[Parcel$ForMeasureNotice]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, x.PID, x.AID, x.Source, x.Type, x.Stage, x.StateID, x.SvcType
	,		RcvHubID,  RcvHubAlias=t.Alias,   t.UtcOffset, t.UtcPlace
	,		Weight,    Length, Width, Height, RefNbrs, ClientRefNbr=isnull(r.Number, N'')
	from	shpt.Parcel#Base()       x
	left	join core.Matter#Raw()   m on m.ID=x.AID
	cross	apply core.RefNbr#Type() k
	left	join core.RefNbr#Raw()   r on r.MatterID=m.ID and r.Type=k.ClientRef
	join	core.Tenant#Raw()        t on t.ID=x.RcvHubID
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$ForOnboardedNotice]...';


GO
-- For eForward Notice
-- Daxia
-- TODO: Must add new Onboarded LocalTime
ALTER FUNCTION [svc].[Parcel$ForOnboardedNotice](@idInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	p.ID,      SiteAlias
	,		p.RefNbrs, m.RefStamps
	from	tvp.I64#Slice(@idInCsv)   x
	join	shpt.SackMft#Base()       m on m.ID=x.ID
	left	join shpt.Sack#Base()     s on s.PID=x.ID
	join	shpt.Parcel#Base()        p on p.PID=s.ID or p.PID=x.ID
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$ForPlatform]...';


GO
--Ken
ALTER FUNCTION [svc].[Parcel$ForPlatform]()
RETURNS TABLE 
WITH SCHEMABINDING --,ENCRYPTION
AS RETURN 
(
	select	x.ID,  SiteAlias, x.Source, RefNbrs
	,		Stage, PostedOn, StatedOn, CourierAlias
	from   shpt.Parcel#Base()  x
	join   tms.Courier#Raw()   c	ON  c.ID=x.LastMilerID
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$ForUploadIDPicture]...';


GO
-- Daxia
ALTER FUNCTION [svc].[Parcel$ForUploadIDPicture]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	with cteCneeInfo as
	(
		select	MatterID, Name=c.v1, Phone=c.v2
		from	core.RefInfo#Type() k, core.RefInfo#Raw() x
		cross	apply tvp.Dozen#Of(x.Info, default) c
		where	x.Type=k.CneeInfo
	)
	select	p.ID, Name, Phone, p.RefInfos from cteCneeInfo x
	join	shpt.Parcel#Base() p on p.ID=x.MatterID and p.StateID in(38336, 17250)--USE State#ID
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$ListForRef]...';


GO
-- Daxia
ALTER FUNCTION [svc].[Parcel$ListForRef](@siteID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, RefNbrs, RefInfos, Stage
	from	shpt.Parcel#Base()
	where	SiteID=@siteID
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$RefInfoFor]...';


GO
--Aimee, Smile
ALTER FUNCTION [svc].[Parcel$RefInfoFor](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, m.Stage, SiteAlias, RefInfos, RefNbrs
	from	core.RefNbr#ScanOne(@number, default, default) x
	join	shpt.Parcel#Base() m on m.ID = x.MatterID
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$ScanOneForApp]...';


GO
-- AaronLiu
ALTER FUNCTION [svc].[Parcel$ScanOneForApp](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	p.ID, p.Stage
	from	core.RefNbr#ScanOne(@number, default, default) x
	join	shpt.Parcel#Base() p on p.ID=x.MatterID
)
GO
PRINT N'Adding schema binding to [vmi].[Parcel$Summary]...';


GO
--Smile
ALTER FUNCTION [vmi].[Parcel$Summary]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, Stage, x.Source, SvcType, RcvHubID, RcvHubAlias=h.Alias, TenantID=t.ID, TenantAlias=t.Alias
	,		RefNbrs, RefInfos
	from	shpt.Parcel#Base() x
	join	core.Party#Raw()   h on h.ID=x.RcvHubID
	join	core.Party#Raw()   p on p.ID=x.SiteID
	join	core.Party#Raw()   t on t.ID=p.PID
	cross	apply core.Source#ID() k
	where	x.Source=k.eVMI
)
GO
PRINT N'Adding schema binding to [vmi].[Parcel$SummaryVia]...';


GO
--Smile
ALTER FUNCTION [vmi].[Parcel$SummaryVia](@idsInCsv nvarchar(max))
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, Stage, x.Source, SvcType, RcvHubID, RcvHubAlias=h.Alias, TenantID=t.ID, TenantAlias=t.Alias
	,		RefNbrs, RefInfos, x.PostedOn
	from	tvp.I64#Slice(@idsInCsv) i
	join	shpt.Parcel#Base() x on x.ID=i.ID
	join	core.Party#Raw()   h on h.ID=x.RcvHubID
	join	core.Party#Raw()   p on p.ID=x.SiteID
	join	core.Party#Raw()   t on t.ID=p.PID
	cross	apply core.Source#ID() k
	where	x.Source=k.eVMI
)
GO
PRINT N'Altering [zeb].[Parcel$RePacked]...';


GO
-- AaronLiu
ALTER FUNCTION [zeb].[Parcel$RePacked](@parcelID I64)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ID
	from	shpt.Parcel#Base()
	where	AID=@parcelID
)
GO
PRINT N'Adding schema binding to [hub].[Sack$DetailForPrint]...';


GO
-- Smile
ALTER FUNCTION [hub].[Sack$DetailForPrint](@sackID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	RouteID=t.ID, FmCountryCode=c.CountryCode, SackSeq=isnull(q.SeqNbr, 0)
	,		x.PostedOn
	from	shpt.Sack#Base()          x
	cross	apply core.Contact#Type() k
	join	core.Contact#Raw() c on x.HubID=c.PartyID and c.Type=k.Billing
	join	tms.Route#Raw()    t on t.ClrMethodID=x.ClrMethodID and t.BrokerID=x.BrokerID
	cross	apply shpt.Sack#SeqNbrOf(x.ID) q
	where	x.ID=@sackID
)
GO
PRINT N'Altering [hub].[Sack$InLoad]...';


GO
-- Eva
ALTER	FUNCTION [hub].[Sack$InLoad](@sackloadID I64)
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ID,  Stage,   StateID, StatedOn,      HubID,    POD, POA
	,		BrokerID, ClrMethodID, Weight=SackWt, PostedOn, FlightID
	,		SackNbr=r.Number
	from	shpt.Sack#Base()         x
	cross	apply core.RefNbr#Type() s
	join	core.RefNbr#Raw()        r on r.MatterID=x.ID and r.Type=s.MIT
	where	x.AID=@sackloadID
)
GO
PRINT N'Altering [hub].[Sack$InManifest]...';


GO
-- AaronLiu
ALTER	FUNCTION [hub].[Sack$InManifest](@sackMftID I64)
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ID,	 Stage,	   StateID,     StatedOn,      HubID,     ManifestID=PID
	,		POA, BrokerID, ClrMethodID, Weight=SackWt, ParcelCnt, PostedOn
	,		SackNbr=r.Number
	from	shpt.Sack#Base()	     x
	cross	apply core.RefNbr#Type() s
	join	core.Port#Raw()		     a on  x.POA=a.Code
	join	core.RefNbr#Raw()        r on r.MatterID=x.ID and r.Type=s.MIT
	cross	apply (
		select	ParcelCnt = isnull(sum(case when m.Type=t.Parcel then 1 else 0 end),0)
		from	core.Matter#PNodeDn(x.ID) m
		cross	apply core.Matter#Type()  t
	) n
	where	x.PID=@sackMftID
)
GO
PRINT N'Altering [hub].[Sack$List]...';


GO
-- Eva
ALTER	FUNCTION [hub].[Sack$List]()
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	x.ID, SackNbr=r.Number, Stage, StateID,  StatedOn, HubID, POD, POA
	,		RouteID=t.ID, PostedOn, ParcelCnt
	from	shpt.Sack#Base()             x
	cross	apply core.RefNbr#Type()     s
	join	core.RefNbr#Raw()            r on r.MatterID=x.ID and r.Type=s.MIT
	join	tms.Route#Raw()              t on t.ClrMethodID=x.ClrMethodID and t.BrokerID=x.BrokerID
	cross	apply hub.Sack#Parcels(x.ID) n
)
GO
PRINT N'Refreshing [hub].[Sack$ScanOne]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[Sack$ScanOne]';


GO
PRINT N'Refreshing [hub].[Sack$ScanOneForMft]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[Sack$ScanOneForMft]';


GO
PRINT N'Refreshing [hub].[SackLoad$List]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[SackLoad$List]';


GO
PRINT N'Refreshing [hub].[SackLoad$ScanOne]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[SackLoad$ScanOne]';


GO
PRINT N'Altering [hub].[SackMft$Summary]...';


GO
-- AaronLiu, Smile
ALTER	FUNCTION [hub].[SackMft$Summary]()
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ID,       Stage, StateID,   StatedOn,   HubID
	,		BrokerID, POA,   ParcelCnt, UnSackedParcelCnt
	,		SackCnt,  PostedOn
	from	shpt.SackMft#Base()	x
	cross	apply (
		select	SackCnt			  = isnull(sum(case when m.Type=t.Sack   then 1 else 0 end),0)
		,		ParcelCnt		  = isnull(sum(case when m.Type=t.Parcel then 1 else 0 end),0)
		,		UnSackedParcelCnt = isnull(sum(case when m.Type=t.Parcel and m.Level=1 then 1 else 0 end),0)
		from	core.Matter#PNodeDn(x.ID) m
		cross	apply core.Matter#Type()  t
	) n
)
GO
PRINT N'Adding schema binding to [shpt].[SackMft#LedgerByCharge]...';


GO
--Daxia
ALTER FUNCTION [shpt].[SackMft#LedgerByCharge](@sackMftID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID=x.ID, ContractID=0, [LedgerPartyID]=p.AID, u.ChargeID, u.ChargeAmt, u.CurrencyID
	from	shpt.SackMft#Base() x
	join	core.Party#Raw()    p on p.ID=x.HubID
	cross	apply core.RefInfo#Type()                    k
	outer	apply core.RefInfo#Of(x.ID, k.BrokerageInfo) i
	cross	apply acct.Charge#ID()                       g
	cross	apply
	(
		select	ChargeAmt=c.Amt,  ChargeID=r.ChargeID, r.CurrencyID
		from	tms.SvcCharge#For(x.HubID, x.BrokerID, x.POA, g.MawbAMSFiling, 0) r
		cross	apply dbo.Money#Make(iif(r.Rate>r.Minimum, r.Rate, r.Minimum), r.CurrencyID) c
		UNION	ALL
		select	ChargeAmt=c.Amt,  ChargeID=r.ChargeID, r.CurrencyID
		from	tms.SvcCharge#For(x.HubID, x.BrokerID, x.POA, g.MawbBaseFee, 0) r
		cross	apply dbo.Money#Make(iif(r.Rate>r.Minimum, r.Rate, r.Minimum), r.CurrencyID) c
		UNION	ALL
		select	ChargeAmt=c.Amt,  ChargeID=r.ChargeID, r.CurrencyID
		from	tms.SvcCharge#For(x.HubID, x.BrokerID, x.POA, g.MawbAirlineISCFee, 0) r
		cross	apply dbo.Money#Make(iif(r.Rate>r.Minimum, r.Rate, r.Minimum), r.CurrencyID) c
		UNION	ALL
		select	ChargeAmt=c.Amt,  ChargeID=r.ChargeID, r.CurrencyID
		from	tms.SvcCharge#For(x.HubID, x.BrokerID, x.POA, g.MawbCfsTransferFuel, 0) r
		cross	apply dbo.Money#Make(iif(r.Rate>r.Minimum, r.Rate, r.Minimum), r.CurrencyID) c
		UNION	ALL
		select	ChargeAmt=c.Amt,  ChargeID=r.ChargeID, r.CurrencyID
		from	tms.SvcCharge#For(x.HubID, x.BrokerID, x.POA, g.MawbCfsTransferFee, 0) r
		cross	apply dbo.Money#Make(iif(r.Rate>r.Minimum, r.Rate, r.Minimum), r.CurrencyID) c
		UNION	ALL
		select	ChargeAmt=c.Amt,  ChargeID=r.ChargeID, r.CurrencyID
		from	tms.SvcCharge#For(x.HubID, x.BrokerID, x.POA, g.MawbSectionEntryFee, 0) r
		cross	apply shpt.SackMft#MawbWtRateCalc(r.Rate, x.MawbWt, 1, r.Minimum) mc
		cross	apply dbo.Money#Make(mc.MawbWtAmt, r.CurrencyID) c
		UNION	ALL
		select	ChargeAmt=c.Amt,  ChargeID=r.ChargeID, r.CurrencyID
		from	tms.SvcCharge#For(x.HubID, x.BrokerID, x.POA, g.MawbTerminalTransfer, 0) r
		cross	apply shpt.SackMft#MawbWtRateCalc(r.Rate, x.MawbWt, 1, r.Minimum) mc
		cross	apply dbo.Money#Make(mc.MawbWtAmt, r.CurrencyID) c
		UNION	ALL
		select	ChargeAmt=c.Amt,  ChargeID=r.ChargeID, r.CurrencyID
		from	tms.SvcCharge#For(x.HubID, x.BrokerID, x.POA, g.MawbPickUpCharge, 0) r
		cross	apply shpt.SackMft#MawbWtRateCalc(r.Rate, x.MawbWt, 1, r.Minimum) mc
		cross	apply dbo.Money#Make(mc.MawbWtAmt, r.CurrencyID) c
		UNION	ALL
		select	ChargeAmt=c.Amt,  ChargeID=r.ChargeID, r.CurrencyID
		from	tms.SvcCharge#For(x.HubID, x.BrokerID, x.POA, g.MawbPalletizing, 0) r
		cross	apply shpt.SackMft#MawbWtRateCalc(r.Rate, x.MawbWt, 150, r.Minimum) mc
		cross	apply dbo.Money#Make(mc.MawbWtAmt, r.CurrencyID) c
		UNION	ALL
		select	ChargeAmt=c.Amt,  ChargeID=r.ChargeID, r.CurrencyID
		from	tms.SvcCharge#For(x.HubID, x.BrokerID, x.POA, g.HawbBrkgFee, 0) r
		cross	apply shpt.SackMft#HawbCntRateCalc(x.ID, r.Rate, r.Minimum, 1000) hc
		cross	apply dbo.Money#Make(hc.HawbAmt, r.CurrencyID) c
		UNION	ALL
		select	ChargeAmt=c.Amt,  ChargeID=r.ChargeID, r.CurrencyID
		from	tms.SvcCharge#For(x.HubID, x.BrokerID, x.POA, g.HawbBrkgLessthanFee, 0) r
		cross	apply shpt.SackMft#HawbCntRateCalc(x.ID, r.Rate, r.Minimum, 1000) hc
		cross	apply dbo.Money#Make(hc.HawbAmt, r.CurrencyID) c
		UNION	ALL
		select	ChargeAmt=c.Amt,  ChargeID=r.ChargeID, r.CurrencyID
		from	tms.SvcCharge#For(x.HubID, x.BrokerID, x.POA, g.HawbHandlingFee, 0) r
		cross	apply shpt.SackMft#HawbCntRateCalc(x.ID, r.Rate, r.Minimum, 5000) hc
		cross	apply dbo.Money#Make(hc.HawbAmt, r.CurrencyID) c
	) u
	where	x.ID in (@sackMftID) and u.ChargeAmt>0
)
GO
PRINT N'Adding schema binding to [svc].[SackMft$MawbInfo]...';


GO
--	Smile
ALTER	FUNCTION [svc].[SackMft$MawbInfo]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	SELECT	ID, MawbNbr, POA, p.UtcOffset, p.UtcPlaceID
	FROM 	shpt.SackMft#Base()   x
	join	core.Port#Raw()       p on p.Code=x.POA
	cross	apply core.Stage#ID() k
	where	x.Stage=k.Arrived
)
GO
PRINT N'Adding schema binding to [svc].[Flight$List]...';


GO
-- AaronLiu
ALTER FUNCTION [svc].[Flight$List]()
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID,  FlightNbr, PostedOn, Stage, StateID, StatedOn, RefStamps, RoledActions
	,		POD, [PODUtcOffset]=d.UtcOffset, [PODUtcPlaceID]=d.UtcPlaceID, ETD
	,		POA, [POAUtcOffset]=a.UtcOffset, [POAUtcPlaceID]=a.UtcPlaceID, ETA
	from	tms.Flight#Base()	 x
	join	core.Port#Raw() a on x.POA=a.Code
	join	core.Port#Raw() d on x.POD=d.Code
)
GO
PRINT N'Adding schema binding to [vmi].[AsnNbr$Verify]...';


GO
--Smile
ALTER FUNCTION [vmi].[AsnNbr$Verify](@siteID int, @asnNbrs nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID=iif(r.MatterID is null, -1, isnull(b.ID, 0)), AsnNbr=x.Piece
	from	tvp.Many#Slice(@asnNbrs)       x
	cross	apply loc.RefNbr#Cast(x.Piece) n
	cross	apply core.RefNbr#Type()       k
	cross	apply core.State#ID()          s
	left	join core.RefNbr#Raw()         r on r.Number=n.Number and r.Type=k.AsnNbr
	left	join whse.StockInOrder#Base()  b on b.ID=r.MatterID  and 
												b.StateID=s.AsnNbrGenerated and
												b.SiteID=@siteID

)
GO
PRINT N'Adding schema binding to [vmi].[StockInOrder$Summary]...';


GO
-- Smile
ALTER FUNCTION [vmi].[StockInOrder$Summary]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID, CreatedOn=PostedOn, Stage, r.Number, SiteID
	from	whse.StockInOrder#Base() x
	cross	apply core.RefNbr#Type() t
	join	core.RefNbr#Raw()        r on r.MatterID=x.ID and r.Type=t.AsnNbr
)
GO
PRINT N'Refreshing [svc].[FileBankID$Lookup]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[FileBankID$Lookup]';


GO
PRINT N'Adding schema binding to [core].[Matter#Maybe]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Matter#Maybe](@matterID bigint, @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	core._Matter x
	cross	apply core.Transition#Tobe(x.StateID, @roleID, @actionID, x.RejoinID) t
	cross	apply core.Challenge#Borderline(x.ID) c
	where	x.ID=@matterID and x.LockCnt=0 and t.ToStage<=c.Borderline
)
GO
PRINT N'Adding schema binding to [core].[Matter#MaybeVia]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Matter#MaybeVia](@idsInCsv nvarchar(max), @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	tvp.I64#Slice(@idsInCsv) i join core._Matter x on x.ID=i.ID
	cross	apply core.Transition#Tobe(x.StateID, @roleID, @actionID, x.RejoinID) t
	cross	apply core.Challenge#Borderline(x.ID) c
	where	x.LockCnt=0 and t.ToStage<=c.Borderline

/*
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	tvp.I64#Slice(@idsInCsv) i join core._Matter x on x.ID=i.ID
	cross	apply core.Transition#Tobe(x.StateID, @roleID, @actionID) t
*/
)
GO
PRINT N'Adding schema binding to [shpt].[Parcel#Maybe]...';


GO
--PeterHo
ALTER FUNCTION [shpt].[Parcel#Maybe](@id bigint, @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID, ActionID, OnStateID, ToStateID, ToStage, Source, OutboundQ, TodoHours
	from	shpt.Parcel#Raw() p
	cross	apply tms.RouteRole#For(p.RouteID, @roleID, @actionID) r
	cross	apply core.Matter#Maybe(p.ID,     r.RoleID, @actionID) t
	where	p.ID=@id
)
GO
PRINT N'Adding schema binding to [shpt].[Parcel#MaybeVia]...';


GO
--PeterHo
ALTER FUNCTION [shpt].[Parcel#MaybeVia](@idsInCsv nvarchar(max), @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID, ActionID, OnStateID, ToStateID, ToStage, Source, OutboundQ, TodoHours
	from	tvp.I64#Slice(@idsInCsv) x join shpt.Parcel#Raw()      p on p.ID=x.ID
	cross	apply tms.RouteRole#For(p.RouteID, @roleID, @actionID) r
	cross	apply core.Matter#Maybe(p.ID,     r.RoleID, @actionID) t
)
GO
PRINT N'Altering [core].[Challenge#Of]...';


GO
--PeterHo
ALTER FUNCTION [core].[Challenge#Of](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	Marker=lead(m.RegID) over (partition by m.RegID, m.RowID, m.AuxID order by (select 0))
		,		x.Type, x.BoundStage, m.Body, m.PostedOn, m.PosterID, m.PosterAlias
		from	core.Challenge#Raw()     x
		cross	apply core.Registry#ID() r
		cross	apply core.Message#Of(r.Matter, MatterID, Type) m
		where	x.MatterID=@matterID
	)
	select	Type, BoundStage, Body, PostedOn, PosterID, PosterAlias
	from	cte where Marker is null
)
GO
PRINT N'Adding schema binding to [core].[Challenge#Of]...';


GO
--PeterHo
ALTER FUNCTION [core].[Challenge#Of](@matterID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte as
	(
		select	Marker=lead(m.RegID) over (partition by m.RegID, m.RowID, m.AuxID order by (select 0))
		,		x.Type, x.BoundStage, m.Body, m.PostedOn, m.PosterID, m.PosterAlias
		from	core.Challenge#Raw()     x
		cross	apply core.Registry#ID() r
		cross	apply core.Message#Of(r.Matter, MatterID, Type) m
		where	x.MatterID=@matterID
	)
	select	Type, BoundStage, Body, PostedOn, PosterID, PosterAlias
	from	cte where Marker is null
)
GO
PRINT N'Adding schema binding to [svc].[Message$List]...';


GO
--PeterHo: HACK!!， Aimee
ALTER	FUNCTION [svc].[Message$List](@matterID bigint)
RETURNS	TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	m.ID, m.AuxID, m.Body, m.PostedOn, m.PosterID, m.PosterAlias, BoundStage=isnull(cast(c.BoundStage as int), 0)
	from	core.Registry#ID() k
	cross	apply core.Message#Of(k.Matter, @matterID, default) m
	left	join core.Challenge#Of(@matterID) c on c.Type=m.AuxID and c.Body=m.Body and c.PostedOn=m.PostedOn
)
GO
PRINT N'Adding schema binding to [svc].[User$Summary]...';


GO
--Smile
ALTER FUNCTION [svc].[User$Summary]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, Alias, RoleTvps=r.Tvp, Name, Email
	from	core.User#Raw()           x
	cross	apply core.Contact#Type() k
	left	join core.Contact#Raw()   c on c.PartyID=x.ID and c.Type=k.Billing
	cross	apply core.UserRole#Tvp(x.ID) r 
)
GO
PRINT N'Adding schema binding to [api].[MIC$VefityForPlatform]...';


GO
/*
@micsInCsv =Duad[Alias, MIC]
*/
--Smile, AaronLiu
ALTER	FUNCTION [api].[MIC$VefityForPlatform](@userID int, @micsInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID=isnull(b.ID, 0), ClientRefNbr=d.Number
	from	tvp.Duad#Slice(@micsInCsv, default, default) x
	cross	apply loc.RefNbr#Cast(x.v2)                  d
	cross	apply core.RefNbr#Type()                     k
	left	join  core.RefNbr#Raw()                      r on r.Number=d.Number and r.Type=k.MIT
	join	core.Party#Raw()                             n on n.ID=@userID
	left	join  core.Party#Raw()                       p on p.Source=n.Source and p.Alias=x.v1
	cross	apply core.Stage#ID()                        s
	left	join  core.Matter#Raw()                      b on r.MatterID=b.ID   and b.PosterID=p.ID
)
GO
PRINT N'Adding schema binding to [hub].[Parcel$CheckForRackOut]...';


GO
-- Smile
ALTER FUNCTION [hub].[Parcel$CheckForRackOut](@number varchar(40), @orderID int, @userID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	d.ID
	from	whse.RackOrder#Raw()    x
	cross	apply core.RefNbr#ScanOne(@number, default, default) m
	join	core.Matter#Raw()       d on d.ID=m.MatterID
	join	shpt.RackXact#Raw()     r on r.OrderOutID=x.ID and r.ParcelID=m.MatterID
	cross	apply core.State#ID()   k
	where	x.ID=@orderID and x.RackerID=@userID and d.StateID=k.TobeRackedOut
	
)
GO
PRINT N'Adding schema binding to [rpt].[Dashboard$ParcelSummary]...';


GO
-- Eason
ALTER FUNCTION [rpt].[Dashboard$ParcelSummary](@siteID bigint, @startDate datetime, @endDate datetime, @timezoneOffset int=0)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	c.Value as [Date]
	,		Parcel=isnull(count(*), 0)
	,		Sales =round(sum(isnull(s.Sales, 0)), 2)
	from	core.Matter#Raw()         x
	cross	apply core.Matter#Type()  mt
	cross	apply core.RefInfo#Type() rt
	cross	apply tvp.Spr#Const()     sp
	cross   apply dbo.Calendar#Of(DATEADD(HOUR, -@timezoneOffset, @startDate)) sd
	cross   apply dbo.Calendar#Of(DATEADD(HOUR, -@timezoneOffset, @endDate  )) ed
	join	dbo.Calendar#Raw() c on cast(x.PostedOn as Date)=c.Value
	cross	apply
	(
		select	Sales=isnull(sum(m.DecAmt), 0)
		from	core.RefInfo#Of(x.ID,rt.DeclaredInfo)           i
		cross	apply tvp.Quad#Slice(i.Info, default, sp.Mucho) t
		cross	apply dbo.Money#Of(t.v3)                        m
	) s
	where	c.DOffset between sd.DOffset and ed.DOffset
	and		x.Type=mt.Parcel
	and		x.PosterID=@siteID
	group	by c.Value
);
GO
PRINT N'Adding schema binding to [svc].[Parcel$ForBrokerage]...';


GO
-- Eason
ALTER FUNCTION [svc].[Parcel$ForBrokerage]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, m.PID, AID, m.Source, Type, LockCnt, Stage, m.StateID, StatedOn, PostedOn
	,		RcvHubID,  RcvHubAlias=c.Alias
	,		RouteID,   RouteCode, BrokerID, CourierID       , ClrMethodID
	,		POA,       SvcType,   SvcZone,  SvcClass, Weight, Length, Width, Height
	,		RefNbrs,   RefInfos=i.RefInfos
	,		Endorsement=e.Tvp
	from	shpt.Parcel#Raw()            x
	join	core.Matter#Raw()            m on m.ID=x.ID
	join	tms.Route#Raw()              r on r.ID=x.RouteID
	join	core.Tenant#Raw()			 c on c.ID=x.RcvHubID
	cross	apply core.RefInfo#Tvp(x.ID) i
	cross	apply core.RefInfo#Type()    t
	cross	apply core.RefNbr#Tvp(x.ID)  rn
	cross	apply
	(
		select	Info=i.v2
		from	tvp.Duad#Slice(i.RefInfos, default, default)  i
		where	i.v1=t.BrokerageInfo
	) ri	
	cross	apply
	(
		select	[text()]=concat(k.Many, b.SkuID, k.Triad, mt.v3, k.Triad, e.v2)
		from	tvp.Spr#Const() k, tvp.Mucho#Slice(ri.Info) m
		cross	apply tvp.Triad#Of(m.Piece, default)        mt
		join	invt.SkuBrokerage#Raw()                     b
		on		b.SkuID=cast(mt.v1 as int) and b.BrokerID=r.BrokerID and b.ClrMethodID=r.ClrMethodID
		cross	apply tvp.Pair#Of(b.Endorsement)			e
		for	xml path(N'')
	) z (text)
	cross	apply tvp.Spr#Purify(z.text, default) e
)
GO
PRINT N'Adding schema binding to [hub].[Parcel$ShippingPlanInfo]...';


GO
-- Smile
ALTER FUNCTION [hub].[Parcel$ShippingPlanInfo](@number varchar(40))
RETURNS TABLE
--, ENCRYPTION
WITH SCHEMABINDING
AS RETURN 
(
	select	ID=x.MatterID, Seq=b.Seq, ParcelItem=b.Piece
	from	core.RefNbr#ScanOne(@number, default, default)        x
	cross	apply core.RefInfo#Type()                             t
	cross	apply core.RefInfo#Of(x.MatterID, t.ShippingPlanInfo) i
	cross	apply tvp.Bag#Slice(i.Info)                           b
	
)
GO
PRINT N'Adding schema binding to [hub].[Parcel$ShippingPlanVia]...';


GO
-- Eva
ALTER FUNCTION [hub].[Parcel$ShippingPlanVia](@number varchar(40))
RETURNS TABLE
--, ENCRYPTION
WITH SCHEMABINDING
AS RETURN 
(
	select	ID=x.MatterID, x.Number, ShippingPlan=i.Info
	from	core.RefNbr#ScanOne(@number, default, default)        x
	cross	apply core.RefInfo#Type()                             t
	cross	apply core.RefInfo#Of(x.MatterID, t.ShippingPlanInfo) i
	cross	apply core.Matter#Type()                              mt
	where	x.Type=mt.Parcel
)
GO
PRINT N'Altering [core].[Matter#Tobe]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Matter#Tobe](@matterID bigint, @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	core._Matter x cross apply core.Transition#Tobe(x.StateID, @roleID, @actionID, x.RejoinID) t
	where	x.ID=@matterID
)
GO
PRINT N'Adding schema binding to [core].[Matter#Tobe]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Matter#Tobe](@matterID bigint, @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	core._Matter x cross apply core.Transition#Tobe(x.StateID, @roleID, @actionID, x.RejoinID) t
	where	x.ID=@matterID
)
GO
PRINT N'Adding schema binding to [shpt].[Parcel#Tobe]...';


GO
--PeterHo
ALTER FUNCTION [shpt].[Parcel#Tobe](@id bigint, @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID, ActionID, OnStateID, ToStateID, ToStage, Source, OutboundQ, TodoHours
	from	shpt.Parcel#Raw() p
	cross	apply tms.RouteRole#For(p.RouteID, @roleID, @actionID) r
	cross	apply core.Matter#Tobe (p.ID,     r.RoleID, @actionID) t
	where	p.ID=@id
)
GO
PRINT N'Adding schema binding to [shpt].[Parcel#TobeVia]...';


GO
--PeterHo
ALTER FUNCTION [shpt].[Parcel#TobeVia](@idsInCsv nvarchar(max), @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID, ActionID, OnStateID, ToStateID, ToStage, Source, OutboundQ, TodoHours
	from	shpt.Parcel#Raw() p
	cross	apply tms.RouteRole#For(p.RouteID, @roleID, @actionID) r
	cross	apply core.Matter#Tobe (p.ID,     r.RoleID, @actionID) t
	where	p.ID in (select ID from tvp.I64#Slice(@idsInCsv))
)
GO
PRINT N'Altering [core].[Matter#TobeVia]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Matter#TobeVia](@idsInCsv nvarchar(max), @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	tvp.I64#Slice(@idsInCsv) i join core._Matter x on x.ID=i.ID
	cross	apply core.Transition#Tobe(x.StateID, @roleID, @actionID, x.RejoinID) t

/*	-- Cheated by Execution Plan.
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	core._Matter x
	cross	apply core.Transition#Tobe(x.StateID, @roleID, @actionID) t
	where	x.ID in (select ID from tvp.I64#Slice(@idsInCsv))
*/
)
GO
PRINT N'Adding schema binding to [core].[Matter#TobeVia]...';


GO
-- PeterHo
ALTER FUNCTION [core].[Matter#TobeVia](@idsInCsv nvarchar(max), @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	tvp.I64#Slice(@idsInCsv) i join core._Matter x on x.ID=i.ID
	cross	apply core.Transition#Tobe(x.StateID, @roleID, @actionID, x.RejoinID) t

/*	-- Cheated by Execution Plan.
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	core._Matter x
	cross	apply core.Transition#Tobe(x.StateID, @roleID, @actionID) t
	where	x.ID in (select ID from tvp.I64#Slice(@idsInCsv))
*/
)
GO
PRINT N'Altering [core].[MIC#Emit]...';


GO
--PeterHo
ALTER FUNCTION [core].[MIC#Emit](@matterID bigint, @source tinyint, @type tinyint, @postedOn date)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePic as
	(
		select	nbr=concat('36'
				,   format(@source  %100,      '00')
				,   format(@type    %100,      '00')
				,   format(DOffset  %100000,   '00000')
				,	format(@matterID%10000000, '0000000'))
		from	dbo.Calendar#Of(@postedOn)
	)
	select	MIC=n.EncodedNbr
	from	ctePic cross apply dbo.Nbr#Mod10(nbr) n
)
GO
PRINT N'Adding schema binding to [core].[MIC#Emit]...';


GO
--PeterHo
ALTER FUNCTION [core].[MIC#Emit](@matterID bigint, @source tinyint, @type tinyint, @postedOn date)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with ctePic as
	(
		select	nbr=concat('36'
				,   format(@source  %100,      '00')
				,   format(@type    %100,      '00')
				,   format(DOffset  %100000,   '00000')
				,	format(@matterID%10000000, '0000000'))
		from	dbo.Calendar#Of(@postedOn)
	)
	select	MIC=n.EncodedNbr
	from	ctePic cross apply dbo.Nbr#Mod10(nbr) n
)
GO
PRINT N'Altering [core].[MIC#IdOf]...';


GO
--PeterHo
ALTER FUNCTION [core].[MIC#IdOf](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID from core.RefNbr#Type() k
	cross	apply core.RefNbr#IdOfFirst(@number, k.MIT)
)
GO
PRINT N'Adding schema binding to [core].[MIC#IdOf]...';


GO
--PeterHo
ALTER FUNCTION [core].[MIC#IdOf](@number varchar(40))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID from core.RefNbr#Type() k
	cross	apply core.RefNbr#IdOfFirst(@number, k.MIT)
)
GO
PRINT N'Adding schema binding to [svc].[Sku$Verify]...';


GO
--PeterHo, Smile
ALTER FUNCTION [svc].[Sku$Verify](@siteID int, @svcType int, @skuNbrs nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	
	select	ID=isnull(cast(d.SkuID as bigint), 0), c.SkuNbr
	from	tvp.Many#Slice(@skuNbrs)       x
	cross	apply loc.SkuNbr#Cast(x.Piece) c
	join	core.Party#Raw()               p on p.ID=@siteID
	left	join invt.Sku#Raw()            t on t.TenantID=p.PID and t.SkuNbr=c.SkuNbr
	cross	apply tms.SvcType#For(@svcType, @siteID)    s
	cross	apply tms.SvcRoute#For(s.ID, s.FallbackPOA) r
	join	tms.Route#Raw()                             a on a.ID=r.RouteID
	outer	apply
	(
		select	top(1) SkuID from invt.SkuBrokerage#Raw()
		where	SkuID=t.ID 
		and		ClrMethodID=a.ClrMethodID
		and		BrokerID=a.BrokerID
	) d
)
GO
PRINT N'Adding schema binding to [svc].[Sku$VerifyForPlatform]...';


GO
/*
@skus = Triad[Alias, Mucho<skus>, SvcType]
*/
--Smile
ALTER FUNCTION [svc].[Sku$VerifyForPlatform](@userID int, @skus nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID=isnull(cast(d.SkuID as bigint), 0), c.SkuNbr, SvcType=isnull(cast(x.v3 as int), 0)
	from	tvp.Triad#Slice(@skus, default, default)	x	
	cross	apply tvp.Mucho#Slice(x.v2)					m
	cross	apply loc.SkuNbr#Cast(m.Piece)				c
	join	core.Party#Raw()							n on n.ID=@userID
	left	join core.Party#Raw()						p on p.Alias=x.v1 and p.Source=n.Source
	left	join invt.Sku#Raw()							t on t.TenantID=p.PID and t.SkuNbr=c.SkuNbr
	cross	apply tms.SvcType#For(x.v3, p.ID)			s
	cross	apply tms.SvcRoute#For(s.ID, s.FallbackPOA) r
	join	tms.Route#Raw()                             a on a.ID=r.RouteID
	outer	apply
	(
		select	top(1) SkuID from invt.SkuBrokerage#Raw()
		where	SkuID=t.ID		 
		and		ClrMethodID=a.ClrMethodID
		and		BrokerID=a.BrokerID
	) d
)
GO
PRINT N'Adding schema binding to [svc].[Tenancy$For]...';


GO
--Eva, PeterHo
ALTER FUNCTION [svc].[Tenancy$For](@userID int)
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	Tvp=concat(p.ID, k.Quad, p.PID, k.Quad, p.AID, k.Quad, x.Alias, k.Duad, r.RoleIDs)
	from	tvp.Spr#Const()  k, core.User#Raw() x
	join	core.Party#Raw() p  on p.ID=x.ID
	cross	apply core.RoleID#Tvp(x.ID) r
	where	x.ID=@userID
)
GO
PRINT N'Adding schema binding to [vmi].[Tenancy$For]...';


GO
--Smile
ALTER FUNCTION [vmi].[Tenancy$For](@userID int)
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	Tvp=concat(p.ID, k.Quad, p.PID, k.Quad, p.AID, k.Quad, t.Alias, k.Duad, r.RoleIDs)
	from	tvp.Spr#Const()   k, core.User#Raw() x
	join	core.Party#Raw()  p  on p.ID=x.ID
	join	core.Tenant#Raw() t  on t.ID=p.AID
	cross	apply core.RoleID#Tvp(x.ID) r
	where	x.ID=@userID
)
GO
PRINT N'Refreshing [svc].[Flight$Verify]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Flight$Verify]';


GO
PRINT N'Adding schema binding to [zeb].[Matter$TobeVia]...';


GO
-- AaronLiu
ALTER FUNCTION [zeb].[Matter$TobeVia](@idsInCsv nvarchar(max), @roleID int, @actionID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	-- !!!	DON'T CHANGE THE ORDERS; Sync with core.TransitionSpec. !!!
	select	MatterID =x.ID,      ActionID=@actionID
	,		OnStateID=x.StateID, ToStateID, ToStage, x.Source, OutboundQ, TodoHours
	from	tvp.I64#Slice(@idsInCsv) i join core._Matter x on x.ID=i.ID
	cross	apply core.Transition#Tobe(x.StateID, @roleID, @actionID, x.RejoinID) t
)
GO
PRINT N'Altering [dbo].[Bit#On]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Bit#On](@value bigint, @size tinyint)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	top(@size%65) Bit, Val
	from	dbo.Bit#Wise()
	where	(Val&@value)<>cast(0 as bigint)
)
GO
PRINT N'Adding schema binding to [dbo].[Bit#On]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Bit#On](@value bigint, @size tinyint)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	top(@size%65) Bit, Val
	from	dbo.Bit#Wise()
	where	(Val&@value)<>cast(0 as bigint)
)
GO
PRINT N'Altering [dbo].[Calendar#Emit]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Calendar#Emit] (@dayCount int, @anchorOffset int=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteAnchor as
	(
		select	[Anchor]=dateadd(yy, isnull(@anchorOffset, 0), k.Anchor)
		from	dbo.DT#Const() k
	)
	select	Value
	,		Year,    Quarter, Month,   Week,    Day,Dow
	,		YOffset, QOffset, MOffset, WOffset, DOffset
	from	cteAnchor
	cross	apply dbo.Nbr#Emit(abs(@dayCount))
	cross	apply dbo.Calendar#Of(dateadd(dd, (Nbr-1)*sign(@dayCount), Anchor))
)
GO
PRINT N'Adding schema binding to [dbo].[Calendar#Emit]...';


GO
-- PeterHo
ALTER FUNCTION [dbo].[Calendar#Emit] (@dayCount int, @anchorOffset int=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteAnchor as
	(
		select	[Anchor]=dateadd(yy, isnull(@anchorOffset, 0), k.Anchor)
		from	dbo.DT#Const() k
	)
	select	Value
	,		Year,    Quarter, Month,   Week,    Day,Dow
	,		YOffset, QOffset, MOffset, WOffset, DOffset
	from	cteAnchor
	cross	apply dbo.Nbr#Emit(abs(@dayCount))
	cross	apply dbo.Calendar#Of(dateadd(dd, (Nbr-1)*sign(@dayCount), Anchor))
)
GO
PRINT N'Adding schema binding to [loc].[LineInfo#Of]...';


GO
-- PeterHo
ALTER FUNCTION [loc].[LineInfo#Of](@info nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	GoodsInfo=v1
	,		LineQty  =cast(v2 as int)
	,		CmdyID   =cast(v4 as int)
	,		LineTotal=cast(v3 as bigint)
	,		LineRawTotal=m.RawAmt
	,		LineDecTotal=m.DecAmt
	,		m.CurrencyID
	from	tvp.Quad#Of(@info, default)
	cross	apply dbo.Money#Of(cast(v3 as bigint)) m
)
GO
PRINT N'Adding schema binding to [loc].[TotalSkuQty#For]...';


GO
ALTER FUNCTION [loc].[TotalSkuQty#For](@declaredInfo nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	TotalSkuQty=sum(l.LineQty)
	from	tvp.Mucho#Slice(@declaredInfo) x
	cross	apply loc.LineInfo#Of(x.Piece) l
)
GO
PRINT N'Adding schema binding to [invt].[SkuInfo#ToDeclared]...';


GO
/*
@skuInfos: Mucho[Triad<SkuID, LineQty, LineTotal>]
*/
--PeterHo, AaronLiu
ALTER FUNCTION [invt].[SkuInfo#ToDeclared](@skuInfos nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat
		(
			k.Mucho, /*GoodsInfo*/ p.v1
		,	k.Quad,  /*LineQty  */ t.v2
		,	k.Quad,  /*LineTotal*/ t.v3
		,	k.Quad,  /*CmdyID   */ N'0'
		)
		from	tvp.Mucho#Slice(@skuInfos)           x
		cross	apply tvp.Triad#Of(x.Piece, default) t
		join	invt.Sku#Raw()						 s on s.ID=cast(t.v1 as int)
		cross	apply tvp.Pair#Of(s.FiledInfo)		 p
		cross	apply tvp.Spr#Const()				 k 
		order	by x.Seq for xml path (N'')
	)
	select Info=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Adding schema binding to [svc].[Sku$VerifyForEndorsement]...';


GO
/*
@skuIDs = string.Join(at.Spr.Comma, skuIDs);
*/
--Aimee
ALTER FUNCTION [svc].[Sku$VerifyForEndorsement](@skuIDs nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	SkuID=x.Piece, Result=isnull(cast(s.ID as bigint), 0)
	from	tvp.Comma#Slice(@skuIDs) x
	left	join invt.Sku#Raw()      s on s.ID=x.Piece
)
GO
PRINT N'Altering [loc].[CmdyInfo#Of]...';


GO
-- PeterHo
ALTER FUNCTION [loc].[CmdyInfo#Of](@info nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	CmdyHeadID=cast(v1 as int)
	,		CmdyTailID=cast(v2 as int)
	,		DutyCode  =v3
	,		DutyRate  =cast(v4 as real)
	from	tvp.Quad#Of(@info, default)
)
GO
PRINT N'Adding schema binding to [loc].[CmdyInfo#Of]...';


GO
-- PeterHo
ALTER FUNCTION [loc].[CmdyInfo#Of](@info nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	CmdyHeadID=cast(v1 as int)
	,		CmdyTailID=cast(v2 as int)
	,		DutyCode  =v3
	,		DutyRate  =cast(v4 as real)
	from	tvp.Quad#Of(@info, default)
)
GO
PRINT N'Altering [loc].[Contact#Of]...';


GO
-- PeterHo
ALTER FUNCTION [loc].[Contact#Of](@slip nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Name=v1,    Phone=v2,     Email=v3,       Company=v4
	,		Street1=v5, Street2=v6,   Street3=v7,     District=v8
	,		City=v9,    Province=v10, PostalCode=v11, CountryCode=v12
	from	tvp.Dozen#Of(@slip, default)
)
GO
PRINT N'Adding schema binding to [loc].[Contact#Of]...';


GO
-- PeterHo
ALTER FUNCTION [loc].[Contact#Of](@slip nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Name=v1,    Phone=v2,     Email=v3,       Company=v4
	,		Street1=v5, Street2=v6,   Street3=v7,     District=v8
	,		City=v9,    Province=v10, PostalCode=v11, CountryCode=v12
	from	tvp.Dozen#Of(@slip, default)
)
GO
PRINT N'Adding schema binding to [loc].[RefNbr#Slice]...';


GO
--PeterHo
ALTER FUNCTION [loc].[RefNbr#Slice](@numbersInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.Seq, n.Number
	from	tvp.Comma#Slice(@numbersInCsv) x
	cross	apply loc.RefNbr#Cast(x.Piece) n
)
GO
PRINT N'Altering [loc].[Tenancy#Of]...';


GO
-- PeterHo
ALTER FUNCTION [loc].[Tenancy#Of](@slip nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteFact as
	(
		select	[PID]   =cast(v1 as int)
		,		[AID]   =cast(v2 as int)
		,		[UserID]=cast(v3 as int)
		,		[RoleID]=cast(v4 as int)
		from	tvp.Quad#Of(@slip, default)
	)
	select	PID,  AID, UserID,     RoleID
	,		HubID=PID, SiteID=PID, AcctID=AID
	from	cteFact
)
GO
PRINT N'Adding schema binding to [loc].[Tenancy#Of]...';


GO
-- PeterHo
ALTER FUNCTION [loc].[Tenancy#Of](@slip nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteFact as
	(
		select	[PID]   =cast(v1 as int)
		,		[AID]   =cast(v2 as int)
		,		[UserID]=cast(v3 as int)
		,		[RoleID]=cast(v4 as int)
		from	tvp.Quad#Of(@slip, default)
	)
	select	PID,  AID, UserID,     RoleID
	,		HubID=PID, SiteID=PID, AcctID=AID
	from	cteFact
)
GO
PRINT N'Adding schema binding to [svc].[CourierAlias$Verify]...';


GO
--Smile
ALTER FUNCTION [svc].[CourierAlias$Verify](@aliasInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID=c.CourierID, CourierAlias=x.Piece
	from	tvp.Comma#Slice(@aliasInCsv)          x
	cross	apply tms.Courier#IdOfAlias(x.Piece)  c
)
GO
PRINT N'Adding schema binding to [tms].[SvcFacility#For]...';


GO
-- PeterHo
ALTER FUNCTION [tms].[SvcFacility#For](@source tinyint, @svcClass tinyint, @zip3 char(3))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	f.CourierID,    c.ClassCode, TokenID
	,		ImportZoneCode, POA,         MailerID
	,		ImportZip3,     FacilityID,  FacilityInfo
	,		ShprInfo,       CneeInfo,    ReturnInfo
	from	tms.SvcClass#Raw() c
	join	tms.SvcFacility#ZoneCode() f on f.CourierID=c.CourierID
	where	c.ID=@svcClass and f.ZoneCode=@zip3 and f.SourceID=@source
)
GO
PRINT N'Adding schema binding to [tms].[SvcZone#For]...';


GO
-- Daxia
ALTER FUNCTION [tms].[SvcZone#For](@source tinyint, @svcClass tinyint, @onZip3 char(3), @toZip3 char(3))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	z.CourierID, z.OnZoneCode3, z.ToZoneCode3, z.Zone
	from	tms.SvcClass#Raw() c
	join	tms.SvcFacility#ZoneCode() f on f.CourierID=c.CourierID
	join	tms._SvcZone z on z.CourierID=c.CourierID and z.OnZoneCode3=@onZip3 and z.ToZoneCode3=@toZip3
	where	c.ID=@svcClass and f.ZoneCode=@onZip3 and f.SourceID=@source
)
GO
PRINT N'Adding schema binding to [tms].[TrackingNbr#Slice]...';


GO
-- PeterHo
ALTER FUNCTION [tms].[TrackingNbr#Slice](@slip nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	TrackingNbr
	from	tvp.Many#Slice(@slip)
	cross	apply tms.TrackingNbr#Cast(Piece)
)
GO
PRINT N'Altering [tvp].[Block#At]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Block#At]
(
	@index     int,
	@source    nvarchar(max),
	@blockSpr  nvarchar(255)=N'	%	',
	@sourceSpr nvarchar(255)=N'	;	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select [Tvp]=stuff(
	(
		select	[text()]=@sourceSpr + v.Piece
		from	tvp.Pcs#SliceV(@index, @source, @blockSpr, @sourceSpr) v
		for     xml path(N'')
	), 1, datalength(@sourceSpr)/2, N'')
)
GO
PRINT N'Adding schema binding to [tvp].[Block#At]...';


GO
-- PeterHo: 4/1
ALTER FUNCTION [tvp].[Block#At]
(
	@index     int,
	@source    nvarchar(max),
	@blockSpr  nvarchar(255)=N'	%	',
	@sourceSpr nvarchar(255)=N'	;	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select [Tvp]=stuff(
	(
		select	[text()]=@sourceSpr + v.Piece
		from	tvp.Pcs#SliceV(@index, @source, @blockSpr, @sourceSpr) v
		for     xml path(N'')
	), 1, datalength(@sourceSpr)/2, N'')
)
GO
PRINT N'Altering [tvp].[Block#Fold]...';


GO
 --PeterHo: 4/1
ALTER FUNCTION [tvp].[Block#Fold]
(
	@index     int          --=2
,	@master    nvarchar(max)--=N'1,2'
,	@house     nvarchar(max)--=N'T	%	A	,	B	;	U	%	C	,	D'
--------------------------------------------------------------------------
,	@masterSpr nvarchar(255)=N','
,	@houseSpr  nvarchar(255)=N'	;	'
,	@blockSpr  nvarchar(255)=N'	%	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.Seq, Master=x.Piece, House=v.Piece
	from	tvp.Pcs#Slice(@master, @masterSpr) x
	join	tvp.Pcs#SliceV(@index, @house, @blockSpr, @houseSpr) v on v.Seq=x.Seq
/*
	select	m.Seq, Master=m.Piece, House=h.Piece
	from	tvp.Pcs#Slice(@master, @masterSpr)           m
	cross	apply tvp.Pcs#At(m.Seq,   @house, @houseSpr) x
	cross	apply tvp.Pcs#At(@index, x.Piece, @blockSpr) h
*/
)
GO
PRINT N'Adding schema binding to [tvp].[Block#Fold]...';


GO
 --PeterHo: 4/1
ALTER FUNCTION [tvp].[Block#Fold]
(
	@index     int          --=2
,	@master    nvarchar(max)--=N'1,2'
,	@house     nvarchar(max)--=N'T	%	A	,	B	;	U	%	C	,	D'
--------------------------------------------------------------------------
,	@masterSpr nvarchar(255)=N','
,	@houseSpr  nvarchar(255)=N'	;	'
,	@blockSpr  nvarchar(255)=N'	%	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.Seq, Master=x.Piece, House=v.Piece
	from	tvp.Pcs#Slice(@master, @masterSpr) x
	join	tvp.Pcs#SliceV(@index, @house, @blockSpr, @houseSpr) v on v.Seq=x.Seq
/*
	select	m.Seq, Master=m.Piece, House=h.Piece
	from	tvp.Pcs#Slice(@master, @masterSpr)           m
	cross	apply tvp.Pcs#At(m.Seq,   @house, @houseSpr) x
	cross	apply tvp.Pcs#At(@index, x.Piece, @blockSpr) h
*/
)
GO
PRINT N'Altering [tvp].[Block#FoldA]...';


GO
 --PeterHo: 4/1
ALTER FUNCTION [tvp].[Block#FoldA]
(
	@index     int
,	@master    dbo.I64AutoSeqs readonly
,	@house     nvarchar(max)
,	@houseSpr  nvarchar(255)=N'	;	'
,	@blockSpr  nvarchar(255)=N'	%	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	m.Seq, Master=m.ID, House=v.Piece
	from	tvp.Pcs#SliceV(@index, @house, @blockSpr, @houseSpr) v 
	join	@master m on m.Seq=v.Seq
/*
	select	m.Seq, Master=m.ID, House=h.Piece from @master m
	cross	apply tvp.Pcs#At(m.Seq,   @house, @houseSpr)   x
	cross	apply tvp.Pcs#At(@index, x.Piece, @blockSpr)   h
*/
)
GO
PRINT N'Adding schema binding to [tvp].[Block#FoldA]...';


GO
 --PeterHo: 4/1
ALTER FUNCTION [tvp].[Block#FoldA]
(
	@index     int
,	@master    dbo.I64AutoSeqs readonly
,	@house     nvarchar(max)
,	@houseSpr  nvarchar(255)=N'	;	'
,	@blockSpr  nvarchar(255)=N'	%	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	m.Seq, Master=m.ID, House=v.Piece
	from	tvp.Pcs#SliceV(@index, @house, @blockSpr, @houseSpr) v 
	join	@master m on m.Seq=v.Seq
/*
	select	m.Seq, Master=m.ID, House=h.Piece from @master m
	cross	apply tvp.Pcs#At(m.Seq,   @house, @houseSpr)   x
	cross	apply tvp.Pcs#At(@index, x.Piece, @blockSpr)   h
*/
)
GO
PRINT N'Altering [tvp].[Block#FoldT]...';


GO
 --PeterHo: 4/1
ALTER FUNCTION [tvp].[Block#FoldT]
(
	@index     int
,	@master    dbo.I64Seqs readonly
,	@house     nvarchar(max)
,	@houseSpr  nvarchar(255)=N'	;	'
,	@blockSpr  nvarchar(255)=N'	%	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	m.Seq, Master=m.ID, House=v.Piece
	from	tvp.Pcs#SliceV(@index, @house, @blockSpr, @houseSpr) v 
	join	@master m on m.Seq=v.Seq
/*
	select	m.Seq, Master=m.ID, House=h.Piece from @master m
	cross	apply tvp.Pcs#At(m.Seq,   @house, @houseSpr)   x
	cross	apply tvp.Pcs#At(@index, x.Piece, @blockSpr)   h
*/
)
GO
PRINT N'Adding schema binding to [tvp].[Block#FoldT]...';


GO
 --PeterHo: 4/1
ALTER FUNCTION [tvp].[Block#FoldT]
(
	@index     int
,	@master    dbo.I64Seqs readonly
,	@house     nvarchar(max)
,	@houseSpr  nvarchar(255)=N'	;	'
,	@blockSpr  nvarchar(255)=N'	%	'
)
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	m.Seq, Master=m.ID, House=v.Piece
	from	tvp.Pcs#SliceV(@index, @house, @blockSpr, @houseSpr) v 
	join	@master m on m.Seq=v.Seq
/*
	select	m.Seq, Master=m.ID, House=h.Piece from @master m
	cross	apply tvp.Pcs#At(m.Seq,   @house, @houseSpr)   x
	cross	apply tvp.Pcs#At(@index, x.Piece, @blockSpr)   h
*/
)
GO
PRINT N'Adding schema binding to [svc].[Account$Ledger]...';


GO
-- Smile, PeterHo, FJJ, PeterHo, Smile
ALTER FUNCTION [svc].[Account$Ledger]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,      d.Source,    ChargeAmt, CurrencyID
	,		TalliedOn, x.PartyID,   PartyAlias=p.Alias
	,		Weight,    SvcType,     RefInfos,  RefNbrs
	,		SectionWt, g.VaultTag,  NetDays=isnull(BillingCycle, 0)
	,		BizUnitID, BizUnit=n.Alias, ChargeID, x.MatterID
	from	acct.Ledger#Raw()        x
	join	core.Party#Raw()         p on p.ID=x.PartyID
	join	shpt.Parcel#Base()       d on d.ID=x.MatterID
	join	acct.Charge#Raw()        g on g.ID=x.ChargeID
	join	acct.Contract#Raw()      t on t.ID=d.ContractID
	join	core.Party#Raw()         n on n.ID=t.BizUnitID
	cross	apply acct.Ledger#Side() s 
	cross	apply tms.SvcRate#For(d.SvcType, d.RcvHubID, d.Weight) a
	where	x.LedgerSide=s.AR
)
GO
PRINT N'Adding schema binding to [svc].[Account$StockInOrderLedger]...';


GO
-- Smile
ALTER FUNCTION [svc].[Account$StockInOrderLedger]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,      d.Source,    ChargeAmt, CurrencyID
	,		TalliedOn, x.PartyID,   PartyAlias=p.Alias	
	,		NetDays=isnull(BillingCycle, 0), ChargeID
	,		BizUnitID, BizUnit=n.Alias, AsnNbr=a.Number
	from	acct.Ledger#Raw()        x
	join	core.Party#Raw()         p on p.ID=x.PartyID
	join	whse.StockInOrder#Base() d on d.ID=x.MatterID
	join	acct.Contract#Raw()      t on t.ID=d.ContractID
	join	core.Party#Raw()         n on n.ID=t.BizUnitID
	cross	apply core.RefNbr#Type() r
	join	core.RefNbr#Raw()        a on a.MatterID=d.ID and a.Type=r.AsnNbr
	cross	apply acct.Ledger#Side() s 
	where	x.LedgerSide=s.AR
)
GO
PRINT N'Altering [acct].[Ledger#DutyTvpFor]...';


GO
--Smile.Wang
ALTER FUNCTION [acct].[Ledger#DutyTvpFor](@invoiceID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, row_number() over(order by (select 0)), k.Dozen, TalliedOn, k.Dozen, r.Number
						 , k.Dozen, m.Number, k.Dozen, concat(c.City, ', ', c.Province, ', ',c.CountryCode), k.Dozen, 
						 Source, k.Dozen, SvcType, k.Dozen, v.Info, k.Dozen, ChargeAmt)
		--Seq, LedgerDate, ClientRef, MIC, Destination, Source, SvcType, VerifiedInfo.FallBack(DeclaredInfo), Duty
		from	acct.Ledger#Raw()            x
		join	shpt.Parcel#Base()           p on p.ID=x.MatterID
		cross	apply core.RefNbr#Type()     rt 
		join	core.RefNbr#Raw()            r on r.MatterID=p.ID and r.Type=rt.ClientRef
		join	core.RefNbr#Raw()            m on m.MatterID=p.ID and m.Type=rt.MIT
		cross	apply core.RefInfo#Type()    ri
		join	core.RefInfo#Raw()           i  on i.MatterID=p.ID   and i.Type=ri.CneeInfo
		cross	apply core.RefInfo#VerifiedOrDeclared(p.ID) v
		cross	apply loc.Contact#Of(i.Info) c
		cross	apply tvp.Spr#Const()        k
		where   x.InvoiceID=@invoiceID  
		for		xml path(N'')
	)
	select DutyTvp=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Adding schema binding to [acct].[Ledger#DutyTvpFor]...';


GO
--Smile.Wang
ALTER FUNCTION [acct].[Ledger#DutyTvpFor](@invoiceID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, row_number() over(order by (select 0)), k.Dozen, TalliedOn, k.Dozen, r.Number
						 , k.Dozen, m.Number, k.Dozen, concat(c.City, ', ', c.Province, ', ',c.CountryCode), k.Dozen, 
						 Source, k.Dozen, SvcType, k.Dozen, v.Info, k.Dozen, ChargeAmt)
		--Seq, LedgerDate, ClientRef, MIC, Destination, Source, SvcType, VerifiedInfo.FallBack(DeclaredInfo), Duty
		from	acct.Ledger#Raw()            x
		join	shpt.Parcel#Base()           p on p.ID=x.MatterID
		cross	apply core.RefNbr#Type()     rt 
		join	core.RefNbr#Raw()            r on r.MatterID=p.ID and r.Type=rt.ClientRef
		join	core.RefNbr#Raw()            m on m.MatterID=p.ID and m.Type=rt.MIT
		cross	apply core.RefInfo#Type()    ri
		join	core.RefInfo#Raw()           i  on i.MatterID=p.ID   and i.Type=ri.CneeInfo
		cross	apply core.RefInfo#VerifiedOrDeclared(p.ID) v
		cross	apply loc.Contact#Of(i.Info) c
		cross	apply tvp.Spr#Const()        k
		where   x.InvoiceID=@invoiceID  
		for		xml path(N'')
	)
	select DutyTvp=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Altering [acct].[Ledger#FreightTvpFor]...';


GO
--Smile.Wang
ALTER FUNCTION [acct].[Ledger#FreightTvpFor](@invoiceID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, row_number() over(order by (select 0)), k.Dozen, TalliedOn, k.Dozen, r.Number, 
						 k.Dozen, m.Number, k.Dozen, concat(c.City, ', ', c.Province, ', ',c.CountryCode), k.Dozen, 
						 Source, k.Dozen, SvcType, k.Dozen, Weight, k.Dozen, SectionWt, k.Dozen, ChargeAmt)
		--Seq, LedgerDate, ClientRef, MIC, Destination, Source, SvcType, Weight, SectionWt, Duty
		from	acct.Ledger#Raw()            x
		join	shpt.Parcel#Base()           p on p.ID=x.MatterID
		cross	apply core.RefNbr#Type()     rt 
		join	core.RefNbr#Raw()            r on r.MatterID=p.ID and r.Type=rt.ClientRef
		join	core.RefNbr#Raw()            m on m.MatterID=p.ID and m.Type=rt.MIT
		cross	apply core.RefInfo#Type()    ri
		join	core.RefInfo#Raw()           i on i.MatterID=p.ID   and i.Type=ri.CneeInfo
		cross	apply loc.Contact#Of(i.Info) c
		cross	apply tms.SvcRate#For(p.SvcType, p.RcvHubID, p.Weight) a
		cross	apply tvp.Spr#Const()        k
		where   x.InvoiceID=@invoiceID  
		for		xml path(N'')
	)
	select FreightTvp=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Adding schema binding to [acct].[Ledger#FreightTvpFor]...';


GO
--Smile.Wang
ALTER FUNCTION [acct].[Ledger#FreightTvpFor](@invoiceID bigint)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(k.Many, row_number() over(order by (select 0)), k.Dozen, TalliedOn, k.Dozen, r.Number, 
						 k.Dozen, m.Number, k.Dozen, concat(c.City, ', ', c.Province, ', ',c.CountryCode), k.Dozen, 
						 Source, k.Dozen, SvcType, k.Dozen, Weight, k.Dozen, SectionWt, k.Dozen, ChargeAmt)
		--Seq, LedgerDate, ClientRef, MIC, Destination, Source, SvcType, Weight, SectionWt, Duty
		from	acct.Ledger#Raw()            x
		join	shpt.Parcel#Base()           p on p.ID=x.MatterID
		cross	apply core.RefNbr#Type()     rt 
		join	core.RefNbr#Raw()            r on r.MatterID=p.ID and r.Type=rt.ClientRef
		join	core.RefNbr#Raw()            m on m.MatterID=p.ID and m.Type=rt.MIT
		cross	apply core.RefInfo#Type()    ri
		join	core.RefInfo#Raw()           i on i.MatterID=p.ID   and i.Type=ri.CneeInfo
		cross	apply loc.Contact#Of(i.Info) c
		cross	apply tms.SvcRate#For(p.SvcType, p.RcvHubID, p.Weight) a
		cross	apply tvp.Spr#Const()        k
		where   x.InvoiceID=@invoiceID  
		for		xml path(N'')
	)
	select FreightTvp=Tvp from cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Adding schema binding to [shpt].[Parcel#Deep]...';


GO
--PeterHo
ALTER FUNCTION [shpt].[Parcel#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID, PID,   AID, x.Source,  Type, LockCnt, Stage, StateID, StatedOn,      BatchID,  b.BatchedOn
	,		x.SiteID,    x.SiteAlias,    PostedAt,      PostedOn,       SiteUtcOffset, RcvHubID, RcvHubAlias=h.Alias
	,		RouteID,     r.RouteCode,    r.MftGroup,    r.BrokerID,     r.BrokerAlias, r.CmdyRootID, POA
	,		r.CourierID, r.CourierAlias, r.CourierCode  --<<-- TobeDropped
	,		LastMilerID, LastMilerAlias=c.CourierAlias, LastMilerCode=c.CourierCode
	,		ContractID
	,		SvcType,     SvcZone,  SvcClass,  Weight,     Length,       Width,      Height, ZoneCode
	,		RefNbrs,     RefInfos, RefStamps, RefParties, RoledActions, Challenges, a.Ledgers
	,		HandlerID,   AddOnServices
	from	shpt.Parcel#Base() x
	join	shpt.Batch#Raw()   b on b.ID=x.BatchID
	join	core.Tenant#Raw()  h on h.ID=x.RcvHubID
	join	tms.Courier#Raw()  c on c.ID=x.LastMilerID
	join	tms.Route#Deep()   r on r.ID=x.RouteID
	outer	apply acct.Ledger#Tvp  (x.ID) a
)
GO
PRINT N'Adding schema binding to [shpt].[SackMft#Deep]...';


GO
--PeterHo, AaronLiu, Smile
ALTER FUNCTION [shpt].[SackMft#Deep]()
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.ID,    PID, AID,  Source,   Type,     LockCnt,        Stage, StateID, StatedOn
	,		HubID,   HubAlias,  PostedAt, PostedOn, HubUtcOffset,   POD=isnull(f.POD, x.POD)
	,		POA=isnull(f.POA, x.POA),   MawbNbr,   FlightNbr=isnull(f.FlightNbr, x.FlightNbr), BrokerID
	,		RefNbrs, RefStamps, RoledActions, Challenges, a.Ledgers, ETA, ETD, MawbWt
	from	shpt.SackMft#Base()   x
	left	join tms.Flight#Raw() f  on x.PID=f.ID
	outer	apply acct.Ledger#Tvp(x.ID) a
)
GO
PRINT N'Altering [hub].[Parcel$InParcel]...';


GO
-- AaronLiu
ALTER	FUNCTION [hub].[Parcel$InParcel](@parcelID I64)
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	ID, RefNbrs
	from	shpt.Parcel#Deep()
	where	PID=@parcelID
)
GO
PRINT N'Altering [hub].[Parcel$InSack]...';


GO
-- AaronLiu
ALTER	FUNCTION [hub].[Parcel$InSack](@sackID I64)
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	x.ID, x.Weight, x.RefNbrs
	from	shpt.Parcel#Deep() x
	where	x.PID=@sackID
)
GO
PRINT N'Altering [hub].[Parcel$ScanOneForSacking]...';


GO
-- AaronLiu
ALTER	FUNCTION [hub].[Parcel$ScanOneForSacking](@number varchar(40))
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	x.ID, x.Stage, x.StateID, x.PID, x.POA, RouteID, x.BrokerID, r.ClrMethodID, x.Weight, x.RefNbrs
	from	shpt.Parcel#Deep()  x
	join	tms.Route#Raw()	    r on x.RouteID=r.ID
	join	core.RefNbr#ScanOne(@number, default, default) m on m.MatterID=x.ID
)
GO
PRINT N'Adding schema binding to [ic].[Parcel$ForExportActivityInfo]...';


GO
--Aimee Tan, Sean Rao
ALTER FUNCTION [ic].[Parcel$ForExportActivityInfo]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, Stage,    x.Source, RcvHubID, RcvHubAlias, RouteID,  RouteCode
	,		SiteAlias,      LastMilerAlias,     PostedOn,    StatedOn, RefNbrs
	,		Weight,			Length,				Height,		 Width
	,		TenantID=p.PID, Activities=e.Tvp
	from	shpt.Parcel#Deep() x
	join	core.Party#Raw()   p on p.ID=x.SiteID
	outer	apply
	(
		select	[text()]=concat(k.Many, Stage, k.Quad, TalliedOn, k.Quad, t.UtcOffset, k.Quad, p.UtcOffset)
		from	core.Activity#Raw()    a
		left	join core.Tenant#Raw() t on t.ID=x.RcvHubID
		left	join core.Port#Raw()   p on p.Code=x.POA
		cross	apply core.Stage#Of(a.StateID) s
		cross	apply tvp.Spr#Const()  k
		where	a.MatterID=x.ID for xml path(N'')
	) z (text)
	cross	apply tvp.Spr#Purify(z.text, default) e
)
GO
PRINT N'Adding schema binding to [ic].[Parcel$WithConcern]...';


GO
--ken, Smile
ALTER FUNCTION [ic].[Parcel$WithConcern](@concernType tinyint)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, Stage, SvcType,   Source, RouteID, RouteCode, StatedOn, RefNbrs, RefInfos
	,		Handler,  HandlerID,    Concerns
	from	shpt.Parcel#Deep()                      x 
	cross	apply core.Concern#Tvp(x.ID)            t
	cross	apply svc.User$ContactName(x.HandlerID) u
	where   exists (
						select	MatterID
						from	core.Concern#Raw() where x.ID=MatterID 
						and		(Type=@concernType or nullif(@concernType, 0) is null)
					)
	
)
GO
PRINT N'Adding schema binding to [lc].[Parcel$Sorting]...';


GO
/*
	Activities = Tuplet<ID, Operator, ActionID, Stage, TailledOn>
*/
--AaronLiu
ALTER FUNCTION [lc].[Parcel$Sorting](@number varchar(40))
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	with cteParcel as
	(
		select	p.ID, p.RcvHubID, p.Stage, p.RouteID, p.RouteCode, p.SvcType, p.POA
		from	core.RefNbr#ScanOne(@number, default, default) x
		join	shpt.Parcel#Deep() p on x.MatterID=p.ID
	),	cteActivities(text) as
	(
		select	[text()]=concat
		(		k.Many,	  a.ID,			k.Tuplet,	 u.Alias
		,		k.Tuplet, a.ActionID,	k.Tuplet,	 s.Stage
		,		k.Tuplet, dateadd(hour, t.UtcOffset, TalliedOn)
		)
		from	tvp.Spr#Const() k, cteParcel	x
		cross	apply core.Matter#PNodeUp(x.ID) m
		join	core.Activity#Raw() a on a.MatterID=m.ID
		join	core.Tenant#Raw()	t on t.ID=x.RcvHubID
		join	core.State#Raw()    s on s.ID=a.StateID
		join	core.Party#Raw()    u on u.ID=a.UserID
		for		xml path('')
	)
	select	x.ID, x.Stage, x.RouteID, x.RouteCode, x.SvcType, x.POA, Activities=Tvp
	from	cteParcel x, cteActivities
	cross	apply tvp.Spr#Purify(text, default) 
)
GO
PRINT N'Adding schema binding to [svc].[Batch$ExportForAmazon]...';


GO
--Smile, PeterHo
ALTER FUNCTION [svc].[Batch$ExportForAmazon](@batchIDs nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	ID=BatchID, RefNbrs, RefInfos, CourierAlias, SvcType, PostedOn=l.LocalTime
	from	tvp.I64#Slice(@batchIDs) x
	join	shpt.Parcel#Deep()  p on p.BatchID=x.ID
	cross	apply dbo.DT#ToLocal(p.PostedOn, p.SiteUtcOffset) l
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$Detail]...';


GO
-- Eason, AaronLiu
ALTER FUNCTION svc.Parcel$Detail()
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	x.ID,	  PID, AID,	   x.Source, PostedOn,	  Stage, StateID, StatedOn
	,		BatchID,  BatchedOn,   RcvHubID, RcvHubAlias, RcvHubUtcOffset=t.UtcOffset
	,		SiteID,   SiteAlias,   RouteID,  RouteCode,   CourierID, CourierAlias
	,		BrokerID, BrokerAlias, POA,		 SvcType,     SvcZone,   SvcClass
	,		Weight,   Length,	   Width,	 Height,	  RefNbrs,	 RefInfos
	,		Ledgers,  Challenges,  ZoneCode, AddOnServices
	from	shpt.Parcel#Deep() x
	join	core.Tenant#Raw()  t on t.ID=x.RcvHubID
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$ExceptionList]...';


GO
-- Smile, Ken, bd.he, Daxia
ALTER FUNCTION [svc].[Parcel$ExceptionList]()
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	x.ID,    x.StateID, StatedOn, Stage,    Source, SvcType, POA, HandlerID, u.Handler
	,		RouteID, RouteCode, RefNbrs,  RefInfos, RoledActions,    LastMessage=m.Body
	from	shpt.Parcel#Deep() x cross apply core.Registry#ID() k
	cross	apply svc.User$ContactName(x.HandlerID)             u
	outer	apply core.Message#BodyOfLast(k.Matter, x.ID)       m
)
GO
PRINT N'Refreshing [svc].[Parcel$ExportByIDs]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$ExportByIDs]';


GO
PRINT N'Adding schema binding to [svc].[Parcel$ForCreateSackMft]...';


GO
-- Smile
--TODO: clear old Parcel$ForLoadBalance
ALTER FUNCTION [svc].[Parcel$ForCreateSackMft] ()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID,      Source,   RefNbrs,   RcvHubID, RcvHubAlias, POA,      StateID, StatedOn
	,		RouteID, MftGroup, RouteCode, BrokerID, BrokerAlias, RefInfos, Weight
	from	shpt.Parcel#Deep()    x 
	cross	apply core.Stage#ID() k
	where	x.Stage=k.RouteCfmed
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$ForLoadBalance]...';


GO
-- Smile, PeterHo, Aimee
ALTER FUNCTION [svc].[Parcel$ForLoadBalance] (@stage int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, RefNbrs, RcvHubID,  RcvHubAlias, POA, StateID, StatedOn, Source
	,		RouteID,     RouteCode, BrokerID,    BrokerAlias
	from	shpt.Parcel#Deep() 	
	where	Stage=@stage
)
GO
PRINT N'Altering [svc].[Parcel$ForOutgatedNotice]...';


GO
-- For eForward Notice
-- Daxia
ALTER FUNCTION [svc].[Parcel$ForOutgatedNotice]()
RETURNS TABLE
WITH  ENCRYPTION
AS RETURN
(
	select	x.ID, SvcType, Weight,          LastMilerAlias,      SiteAlias
	,		x.RefNbrs,     m.RefStamps,     m.MawbNbr,           FlightNbr
	,		HubCountryCode=c.CountryCode,   SackSeqNbr=isnull(n.SeqNbr, 0)
	,		SackPostedOn=isnull(p.PostedOn, N'0001-01-01'), x.StatedOn
	,		ETA=isnull(ETA, N'0001-01-01'), ETD=isnull(ETD, N'0001-01-01')
	,		HubUtcOffset=isnull(a.UtcOffset, 0), OutgatedOn=isnull(a.UtcTime, '')
	from	core.State#ID() i, shpt.Parcel#Deep()   x
	cross	apply core.Matter#Type() k
	outer	apply (
					select	SackMftID=ID 
					from	core.Matter#PNodeUp(x.ID) d
					where	Type=k.SackMft) s
	left	join  shpt.SackMft#Deep()       m on m.ID=s.SackMftID 
	left	join  shpt.Sack#Base()          p on p.ID=x.PID
	outer	apply core.Activity#TrackSpecific(x.ID, 48700) a--i.OutGated) a
	outer	apply shpt.Sack#SeqNbrOf(p.ID)  n
	outer	apply (
		select	top(1) CountryCode
		from	core.Contact#Type() k, core.Contact#Raw() c 
		where	c.PartyID=p.HubID and c.Type=k.Billing
	) c
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$ForStage]...';


GO
--Aimee, Ken, bd.he
ALTER FUNCTION [svc].[Parcel$ForStage]()
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	x.ID, x.Source, Stage, RcvHubID, RcvHubAlias, RefNbrs, StatedOn
	,		TenantID=t.ID, TenantAlias=t.Alias,   RouteID, RouteCode
	,		Handler, HandlerID
	from	core.Party#Type() k, shpt.Parcel#Deep() x
	join	core.Party#Raw()  s on s.ID=x.SiteID
	join	core.Party#Raw()  t on t.ID=s.PID
	cross	apply svc.User$ContactName(x.HandlerID) u
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$List]...';


GO
-- Eason, AaronLiu, Smile, Daxia, Aimee
ALTER FUNCTION [svc].[Parcel$List]()
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	x.ID,    x.Source,  PostedOn,  Stage,     StateID,  StatedOn, BatchID,  RcvHubID
	,		SiteID, RouteID, RouteCode, CourierID, BrokerID, SvcType,  SvcZone,  SvcClass, CmdyRootID
	,		Weight, Length,  Width,     Height,    POA,      RefNbrs,  RefInfos, Ledgers,  Challenges
	,		LastMilerCode, HandlerID,   u.Handler, AddOnServices, HasIDNbr, HasConcern,    ZoneCode
	from	shpt.Parcel#Deep()                      x 
	cross	apply svc.User$ContactName(x.HandlerID) u	
	cross	apply core.Concern#Exists(x.ID)         e
	cross	apply shpt.IDNbr#Exists(x.ID)           i
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$ListForCainiao]...';


GO
--Smile, AaronLiu
ALTER FUNCTION [svc].[Parcel$ListForCainiao]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID,		 x.RcvHubAlias, MIC=m.Number
	,		LastMilerID, LastMilerCode, x.RouteID
	,		PostCourier=isnull(c.Number,    N'')
	,		FlightNbr  =isnull(d.FlightNbr, N'')
	,		POA=isnull(d.POA, N'')
	,		POD=isnull(d.POD, N'')
	from	shpt.Parcel#Deep()       x
	cross	apply core.Matter#Type() mk
	cross	apply core.RefNbr#Type() k
	join	core.RefNbr#Raw()        m on m.MatterID=x.ID and m.Type=k.MIT
	left	join core.RefNbr#Raw()   c on c.MatterID=x.ID and c.Type=k.PostCourier
	outer	apply 
	(
		select	SackMftID=ID 
		from	core.Matter#PNodeUp(x.ID)
		where	Type=mk.SackMft
	) s
	left	join shpt.SackMft#Deep() d on d.ID=s.SackMftID 
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$OutgatedList]...';


GO
--Smile, Aimee
ALTER FUNCTION [svc].[Parcel$OutgatedList]()
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	select	x.ID, x.Source, x.StatedOn,  x.StateID, SvcType, x.Stage, x.PostedOn, x.RefStamps, x.RefNbrs
	,		x.POA,  RcvHubID, RcvHubAlias, RouteID, RouteCode, LastMilerAlias,      MawbNbr,     FlightNbr
	,		[PosterAlias]=x.SiteAlias, [SackNbr]=s.RefNbrs,    RefInfos
	from	shpt.Parcel#Deep()       x	
	left	join shpt.Sack#Base()    s  on s.ID=x.PID
	left	join shpt.SackMft#Deep() sm on sm.ID=s.PID or sm.ID=x.PID
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$ShippingPlanList]...';


GO
-- Aimee, Smile
ALTER FUNCTION [svc].[Parcel$ShippingPlanList]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, Stage, x.Source, POA, Weight, RefNbrs, RouteID, RouteCode
	,		RcvHubID,  RcvHubAlias, RefInfos, HandlerID, Handler=u.Alias
	from	shpt.Parcel#Deep() x
	join	core.User#Raw()    u on x.HandlerID=u.ID
)
GO
PRINT N'Altering [svc].[Parcel$VerifyForSackMft]...';


GO
/*
	@numbers = Comma<MIC>
*/
-- AaronLiu
ALTER FUNCTION [svc].[Parcel$VerifyForSackMft](@numbers tvp, @tenancy tvp)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	p.ID,       MIC=x.Piece,   p.Stage, p.BrokerID, p.BrokerAlias, p.POA
	,		p.RcvHubID, p.RcvHubAlias, Transitable=iif(b.MatterID is null, 0, 1)
	from	tvp.Comma#Slice(@numbers)      x
	cross	apply core.MIC#IdOf(x.Piece)   m
	join	shpt.Parcel#Deep()			   p on m.MatterID=p.ID
	cross	apply core.Action#ID()         a
	cross	apply loc.Tenancy#Of(@tenancy) t
	outer	apply shpt.Parcel#Maybe(p.ID,  t.RoleID, a.ICManifest) b
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$WithChallenge]...';


GO
--wangtianqi, Smile
ALTER FUNCTION [svc].[Parcel$WithChallenge]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID,    x.StateID, StatedOn, Stage, Source, SvcType, POA 
	,		HandlerID, RouteID, RouteCode, RefNbrs,  RoledActions, ChallengeBody=c.Body, u.Handler
	from	shpt.Parcel#Deep()            x 
	cross	apply core.Challenge#Of(x.ID) c
	cross	apply svc.User$ContactName(x.HandlerID) u
)
GO
PRINT N'Adding schema binding to [svc].[SackMft$Export]...';


GO
--Sam
ALTER	FUNCTION [svc].[SackMft$Export]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, p.RefNbrs, p.RefInfos,  p.Weight, p.RouteID, p.PostedOn
	from	shpt.SackMft#Raw()  x
	join    shpt.Parcel#Deep()  p on p.PID = x.ID
)
GO
PRINT N'Adding schema binding to [svc].[SackMft$ExportForOutgate]...';


GO
--Eva
ALTER	FUNCTION [svc].[SackMft$ExportForOutgate]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID,    x.FlightNbr, x.MawbNbr, MftPostedOn=x.PostedOn, x.BrokerID, x.POD, x.POA, x.HubAlias
	,		SackNbrs=s.RefNbrs
	,		p.RefNbrs, p.RefInfos, p.Weight, p.RouteID, p.PostedOn
	from	shpt.SackMft#Deep() x
	join	shpt.Sack#Base()    s on s.PID=x.ID
	join	shpt.Parcel#Deep()  p on p.PID=s.ID

	UNION

	select	x.ID,    x.FlightNbr, x.MawbNbr, MftPostedOn=x.PostedOn, x.BrokerID, x.POD, x.POA, x.HubAlias
	,		SackNbrs=N''
	,		p.RefNbrs, p.RefInfos, p.Weight, p.RouteID, p.PostedOn
	from	shpt.SackMft#Deep() x
	join	shpt.Parcel#Deep()  p on p.PID = x.ID
)
GO
PRINT N'Adding schema binding to [vmi].[Parcel$Detail]...';


GO
--Smile
ALTER FUNCTION [vmi].[Parcel$Detail]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, Source, PostedOn,  Stage,  StateID, StatedOn,  OutgatedOn=isnull(OutgatedOn,'')
	,		RcvHubID, RcvHubAlias, SiteID, SiteAlias, RefNbrs, RefInfos
	,		SvcType,  t.CourierCode, t.CourierNbr, t.Tracks
	from	shpt.Parcel#Deep()           x
	cross	apply svc.Parcel$Track(x.ID) t
	outer	apply(
					select	top(1) OutgatedOn=TalliedOn
					from	core.Activity#Raw()   a
					join    core.State#Raw()      t on a.StateID=t.ID
					cross	apply core.Stage#ID() k
					where	Stage=k.Outgated and MatterID=x.ID
					
				) c
	cross	apply core.Source#ID() k
	where	x.Source=k.eVMI
)
GO
PRINT N'Adding schema binding to [vmi].[Parcel$ForExport]...';


GO
--Smile
ALTER FUNCTION [vmi].[Parcel$ForExport](@siteID int, @trackingNbr varchar(40))
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, Weight, PostedOn,  Stage, RcvHubAlias, CourierAlias
	,		SvcType,    RefNbrs,   RefInfos, Ledgers
	from	shpt.Parcel#Deep()     x
	cross	apply core.Source#ID() k
	where	x.Source=k.eVMI
	and		x.SiteID=@siteID
	and		(nullif(@trackingNbr, '') is null
	or		exists (
						select	MatterID from core.RefNbr#Raw()
						where	MatterID=x.ID and Number=@trackingNbr
					))
)
GO
PRINT N'Adding schema binding to [vmi].[Parcel$List]...';


GO
--Smile
ALTER FUNCTION [vmi].[Parcel$List](@trackingNbr varchar(40))
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID, Weight, Source, PostedOn,  Stage,   StateID,  StatedOn
	,		SvcType,    SiteID, SiteAlias, RefNbrs, RefInfos, Ledgers
	from	shpt.Parcel#Deep()     x
	cross	apply core.Source#ID() k
	where	x.Source=k.eVMI
	and		(nullif(@trackingNbr, '') is null
	or		exists (
						select	MatterID from core.RefNbr#Raw()
						where	MatterID=x.ID and Number=@trackingNbr
					))
)
GO
PRINT N'Adding schema binding to [ic].[SackMft$ForOutgated]...';


GO
--Daxia
ALTER	FUNCTION [ic].[SackMft$ForOutgated]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, MawbNbr, FlightNbr, Stage,       StatedOn
	,		POA,  POD,     p.RouteID, t.RouteCode
	,		[TotalParcelCnt]=isnull(p.TotalParcelCnt, 0)
	from	shpt.SackMft#Deep()	  x
	cross	apply
	(
		select	TotalParcelCnt=count(*), RouteID
		from	core.Matter#Raw() m cross apply core.Matter#Type() k
		join	shpt.Parcel#Base()  t on t.PID=m.ID 
		where	m.PID=x.ID group by t.RouteID
	) p
	join	tms.Route#Raw() t on t.ID=p.RouteID
)
GO
PRINT N'Adding schema binding to [svc].[SackMft$List]...';


GO
--Aimee, Smile, AaronLiu, hbd
ALTER	FUNCTION [svc].[SackMft$List]()
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID,	      MawbNbr, FlightID=x.PID, FlightNbr,    PostedOn,  Stage, StateID
	,		StatedOn,   HubID, HubAlias,       HubUtcOffset, RefStamps, RoledActions
	,		UnSackedParcelCnt, UnTransloadedSackCnt, Source
	,		POA, [POAUtcOffset]=a.UtcOffset, [POAUtcPlaceID]=a.UtcPlaceID
	,		POD, [PODUtcOffset]=d.UtcOffset, [PODUtcPlaceID]=d.UtcPlaceID
	from	shpt.SackMft#Deep()	  x
	join	core.Port#Raw() a on  x.POA=a.Code
	join	core.Port#Raw() d on  x.POD=d.Code
	cross	apply (
		select	UnSackedParcelCnt   =isnull(sum(case when m.Type=t.Parcel and m.Level=1             then 1 else 0 end),0)
		,		UnTransloadedSackCnt=isnull(sum(case when m.Type=t.Sack   and m.Stage<s.Transloaded then 1 else 0 end),0)
		from	core.Matter#PNodeDn(x.ID) m
		cross	apply core.Matter#Type()  t
		cross	apply core.Stage#ID()     s
	) n
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$DetailVia]...';


GO
-- Eason, Aimee, AaronLiu
ALTER FUNCTION svc.Parcel$DetailVia(@number varchar(40))
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	ID, PID,     AID,		p.Source,  PostedOn,	p.Stage, StateID, StatedOn
	,		BatchID,     BatchedOn, RcvHubID,  RcvHubAlias, RcvHubUtcOffset,  SiteID
	,		SiteAlias,   RouteID,	RouteCode, CourierID,   CourierAlias,	  BrokerID
	,		BrokerAlias, POA,		SvcType,   SvcZone,		SvcClass,		  Weight
	,		Length,		 Width,		Height,	   RefNbrs,		RefInfos,		  Ledgers
	,		Challenges,  ZoneCode,  AddOnServices		  
	from	core.RefNbr#ScanOne(@number, default, default) x
	join	svc.Parcel$Detail() p on p.ID=x.MatterID
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$Label]...';


GO
-- Daxia
ALTER FUNCTION svc.Parcel$Label()
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	ID, PID, AID, Source, PostedOn,    x.Stage,      StateID,  StatedOn
	,		BatchID, BatchedOn,   RcvHubID,    RcvHubAlias,  SiteID,   SiteAlias
	,		RouteID, RouteCode,   x.CourierID, CourierAlias, BrokerID, BrokerAlias
	,		x.POA,   SvcType,     SvcZone,     SvcClass,     Weight,   Length, Width, Height
	,		RefNbrs, RefInfos,    Ledgers,     Challenges,   AddOnServices,    ZoneCode
	,		FacilityID=isnull(FacilityID%100, 0), BarcodeNbr
	from	svc.Parcel$Detail() x
	cross	apply core.RefNbr#Type() k
	left	join core.RefNbr#Raw() r on r.MatterID=x.ID and r.Type=k.PostCourier
	outer	apply tms.SvcFacility#For(x.Source, x.SvcClass, left(x.ZoneCode, 3)) f
	outer	apply tms.BarcodeNbr#Make(x.ZoneCode, r.Number)      b
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$LabelVia]...';


GO
-- Daxia
ALTER FUNCTION svc.Parcel$LabelVia(@number varchar(40))
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	ID, PID, AID, Source, PostedOn,    p.Stage,      StateID,  StatedOn
	,		BatchID, BatchedOn,   RcvHubID,    RcvHubAlias,  SiteID,   SiteAlias
	,		RouteID, RouteCode,   p.CourierID, CourierAlias, BrokerID, BrokerAlias
	,		p.POA,   SvcType,     SvcZone,     SvcClass,     Weight,   Length, Width, Height
	,		RefNbrs, RefInfos,    Ledgers,     Challenges,   AddOnServices,    ZoneCode
	,		FacilityID=isnull(FacilityID%100, 0), BarcodeNbr
	from	core.RefNbr#ScanOne(@number, default, default) x
	cross	apply core.RefNbr#Type() k
	join	svc.Parcel$Detail() p on p.ID=x.MatterID
	left	join core.RefNbr#Raw() r on r.MatterID=x.MatterID and r.Type=k.PostCourier
	outer	apply tms.SvcFacility#For(p.Source, p.SvcClass, left(p.ZoneCode, 3)) f
	outer	apply tms.BarcodeNbr#Make(p.ZoneCode, r.Number)      b
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$ListVia]...';


GO
/*
  ToAaron:
	Should not use Parcel$List() any more, avoid 2100 parameters error for now.
	Don't use me, this will be dropped after brokerage dequeue refactoring.
*/
-- AaronLiu
ALTER FUNCTION [svc].[Parcel$ListVia](@idsInCsv nvarchar(max))
RETURNS TABLE 
WITH SCHEMABINDING
AS RETURN 
(
	select	x.ID,	   Source,	  PostedOn,		 Stage,	   StateID,	   StatedOn, BatchID,  RcvHubID,   SiteID
	,		RouteID,   RouteCode, CourierID,	 BrokerID, SvcType,	   SvcZone,  SvcClass, CmdyRootID, Weight
	,		Length,	   Width,     Height,		 POA,      RefNbrs,	   RefInfos, Ledgers,  Challenges, LastMilerCode
	,		HandlerID, Handler,   AddOnServices, HasIDNbr, HasConcern, ZoneCode
	from	tvp.I64#Slice(@idsInCsv) i,	svc.Parcel$List() x
	where	i.ID=x.ID
)
GO
PRINT N'Adding schema binding to [brkg].[BrokerageFee#For]...';


GO
/*
brokerageInfo=Mucho[Triad<SkuID, CmdyInfo, LineInfo:Localized>]
CmdyInfo     =Quad<CmdyHeadID, CmdyTailID, DutyCode, DutyRate>
LineInfo     =Quad<GoodsInfo, LineQty, LineTotal, CmdyID>
*/
--Smile.Wang
ALTER FUNCTION [brkg].[BrokerageFee#For](@routeID int,  @brokerageInfo nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with creRate as
	(
		select	l.CurrencyID
		,		BrokerageFee=ceiling(sum(x.PercentRate*l.LineDecTotal)*100)/100
		from	tms.Route#Raw()       u
		join	brkg.Broker#Raw()     x on u.BrokerID=x.ID
		cross	apply tvp.Spr#Const() k
		cross	apply tvp.Triad#Slice(@brokerageInfo, default, k.Mucho) t
		cross	apply loc.CmdyInfo#Of(t.v2)                             c
		cross	apply loc.LineInfo#Of(t.v3)                             l	
		where	u.ID=@routeID
		group	by l.CurrencyID	
	)
		select	CurrencyID, DutyRate=m.Amt
		from	creRate x
		cross	apply dbo.Money#Make(x.BrokerageFee, x.CurrencyID) m
		where	m.Amt>x.CurrencyID
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$CriteriaForLoadBalance]...';


GO
-- PeterHo ,Irene
ALTER FUNCTION svc.Parcel$CriteriaForLoadBalance()
RETURNS TABLE 
WITH SCHEMABINDING, ENCRYPTION
AS RETURN 
(
	with cteSummary as
	(
		select	x.RcvHubID, x.POA, r.BrokerID, r.MftGroup, x.RouteID
		,		TotalParcelCnt=isnull(count(*), 0)
		,		TotalParcelWt =isnull(sum(cast(x.Weight as float)), 0)
		from	shpt.Parcel#Base()       x
		join	tms.Route#Raw()          r on r.ID=x.RouteID
		cross	apply core.Stage#ID()    k
		cross	apply core.Matter#Type() m
		where	x.Stage=k.RouteCfmed and x.PID=0 and x.Type=m.Parcel
		group	by x.RcvHubID, x.POA, r.BrokerID, r.MftGroup, x.RouteID
	)
	select	RcvHubID, RcvHubAlias=t.Alias
	,		BrokerID, b.BrokerAlias,  POA
	,		MftGroup, TotalParcelCnt, RouteID
	,		TotalParcelWt
	from	cteSummary           x
	join	core.Tenant#Raw()    t on t.ID=x.RcvHubID
	join	brkg.Broker#Raw()    b on b.ID=x.BrokerID
)
GO
PRINT N'Adding schema binding to [brkg].[DutyRate#For]...';


GO
/*
brokerageInfo=Mucho[Triad<SkuID, CmdyInfo, LineInfo:Localized>]
CmdyInfo     =Quad<CmdyHeadID, CmdyTailID, DutyCode, DutyRate>
LineInfo     =Quad<GoodsInfo, LineQty, LineTotal, CmdyID>
*/
--Smile.Wang
ALTER FUNCTION [brkg].[DutyRate#For](@partyID int, @clrMethodID int, @brokerageInfo nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteDuty as
	(
		select	l.CurrencyID
		,		DutyRateRaw=sum(c.DutyRate*l.LineRawTotal)
		,		ClrRateRaw=sum(d.PercentRate*l.LineRawTotal)
		from	tvp.Spr#Const() k 
		cross	apply tvp.Triad#Slice(@brokerageInfo, default, k.Mucho) x
		cross	apply loc.CmdyInfo#Of(x.v2)       c
		cross	apply loc.LineInfo#Of(x.v3)       l	
		cross	apply brkg.ClrMethodRate#For(@partyID, @clrMethodID) d
		group	by l.CurrencyID		
	)
	, cteTotalDuty as
	(
		select	CurrencyID, DutyRaw=sum(DutyRaw)
		from	
		(
			select	x.CurrencyID, DutyRaw=iif(x.CurrencyID=d.CurrencyID,  iif(DutyRateRaw>d.ExemptionRaw, DutyRateRaw, 0), DutyRateRaw)+ClrRateRaw
			from	cteDuty x
			join	brkg.ClrMethod#Raw() d on d.ID=@clrMethodID
			union	all
			select	CurrencyID, FlatRateRaw
			from	brkg.ClrMethodRate#For(@partyID, @clrMethodID)
		) u
		group by u.CurrencyID
	)
		select	CurrencyID, DutyRate=m.Amt
		from	cteTotalDuty x
		cross	apply dbo.Currency#Encode(x.DutyRaw, CurrencyID) m
)
GO
PRINT N'Refreshing [svc].[Parcel$DutyEstimate]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$DutyEstimate]';


GO
PRINT N'Adding schema binding to [tms].[Freight#For]...';


GO
/*
brokerageInfo=Mucho[Triad<SkuID, CmdyInfo, LineInfo:Localized>]
CmdyInfo     =Quad<CmdyHeadID, CmdyTailID, DutyCode, DutyRate>
LineInfo     =Quad<GoodsInfo, LineQty, LineTotal, CmdyID>
*/
--Smile.Wang
ALTER FUNCTION [tms].[Freight#For](@svcType int, @rcvHubID bigint, @measuredWt real, @brokerageInfo nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteFreight as
	(
	select	SvcRate=cast((SvcRate*10000) as float)/10000
	from	tms.SvcRate#For(@svcType, @rcvHubID, @measuredWt)
	UNION	ALL
	select	isnull(cast((c.Surcharge*10000) as float)/10000,0)
	from	tvp.Spr#Const()      k
	cross	apply tvp.Triad#Slice(@brokerageInfo, default, k.Mucho) x
	cross	apply loc.LineInfo#Of(x.v3) q
	join	brkg.Commodity#Raw()        c on c.ID=q.CmdyID
	)

	select Freight=sum(SvcRate) from cteFreight
)
GO
PRINT N'Altering [co].[Parcel$PendingFor]...';


GO
--Ken
ALTER FUNCTION [co].[Parcel$PendingFor](@days tinyint,@tenantID int)
RETURNS TABLE
WITH SCHEMABINDING,ENCRYPTION
AS RETURN
(
	select	ParcelCnt=count(ID), Date=x.Value 
	from	dbo.Calendar#Raw()            x
	cross	apply core.Stage#Boundary()   s
	left	join shpt.Parcel#Base()       p 
	on		x.Value=cast(StatedOn as date)  and p.Stage between s.PreMin and s.PreMax
	and		p.SiteID in 
	(
		select	ID 
		from	core.Party#Raw()         t
		cross	apply core.Party#Type()  k
		where	t.PID=@tenantID and      t.Type=k.TenantSite
	)	
	where  Value between dateadd(day, -@days+1, cast(getutcdate() as date)) and cast(getutcdate() as date) 
	group  by x.Value 
)
GO
PRINT N'Adding schema binding to [co].[Parcel$PendingFor]...';


GO
--Ken
ALTER FUNCTION [co].[Parcel$PendingFor](@days tinyint,@tenantID int)
RETURNS TABLE
WITH SCHEMABINDING,ENCRYPTION
AS RETURN
(
	select	ParcelCnt=count(ID), Date=x.Value 
	from	dbo.Calendar#Raw()            x
	cross	apply core.Stage#Boundary()   s
	left	join shpt.Parcel#Base()       p 
	on		x.Value=cast(StatedOn as date)  and p.Stage between s.PreMin and s.PreMax
	and		p.SiteID in 
	(
		select	ID 
		from	core.Party#Raw()         t
		cross	apply core.Party#Type()  k
		where	t.PID=@tenantID and      t.Type=k.TenantSite
	)	
	where  Value between dateadd(day, -@days+1, cast(getutcdate() as date)) and cast(getutcdate() as date) 
	group  by x.Value 
)
GO
PRINT N'Adding schema binding to [core].[Activity#TrackMany]...';


GO
--PeterHo
ALTER FUNCTION [core].[Activity#TrackMany](@numbersInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteMatter as
	(
		select	SeqID=row_number() over (order by (select null))
		,		TrackingID =n.MatterID
		,		TrackingNbr=n.Number
		from	loc.RefNbr#Slice(@numbersInCsv) x
		cross	apply core.RefNbr#ScanOne(x.Number, default, default) n
	)
	, cteMarked as
	(
		select	x.TrackingID,      x.TrackingNbr
		,		ID,		Type,      MatterID, StateID,   Stage,    TalliedOn
		,		UserID, UserAlias, UtcTime,  UtcOffset, UtcPlace, UtcPlaceID
		,		Marker=lead(ID) over (partition by x.SeqID order by Stage)
		from	cteMatter x
		cross	apply core.Activity#Track(x.TrackingID)
	)
	select	TrackingID,        TrackingNbr
	,		ID,		Type,      MatterID, StateID,   Stage,    TalliedOn
	,		UserID, UserAlias, UtcTime,  UtcOffset, UtcPlace, UtcPlaceID--, Marker
	from	cteMarked where Marker is null
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$TrackManyForZPS]...';


GO
--Smile
ALTER FUNCTION [svc].[Parcel$TrackManyForZPS](@numbersInCsv nvarchar(max), @siteID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
		with cteMatter as
	(
		select	SeqID=row_number() over (order by (select null))
		,		TrackingID =n.MatterID
		,		TrackingNbr=n.Number
		from	loc.RefNbr#Slice(@numbersInCsv)                       x
		cross	apply core.RefNbr#ScanOne(x.Number, default, default) n
		cross	apply core.Matter#Type() m 
		join	core.Matter#Raw()        r on r.Type=m.Parcel and r.ID=n.MatterID 
		cross	apply core.RefNbr#Type() k
		where	(case when n.Type in (k.ClientRef, k.PreCourier) then @siteID else r.PosterID end)=r.PosterID
	)
	, cteMarked as
	(
		select	x.TrackingID,      x.TrackingNbr
		,		ID,		Type,      MatterID, StateID,   Stage,    TalliedOn
		,		UserID, UserAlias, UtcTime,  UtcOffset, UtcPlace, UtcPlaceID
		,		Marker=lead(ID) over (partition by x.SeqID order by Stage)
		from	cteMatter x
		cross	apply core.Activity#Track(x.TrackingID)
	)
	select	ID=TrackingID, TrackingNbr, Stage
	,		UtcTime,       UtcOffset,   UtcPlace
	from	cteMarked where Marker is null
)
GO
PRINT N'Adding schema binding to [vmi].[Parcel$TrackMany]...';


GO
--Smile
ALTER FUNCTION [vmi].[Parcel$TrackMany](@numbersInCsv nvarchar(max), @siteID int)
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
		with cteMatter as
	(
		select	SeqID=row_number() over (order by (select null))
		,		TrackingID =n.MatterID
		,		TrackingNbr=n.Number
		from	loc.RefNbr#Slice(@numbersInCsv)                       x
		cross	apply core.RefNbr#ScanOne(x.Number, default, default) n
		cross	apply core.Matter#Type() m 
		cross	apply core.Source#ID()   s
		join	core.Matter#Raw()        r on r.Type=m.Parcel and r.ID=n.MatterID and r.Source=s.eVMI
		cross	apply core.RefNbr#Type() k
		where	r.PosterID=r.PosterID
	)
	, cteMarked as
	(
		select	x.TrackingID,      x.TrackingNbr
		,		ID,		Type,      MatterID, StateID,   Stage,    TalliedOn
		,		UserID, UserAlias, UtcTime,  UtcOffset, UtcPlace, UtcPlaceID
		from	cteMatter x
		cross	apply core.Activity#Track(x.TrackingID)
	)
	select	ID=TrackingID, TrackingNbr, Stage
	,		UtcTime,       UtcOffset,   UtcPlace
	from	cteMarked
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$TrackMany]...';


GO
--PeterHo
ALTER FUNCTION [svc].[Parcel$TrackMany](@numbersInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID=TrackingID, TrackingNbr, Stage
	,		UtcTime,       UtcOffset,   UtcPlace
	from	core.Activity#TrackMany(@numbersInCsv)
)
GO
PRINT N'Altering [hub].[Parcel$ForUSDEndOfDay]...';


GO
-- Smile
ALTER	FUNCTION [hub].[Parcel$ForUSDEndOfDay](@hubID int)
RETURNS	TABLE
WITH ENCRYPTION
AS RETURN
(
	select	TotalParcelCnt  =isnull(count(*), 0)
	,		TotalAddOnSvcCnt=isnull(sum(u.TotalUnfinished), 0)
	,		OperationDate   =isnull(cast(dateadd(hour, t.UtcOffset, x.StatedOn) as date), '')
	from	shpt.Parcel#Base()         x
	cross	apply core.AddOnSvc#TotalUnfinished(x.ID) u
	cross	apply core.Source#ID()     s
	join	core.Tenant#Raw()          t on t.ID=x.RcvHubID
	cross	apply core.State#ID()      e
	where	x.Source=s.USD  and x.RcvHubID=@hubID and x.StateID=e.CfmOutGated
	group	by cast(dateadd(hour, t.UtcOffset, x.StatedOn) as date)
)
GO
PRINT N'Adding schema binding to [shpt].[Parcel#LedgerByFactor]...';


GO
--Daxia
ALTER FUNCTION [shpt].[Parcel#LedgerByFactor](@parcelIDs dbo.I64Array readonly, @hubID int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteLedger as
	(
		select	[MatterID]  =x.ID, x.ContractID, [LadgerPartyID]=p.AID, [ChargeAmt]=r.Amt, r.CurrencyID
		,		[LedgerPartyID]=iif(lag(p.AID) over (partition by p.AID order by (select 0)) is null, p.AID, 0)
		,		[InvDueAmt] =sum(r.RawAmt)  over (partition by p.AID)
		from	@parcelIDs i
		join	shpt.Parcel#Base() x on x.ID=i.ID
		join	core.Party#Raw()   p on p.ID=x.SiteID
		cross	apply tms.SvcFacility#For(x.Source, x.SvcClass, left(x.ZoneCode, 3)) f
		cross	apply tms.SvcCost#ByFactor(x.ContractID, @hubID, left(x.ZoneCode, 3), substring(x.ZoneCode, 4, 2), x.SvcClass, x.Weight) r
	)
	select	MatterID, ContractID, LadgerPartyID, ChargeID=g.Freight, ChargeAmt, CurrencyID, LedgerPartyID, InvDueAmt=c.Amt
	from	cteLedger
	cross	apply dbo.Currency#Encode(InvDueAmt, CurrencyID) c
	cross	apply acct.Charge#ID() g
)
GO
PRINT N'Adding schema binding to [svc].[ClientRefNbr$Vefity]...';


GO
--Smile, PeterHo
ALTER	FUNCTION [svc].[ClientRefNbr$Vefity](@siteID int, @numbersInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	

		select	ID=isnull(c.ID,0), ClientRefNbr=x.Number
		from	loc.RefNbr#Slice(@numbersInCsv) x
		cross	apply core.RefNbr#Type()        k
		cross	apply(
						select top(1) m.ID 
						from(
								select	p.ID from core.RefNbr#Raw()  r
								join	shpt.Parcel#Base()           p on r.MatterID=p.ID  and p.SiteID=@siteID 
								where	r.Number=x.Number and r.Type=k.ClientRef
								union all
								select	0
						) m
		) c
		
	
	
)
GO
PRINT N'Refreshing [svc].[Parcel$ForFedEx]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$ForFedEx]';


GO
PRINT N'Adding schema binding to [vmi].[ClientRefNbr$Vefity]...';


GO
--Smile
ALTER	FUNCTION [vmi].[ClientRefNbr$Vefity](@siteID int, @numbersInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(	

		select	ID=isnull(c.ID,0), ClientRefNbr=x.Number
		from	loc.RefNbr#Slice(@numbersInCsv) x
		cross	apply core.RefNbr#Type()        k
		cross	apply(
						select top(1) m.ID 
						from(
								select	p.ID from core.RefNbr#Raw()  r
								join	shpt.Parcel#Base()           p on r.MatterID=p.ID  and p.SiteID=@siteID 
								where	r.Number=x.Number and r.Type=k.ClientRef
								union all
								select	0
						) m
		) c
		
	
	
)
GO
PRINT N'Adding schema binding to [hub].[Challenge$List]...';


GO
-- Aimee
ALTER FUNCTION hub.Challenge$List(@number varchar(40))
RETURNS TABLE
--, ENCRYPTION
WITH SCHEMABINDING
AS RETURN 
(
	select	ID=x.MatterID, Messages, Challenges
	from	core.MIC#IdOf(@number) x
	cross	apply core.Message#Tvp(x.MatterID)
	cross	apply core.Challenge#Tvp(x.MatterID)
)
GO
PRINT N'Adding schema binding to [xpd].[Parcel$Verify]...';


GO
--	Aimee
ALTER	FUNCTION [xpd].[Parcel$Verify](@micsInCsv nvarchar(max), @siteID int)
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID=m.MatterID, x.Number, Stage
	from	loc.RefNbr#Slice(@micsInCsv)  x
	cross	apply core.MIC#IdOf(x.Number) m
	join	core.Matter#Raw()             r on r.ID=m.MatterID
	where	r.PosterID=@siteID
)
GO
PRINT N'Adding schema binding to [xpd].[Sack$Verify]...';


GO
--	Aimee
ALTER	FUNCTION [xpd].[Sack$Verify](@numbersInCsv nvarchar(max), @siteID int)
RETURNS	TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID=isnull(m.ID,0), SackNbr=x.Number
	from	loc.RefNbr#Slice(@numbersInCsv) x
	join	core.RefNbr#Raw()  r on r.Number=x.Number
	join	core.Matter#Raw()  m on m.ID=r.MatterID
	where	m.PosterID=@siteID
)
GO
PRINT N'Adding schema binding to [core].[RefNbr#MatchMulti]...';


GO
--PeterHo, Aaron
ALTER FUNCTION [core].[RefNbr#MatchMulti]
(
	@numbersInCsv nvarchar(max), @minStage int=100, @maxStage int=25500
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	x.Seq
	,		[Number]    =isnull(x.Number,    '')
	,		[MatchedCnt]=isnull(n.MatchedCnt, 0)
	,		[MatterID]  =isnull(n.MatterID,   0)
	,		[Type]      =isnull(n.Type,       0)
	,		[Stage]     =isnull(n.Stage,      0)
	from	loc.RefNbr#Slice(@numbersInCsv) x
	outer	apply core.RefNbr#MatchOne(x.Number, @minStage, @maxStage) n
)
GO
PRINT N'Altering [zeb].[RefNbr$ExistedCnt]...';


GO
--Eva
ALTER FUNCTION [zeb].[RefNbr$ExistedCnt](@nbrsInCsv tvp, @minStage int=100, @maxStage int=25500)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	select	Type, MatchedCnt
	from	core.RefNbr#MatchMulti(@nbrsInCsv, @minStage, @maxStage) x
)
GO
PRINT N'Refreshing [svc].[Parcel$VerifyForOutgated]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$VerifyForOutgated]';


GO
PRINT N'Altering [zeb].[Parcel$ViaBarcode]...';


GO
-- Eva, AaronLiu
ALTER FUNCTION [zeb].[Parcel$ViaBarcode](@barcodes tvp)
RETURNS TABLE
WITH ENCRYPTION
AS RETURN
(
	with cte(text) as
	(
		select	[text()]=concat(N',', MatterID)
		from	loc.RefNbr#Slice(@barcodes) x
		cross	apply core.RefNbr#Type()    t
		cross	apply core.RefNbr#ScanOne(x.Number, default, default) m
		where	m.Type in (t.ClientRef, t.PreCourier)
		for		xml path(N'')
	)
	select IDs=Tvp from cte cross apply tvp.Spr#Purify(text, 1)
)
/*
	with cte(text) as
	(
		select	[text()]=concat(N',', MatterID)
		from	loc.RefNbr#Slice(@barcodes) x
		join	core.RefNbr#Raw()           n on n.Number=x.Number
		cross	apply core.RefNbr#Type()    t
		where	Type in (t.ClientRef, t.PreCourier)
		for xml path(N'')
	)
	select IDs=Tvp from cte cross apply tvp.Spr#Purify(text, 1)
*/
GO
PRINT N'Adding schema binding to [core].[RefInfo#ToShippingPlan]...';


GO
--PeterHo
ALTER FUNCTION [core].[RefInfo#ToShippingPlan](@matterID bigint, @spec nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteInfo as
	(
		select	m.Seq, i.GoodsInfo, UnitPrice=i.LineDecTotal/i.LineQty, i.CurrencyID, i.CmdyID
		from	core.RefInfo#VerifiedOrDeclared(@matterID) x
		cross	apply tvp.Mucho#Slice(x.Info)  m
		cross	apply loc.LineInfo#Of(m.Piece) i
	)
	, cteSpec as
	(
		select	Bag=x.Seq, m.Seq, Qty=cast(m.Piece as int)
		from	tvp.Pcs#Slice(@spec, default)  x
		cross	apply tvp.Mucho#Slice(x.Piece) m
	)
	, cteLine as
	(
		select	s.Bag,  Info=q.Tvp, Seq=row_number() over (partition by s.Bag order by i.Seq)
		from	cteInfo i join cteSpec s on s.Seq=i.Seq
		cross	apply dbo.Money#Make(i.UnitPrice*s.Qty, i.CurrencyID)    m
		cross	apply tvp.Quad#Make(i.GoodsInfo, s.Qty, m.Amt, i.CmdyID) q
		
	)
	, cteMixed as
	(
		select	idx=1, x.Bag, x.Seq, x.Info
		from	cteLine x where x.Seq=1
		UNION	ALL
		select	idx=idx+1, x.Bag, x.Seq, p.Info + k.Mucho + x.Info
		from	cteMixed p join cteLine x on x.Bag=p.Bag and x.Seq=idx+1
		cross	apply tvp.Spr#Const() k
	)
	, cteMarked as
	(
		select	Bag, Info, Mark=lead(Seq) over (partition by Bag order by (Seq))
		from	cteMixed 
	)
	, cte(text) as
	(
		select	[text()]=concat(k.Bag, x.Info)
		from	tvp.Spr#Const() k, cteMarked x
		where	x.Mark is null  order by x.Bag
		for xml path(N'')
	)
	select	MatterID=@matterID, Type=k.ShippingPlanInfo, Info=Tvp
	from	core.RefInfo#Type() k, cte cross apply tvp.Spr#Purify(text, default)
)
GO
PRINT N'Altering [core].[RefNbr#DecodeMulti]...';


GO
--Aaron
ALTER FUNCTION [core].[RefNbr#DecodeMulti](@numbersInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
    with cteDecoded(text) as
    (
        select  [text()]=concat(',', n.Number)
        from	loc.RefNbr#Slice(@numbersInCsv) x
        cross   apply core.RefNbr#DecodeOne(x.Number) n
        for     xml path('')
    )
    select Numbers=Tvp from cteDecoded cross apply tvp.Spr#Purify(text, 1)
)
GO
PRINT N'Adding schema binding to [core].[RefNbr#DecodeMulti]...';


GO
--Aaron
ALTER FUNCTION [core].[RefNbr#DecodeMulti](@numbersInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
    with cteDecoded(text) as
    (
        select  [text()]=concat(',', n.Number)
        from	loc.RefNbr#Slice(@numbersInCsv) x
        cross   apply core.RefNbr#DecodeOne(x.Number) n
        for     xml path('')
    )
    select Numbers=Tvp from cteDecoded cross apply tvp.Spr#Purify(text, 1)
)
GO
PRINT N'Adding schema binding to [svc].[MIC$Vefity]...';


GO
--PeterHo
ALTER	FUNCTION [svc].[MIC$Vefity](@micsInCsv nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	ID=isnull(r.MatterID,0), MIC=x.Number
	from	loc.RefNbr#Slice(@micsInCsv) x
	cross	apply core.RefNbr#Type() k
	left	join  core.RefNbr#Raw()  r on r.Number=x.Number and r.Type=k.MIT
)
GO
PRINT N'Altering [loc].[Tenancy#As]...';


GO
-- PeterHo
ALTER FUNCTION [loc].[Tenancy#As](@tenancy nvarchar(max), @tobeRole int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Tenancy=Tvp
	from	loc.Tenancy#Of(@tenancy)
	cross	apply tvp.Quad#Make(PID, AID, UserID, @tobeRole)
)
GO
PRINT N'Adding schema binding to [loc].[Tenancy#As]...';


GO
-- PeterHo
ALTER FUNCTION [loc].[Tenancy#As](@tenancy nvarchar(max), @tobeRole int)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Tenancy=Tvp
	from	loc.Tenancy#Of(@tenancy)
	cross	apply tvp.Quad#Make(PID, AID, UserID, @tobeRole)
)
GO
PRINT N'Adding schema binding to [bo].[Account$ExportForDutyInvoice]...';


GO
--Simile, PeterHo
ALTER FUNCTION [bo].[Account$ExportForDutyInvoice]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	InvoicedOn, InvoiceNbr, i.PartyID, NetDays=isnull(t.BillingCycle,0)
	,		DueDate, BillTo=c.Tvp, l.DutyTvp
	from	acct.Invoice#Raw()                   i
	join	core.Party#Raw()                     p  on p.ID = i.PartyID
	join	acct.Contract#Raw()                  t  on t.ID=i.ContractID
	cross	apply core.Contact#Type()            k
	outer	apply core.Contact#TvpFor(i.PartyID, k.Billing) c
	cross	apply acct.Ledger#DutyTvpFor(i.ID)   l
	cross	apply acct.Vault#Tag()               d
	cross	apply acct.Ledger#Side()             s
	where	i.DueBalance>0 and i.VaultTag=d.Duty and i.LedgerSide=s.AR and BillingCycle>0
)
GO
PRINT N'Adding schema binding to [bo].[Account$ExportForFreightInvoice]...';


GO
--Simile, PeterHo
ALTER FUNCTION [bo].[Account$ExportForFreightInvoice]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	InvoicedOn, InvoiceNbr, i.PartyID, NetDays=isnull(BillingCycle,0)
	,		DueDate, BillTo=c.Tvp, l.FreightTvp
	from	acct.Invoice#Raw()                    i
	join	core.Party#Raw()                      p  on p.ID = i.PartyID
	join	acct.Contract#Raw()                   t  on t.ID=i.ContractID
	cross	apply core.Contact#Type()             k
	outer	apply core.Contact#TvpFor(i.PartyID,  k.Billing) c
	cross	apply acct.Ledger#FreightTvpFor(i.ID) l
	cross	apply acct.Vault#Tag()                d
	cross	apply acct.Ledger#Side()              s
	where	i.DueBalance>0 and i.VaultTag=d.NotDuty and i.LedgerSide=s.AR and BillingCycle>0
)
GO
PRINT N'Adding schema binding to [bo].[Account$IncomeSummary]...';


GO
--Simile
ALTER FUNCTION [bo].[Account$IncomeSummary]()
RETURNS TABLE
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN
(
	select	x.ID, TalliedOn, x.CurrencyID,  x.ChargeAmt,ChargeID, BillingCycle
	,		x.PartyID, TenantAlias=p.Alias, BizUnitID,  BizUnit=b.Alias, POA
	,	    a.Source, RefNbrs, RefInfos, PostedOn,  RcvHubAlias, Supplement=''
	from	acct.Ledger#Raw()   x 
	join	core.Tenant#Raw()   p on p.ID=x.PartyID
	join	shpt.Parcel#Deep()  a on a.ID=x.MatterID
	join	acct.Contract#Raw() c on c.ID=a.ContractID
	join	core.Party#Raw()    b on b.ID=c.BizUnitID
	cross	apply core.Source#ID() e
	where	a.Source in (e.eShip, e.eVMI) and x.InvoiceID>-1
	union all
	select	x.ID, TalliedOn, x.CurrencyID,  x.ChargeAmt,ChargeID, BillingCycle
	,		x.PartyID, TenantAlias=p.Alias, BizUnitID,  BizUnit=b.Alias, POA=''
	,	    a.Source, RefNbrs='', RefInfos='', PostedOn,  RcvHubAlias=t.Alias
	,	    Supplement=''
	from	acct.Ledger#Raw() x
	join	core.Tenant#Raw()   p on p.ID=x.PartyID
	join	whse.StockInOrder#Base() a on a.ID=x.MatterID
	join	acct.Contract#Raw() c on c.ID=a.ContractID
	join	core.Party#Raw()    b on b.ID=c.BizUnitID
	join	core.Tenant#Raw()   t on t.ID=a.RcvHubID
	cross	apply core.Source#ID() e
	where	a.Source in (e.eShip, e.eVMI) and x.InvoiceID>-1
	union all
	select	x.ID, TalliedOn, x.CurrencyID,  x.ChargeAmt,ChargeID, BillingCycle
	,		x.PartyID, TenantAlias=p.Alias, BizUnitID,  BizUnit=b.Alias, POA=''
	,	    a.Source, RefNbrs='', RefInfos='', PostedOn,  RcvHubAlias=''
	,	    Supplement
	from	acct.Ledger#Raw()        x
	join	core.Tenant#Raw()        p on p.ID=x.PartyID
	cross	apply core.Matter#Type() m
	join	core.Matter#Raw()        a on a.ID=x.MatterID 
	cross	apply acct.Contract#For(x.PartyID, a.Source) c
	join	core.Party#Raw()         b on b.ID=c.BizUnitID
	cross	apply core.Registry#ID() r 
	join	core.Supplement#Raw()    s on s.RegID =r.Ledger and s.RowID=x.ID
	cross	apply core.Source#ID() e
	where	a.Source in (e.eShip, e.eVMI) and x.InvoiceID>-1
	union all
	select	x.ID, TalliedOn, x.CurrencyID,  x.ChargeAmt,ChargeID, BillingCycle
	,		x.PartyID, TenantAlias=p.Alias, BizUnitID,  BizUnit=b.Alias, POA=''
	,	    a.Source, RefNbrs='', RefInfos='', PostedOn,  RcvHubAlias=''
	,	    Supplement
	from	acct.Ledger#Raw()        x
	join	core.Tenant#Raw()        p on p.ID=x.PartyID
	cross	apply core.Matter#Type() m
	join	core.Matter#Raw()        a on a.ID=x.MatterID 
	cross	apply acct.Contract#For(x.PartyID, a.Source) c
	join	core.Party#Raw()         b on b.ID=c.BizUnitID
	cross	apply core.Registry#ID() r 
	join	core.Supplement#Raw()    s on s.RegID =r.AssortedFees and s.RowID=a.ID
	cross	apply core.Source#ID() e
	where	a.Source in (e.eShip, e.eVMI) and x.InvoiceID>-1



)
GO
PRINT N'Adding schema binding to [shpt].[Parcel#FreightAndDutyFor]...';


GO
--Smile
ALTER FUNCTION [shpt].[Parcel#FreightAndDutyFor](@parcelIDs dbo.I64Array readonly)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID=x.ID, ContractID, [LedgerPartyID]=p.AID, u.ChargeID, u.ChargeAmt, u.CurrencyID
	from	shpt.Parcel#Base() x
	join	core.Party#Raw()   p on p.ID=x.SiteID
	cross	apply core.RefInfo#Type() k
	outer	apply core.RefInfo#Of(x.ID, k.BrokerageInfo) i
	join	tms.SvcType#Raw()  t on t.ID=x.SvcType
	cross	apply acct.Charge#ID()                                       g
	cross	apply
	(
		select	ChargeAmt=c.Amt,  ChargeID=g.Freight, t.CurrencyID		
		from	tms.Freight#For(x.SvcType, x.RcvHubID, x.Weight, i.Info) r
		cross	apply dbo.Money#Make(r.Freight, t.CurrencyID)            c		
		where	t.ID=x.SvcType
		UNION	ALL
		select	r.DutyRate, ChargeID=g.Duty, r.CurrencyID
		from	brkg.DutyRate#For(p.AID, t.ClrMethodID, i.Info)          r
		UNION	ALL
		select	r.DutyRate, ChargeID=g.BrokerageFee, r.CurrencyID
		from	brkg.BrokerageFee#For(x.RouteID, i.Info)                 r
	) u
	where	x.ID in (select ID from @parcelIDs)	and u.ChargeAmt>0
)
GO
PRINT N'Adding schema binding to [shpt].[Parcel#LedgerForVmi]...';


GO
--Smile
ALTER FUNCTION [shpt].[Parcel#LedgerForVmi](@parcelIDs dbo.I64Array readonly)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	MatterID=x.ID, ContractID, [LedgerPartyID]=p.AID, u.ChargeID, u.ChargeAmt, u.CurrencyID
	from	shpt.Parcel#Base() x
	join	core.Party#Raw()   p on p.ID=x.SiteID
	cross	apply core.RefInfo#Type() k
	outer	apply core.RefInfo#Of(x.ID, k.BrokerageInfo) i
	cross	apply core.RefInfo#Of(x.ID, k.DeclaredInfo)  o
	join	tms.SvcType#Raw()  t on t.ID=x.SvcType
	cross	apply acct.Charge#ID()                                       g
	cross	apply
	(
		select	ChargeAmt=c.Amt,  ChargeID=g.Freight, t.CurrencyID		
		from	tms.Freight#For(x.SvcType, x.RcvHubID, x.Weight, i.Info) r
		cross	apply dbo.Money#Make(r.Freight, t.CurrencyID)            c		
		where	t.ID=x.SvcType
		UNION	ALL
		select	r.DutyRate, ChargeID=g.Duty, r.CurrencyID
		from	brkg.DutyRate#For(p.AID, t.ClrMethodID, i.Info)         r
		where	r.DutyRate>r.CurrencyID
		UNION	ALL
		select	m.Amt, CharegeID=g.OutPkgFee, s.CurrencyID
		from	whse.StorageRate#For(x.RcvHubID, x.SiteID)              s
		cross	apply dbo.Money#Make(s.OutPkgFee, s.CurrencyID)         m
		where	m.Amt>s.CurrencyID
		UNION	ALL
		select	m.Amt, CharegeID=g.OverWeightFee, s.CurrencyID
		from	whse.StorageRate#For(x.RcvHubID, x.SiteID)              s
		cross	apply dbo.Money#Make(s.OverWeightFee, s.CurrencyID)     m
		where	x.Weight>s.WeightLimit
		and		m.Amt>s.CurrencyID
		UNION	ALL
		select	m.Amt, CharegeID=g.ExcessItemsFee, s.CurrencyID
		from	whse.StorageRate#For(x.RcvHubID, x.SiteID)              s
		cross	apply dbo.Money#Make(s.ExcessItemsFee, s.CurrencyID)    m
		cross	apply loc.TotalSkuQty#For(o.Info)                       o
		where	o.TotalSkuQty>s.ItemsQtyLimit	
		and		m.Amt>s.CurrencyID
	) u
	where	x.ID in (select ID from @parcelIDs)	
)
GO
PRINT N'Refreshing [core].[Measure#Todo]...';


GO
EXECUTE sp_refreshsqlmodule N'[core].[Measure#Todo]';


GO
PRINT N'Adding schema binding to [tms].[Route#Check]...';


GO
--PeterHo
ALTER FUNCTION [tms].[Route#Check](@routeID bigint, @svcClass tinyint, @weight real, @length real, @tenancy nvarchar(max))
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteAction as
	(
		select	k.HubMeasure
		,		TobeActionID=iif(@weight>x.MaxWeight, k.ReportOverThreshold, k.HubMeasure)
		from	core.Action#ID() k, tms.Route#Raw() x
		where	x.ID=@routeID
	)
	select	TobeActionID
	,		TobeSvcClass=iif(TobeActionID=HubMeasure, @svcClass, cast(0 as tinyint))
	,		TobeTenancy =iif(TobeActionID=HubMeasure, @tenancy,  (select Tenancy from loc.Tenancy#As(@tenancy, 0)))
	from	cteAction
)
GO
PRINT N'Adding schema binding to [svc].[Parcel$TrackForXpd]...';


GO
-- Aimee
ALTER FUNCTION [svc].[Parcel$TrackForXpd](@numbersInCsv nvarchar(max), @siteID int)
RETURNS TABLE 
WITH SCHEMABINDING--, ENCRYPTION
AS RETURN 
(
	select	Tracks, CourierCode, CourierNbr, TrackingNbr=x.Number
	from	core.RefNbr#MatchMulti(@numbersInCsv, default, default) x
	join	core.Matter#Raw() p on p.ID=x.MatterID
	cross	apply svc.Parcel$Track(p.ID)
	where	p.PosterID=@siteID
)
GO
PRINT N'Adding schema binding to [core].[RefNbr#ScanMulti]...';


GO
--PeterHo, Aaron
ALTER FUNCTION [core].[RefNbr#ScanMulti]
(
	@numbersInCsv nvarchar(max), @minStage int=100, @maxStage int=25500
)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	with cteScaned as
	(
		select	top(1) Seq, Number, MatterID, Type, Stage
		from	core.RefNbr#MatchMulti(@numbersInCsv, @minStage, @maxStage)
		where	MatchedCnt=1
		union	all
		select	top(1) Seq, Number, MatterID, Type, Stage
		from	core.RefNbr#DecodeMulti(@numbersInCsv) x
		cross	apply core.RefNbr#MatchMulti(x.Numbers, @minStage, @maxStage)
		where	MatchedCnt=1
	)
	select	top(1) Seq, Number, MatterID, Type, Stage
	from	cteScaned
)
GO
PRINT N'Refreshing [svc].[Parcel$ScanMultiForAutomation]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$ScanMultiForAutomation]';


GO
PRINT N'Adding schema binding to [tvp].[Pcs#TallyT]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Pcs#TallyT](@source nvarchar(max), @spr nvarchar(255)=N'	;	', @upto int=0)
RETURNS @result TABLE 
(
	[Seq] int not null, [Start] int not null, [Stop] int not null
	PRIMARY KEY CLUSTERED ([Seq] ASC, [Start] ASC, [Stop] ASC)
)
WITH SCHEMABINDING, ENCRYPTION
AS 
BEGIN
	insert	@result select [Seq],   [Start], [Stop]
	from	tvp.Pcs#TallyR(@source, @spr,    @upto)
	option	(maxrecursion 0)
	RETURN
END
GO
PRINT N'Altering [tvp].[Pcs#SliceT]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Pcs#SliceT](@source nvarchar(max), @spr nvarchar(255)=N'	;	', @upto int=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Seq, Start, Stop
	,		[Length]=isnull(Stop-Start, 0)
	,		[Piece] =isnull(substring(@source, Start, Stop-Start), cast(N'' as nvarchar(max)))
	from	tvp.Pcs#TallyT(@source, @spr, @upto)
)
GO
PRINT N'Adding schema binding to [tvp].[Pcs#SliceT]...';


GO
-- PeterHo
ALTER FUNCTION [tvp].[Pcs#SliceT](@source nvarchar(max), @spr nvarchar(255)=N'	;	', @upto int=0)
RETURNS TABLE
WITH SCHEMABINDING, ENCRYPTION
AS RETURN
(
	select	Seq, Start, Stop
	,		[Length]=isnull(Stop-Start, 0)
	,		[Piece] =isnull(substring(@source, Start, Stop-Start), cast(N'' as nvarchar(max)))
	from	tvp.Pcs#TallyT(@source, @spr, @upto)
)
GO
PRINT N'Altering [svc].[Account$InvoiceTallied]...';


GO
/*
declare	@slip tvp = Tuplet[Source, VaultTag, PartyID, BizUnitID, IssueDate0, InvoiceNbrInfo]
*/
--@slip=Quad[];
--Smile
ALTER PROCEDURE [svc].[Account$InvoiceTallied](@slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@source tinyint, @vaultTag tinyint, @partyID int, @bizUnitID int, @issueDate datetime2(2)
		,		@invoiceNbrInfo tvp;
		select	@source=v1, @vaultTag=v2, @partyID=v3, @bizUnitID=v4, @issueDate=v5
		,		@invoiceNbrInfo=v6	
		from	tvp.Tuplet#Of(@slip, default) 

		declare	@ledgerSide E8=(select AR from acct.Ledger#Side())
		,		@ids I64Array;	
		with cte as
		(
			select	ID=cast(v1 as bigint), InvoiceNbr=v2
			from	tvp.Duad#Slice(@invoiceNbrInfo, default, default)
		)
		insert	acct._Invoice( PartyID,      ContractID,   VaultTag,   LedgerSide,  InvoiceNbr,
							   CurrencyID,   DueBalance,   InvoiceAmt, IssueDate, DueDate)
		output	inserted.ID into @ids
		select	               PartyID,      ContractID,   VaultTag,   @ledgerSide, e.InvoiceNbr,
		                       CurrencyID,   ChargeAmt,    ChargeAmt,  IssueDate, DueDate
		from	svc.Invoice$ProcessingList(@source, @vaultTag, @partyID, @bizUnitID, @issueDate) x
		join	cte e on e.ID=x.ID;

		with	cteLedgerGroup as
		(
		select	l.ID, l.PartyID, x.SourceID, p.ContractID, l.CurrencyID, g.VaultTag
		,		IssueDate=iif(BillingCycle%7=0, cd.BOWeek, cd.BOMonth)
		,		l.ChargeRaw, LastInvoiceDate=isnull(i.LastInvoiceDate, dbo.DT@Empty()),	l.TalliedOn, BillingCycle
		from	acct.Contract#Raw()               x
		cross	apply dbo.Calendar#Of(@issueDate) cd
		join	shpt.Parcel#Raw()                 p on p.ContractID=x.ID
		join	acct.Ledger#Raw()                 l on l.MatterID=p.ID
		join	acct.Charge#Raw()                 g on l.ChargeID=g.ID
		cross	apply acct.Vault#Tag()            a
		cross	apply acct.Ledger#Side()          d
		outer	apply (
						select  LastInvoiceDate=max(IssueDate)
						from	acct.Invoice#Raw()
						where	PartyID=x.TenantID
						and		ContractID=x.ID
						and		VaultTag=g.VaultTag
						and		CurrencyID=l.CurrencyID
						and     ID not in (select ID from @ids)
					  )                           i           
		where	l.InvoiceID=0
		and		(nullif(@vaultTag,0) is null or g.VaultTag=@vaultTag)
		and		l.LedgerSide=d.AR
		and		(nullif(@bizUnitID,0) is null or x.BizUnitID=@bizUnitID)
		and		(nullif(@partyID, 0) is null or x.TenantID=@partyID)
		and		(nullif(@source,  0) is null or x.SourceID=@source)
		and		BillingCycle>0
		and	    l.TalliedOn<iif(BillingCycle%7=0, cd.BOWeek, cd.BOMonth)
		), cteInvoiceSummary as
		(
		select	ID, PartyID, SourceID, ContractID, CurrencyID, VaultTag
		,		IssueDate, ChargeRaw
		,		InvoiceGroup=DateDiff(day, TalliedOn, dateadd(day, -1,IssueDate))/BillingCycle
		from	cteLedgerGroup               x
		where	(BillingCycle in(7,14) and datediff(day, LastInvoiceDate, IssueDate)>=BillingCycle)
		or		(BillingCycle=30 and datediff(month, LastInvoiceDate, IssueDate)=1)
		), cteInvoice as
		(
		select	ID, PartyID, VaultTag, CurrencyID, ContractID, InvoiceGroup, IssueDate
		,		ChargeRawAmt=sum(ChargeRaw) over(partition	by PartyID, VaultTag, CurrencyID, ContractID, InvoiceGroup, IssueDate)
		from	cteInvoiceSummary  		
		), cteLedger as
		(
		select	InvoiceID=x.ID, LedgerID=d.ID
		from	@ids               x
		join	acct.Invoice#Raw() i on x.ID=i.ID
		join	cteInvoice         d on d.PartyID=i.PartyID       and 
										d.ContractID=i.ContractID and 
										d.CurrencyID=i.CurrencyID and 
										d.VaultTag=i.VaultTag     and
										d.ChargeRawAmt=i.DueBalanceRaw
		)update l set l.InvoiceID=i.InvoiceID from acct._Ledger l join cteLedger i on l.ID=I.LedgerID;

		declare	@vaultType  E8=(select Fund from acct.Vault#Type());
		with cteInvoiceds as
		(
			select	PartyID, x.CurrencyID, ChargeRawAmt=sum(x.InvoiceRawAmt)
			from	@ids               i
			join	acct.Invoice#Raw() x on i.ID=x.ID
			group	by PartyID, x.CurrencyID
		), cteVaults as
		(
			select	v.ID,  UninvoicedAmt, NewUninvoicedAmt=iif(u.Amt<0, 0, u.Amt)
			from	acct.Vault#Raw() v
			join	cteInvoiceds     x on v.PartyID=x.PartyID and v.CurrencyID=x.CurrencyID and v.VaultType=@vaultType
			cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
			cross	apply dbo.Money#Sum(-m.Amt,v.UninvoicedAmt) u
		)
		update	cteVaults set UninvoicedAmt=NewUninvoicedAmt;
		

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [bo].[Account$UpdateContract]...';


GO
/*

@slip =Dozen<Source, DutyTerms, NoDutyTerms, BillingCycle, 
			 EffectiveOn, ExpiredOn, BIZUnitID, Many[SvcType]>
@context=TenantID

*/
--Smile
ALTER PROCEDURE [bo].[Account$UpdateContract](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;

		declare	@source tinyint, @dutyTerms tinyint,  @nondutyTerms tinyint, @billingCycle tinyint,
				@effectiveOn dbo.DT, @expiredOn dbo.DT, 
				@bizUnitID I32, @svcTypes tvp;

		select	@source=v1, @dutyTerms=v2, @nondutyTerms=v3, @billingCycle=v4,
				@effectiveOn=v5, @expiredOn=v6,
				@bizUnitID=v7,   @svcTypes=v8
		from	tvp.Dozen#Of(@slip, default);

		declare	@contractID int, @obillingCycle tinyint;
		select  @contractID=ID,  @obillingCycle=BillingCycle
		from	acct.Contract#For(@context, @source);

		if((@billingCycle<>@obillingCycle) or nullif(@contractID, 0) is null)
		begin
		insert	into acct._Contract
				(TenantID, BizUnitID,  SourceID, BillingCycle,  DutyTerms,  NonDutyTerms,  EffectiveOn,  ExpiredOn)
		values	(@context, @bizUnitID, @source,  @billingCycle, @dutyTerms, @nondutyTerms, @effectiveOn, @expiredOn)
		;
		select	@contractID=scope_identity();
		end
		else
		begin
		update acct._Contract set BizUnitID=@bizUnitID,  BillingCycle=@billingCycle, 
								  DutyTerms=@dutyTerms,  NonDutyTerms=@nondutyTerms,
								  EffectiveOn=@effectiveOn,  ExpiredOn=@expiredOn
		where	ID=@contractID
		end

		delete	from tms._SvcContract where ContractID=@contractID;
		insert	tms._SvcContract(SvcType, ContractID)
		select	isnull(s.ID, k.Major), @contractID
		from	tvp.Many#Slice(@svcTypes)        x
		cross	apply tms.SvcType#Major(x.Piece) k
		outer	apply (
				 select top(1) t.ID
				 from	tms.SvcType#Raw()        t
				 where	t.TenantID=@context 
				 and	t.ID between k.Major and k.Upto

			  )                                  s;
		declare	@userID I32=(select	UserID from	loc.Tenancy#Of(@tenancy));
		insert	core._ChangeLog(RegID, RowID, ChangedBy, ChangedOn)
		select			  SvcContract, @contractID, @userID, getutcdate()
		from	core.Registry#ID();
	


		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [acct].[Vault#XactByInvoice]...';


GO
--Smile
ALTER PROCEDURE [acct].[Vault#XactByInvoice](@invoiceds I64Array readonly, @paymentID bigint =0, @vaultType tinyint)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
						
		-- 1	Upsert  Vault(s):
		with cteVaultGroup as
		(
			select	PartyID, i.CurrencyID, XactAmt=sum(-m.RawAmt)
			from	@invoiceds         x
			join	acct.Invoice#Raw() i on i.ID=x.ID
			cross	apply dbo.Money#Of(i.InvoiceAmt) m 
			group	by PartyID, i.CurrencyID
		), cteVault as
		(
			select	PartyID, CurrencyID, XactAmt=m.Amt
			from	cteVaultGroup                                    x
			cross	apply dbo.Currency#Encode(x.XactAmt, CurrencyID) m
		)
		merge	acct._Vault as o using cteVault as n
		on		(o.PartyID=n.PartyID and o.VaultType=@vaultType and o.CurrencyID=n.CurrencyID)
		when	matched  then update set VaultBal=(select Amt from dbo.Money#Sum(VaultBal, XactAmt))
										, TalliedOn=getutcdate()
										, InvoicedAmt=(select iif(Amt<o.CurrencyID, o.CurrencyID, Amt) 
										  from dbo.Money#Sum(o.InvoicedAmt, n.XactAmt))
		when	not matched then
				insert(  PartyID,   VaultBal,  VaultType,   CurrencyID)
				values(n.PartyID, n.XactAmt,  @vaultType, n.CurrencyID)
		;

		with cteInvoice as
		(
			select	x.PartyID, InvoiceID=x.ID, VaultID=v.ID, XactAmt=x.InvoiceAmt, XactAmtRaw=c.RawAmt, x.CurrencyID
			,		VaultBalRaw=isnull(PrevBalRaw, 0), Marker=lag(c.RawAmt) over(partition by v.ID order by x.ID)
			from	acct.Invoice#Raw()                    x
			join	 @invoiceds                           d on x.ID=d.ID
			cross	apply dbo.Money#Of(x.InvoiceAmt)      c
			join	acct.Vault#Raw() v on v.PartyID=x.PartyID and v.CurrencyID=x.CurrencyID and v.VaultType=@vaultType
			outer	apply acct.VaultXact#LastBalFor(v.ID) i
		),	cteCummulation as
		(
			select	PartyID, InvoiceID, VaultID, XactAmt, XactAmtRaw, CurrencyID
			,		Cummulation=sum(Marker) over (partition by VaultID  order by InvoiceID)
			,		VaultBalRaw, marker
			from	cteInvoice
		)
		, cteXact as
		(
			select	PartyID, InvoiceID, VaultID, XactAmt, CurrencyID, Cummulation, VaultBalRaw
			,		PrevBalRaw=iif(marker is null, VaultBalRaw, VaultBalRaw-Cummulation)
			from	cteCummulation
		)

		insert	acct._VaultXact
		(		PaymentID, InvoiceID, VaultID, PrevBal,  XactAmt)
		select	@paymentID,InvoiceID, VaultID, m.Amt,   -XactAmt
		from	cteXact                                           x
		cross	apply dbo.Currency#Encode(PrevBalRaw, CurrencyID) m;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [invt].[SkuInfo#AddBlock]...';


GO
--PeterHo
ALTER PROCEDURE [invt].[SkuInfo#AddBlock]
(
	@index int, @idSeqs I64Seqs readonly, @slip nvarchar(max), @routeID int
)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._RefInfo
	(		MatterID,   Type,   Info)
	select	x.Master, i.Type, i.Info
	from	tvp.Block#FoldT(@index, @idSeqs, @slip, default, default) x
	cross	apply
	(
		select	Type=k.DeclaredInfo,  s.Info
		from	core.RefInfo#Type()   k, invt.SkuInfo#ToDeclared(x.House) s
		UNION	ALL
		select	Type=k.BrokerageInfo, b.Info
		from	core.RefInfo#Type()   k, tms.Route#Raw() r
		cross	apply invt.SkuInfo#ToBrokerage(x.House, r.BrokerID, r.ClrMethodID) b
		where	r.ID=@routeID
	) i;
END
GO
PRINT N'Altering [hub].[Parcel$UpdAddOnSvcOverlabel]...';


GO
/*
	@slip tvp = ParcelID
*/
-- Aimee
ALTER PROCEDURE [hub].[Parcel$UpdAddOnSvcOverlabel](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32; select @userID=UserID from	loc.Tenancy#Of(@tenancy);
		update	o set o.OperatorID=@userID, o.EndedOn=getutcdate() 
		from	core.AddOnSvc#Raw()         o
		cross	apply core.AddOnSvc#Type()  k
		where	o.MatterID=cast(@slip as bigint) and o.Type=/*k.Overlabel*/106

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [xpd].[SackMft$UploadLabelForXpd]...';


GO
/*
	@slip = Duad<mawbNbr, FileBankID>
*/
-- Aimee
ALTER PROCEDURE [xpd].[SackMft$UploadLabelForXpd](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	BEGIN TRY
		BEGIN	TRAN;
			declare	@siteID I32=(select SiteID from loc.Tenancy#Of(@tenancy));
			with cte as
			(
				select	RegID=k.Matter, RowID=cast(x.v1 as bigint), AuxID=31, FileBankID=x.v2, PosterID=@siteID -- HACK
				from	tvp.Duad#Slice(@slip, default, default) x
				cross	apply core.Attachment#Type()            t
				cross	apply core.Registry#ID()                k
			)
			merge	core._Attachment as o using cte as n
			on		(o.RegID=n.RegID and o.RowID=n.RowID and o.AuxID=n.AuxID and o.PosterID=n.PosterID)
			when	matched then update set FileBankID=n.FileBankID
			when	not matched then 
					insert(  RegID,   RowID,   AuxID,   PosterID,   FileBankID, PostedOn)
					values(n.RegID, n.RowID, n.AuxID, n.PosterID, n.FileBankID, getutcdate())
					;
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [core].[Concern#Remove]...';


GO
/*
@concerns = Comma[ConcernType]
*/
--Smile
ALTER PROCEDURE [core].[Concern#Remove](@matterID bigint, @concerns tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteConcern as
	(
		select	MatterID, Type
		from	tvp.Comma#Slice(@concerns) c
		join	core.Concern#Raw()         x
		on		x.MatterID=@matterID and x.Type=cast(c.Piece as tinyint)
	)
	delete	from cteConcern;
END
GO
PRINT N'Altering [shpt].[Concern#AttachPreCheckTo]...';


GO
/*
@idSeqs => [MatterID, Seqence]
*/
--PeterHo
ALTER PROCEDURE [shpt].[Concern#AttachPreCheckTo](@idSeqs dbo.I64Seqs readonly)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	declare	@type E8=(select PreCheckIncomplete from core.Concern#Type());

	with cteNotYetBeenAdded as
	(
		select	x.ID, p.SvcType
		from	@idSeqs x
		join	shpt.Parcel#Raw()       p on p.ID=x.ID
		join	tms.SvcType#Raw()       s on s.ID=p.SvcType
		left	join core.Concern#Raw() c on c.MatterID=p.ID and c.Type=@type
		where	s.UsePreCheck=1 and c.MatterID is null
	)
	insert	core._Concern
	(		MatterID,  Type)
	select	ID,       @type
	from	cteNotYetBeenAdded

END
GO
PRINT N'Altering [shpt].[Concern#DetachPreCheckFrom]...';


GO
/*
@idSeqs => [MatterID, Seqence]
*/
--PeterHo
ALTER PROCEDURE [shpt].[Concern#DetachPreCheckFrom](@idSeqs dbo.I64Seqs readonly)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	declare	@type E8=(select PreCheckIncomplete from core.Concern#Type());

	delete	core._Concern
	where	Type=@type
	and		MatterID in (select ID from @idSeqs)
END
GO
PRINT N'Altering [core].[RefInfo#AddContact]...';


GO
--PeterHo
ALTER PROCEDURE [core].[RefInfo#AddContact](@idSeqs I64Seqs readonly, @partyID I32, @type tinyint)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	declare	@shprInfo tvp=(select Tvp from core.Contact#TvpForRefInfo(@partyID, @type));
	insert	core._RefInfo
	(		MatterID, Type,  Info)
	select	ID,       @type, isnull(@shprInfo, N'???')
	from	@idSeqs
END
GO
PRINT N'Altering [ic].[Handler$Assigned]...';


GO
/*
@slip  =Comma[ParcelID]  
@context= UserID
*/
--Smile
ALTER PROCEDURE [ic].[Handler$Assigned](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;

		declare	@userID I32; select @userID=UserID from	loc.Tenancy#Of(@tenancy);
		with cteMatter as
		(
			select	m.ID, HandlerID
			from	tvp.I64#Slice(@slip) x
			join	core.Matter#Raw()    m on m.ID=x.ID
			where	HandlerID IN (0, @userID)
		)
		update	cteMatter set HandlerID=@context;
		
END
GO
PRINT N'Altering [shpt].[SackMft#CreateForFlight]...';


GO
/*
@context =Dozen<POD, POA, Mawb, FlightNbr, OutgatedOn, MawbWt>
*/
--PeterHo
ALTER PROCEDURE [shpt].[SackMft#CreateForFlight](@id bigint out, @flightID bigint, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @site I32;
		select	@userID=UserID, @site=SiteID
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@now        DT =getutcdate();
		declare	@type       E8 =(select SackMft        from core.Matter#Type());
		declare	@stage      E32=(select SackManifested from core.Stage#ID());
		declare	@stateID    I32=(select SackMftCreated from core.State#ID());
		declare	@source     E8 =(select Source         from core.Matter#Raw() where ID=@flightID);
		declare	@sackMftID I64=next value for core.MatterSeq;

		insert	core._Matter
				(ID,               PID, PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		values	(@sackMftID, @flightID, @site,    @stateID, @stage, @source, @type,     @now);

		insert	shpt._SackMft
				(       ID, POD, POA, MawbNbr, FlightNbr, MawbWt)
		select	@sackMftID, v1,  v2,  v3,      v4,        v6
		from	tvp.Dozen#Of(@context, default)

		insert	core._Activity
				(  MatterID,  StateID,  UserID, TalliedOn)
		values	(@sackMftID, @stateID, @userID,      @now);

		select	@id=@sackMftID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [zeb].[Parcel$Reset]...';


GO
/*
	@slip    = Comma<ParcelID>
*/
-- AaronLiu
ALTER PROCEDURE [zeb].[Parcel$Reset](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		with	cte as
		(
			select	m.ID, m.AID
			from	tvp.I64#Slice(@slip) x
			join	core.Matter#Raw()	 m on x.ID=m.ID
		)
		update	cte set AID=0;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH 
END
GO
PRINT N'Altering [zeb].[PIP$Append]...';


GO
/*
	@slip	 = Comma<ParcelID>
	@context = PIPID
*/
-- AaronLiu
ALTER PROCEDURE [zeb].[PIP$Append](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		with	cte as
		(
			select	m.ID, m.AID
			from	tvp.I64#Slice(@slip) x
			join	core.Matter#Raw()	 m on x.ID=m.ID
		)
		update	cte set AID=@context;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH 
END
GO
PRINT N'Altering [svc].[Parcel$MergePostCourier]...';


GO
/*
@slip   =Many[Triad<TrackingNbr, PostCourier, CourierCode>]
*/
--Smile
ALTER PROCEDURE [svc].[Parcel$MergePostCourier](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
	
		declare	@type E8=(select PostCourier from core.RefNbr#Type());
		
		declare	@parcelCourierIDs dbo.I64Pairs;
		with cteCourierNbr as
		(
			select	m.MatterID, Number=cast(v2 as varchar(40)), CourierID
			from	tvp.Triad#Slice(@slip, default, default) x
			cross	apply core.RefNbr#ScanOne(x.v1, default, default) m
			cross	apply tms.Courier#IdOfAlias(v3) t
		)
		merge	core._RefNbr as r using cteCourierNbr as n
		on		(r.MatterID=n.MatterID and r.Type=@type)
		when	matched     and n.Number=N'' then delete
		when	matched     and n.Number>N'' then update set r.Number=n.Number
		when	not matched and n.Number>N'' then insert(MatterID,  Type,   Number)
												values(n.MatterID, @type, n.Number)
		output inserted.MatterID, n.CourierID into @parcelCourierIDs;

		update o set o.LastMilerID=n.RID from shpt._Parcel o join @parcelCourierIDs n on o.ID=n.LID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [shpt].[SackMft#Create]...';


GO
/*
@context =at.Quad.Of(POD, POA, Mawb, FlightNbr)
*/
--PeterHo
ALTER PROCEDURE [shpt].[SackMft#Create](@id bigint out, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @hubID I32;
		select	@userID=UserID, @hubID=HubID
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@now       DT=getutcdate();
		declare	@stateID   I32=(select SackMftCreated from core.State#ID());		
		declare	@source    E8=(select  InfoPath       from core.Source#ID());	
		declare	@type      E8=(select  SackMft        from core.Matter#Type());
		declare	@stage     E32=(select Stage from core.State#Raw() where ID=@stateID);
		declare	@sackMftID I64=next value for core.MatterSeq;

		insert	core._Matter
				(ID,         PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		values	(@sackMftID,   @hubID, @stateID, @stage, @source, @type,     @now);

		insert	shpt._SackMft
				(       ID, POD, POA, MawbNbr, FlightNbr)
		select	@sackMftID, v1,  v2,  v3,      v4
		from	tvp.Quad#Of(@context, default)

		insert	core._Activity
				(  MatterID,  StateID,  UserID, TalliedOn)
		values	(@sackMftID, @stateID, @userID,      @now);

		select	@id=@sackMftID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [tms].[Flight#Create]...';


GO
/*
@context =Dozen<POD, ETD, POA, ETA, FlightNbr, AirlineID>
*/
--Daxia
ALTER PROCEDURE [tms].[Flight#Create](@id bigint out, @source tinyint, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @site I32;
		select	@userID=UserID, @site=SiteID
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@now           DT =getutcdate();
		-- 1.	Add Flight
		declare	@type    E8 =(select Flight       from core.Matter#Type());
		declare	@stage   E32=(select InfoImported from core.Stage#ID());
		declare	@stateID I32=(select FlightBooked from core.State#ID());
		declare	@flightID      I64=next value for core.MatterSeq;

		insert	core._Matter
				(ID,         PosterID, StateID,  Stage,  Source,  Type, PostedOn)
		values	(@flightID,  @site,   @stateID, @stage, @source, @type, @now);

		insert	tms._Flight
		(		ID,        POD, ETD, POA, ETA, FlightNbr, AirlineID)
		select	@flightID, v1,  v2,  v3,  v4,  v5,        v6
		from	tvp.Dozen#Of(@context, default)

		insert	core._Activity
				( MatterID,  StateID,  UserID, TalliedOn)
		values	(@flightID, @stateID, @userID, @now);

		select	@id=@flightID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [core].[RefNbr#AddMIC]...';


GO
--PeterHo
ALTER PROCEDURE [core].[RefNbr#AddMIC](@idSeqs I64Seqs readonly, @source E8, @type E8)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	declare	@now DT=getutcdate();

	insert	core._RefNbr
	(		MatterID, Type,  Number)
	select	x.ID,     k.MIT, m.MIC
	from	core.RefNbr#Type() k, @idSeqs x
	cross	apply core.MIC#Emit(x.ID, @source, @type, @now) m
END
GO
PRINT N'Altering [core].[OutboundQ#Enqueue]...';


GO
--PeterHo
ALTER PROCEDURE [core].[OutboundQ#Enqueue](@source E8, @qtype E8=0, @matterID I64, @stateID I32)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	declare	@src E8=(select Source from core.Source#Rectify(@source, @qtype));
	insert	core._OutboundQ
			(ToSource, QueueType,  MatterID,  StateID)
	values	(@src,     @qtype,    @matterID, @stateID)  
END
GO
PRINT N'Altering [core].[OutboundQ#EnqueueBySpec]...';


GO
--PeterHo:
ALTER PROCEDURE [core].[OutboundQ#EnqueueBySpec](@spec core.TransitionSpec readonly)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	with cteSpec as
	(
		select	Source,   QueueType=try_cast(c.Piece as tinyint)
		,		MatterID, ToStateID
		from	@spec cross apply tvp.Comma#Slice(OutboundQ) c
	)
	insert	core._OutboundQ
	(		ToSource, QueueType, MatterID,   StateID)
	select	q.Source, QueueType, MatterID, ToStateID
	from	cteSpec cross apply core.Source#Rectify(Source, QueueType) q
	where	QueueType>0

/*	2017/11/11 by Peter.
	insert	core._OutboundQ
	(		ToSource, QueueType, MatterID,   StateID)
	select	q.Source, OutboundQ, MatterID, ToStateID
	from	@spec cross apply core.Source#Rectify(Source, OutboundQ) q
	where	OutboundQ>0;
*/
END
GO
PRINT N'Altering [core].[Activity#Once]...';


GO
--PeterHo
ALTER PROCEDURE [core].[Activity#Once](@matterID I64, @stateID I32, @qtype E8=0, @userID I32=0)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	if (@matterID is null or exists(select * from core._Activity where MatterID=@matterID and StateID=@stateID))
		return;

	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		insert	core._Activity
				( MatterID,  StateID, ActionID,  UserID)
		values	(@matterID, @stateID, 0,        @userID);

		if (@qtype>0) -- need outboundQ
		begin
			declare	@source E8=(select Source from core._Matter where ID=@matterID);
			execute	core.OutboundQ#Enqueue @source=@source, @qtype=@qtype, @matterID=@matterID, @stateID=@stateID;
		end

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [acct].[Vault#Upsert]...';


GO
/*
@partyAmts = Many[Duad<PartyID, XactAmt>]
RESULT     = I64PairAmts {PartyID=LID, VaultID=RID, PrevBal=Amt}
*/
--PeterHo
ALTER PROCEDURE [acct].[Vault#Upsert](@partyAmts tvp, @vaultType E8)
WITH ENCRYPTION--
AS
BEGIN
	SET NOCOUNT ON;

	declare	@idAmts I64PairAmts;
	with cteNew as
	(
		select	PartyID=cast(v1 as bigint), VaultType=@vaultType
		,		XactAmt=cast(v2 as bigint), c.CurrencyID
		from	tvp.Duad#Slice(@partyAmts, default, default)
		cross	apply dbo.Currency#Decode(cast(v2 as bigint)) c
	)
	merge	acct._Vault as o using cteNew as n
	on		(o.PartyID=n.PartyID and o.VaultType=n.VaultType and o.CurrencyID=n.CurrencyID)
	when	matched     then update set VaultBal =(select Amt from dbo.Money#Sum(VaultBal, XactAmt))
			                        ,   TalliedOn=getutcdate()
	when	not matched then insert(  PartyID,  VaultBal,   VaultType,   CurrencyID, TalliedOn)
			                 values(n.PartyID, n.XactAmt, n.VaultType, n.CurrencyID, getutcdate())
	output	inserted.PartyID, inserted.ID, isnull(deleted.VaultBal, inserted.CurrencyID) into @idAmts;

	select	/*PartyID*/LID, /*VaultID*/RID, /*PrevBal*/Amt from @idAmts;
END
GO
PRINT N'Altering [acct].[Vault#Xact]...';


GO
--PeterHo
ALTER PROCEDURE [acct].[Vault#Xact]
(
	@paymentID I64, @invoiceID I64, @partyID I32, @vaultType E8, @xactAmt amt
)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@partyAmts tvp=(select Tvp from tvp.Duad#Make(@partyID, @xactAmt));
		declare	@idAmts  I64PairAmts; insert @idAmts 
		(		LID,     RID,     Amt    )
	--	select	PartyID, VaultID, PrevBal)
		execute	acct.Vault#Upsert @partyAmts=@partyAmts, @vaultType=@vaultType;

		insert	acct._VaultXact
		(		 PaymentID,  InvoiceID, VaultID, PrevBal,  XactAmt)
		select	@paymentID, @invoiceID, RID,     Amt,     @xactAmt
		from	@idAmts;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [core].[Contact#Add]...';


GO
--PeterHo
ALTER PROCEDURE [core].[Contact#Add](@id I32 out, @partyID I32, @type E8, @contact tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._Contact
	(		 PartyID,  Type, Name, Phone, Email, Company, Street1, Street2, Street3, City, District, Province, PostalCode, CountryCode)
	select	@partyID, @type, Name, Phone, Email, Company, Street1, Street2, Street3, City, District, Province, PostalCode, CountryCode
	from	loc.Contact#Of(@contact);
END
GO
PRINT N'Altering [core].[Contact#AddVia]...';


GO
--Smile
ALTER PROCEDURE [core].[Contact#AddVia](@partyID I32, @contact tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._Contact
	(		 PartyID,  Type, Name, Phone, Email, Company, Street1, Street2, Street3, City, District, Province, PostalCode, CountryCode)
	select	@partyID, x.v1, Name, Phone, Email, Company, Street1, Street2, Street3, City, District, Province, PostalCode, CountryCode
	from	tvp.Duad#Slice(@contact, default, default) x
	cross	apply loc.Contact#Of(x.v2);
END
GO
PRINT N'Altering [svc].[Tenancy$UpdateContact]...';


GO
/*
@slip =  at.Tvp.Field.Join(PartyID, Alias, Contact, UtcPlace, UtcOffset)
@context=Source
*/
--Smile
ALTER PROCEDURE [svc].[Tenancy$UpdateContact](@slip tvp, @context tvp)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;

		declare	@partyID int, @alias loc.Alias, @contact tvp, @utcPlace loc.Alias, @utcOffset smallint;

		select	@partyID=v1, @alias=v2, @contact=v3, @utcPlace=v4, @utcOffset=v5
		from	tvp.Field#Of(@slip, default);

		update	core._Tenant set UtcOffset=@utcOffset, UtcPlace=@utcPlace where ID=@partyID;

		with cteContact as
		(
			select	PartyID=@partyID, Type=cast(x.v1 as tinyint), Name, Phone, Email, Company, 
					Street1, Street2, Street3, City, District, Province, PostalCode, CountryCode
			from	tvp.Duad#Slice(@contact, default, default) x
			cross	apply loc.Contact#Of(x.v2)
		)
		merge	into core._Contact as o using cteContact as n
		on		(o.PartyID=n.PartyID and o.Type=n.Type)
		when	matched	    then update set o.PartyID=n.PartyID, o.Type=n.Type,         o.Name=n.Name, 
											o.Phone=n.Phone,     o.Email=n.Email,       o.Company=n.Company, 
											o.Street1=n.Street1, o.Street2=n.Street2,   o.Street3=n.Street3, 
											o.City=n.City,       o.District=n.District, o.Province=n.Province,  
											o.PostalCode=n.PostalCode, o.CountryCode=n.CountryCode
		when	not matched then insert(  PartyID,   Type,   Name,   Phone,  Email,   Company,   
										  Street1,   Street2,   Street3,   City,  District,    Province,   PostalCode,   CountryCode)
								 values(n.PartyID, n.Type, n.Name, n.Phone, n.Email, n.Company, 
										n.Street1, n.Street2, n.Street3, n.City, n.District, n.Province, n.PostalCode, n.CountryCode)
		;

		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [core].[RefNbr#Merge]...';


GO
/*
@slip = Many[Triad<MatterID, Type, Number>]
*/
--PeterHo
ALTER PROCEDURE [core].[RefNbr#Merge](@slip nvarchar(max))
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteSlip as
	(
		select	MatterID=cast(v1 as bigint), Type=cast(v2 as tinyint), n.Number
		from	tvp.Triad#Slice(@slip, default, default) x
		cross	apply loc.RefNbr#Cast(x.v3) n
	)
	merge	core._RefNbr as o using cteSlip as n
	on		(o.MatterID=n.MatterID and o.Type=n.Type)
	when	matched and len(n.Number)=0     then delete
	when	matched and o.Number<>n.Number  then update set Number=n.Number
	when	not matched and len(n.Number)>0 then insert (  MatterID,   Type,   Number)
			                                     values (n.MatterID, n.Type, n.Number)
	;
END
GO
PRINT N'Altering [zeb].[RefNbr$Merge]...';


GO
--Eva
ALTER PROCEDURE [zeb].[RefNbr$Merge](@slip nvarchar(max))
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	
	execute	core.RefNbr#Merge @slip=@slip;
END
GO
PRINT N'Altering [core].[Message#Invoke]...';


GO
--PeterHo
ALTER PROCEDURE [core].[Message#Invoke](@regID I32, @rowAuxes I64Enums readonly, @body msg, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	declare	@posterID I32=(select UserID from loc.Tenancy#Of(@tenancy));
	insert	core._Message
	(		 RegID, RowID, AuxID,  PosterID,  Body)
	select	@regID,    ID,   Val, @posterID, @body from @rowAuxes
END
GO
PRINT N'Altering [core].[Challenge#Push]...';


GO
/*
@slip    = Many[Triad<MatterID, ChallengeType, BoundStage>]
@context = MessageBody
*/
--PeterHo
ALTER PROCEDURE [core].[Challenge#Push](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@rowAuxes I64Enums;
		with cteSlip as
		(
			select	MatterID  =cast(v1 as bigint)
			,		Type      =cast(v2 as tinyint)
			,		BoundStage=cast(v3 as int)
			from	tvp.Triad#Slice(@slip, default, default)
		)
		merge	core._Challenge as o using cteSlip as n on (o.MatterID=n.MatterID and o.Type=n.Type)
		when	matched     and n.BoundStage=0 then delete --- Preventing GHOST.
		when	matched     and n.BoundStage>0 then update set BoundStage=n.BoundStage
		when	not matched and n.BoundStage>0 then insert (  MatterID,   Type,   BoundStage)
				                                    values (n.MatterID, n.Type, n.BoundStage)
		output	inserted.MatterID, inserted.Type into @rowAuxes;

		declare	@regID I32=(select Matter from core.Registry#ID());
		execute	core.Message#Invoke @regID=@regID, @rowAuxes=@rowAuxes, @body=@context, @tenancy=@tenancy;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [tms].[Pic#Emit]...';


GO
--PeterHo: HACKED.
ALTER PROCEDURE [tms].[Pic#Emit](@source tinyint, @picSpec tms.PicSpec readonly)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT ON;

	declare	@parts as table
	(
		SeqNbr   bigint  NOT NULL PRIMARY KEY CLUSTERED,
		SvcClass tinyint NOT NULL,
		SvcCode  char(3) NOT NULL,
		MailerID char(9) NOT NULL,
		TokenID  char(9) NOT NULL,
		POA      char(3) NOT NULL,
		OnZip3   char(3) NOT NULL
	);
	insert	@parts
	select	x.SeqNbr
	,		[SvcClass]=iif(f.MailerID is null, 0,           r.SvcClass)
	,		[SvcCode] =iif(f.MailerID is null, '000',       f.ClassCode)
	,		[MailerID]=iif(f.MailerID is null, '000000000', f.MailerID)
	,		[TokenID] =iif(f.MailerID is null, '',          f.TokenID)
	,		[POA] =    iif(f.MailerID is null, '',          f.POA)
	,		[OnZip3] = iif(f.MailerID is null, '000',       f.ImportZip3)
	from	@picSpec  x
	cross	apply tms.SvcClass#For(x.SvcType, x.MeasuredWt)        r
	outer	apply tms.SvcFacility#For(@source, r.SvcClass, x.Zip3) f

	--UAA:
	declare	@idPairs dbo.I32Pairs;
	insert	@idPairs (LID, RID)  select SeqNbr, 0 from @parts where TokenID='';

	----USPS:
	
	--FedEx(9016)-USD(08):
	insert	@idPairs (LID, RID)  select SeqNbr, next value for tms.JFK901608
	from	@parts cross apply tms.SvcToken#ID() s where TokenID=s.JFK901608;
	;
	insert	@idPairs (LID, RID)  select SeqNbr, next value for tms.LAX901608
	from	@parts cross apply tms.SvcToken#ID() s where TokenID=s.LAX901608;
	
	--FedEx(9016)-XPD(07):
	insert	@idPairs (LID, RID)  select SeqNbr, next value for tms.JFK901607
	from	@parts cross apply tms.SvcToken#ID() s where TokenID=s.JFK901607;
	;
	insert	@idPairs (LID, RID)  select SeqNbr, next value for tms.LAX901607
	from	@parts cross apply tms.SvcToken#ID() s where TokenID=s.LAX901607;

	--PICs:
	select	SeqNbr, SvcClass, SvcCode, MailerID, MailerSeq=x.RID, p.POA, p.OnZip3
	from	@idPairs x join @parts p on p.SeqNbr=x.LID;
END
GO
PRINT N'Altering [core].[RefInfo#AddBlock]...';


GO
--PeterHo
ALTER PROCEDURE [core].[RefInfo#AddBlock](@index int, @idSeqs I64Seqs readonly, @slip nvarchar(max), @type tinyint)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._RefInfo
	(		MatterID, Type, Info)
	select	Master,  @type, House
	from	tvp.Block#FoldT(@index, @idSeqs, @slip, default, default)
	where	House>N''
/*
	insert	core._RefInfo
	(		MatterID, Type,  Info)
	select	x.Master, @type, h.Piece
	from	tvp.Block#FoldT(@index, @idSeqs, @slip, default, default) x
	cross	apply tvp.Many#Slice(x.House) h
	where	h.Piece>N''
*/
END
GO
PRINT N'Altering [core].[RefNbr#AddBlock]...';


GO
--PeterHo
ALTER PROCEDURE [core].[RefNbr#AddBlock](@index int, @idSeqs I64Seqs readonly, @slip nvarchar(max), @type tinyint)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._RefNbr
	(		MatterID, Type, Number)
	select	Master,  @type, House
	from	tvp.Block#FoldT(@index, @idSeqs, @slip, default, default)
	where	House>N''
/*
	insert	core._RefNbr
	(		MatterID,  Type, Number)
	select	x.Master, @type, h.Piece
	from	tvp.Block#FoldT(@index, @idSeqs, @slip, default, default) x
	cross	apply tvp.Many#Slice(x.House) h
	where	h.Piece>N''
*/
END
GO
PRINT N'Altering [core].[Concern#Add]...';


GO
/*
@concerns = Comma[ConcernType]
*/
--PeterHo
ALTER PROCEDURE [core].[Concern#Add](@matterID bigint, @concerns tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteConcern as
	(
		select	MatterID=@matterID, Type=cast(c.Piece as tinyint)
		from	tvp.Comma#Slice(@concerns) c
	)
	insert	core._Concern
	select	x.MatterID, x.Type
	from	cteConcern  x left join core._Concern c
	on		c.MatterID= x.MatterID and c.Type=x.Type
	where	c.MatterID is null
END
GO
PRINT N'Altering [core].[Concern#AddVia]...';


GO
/*
@slip = Many[Duad<MatterID, Comma[ConcernType]>]
*/
--PeterHo
ALTER PROCEDURE [core].[Concern#AddVia](@slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteConcern as
	(
		select	MatterID=cast(x.v1 as bigint), Type=cast(c.Piece as tinyint)
		from	tvp.Duad#Slice(@slip, default, default) x
		cross	apply tvp.Comma#Slice(x.v2) c
	)
	insert	core._Concern
	select	x.MatterID, x.Type
	from	cteConcern  x left join core._Concern c
	on		c.MatterID= x.MatterID and c.Type=x.Type	
	where	c.MatterID is null
END
GO
PRINT N'Altering [core].[RefParty#MergeVia]...';


GO
--AaronLiu
ALTER PROCEDURE [core].[RefParty#MergeVia](@idsInCsv tvp, @partyRole E8, @partyID E32)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with	cteSlip as
	(
		select	MatterID=cast(Piece as bigint )
		from	tvp.Comma#Slice(@idsInCsv)
	)
	merge	core._RefParty as o using cteSlip as n
	on		(o.MatterID=n.MatterID and o.PartyRole=@partyRole)
	when	matched		and @partyID=0          then delete
	when	matched		and o.PartyID<>@partyID then update set PartyID=@partyID
	when	not matched and @partyID>0			then insert	(  MatterID,  PartyRole,  PartyID)
													 values (n.MatterID, @partyRole, @partyID)
	;
END
GO
PRINT N'Altering [core].[RefStamp#Merge]...';


GO
--PeterHo
ALTER PROCEDURE [core].[RefStamp#Merge](@slip nvarchar(max))
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteSlip as
	(
		select	MatterID  =cast(x.v1 as bigint)
		,		StateID   =cast(x.v2 as int   )
		,		UtcTime   =cast(isnull(nullif(t.v1, ''), '0001') as datetime2(2))
		,		UtcOffset =cast(t.v2 as smallint)
		,		UtcPlaceID=cast(t.v3 as int)
		from	tvp.Triad#Slice(@slip, default, default) x
		cross	apply tvp.Trio#Of(x.v3) t
	)
	merge	core._RefStamp as o using cteSlip as n
	on		(o.MatterID=n.MatterID and o.StateID=n.StateID)
	when	matched and n.UtcTime=cast('0001' as datetime2(2)) then
				delete
	when	matched and o.UtcTime<>n.UtcTime then
				update  set o.UtcTime=n.UtcTime, o.UtcOffset=n.UtcOffset, o.UtcPlaceID=n.UtcPlaceID
	when	not matched and n.UtcTime<>cast('0001' as datetime2(2)) then
				insert (  MatterID,   StateID,   UtcTime,   UtcOffset,   UtcPlaceID)
				values (n.MatterID, n.StateID, n.UtcTime, n.UtcOffset, n.UtcPlaceID);
END
GO
PRINT N'Altering [core].[RefInfo#Merge]...';


GO
--PeterHo
ALTER PROCEDURE [core].[RefInfo#Merge](@slip nvarchar(max))
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteSlip as
	(
		select	MatterID=cast(v1 as bigint), Type=cast(v2 as tinyint), Info=v3
		from	tvp.Triad#Slice(@slip, default, default)
	)
	merge	core._RefInfo as o using cteSlip as n
	on		(o.MatterID=n.MatterID and o.Type=n.Type)
	when	matched and len(n.Info)=0     then delete
	when	matched and o.Info<>n.Info    then update set Info=n.Info
	when	not matched and len(n.Info)>0 then insert (  MatterID,   Type,   Info)
			                                   values (n.MatterID, n.Type, n.Info)
	;
END
GO
PRINT N'Altering [core].[RefParty#Merge]...';


GO
--PeterHo
ALTER PROCEDURE [core].[RefParty#Merge](@slip nvarchar(max))
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteSlip as
	(
		select	MatterID =cast(v1 as bigint )
		,		PartyRole=cast(v2 as tinyint)
		,		PartyID  =cast(v3 as int    )
		from	tvp.Triad#Slice(@slip, default, default)
	)
	merge	core._RefParty as o using cteSlip as n
	on		(o.MatterID=n.MatterID and o.PartyRole=n.PartyRole)
	when	matched and n.PartyID=0          then delete
	when	matched and o.PartyID<>n.PartyID then update set PartyID=n.PartyID
	when	not matched and n.PartyID>0      then insert (  MatterID,   PartyRole,   PartyID)
			                                      values (n.MatterID, n.PartyRole, n.PartyID)
	;
END
GO
PRINT N'Altering [core].[Supplement#MergeVia]...';


GO
--Smile
ALTER PROCEDURE [core].[Supplement#MergeVia](@supplements tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteNew as
	(
		select	RegID=cast(v1 as int), RowID=cast(v2 as bigint), Supplement=v3
		from	tvp.Triad#Slice(@supplements, default, default)
	)
	merge	core._Supplement as o using cteNew as n
	on		(n.RegID=o.RegID and n.RowID=o.RowID)
	when	matched and len(n.Supplement)=0        then delete
	when	matched and o.Supplement<>n.Supplement then update set Supplement=n.Supplement
	when	not matched and len(n.Supplement)>0    then insert (RegID,     RowID,   Supplement)
			                                            values (n.RegID, n.RowID, n.Supplement)
	;
END
GO
PRINT N'Altering [core].[RefStamp#MergeBySpec]...';


GO
--PeterHo
ALTER PROCEDURE [core].[RefStamp#MergeBySpec](@spec core.TransitionSpec readonly, @utcStamp tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	declare	@slip tvp;
	with cte(text) as
	(
		select	[text()]=concat(k.Many, MatterID, k.Triad, ToStateID, k.Triad, @utcStamp)
		from	@spec cross apply tvp.Spr#Const() k for xml path(N'')
	)
	select	@slip=Tvp from cte cross apply tvp.Spr#Purify(text, default);
	execute core.RefStamp#Merge @slip=@slip;
END
GO
PRINT N'Altering [ic].[Parcel$MergeStamp]...';


GO
/*
@slip=Many[Triad<ParcelID, StateID, Trio<UtcTime, UtcOffset, UtcPlaceID>>]
*/
--Smile
ALTER PROCEDURE [ic].[Parcel$MergeStamp](@slip tvp)
WITH ENCRYPTION
AS
BEGIN	
	SET	NOCOUNT ON;

	execute core.RefStamp#Merge @slip=@slip;	

END
GO
PRINT N'Altering [svc].[Parcel$MergeRefInfo]...';


GO
/*
@slip   =Many[Triad<MatterID, RefInfoType, RefInfo>]
*/
ALTER PROCEDURE [svc].[Parcel$MergeRefInfo](@slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT ON;	

	execute	core.RefInfo#Merge @slip=@slip;	
END
GO
PRINT N'Altering [zeb].[RefInfo$Merge]...';


GO
--AaronLiu
ALTER PROCEDURE [zeb].[RefInfo$Merge](@slip nvarchar(max))
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	
	execute	core.RefInfo#Merge @slip=@slip;
END
GO
PRINT N'Altering [core].[Party#Add]...';


GO
/*
@slip = at.Tvp.Field.Join(PID, AID, Alias, Contact)
*/
--PeterHo
ALTER PROCEDURE [core].[Party#Add](@id I32 out, @source E8, @type E8, @slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		select	@id=next value for core.PartySeq;

		declare	@pid I32, @aid I32, @alias loc.Alias, @contact tvp;
		select	@pid=v1,  @aid=v2,  @alias=v3,        @contact=v4
		from	tvp.Field#Of(@slip, default);

		declare	@tobePID I32=iif(@pid is null or @pid<0, 0,   @pid);
		declare	@tobeAID I32=iif(@aid is null or @aid<1, @id, @aid);
		insert	core._Party
				( ID,  PID,      AID,      Type,  Source,  Alias)
		values	(@id, @tobePID, @tobeAID, @type, @source, @alias);

		--declare	@contactID I32, @kind E8=(select Billing from Contact#Type());
		--execute	core.Contact#Add @id=@contactID out, @partyID=@id, @type=@kind, @contact=@contact;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [core].[OutboundQ#Dequeue]...';


GO
/*
@source = Source of Application.
@qtype  = 0 means all items, otherwise specified that belong to @source.
@result = Many[Quad<MatterID, StateID, QueueType, QueuedOn>]
*/
--PeterHo
ALTER PROCEDURE [core].[OutboundQ#Dequeue](@source E8, @qtype E8=0, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		declare	@q as table
		(
			QueueType dbo.E8  not null,
			QueuedOn  dbo.DT  not null,
			MatterID  dbo.I64 not null,
			StateID   dbo.I32 not null
		)
		delete	top(1000) core._OutboundQ
		output	deleted.QueueType, deleted.QueuedOn, deleted.MatterID, deleted.StateID into @q
		where	ToSource=@source and (nullif(0, @qtype) is null or QueueType=@qtype);

		insert	core._OutboundX
		(		ToSource, QueueType, QueuedOn, MatterID, StateID)
		select	 @source, QueueType, QueuedOn, MatterID, StateID from @q;

		with cte(text) as
		(
			select	[text()]=concat(k.Many, MatterID, k.Quad, StateID, k.Quad, QueueType, k.Quad, QueuedOn)
			from	tvp.Spr#Const()k, @q for xml path(N'')
		)
		select	@result=Tvp from cte cross apply tvp.Spr#Purify(text, default);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [zeb].[OutboundQ$Dequeue]...';


GO
--Eva
ALTER PROCEDURE [zeb].[OutboundQ$Dequeue](@source E8, @qtype E8=0, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	execute	core.OutboundQ#Dequeue @source=@source, @qtype=@qtype, @result=@result out
END
GO
PRINT N'Altering [core].[Activity#AddByIdSeqs]...';


GO
--PeterHo
ALTER PROCEDURE [core].[Activity#AddByIdSeqs](@idSeqs I64Seqs readonly, @stateID I32, @userID I32)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._Activity
	(		MatterID,  StateID, ActionID,  UserID, TalliedOn)
	select	x.ID,     @stateID, 0,        @userID, getutcdate()
	from	@idSeqs x;
END
GO
PRINT N'Altering [core].[Activity#AddBySpec]...';


GO
--PeterHo
ALTER PROCEDURE [core].[Activity#AddBySpec](@spec core.TransitionSpec readonly, @userID I32)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._Activity
	(		MatterID,   StateID, ActionID,  UserID,  TalliedOn)
	select	MatterID, ToStateID, ActionID, @userID, getutcdate() from @spec;
END
GO
PRINT N'Altering [core].[RefInfo#AddViaCells]...';


GO
--PeterHo
ALTER PROCEDURE [core].[RefInfo#AddViaCells](@column int, @cells dbo.Cells readonly, @type tinyint)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._RefInfo
	(		MatterID, Type, Info)
	select	Row,     @type, Val
	from	@cells
	where	Col=@column and Val>N''
/*
	insert	core._RefInfo
	(		MatterID, Type,  Info)
	select	x.Master, @type, h.Piece
	from	tvp.Block#FoldT(@index, @idSeqs, @slip, default, default) x
	cross	apply tvp.Many#Slice(x.House) h
	where	h.Piece>N''
*/
END
GO
PRINT N'Altering [core].[RefNbr#AddViaCells]...';


GO
--PeterHo
ALTER PROCEDURE [core].[RefNbr#AddViaCells](@column int, @cells dbo.Cells readonly, @type tinyint)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	insert	core._RefNbr
	(		MatterID,  Type, Number)
	select	Row,      @type, Val
	from	@cells
	where	Col=@column and Val>N''
END
GO
PRINT N'Altering [core].[Supplement#Merge]...';


GO
--PeterHo
ALTER PROCEDURE [core].[Supplement#Merge](@regID I32, @rowID I64, @supplement nvarchar(max))
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	with cteNew as
	(
		select	RegID=@regID, RowID=@rowID, Supplement=isnull(@supplement, N'')
	)
	merge	core._Supplement as o using cteNew as n
	on		(n.RegID=o.RegID and n.RowID=o.RowID)
	when	matched and len(n.Supplement)=0        then delete
	when	matched and o.Supplement<>n.Supplement then update set Supplement=n.Supplement
	when	not matched and len(n.Supplement)>0    then insert (RegID,     RowID,   Supplement)
			                                            values (n.RegID, n.RowID, n.Supplement)
	;
END
GO
PRINT N'Altering [dbo].[Assert#Concurrency]...';


GO
ALTER PROCEDURE [dbo].[Assert#Concurrency]
WITH ENCRYPTION
AS
BEGIN ----SET NOCOUNT ON;
	if (@@ROWCOUNT<>0) return;
	throw 50000, N'{{ The data had been altered since last read. }}', 0;
END
GO
PRINT N'Altering [dbo].[Assert#Fail]...';


GO
ALTER PROCEDURE [dbo].[Assert#Fail](@msg NVARCHAR (2048)=null, @state TINYINT=0)
WITH ENCRYPTION
AS
BEGIN ----SET NOCOUNT ON;
	declare	@message nvarchar(2048) = concat(N'{{', iif(@msg is null, N'Failed', @msg), N'}}');
	declare	@exstate tinyint = iif(@state is null, 0, @state);
	throw 50000, @message, @exstate;
END
GO
PRINT N'Altering [dbo].[Assert#RowCntEQ]...';


GO
ALTER PROCEDURE [dbo].[Assert#RowCntEQ](@rowCnt INT, @msg NVARCHAR (2048)=null, @state TINYINT=0)
WITH ENCRYPTION
AS
BEGIN ----SET NOCOUNT ON;
	if (@@ROWCOUNT = @rowCnt) return;
	declare	@message nvarchar(2048) = concat(N'{{', iif(@msg is null, N'The data had been altered since last read.', @msg), N'}}');
	declare	@exstate tinyint = iif(@state is null, 0, @state);
	throw 50000, @message, @exstate;
END
GO
PRINT N'Altering [dbo].[Assert#RowCntNE]...';


GO
ALTER PROCEDURE [dbo].[Assert#RowCntNE](@rowCnt INT, @msg NVARCHAR (2048)=null, @state TINYINT=0)
WITH ENCRYPTION
AS
BEGIN ----SET NOCOUNT ON;
	if (@@ROWCOUNT <> @rowCnt) return;
	declare	@message nvarchar(2048) = concat(N'{{', iif(@msg is null, N'The data had been altered since last read.', @msg), N'}}');
	declare	@exstate tinyint = iif(@state is null, 0, @state);
	throw 50000, @message, @exstate;
END
GO
PRINT N'Altering [dbo].[Assert#Transited]...';


GO
ALTER PROCEDURE [dbo].[Assert#Transited](@rowCnt INT, @state TINYINT=0)
WITH ENCRYPTION
AS
BEGIN ----SET NOCOUNT ON;
	if (@@ROWCOUNT=@rowCnt) return;
	throw 50000, N'{{ State Transition Violation }}', @state;
END
GO
PRINT N'Altering [shpt].[Batch#Create]...';


GO
--PeterHo
ALTER PROCEDURE [shpt].[Batch#Create](@id I64 out, @siteID I32, @errorCnt int, @errors json)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		insert	shpt._Batch (SiteID, ErrorCnt) values (@siteID, @errorCnt);
		select	@id=scope_identity();

		if (@errorCnt>0)
		begin
			declare	@regID I32=(select ParcelBatch from core.Registry#ID());
			insert	core._Supplement (RegID, RowID, Supplement) values (@regID, @id, @errors);
		end

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [whse].[RackOrder#Create]...';


GO
--Smile, PeterHo
ALTER PROCEDURE [whse].[RackOrder#Create](@id I32 out, @rackerID I32, @orderType E8)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	insert	whse._RackOrder
			( RackerID,  OrderType)--, CreatedOn,    CompletedOn)
	values	(@rackerID, @orderType)--, getutcdate(), dbo.DT@Empty())
	select  @id=scope_identity();
END
GO
PRINT N'Altering [bo].[AssortedFees$Bill]...';


GO
/*
@slip   =Quad<TenantID, Source, ClientRef, Remark>
@context=Duad[ChargeID, XactAmt]
*/
--Smile
ALTER PROCEDURE [bo].[AssortedFees$Bill](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;

		declare	@tenantID I32,    @source E8,  @supplement nvarchar(max)
		,		@contractID I32,  @billingCycle tinyint, @clientRef loc.RefNbr;
		select	@tenantID=v1,     @source=v2,  @supplement=v4, @clientRef=v3
		,		@contractID=c.ID, @billingCycle=BillingCycle
		from	tvp.Quad#Of(@slip, default)
		cross	apply acct.Contract#For(v1, v2) c;

		declare	@type     E8=(select AssortedFees from core.Matter#Type());
		declare	@matterID I64=next value for core.MatterSeq;
		declare	@userID   I32=(select UserID from loc.Tenancy#Of(@tenancy));
		insert	core._Matter
				(ID,        PosterID, StateID, Stage, Source,  Type, PostedOn)
		values	(@matterID, @tenantID,  0,       0,    @source, @type, getutcdate());

		insert	core._RefNbr(MatterID, Type, Number) select @matterID, ClientRef, @clientRef 
		from	core.RefNbr#Type()

		declare	@regID I32=(select AssortedFees from core.Registry#ID());
		execute	core.Supplement#Merge @regID=@regID, @rowID=@matterID, @supplement=@supplement; 

		declare	@ledgerSide E8=(select AR from acct.Ledger#Side());
		declare	@vaultType  E8=(select Fund from acct.Vault#Type());
		declare	@ledgerIDs I64Array,  @invoiceds I64Array;
		with cteInvoice as
		(
			select	m.CurrencyID, c.VaultTag, XactDecAmt=sum(m.DecAmt)
			from	tvp.Duad#Slice(@context, default, default) x
			join	acct.Charge#Raw()      c on c.ID=cast(x.v1 as int)
			cross	apply dbo.Money#Of(cast(x.v2 as bigint)) m
			where	@billingCycle=0
			group	by m.CurrencyID, c.VaultTag
		)
		insert	acct._Invoice
		(		PartyID,   VaultTag,  LedgerSide, CurrencyID, DueBalance, InvoiceAmt, ContractID)
		output	inserted.ID into @invoiceds
		select	@tenantID, VaultTag, @ledgerSide, CurrencyID, CurrencyID, m.Amt,   @contractID
		from	cteInvoice x
		cross	apply dbo.Money#Make(x.XactDecAmt, x.CurrencyID) m;
	    
		with	cteInvoiced as
		(
			select	x.ID, PartyID, CurrencyID, VaultTag, ContractID
			from	@invoiceds x
			join	acct.Invoice#Raw() i on x.ID=i.ID
		)
		insert	acct._Ledger
		(		PartyID,   MatterID, ChargeID, ChargeAmt,  CurrencyID, LedgerSide,  InvoiceID)
		output	inserted.ID into @ledgerIDs
		select	@tenantID, @matterID, x.v1,    x.v2,     p.CurrencyID, @ledgerSide, isnull(i.ID, 0)
		from	tvp.Duad#Slice(@context, default, default) x
		cross	apply dbo.Money#Of(x.v2)                 p
		join	acct.Charge#Raw()  c on c.ID=cast(x.v1 as int)
		left	join cteInvoiced   i on i.VaultTag=c.VaultTag
									and i.CurrencyID=p.CurrencyID;
										
		with cteUnInvoiceds as
		(
			select	PartyID, x.CurrencyID, ChargeRawAmt=sum(x.ChargeRaw)
			from	@ledgerIDs l
			join	acct.Ledger#Raw() x on x.ID=l.ID
			where	InvoiceID=0
			group	by PartyID, x.CurrencyID
		), cteVaults as
		(
			select	PartyID, CurrencyID, ChargeAmt=m.Amt
			from	cteUnInvoiceds x
			cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
		)
		merge	acct._Vault as o using cteVaults as n
		on		(o.PartyID=n.PartyID and o.VaultType=@vaultType and o.CurrencyID=n.CurrencyID)
		when	matched then
				update set UninvoicedAmt=(select Amt from dbo.Money#Sum(n.ChargeAmt, o.UninvoicedAmt)), TalliedOn=getutcdate()
		when	not matched then
				insert(  PartyID,   VaultBal,    VaultType,   CurrencyID,   UninvoicedAmt)
				values(n.PartyID, n.CurrencyID, @vaultType, n.CurrencyID, n.ChargeAmt)
		;
		execute acct.Vault#XactByInvoice @invoiceds=@invoiceds, @paymentID=default, @vaultType=@vaultType;

		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [shpt].[Parcel#BillForFactor]...';


GO
--Daxia
ALTER PROCEDURE [shpt].[Parcel#BillForFactor](@parcelIDs dbo.I64Array readonly, @hubID int)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
					
		-- 1	Insert  Invoice(s):
		declare	@ledgerSide E8=(select AR from acct.Ledger#Side());
		declare	@invoiceds I64Array; 
		declare	@vaultType  E8=(select Fund from acct.Vault#Type());
		with cteInvoice as
		(
			select	LedgerPartyID, x.CurrencyID, c.VaultTag, x.ContractID, ChargeRawAmt=sum(x.InvDueAmt)
			from	shpt.Parcel#LedgerByFactor(@parcelIDs, @hubID) x
			join	acct.Charge#Raw() c on c.ID=x.ChargeID
			where	not exists
			(
				select	ID from acct.Contract#Raw() t 
				where	t.ID=x.ContractID and t.BillingCycle>0
			) 
			group	by LedgerPartyID, x.CurrencyID, c.VaultTag, x.ContractID
		)	
		insert	acct._Invoice
		(		PartyID,       VaultTag,  LedgerSide,   CurrencyID, DueBalance, InvoiceAmt, ContractID)
		output	inserted.ID into @invoiceds
		select	LedgerPartyID, VaultTag, @ledgerSide, x.CurrencyID, 0,               m.Amt, ContractID
		from	cteInvoice x
		cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
		where	x.ChargeRawAmt>0;
		
		declare	@ledgerIDs I64Array;
		with	cteInvoiced as
		(
			select	x.ID, PartyID, CurrencyID, VaultTag, ContractID
			from	@invoiceds x
			join	acct.Invoice#Raw() i on x.ID=i.ID
		)
		-- 2	Insert  Ledger(s):
		insert	acct._Ledger
		(		PartyID,       MatterID,   ChargeID, ChargeAmt,   CurrencyID,   LedgerSide, InvoiceID)
		output	inserted.ID into @ledgerIDs
		select	LedgerPartyID, MatterID, p.ChargeID, ChargeAmt, p.CurrencyID,  @ledgerSide, iif(ChargeAmt=p.CurrencyID, -1, isnull(i.ID, 0))
		from	shpt.Parcel#LedgerByFactor(@parcelIDs, @hubID) p
		join	acct.Charge#Raw()  c  on c.ID=p.ChargeID
		left	join cteInvoiced   i  on i.PartyID=p.LedgerPartyID 
										 and i.VaultTag=c.VaultTag
										 and i.CurrencyID=p.CurrencyID
										 and i.ContractID=p.ContractID;
		with cteUnInvoiceds as
		(
			select	PartyID, x.CurrencyID, ChargeRawAmt=sum(x.ChargeRaw)
			from	@ledgerIDs l
			join	acct.Ledger#Raw() x on x.ID=l.ID
			where	InvoiceID=0
			group	by PartyID, x.CurrencyID
		), cteVaults as
		(
			select	PartyID, CurrencyID, ChargeAmt=m.Amt
			from	cteUnInvoiceds x
			cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
		)
		merge	acct._Vault as o using cteVaults as n
		on		(o.PartyID=n.PartyID and o.VaultType=@vaultType and o.CurrencyID=n.CurrencyID)
		when	matched then
				update set UninvoicedAmt=(select Amt from dbo.Money#Sum(n.ChargeAmt, o.UninvoicedAmt)), TalliedOn=getutcdate()
		when	not matched then
				insert(  PartyID,   VaultBal,    VaultType,   CurrencyID, UninvoicedAmt)
				values(n.PartyID, n.CurrencyID, @vaultType, n.CurrencyID,   n.ChargeAmt)
		;
		execute acct.Vault#XactByInvoice @invoiceds=@invoiceds, @paymentID=default, @vaultType=@vaultType;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [shpt].[SackMft#BillForCharge]...';


GO
--Daxia
ALTER PROCEDURE [shpt].[SackMft#BillForCharge](@sackMftID bigint)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
					
		-- 1	Insert  Invoice(s):
		declare	@ledgerSide E8=(select AR from acct.Ledger#Side());
		declare	@invoiceds I64Array; 
		declare	@vaultType  E8=(select Fund from acct.Vault#Type());
		with cteInvoice as
		(
			select	LedgerPartyID, x.CurrencyID, c.VaultTag, x.ContractID, ChargeRawAmt=sum(x.ChargeAmt)
			from	shpt.SackMft#LedgerByCharge(@sackMftID) x
			join	acct.Charge#Raw() c on c.ID=x.ChargeID
			where	not exists
			(
				select	ID from acct.Contract#Raw() t 
				where	t.ID=x.ContractID and t.BillingCycle>0
			) 
			group	by LedgerPartyID, x.CurrencyID, c.VaultTag, x.ContractID
		)	
		insert	acct._Invoice
		(		PartyID,       VaultTag,  LedgerSide,   CurrencyID, DueBalance, InvoiceAmt, ContractID)
		output	inserted.ID into @invoiceds
		select	LedgerPartyID, VaultTag, @ledgerSide, x.CurrencyID, 0,               m.Amt, ContractID
		from	cteInvoice x
		cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
		where	x.ChargeRawAmt>0;
		
		declare	@ledgerIDs I64Array;
		with	cteInvoiced as
		(
			select	x.ID, PartyID, CurrencyID, VaultTag, ContractID
			from	@invoiceds x
			join	acct.Invoice#Raw() i on x.ID=i.ID
		)
		-- 2	Insert  Ledger(s):
		insert	acct._Ledger
		(		PartyID,       MatterID,   ChargeID, ChargeAmt,   CurrencyID,   LedgerSide, InvoiceID)
		output	inserted.ID into @ledgerIDs
		select	LedgerPartyID, MatterID, p.ChargeID, ChargeAmt, p.CurrencyID,  @ledgerSide, iif(ChargeAmt=p.CurrencyID, -1, isnull(i.ID, 0))
		from	shpt.SackMft#LedgerByCharge(@sackMftID) p
		join	acct.Charge#Raw()  c  on c.ID=p.ChargeID
		left	join cteInvoiced   i  on i.PartyID=p.LedgerPartyID 
										 and i.VaultTag=c.VaultTag
										 and i.CurrencyID=p.CurrencyID
										 and i.ContractID=p.ContractID;
		with cteUnInvoiceds as
		(
			select	PartyID, x.CurrencyID, ChargeRawAmt=sum(x.ChargeRaw)
			from	@ledgerIDs l
			join	acct.Ledger#Raw() x on x.ID=l.ID
			where	InvoiceID=0
			group	by PartyID, x.CurrencyID
		), cteVaults as
		(
			select	PartyID, CurrencyID, ChargeAmt=m.Amt
			from	cteUnInvoiceds x
			cross	apply dbo.Currency#Encode(x.ChargeRawAmt, x.CurrencyID) m
		)
		merge	acct._Vault as o using cteVaults as n
		on		(o.PartyID=n.PartyID and o.VaultType=@vaultType and o.CurrencyID=n.CurrencyID)
		when	matched then
				update set UninvoicedAmt=(select Amt from dbo.Money#Sum(n.ChargeAmt, o.UninvoicedAmt)), TalliedOn=getutcdate()
		when	not matched then
				insert(  PartyID,   VaultBal,    VaultType,   CurrencyID, UninvoicedAmt)
				values(n.PartyID, n.CurrencyID, @vaultType, n.CurrencyID,   n.ChargeAmt)
		;
		execute acct.Vault#XactByInvoice @invoiceds=@invoiceds, @paymentID=default, @vaultType=@vaultType;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [app].[Parcel$InitForUsd]...';


GO
/*
@slip    = at.Tvp.Block.Join(RefNbr, ShprInfo, CneeInfo
,          DeclaredInfo[Quad.Join(GoodsInfo, LineQty, LineTotal, CmdyID).Over(at.Tvp.Mucho)]
,          Weight, Height, Width, Length ).Over(at.Tvp.Entry)
@context = at.Quad.Join(Source, SvcType, errorCnt, errors)
*/
--Daxia
ALTER PROCEDURE [app].[Parcel$InitForUsd](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32;
		select	@siteID=SiteID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy);

		declare	@source E8, @errorCnt int, @errors json, @svcType I32,  @routeID I32,       @courierID I32,         @stateID I32,           @contractID I32;
		select	@source=v1, @errorCnt=v3,  @errors=v4,   @svcType=t.ID, @routeID=r.RouteID, @courierID=r.CourierID, @stateID=t.InitStateID, @contractID=c.ID
		from	tvp.Quad#Of(@context, default)                          x
		cross	apply tms.SvcType#For(cast(x.v2 as int), @siteID)       t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)             r
		cross	apply acct.Contract#For(@siteID, cast(x.v1 as tinyint)) c;
		
		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@stage E32=(select Stage  from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID,  @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 2.1	Add RefNbrs & RefInfos:
		declare	@clientRef E8,          @postCourier E8,            @shprInfo E8,         @cneeInfo E8,         @declaredInfo E8,             @brkgInfo E8;
		select	@clientRef=n.ClientRef, @postCourier=n.PostCourier, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo, @declaredInfo=i.DeclaredInfo, @brkgInfo=i.BrokerageInfo
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;

		execute	core.RefNbr#AddBlock  @index=1, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefInfo#AddBlock @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@declaredInfo;
		execute	core.RefInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@brkgInfo;
		
		-- 2.2	Prepare PicSpecs:
		declare	@picSpec tms.PicSpec; insert @picSpec
		(		MeasuredWt, SvcType, Zip3,           Plus2,                  RefNbr)
		select	f.v5,      @svcType, left(i.v11, 3), substring(i.v11, 4, 2), f.v1
		from	tvp.Field#Slice(@slip, N'	%	', default) f
		cross	apply tvp.Dozen#Of(f.v3, default)           i;

		-- 2.3	Emit PICs:
		declare	@picResult tms.PicResult; insert @picResult
		exec	tms.Pic#Emit @source=@source, @picSpec=@picSpec;
		
		declare	@postCourierSpec as table
		(
			MatterID    dbo.I64     NOT NULL,
			SvcClass    tinyint     NOT NULL,
			Type        dbo.E8      NOT NULL,--RefNbr Type
			PostCourier varchar(40) NOT NULL
		);
		declare	@svcClassLW     dbo.E8=13, @svcClassPS     dbo.E8=14
		,		@postCourierPre dbo.E8=18, @postCourierOrg dbo.E8=19
		;
		insert	@postCourierSpec
		(		MatterID,   SvcClass, PostCourier,   Type)
		select	    x.ID, r.SvcClass, t.TrackingNbr, iif(r.SvcClass=@svcClassLW, @postCourierPre, @postCourierOrg)
		from	@idSeqs x join @picResult r on r.SeqNbr=x.Seq
		cross	apply tms.TrackingNbr#Make(r.SvcCode, r.MailerID, r.MailerSeq, x.ID) t
		;
		-- 2.4	Init TrackingNbr
		insert	core._RefNbr
		(		MatterID, Type, Number)
		select	MatterID, Type, PostCourier
		from	@postCourierSpec;
		-- 2.5	Init PostCourier
		insert	core._RefNbr
		(		MatterID, Type,          Number)
		select	MatterID, n.PostCourier, x.PostCourier
		from	@postCourierSpec x cross apply core.RefNbr#Type() n;


		-- 3.1	Add Batch:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=@errorCnt, @errors=@errors;

		
		-- 3.2	Add Parcels:
		declare @weight real, @length real, @width real, @height real;
		insert	shpt._Parcel
		(		ID,  BatchID,  RouteID, LastMilerID,  SvcType,  SvcZone,              SvcClass,   POA,  ContractID, Weight, Height, Width, Length, ZoneCode)
		select	ID, @batchID, @routeID, @courierID,  @svcType,  isnull(z.Zone, 1),  r.SvcClass, r.POA, @contractID, s.v5,   s.v6,   s.v7,  s.v8,   left(i.v11, 5)
		from	@idSeqs x join @picResult r on r.SeqNbr=x.Seq
		join	tvp.Field#Slice(@slip, N'	%	', default) s on s.Seq=x.Seq
		cross	apply tvp.Dozen#Of(s.v3, default)           i
		outer	apply tms.SvcZone#For(@source, r.SvcClass, r.OnZip3, left(i.v11, 3)) z;
		
		-- 5.	Result:
		--select	@result=@batchID;
		with cteResult(text) as
		(
			select	[text()]=concat(k.Many, c.Number, k.Duad, m.Number)
			from	tvp.Spr#Const() k, @idSeqs x
			cross	apply core.RefNbr#Type()   t
			join	core.RefNbr#Raw() m on m.MatterID=x.ID and m.Type=t.MIT
			join	core.RefNbr#Raw() c on c.MatterID=x.ID and c.Type=t.ClientRef
			for		xml path(N'')
		)
		select	@result=r.Tvp from cteResult 
		cross	apply tvp.Spr#Purify(text, default)  x
		cross	apply tvp.Pair#Make(@batchID, x.Tvp) r
		;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [xpd].[Parcel$InitForXpd]...';


GO
/*
@slip    = at.Tvp.Block.Join(RefNbr, ShprInfo, CneeInfo
,          DeclaredInfo[Quad.Join(GoodsInfo, LineQty, LineTotal, CmdyID).Over(at.Tvp.Mucho)]
,          BrokerageInfo[Triad.Join(SkuID, CmdyInfo, Quad.Join(GoodsInfo, LineQty, LineTotal, CmdyID)).Over(at.Tvp.Mucho)]
,          Weight, Height, Width, Length ).Over(at.Tvp.Entry)
@context = at.Duad.Join(Source, SvcType)
*/
--Daxia
ALTER PROCEDURE [xpd].[Parcel$InitForXpd](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Tenancy & Contexts:
		declare	@siteID I32,    @userID I32;
		select	@siteID=SiteID, @userID=UserID
		from	loc.Tenancy#Of(@tenancy);

		declare	@source E8, @errorCnt int, @errors json, @svcType I32,  @routeID I32,       @courierID I32,         @stateID I32,           @contractID I32;
		select	@source=v1, @errorCnt=0,   @errors=N'',  @svcType=t.ID, @routeID=r.RouteID, @courierID=r.CourierID, @stateID=t.InitStateID, @contractID=c.ID
		from	tvp.Duad#Of(@context, default)                          x
		cross	apply tms.SvcType#For(cast(x.v2 as int), @siteID)       t
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)             r
		cross	apply acct.Contract#For(@siteID, cast(x.v1 as tinyint)) c;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@stage E32=(select Stage  from core.Stage#Of(@stateID));
		insert	core._Matter
		(		ID,  PosterID,  StateID,  Stage,  Source,  Type, PostedOn   )
		select	ID,  @siteID,  @stateID, @stage, @source, @type, getutcdate()
		from	@idSeqs;

		execute	core.Activity#AddByIdSeqs @idSeqs=@idSeqs, @stateID=@stateID, @userID=@userID;

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef E8,          @shprInfo E8,         @cneeInfo E8,          @declaredInfo E8,             @brkgInfo E8;
		select	@clientRef=n.ClientRef, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo,  @declaredInfo=i.DeclaredInfo, @brkgInfo=i.BrokerageInfo
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;

		execute	core.RefNbr#AddBlock  @index=1, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefInfo#AddBlock @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@declaredInfo;
		execute	core.RefInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@brkgInfo;

		-- 3.	Add Batch:
		declare	@batchID I64;
		execute	shpt.Batch#Create @id=@batchID out, @siteID=@siteID, @errorCnt=@errorCnt, @errors=@errors;

		-- 3.	Add Parcels: TODO: add ZoneCode Slice Function.
		insert	shpt._Parcel
		(		ID,  BatchID,  RouteID, LastMilerID,  SvcType, SvcZone,   SvcClass,   POA,  ContractID, Weight, DeclaredWt, Height, Width, Length, ZoneCode)
		select	ID, @batchID, @routeID, @courierID,  @svcType,  z.Zone, c.SvcClass, f.POA, @contractID, s.v6,   s.v6,       s.v7,   s.v8,  s.v9,   left(i.v11, 5)
		from	@idSeqs x join tvp.Field#Slice(@slip, N'	%	', default) s on s.Seq=x.Seq
		cross	apply tms.SvcClass#For(@svcType, s.v6)                                   c
		cross	apply tvp.Dozen#Of(s.v3, default)                                        i
		cross	apply tms.SvcFacility#For(@source, c.SvcClass, left(i.v11, 3))           f
		outer	apply tms.SvcZone#For(@source, c.SvcClass, f.ImportZip3, left(i.v11, 3)) z;

		-- 5.	Result:
		with cteResult(text) as
		(
			select	[text()]=concat(k.Many, c.Number, k.Duad, m.Number)
			from	tvp.Spr#Const() k, @idSeqs x
			cross	apply core.RefNbr#Type()   t
			join	core.RefNbr#Raw() m on m.MatterID=x.ID and m.Type=t.MIT
			join	core.RefNbr#Raw() c on c.MatterID=x.ID and c.Type=t.ClientRef
			for		xml path(N'')
		)
		select	@result=r.Tvp from cteResult
		cross	apply tvp.Spr#Purify(text, default)  x
		cross	apply tvp.Pair#Make(@batchID, x.Tvp) r
		;
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [bo].[Account$ChargeOffInvoice]...';


GO
/*

@slip =InvoiceIDsInCsv

*/
--Smile
ALTER PROCEDURE [bo].[Account$ChargeOffInvoice](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;

		declare	@invoiceds I64Array; insert @invoiceds
		select	x.ID from tvp.I64#Slice(@slip) x
		join	acct.Invoice#Raw() v 
		on		v.ID=x.ID
		where	v.DueBalance=v.InvoiceAmt;

		declare	@ledgerSide E8=(select AR from acct.Ledger#Side());
		declare @PayMethod E8=(select Cash from acct.Payment#Method());
		declare @paymentSpec dbo.I64PairAmts;

		with ctePayment as
		(
			select	PartyID, PaidAmt=sum(v.DueBalanceRaw), CurrencyID
			from	@invoiceds           x
			join	acct.Invoice#Raw()   v on x.ID=v.ID
			group	by PartyID, CurrencyID
		)
		insert	acct._Payment
				( PartyID,  LedgerSide,  CurrencyID,  PayMethod,  PaidAmt)
		output    inserted.ID, inserted.PartyID, inserted.PaidAmt into @paymentSpec
		select	PartyID,    @ledgerSide, CurrencyID,  @PayMethod, Amt
		from	ctePayment x
		cross	apply dbo.Currency#Encode(PaidAmt, CurrencyID) c;

		declare	@partyAmts tvp;
		with ctePartyAmts(text) as
		(
			select [text()]=concat( '	,	', RID, '	^	', Amt)
			from	@paymentSpec
			for	xml path(N'')
		)

		select	@partyAmts=Tvp from ctePartyAmts cross	apply tvp.Spr#Purify(text, DEFAULT);
		declare	@vaultType E8=(select Fund from acct.Vault#Type());
		declare	@idAmts  I64PairAmts; insert @idAmts 
		(		LID,     RID,     Amt    )
	--	select	PartyID, VaultID, PrevBal)
		execute	acct.Vault#Upsert @partyAmts=@partyAmts, @vaultType=@vaultType;

		with ctePayment as
		(
			select	PaymentID=x.LID, PartyID=x.RID, PaidAmt=x.Amt, CurrencyID
			from	@paymentSpec x
			cross	apply dbo.Money#Of(x.Amt)
		)
		insert	acct._VaultXact
		(		PaymentID,  InvoiceID, VaultID, PrevBal,  XactAmt)
		select	PaymentID, 0, RID,     x.Amt,     PaidAmt
		from	@idAmts x
		cross	apply dbo.Money#Of(x.Amt) m
		join	ctePayment                p 
		on		p.PartyID=X.LID and p.CurrencyID=m.CurrencyID;
		

		execute acct.Vault#XactByInvoice @invoiceds=@invoiceds, @paymentID=default, @vaultType=@vaultType;

		with	cte as
		(
			select	x.ID, x.DueBalance
			from	acct.Invoice#Raw() x
			join	@invoiceds         i on i.ID=x.ID
		)
		update	cte set DueBalance=0;

		declare	@userID int=(select UserID from loc.Tenancy#Of(@tenancy));
		insert	core._ChangeLog(RegID, RowID, ChangedBy, ChangedOn)
		select			      Invoice,  x.ID,   @userID, getutcdate()
		from	@invoiceds x
		cross	apply core.Registry#ID() r; 


		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [hub].[RackOutOrder$Init]...';


GO
/*
	@result  = Duad<OrderOutID, CreatedOn>
*/
-- Smile, AaronLiu
ALTER PROCEDURE [hub].[RackOutOrder$Init](@tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
	
		declare	@userID I32,    @hubID I32;
		select	@userID=UserID, @hubID=HubID
		from	loc.Tenancy#Of(@tenancy);

		declare	@orderType E8=(select RackOut from whse.Order#Type());
		declare	@id I32, @createdOn DT=(getutcdate());
		select	@id=ID,  @createdOn=CreatedOn
		from	whse.RackOrder#Raw()
		where	RackerID=@userID and OrderType=@orderType and CompletedOn=dbo.DT@Empty();

		if(isnull(@id, 0)=0)
		begin
			execute	whse.RackOrder#Create @id=@id out, @rackerID=@userID, @orderType=@orderType;
			with	cte as
			(
				select	x.ParcelID, x.RackID, x.OrderInID, x.OrderOutID, p.AID
				,		LagAID=lag(p.AID, 1, 0) over(order by x.ParcelID)
				from	shpt.RackXact#Raw()	  x
				join	shpt.Parcel#Base()	  p on p.ID=x.ParcelID
				join	whse.Rack#Raw()		  r on r.ID=x.RackID
				cross	apply core.State#ID() s
				where	r.HubID=@hubID and x.OrderOutID=0 and p.StateID=s.TobeRackedOut
			),	cteMarker as
			(
				select	ParcelID, RackID, OrderInID, OrderOutID
				,		Marker=sum(case when AID=0 or AID<>LagAID then 1 else 0 end) over (order by AID, ParcelID)
				from	cte
			), cteRackOut as
			(
				select	ParcelID, RackID, OrderInID, OrderOutID
				from	cteMarker
				where	Marker<101
			)
			update	cteRackOut set OrderOutID=@id;
			declare	@expectedCnt int=(@@rowcount);
			if (@expectedCnt=0)
				delete	from whse._RackOrder where ID=@id;
		end

		select	@result=Tvp from tvp.Duad#Make(@id, @createdOn);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [core].[Matter#TransitBySpec]...';


GO
--PeterHo
ALTER PROCEDURE [core].[Matter#TransitBySpec](@spec core.TransitionSpec readonly, @userID I32, @beAffected bit=0)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@expectedCnt int=(select count(*) from @spec);
		if (@beAffected=1 and @expectedCnt=0)
			execute	dbo.Assert#Fail N'Empty transition is not allowed.';

		with cteMatter as
		(
			select	m.ID,      m.StatedOn
			,		m.StateID, x.ToStateID
			,		m.Stage,   x.ToStage
			,		m.HandlerID
			from	@spec  x join core._Matter m
			on		m.ID=x.MatterID
			and		m.StateID=x.OnStateID                   -- Geninue    Check.
			and		m.LockCnt=0                             -- AdminLock  Check.
			cross	apply core.Challenge#Borderline(m.ID) c -- Borderline Check.
			where	x.ToStage<=c.Borderline
		)
		update	cteMatter set StateID=ToStateID, StatedOn=getutcdate(), Stage=ToStage, HandlerID=0;

		execute	dbo.Assert#Transited @expectedCnt;

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;
		execute	core.OutboundQ#EnqueueBySpec @spec=@spec;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [core].[Matter#TransitBySpecWithPID]...';


GO
--PeterHo
ALTER PROCEDURE [core].[Matter#TransitBySpecWithPID](@spec core.TransitionSpec readonly, @userID I32, @pid bigint)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@expectedCnt int=(select count(*) from @spec);
		with cteMatter as
		(
			select	m.ID, m.PID, m.StatedOn
			,		m.StateID,   x.ToStateID
			,		m.Stage,     x.ToStage
			,		m.HandlerID
			from	@spec  x join core._Matter m
			on		m.ID=x.MatterID
			and		m.StateID=x.OnStateID                   -- Geninue Check.
			and		m.LockCnt=0                             -- AdminLock Check.
			cross	apply core.Challenge#Borderline(m.ID) c -- Borderline Check.
			where	x.ToStage<=c.Borderline
		)
		update	cteMatter set PID=@pid, StateID=ToStateID, StatedOn=getutcdate(), Stage=ToStage, HandlerID=0;

		execute	dbo.Assert#Transited @expectedCnt;

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;
		execute	core.OutboundQ#EnqueueBySpec @spec=@spec;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [core].[Matter#CascadeAllBySpec]...';


GO
-- AaronLiu, PeterHo
ALTER PROCEDURE [core].[Matter#CascadeAllBySpec](@spec core.TransitionSpec readonly, @userID I32)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		declare	@descendantSpec core.TransitionSpec; insert @descendantSpec
		(		MatterID,   ActionID, OnStateID,   ToStateID,   ToStage,   Source,   TodoHours,   OutboundQ)
		select	    m.ID, x.ActionID, m.StateID, t.ToStateID, t.ToStage, m.Source, t.TodoHours, t.OutboundQ
		from	@spec x cross apply core.Matter#NodeDn (x.MatterID) m
		cross	apply core.Transition#Tobe(m.StateID, 0, x.ActionID, m.RejoinID) t

		execute	core.Matter#TransitBySpec @spec=@descendantSpec, @userID=@userID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [core].[Matter#CascadeBySpec]...';


GO
--PeterHo
ALTER PROCEDURE [core].[Matter#CascadeBySpec](@spec core.TransitionSpec readonly, @userID I32)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		declare	@descendantSpec core.TransitionSpec; insert @descendantSpec
		(		MatterID,   ActionID, OnStateID,   ToStateID,   ToStage,   Source,   TodoHours,   OutboundQ)
		select	    m.ID, x.ActionID, m.StateID, t.ToStateID, t.ToStage, m.Source, t.TodoHours, t.OutboundQ
		from	@spec x cross apply core.Matter#PNodeDn (x.MatterID) m
		cross	apply core.Transition#Tobe(m.StateID, 0, x.ActionID, m.RejoinID) t

		execute	core.Matter#TransitBySpec @spec=@descendantSpec, @userID=@userID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [core].[Matter#CascadeBySpecWithStamp]...';


GO
--Smile
ALTER PROCEDURE [core].[Matter#CascadeBySpecWithStamp](@spec core.TransitionSpec readonly, @utcStamp tvp, @userID I32)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;
		execute	core.RefStamp#MergeBySpec @spec=@spec, @utcStamp=@utcStamp;

		declare	@descendantSpec core.TransitionSpec; insert @descendantSpec
		(		MatterID,   ActionID, OnStateID,   ToStateID,   ToStage,   Source,   TodoHours,   OutboundQ)
		select	    m.ID, x.ActionID, m.StateID, t.ToStateID, t.ToStage, m.Source, t.TodoHours, t.OutboundQ
		from	@spec x cross apply core.Matter#PNodeDn (x.MatterID) m
		cross	apply core.Transition#Tobe(m.StateID, 0, x.ActionID, m.RejoinID) t

		execute	core.Matter#TransitBySpec @spec=@descendantSpec, @userID=@userID;
		execute	core.RefStamp#MergeBySpec @spec=@descendantSpec, @utcStamp=@utcStamp;
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [api].[Parcel$CfmDoorDeliverdForTC]...';


GO
/*
	@slip = Comma<ParcelID>
*/
-- AaronLiu
ALTER PROCEDURE [api].[Parcel$CfmDoorDeliverdForTC](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

--		declare	@actionID I32=(select CfmDoorDelivered from core.Action#ID());
		declare	@actionID I32=19990;
		execute	svc.Parcel$Transit @idsInCsv=@slip, @actionID=@actionID, @tenancy=@tenancy;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [svc].[Parcel$CfmDoorDeliverd]...';


GO
/*
	@slip = Comma<PostCourierNbr>
*/
-- AaronLiu
ALTER PROCEDURE [svc].[Parcel$CfmDoorDeliverd](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		with cte(text) as
		(
			select	[text()]=concat(N',',  n.MatterID)
			from	tvp.Comma#Slice(@slip) x
			cross	apply core.Stage#ID()  s
			cross	apply core.RefNbr#ScanOne(x.Piece, s.Surrendered, s.DoorDelivered) n
			  for	xml path(N'')
		)
		select	@slip=Tvp from cte cross apply tvp.Spr#Purify(text, 1);

--		declare	@actionID I32=(select CfmDoorDelivered from core.Action#ID());
		declare	@actionID I32=19990;
		execute	svc.Parcel$Transit @idsInCsv=@slip, @actionID=@actionID, @tenancy=@tenancy;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [ic].[Concern$Post]...';


GO
/*
@slip=Duad<Comma[AddedConcernType], Comma[DeletedConcernType]>
@context=MatterID
*/
--Smile
ALTER PROCEDURE [ic].[Concern$Post](@slip tvp, @context tvp)
WITH ENCRYPTION
AS
BEGIN	
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

	declare	@addedConcerns tvp, @deletedConcerns tvp, @matterID bigint;
	select	@addedConcerns=v1,  @deletedConcerns=v2,  @matterID=@context
	from	tvp.Duad#Of(@slip, default);

	execute	core.Concern#Add	@matterID=@matterID, @concerns=@addedConcerns;
	execute	core.Concern#Remove @matterID=@matterID, @concerns=@deletedConcerns;

	update	core._Matter set HandlerID=0 where ID=@matterID;

COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [svc].[Parcel$MergeRefInfoByMics]...';


GO
/*
@slip   =Many[Triad<MIC, RefInfoType, RefInfo>]
*/
ALTER PROCEDURE [svc].[Parcel$MergeRefInfoByMics](@slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT ON;	

	declare @refInfoSlip tvp;
	with cteParcel(text) as
	(
		select	[text()]=concat(k.Many, m.MatterID, k.Triad, x.v2, k.Triad, x.v3)
		from	tvp.Triad#Slice(@slip, default, default) x
		cross	apply core.MIC#IdOf(x.v1) m
		join	core.Matter#Raw()         t on t.ID=m.MatterID
		cross	apply core.Stage#ID()     s
		cross	apply tvp.Spr#Const()     k
		where t.Stage=s.RouteAssigned
		for xml path(N'')
	)
	select @refInfoSlip=Tvp from cteParcel cross apply tvp.Spr#Purify(text, default);
	execute core.RefInfo#Merge @slip=@refInfoSlip;

END
GO
PRINT N'Altering [xpd].[Parcel$UpdateForXpd]...';


GO
/*
@slip    = =Many[Triad<MIC, RefInfoType, RefInfo>]
*/
--Aimee
ALTER PROCEDURE [xpd].[Parcel$UpdateForXpd](@slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;

		declare @exeSlip tvp;
		with cteParcel(text) as
		(
			select	[text()]=concat(k.Many, m.MatterID, k.Triad, x.v2, k.Triad, x.v3)
			from	tvp.Triad#Slice(@slip, default, default) x
			cross	apply core.MIC#IdOf(x.v1) m
			join	core.Matter#Raw()         t on t.ID=m.MatterID
			cross	apply core.Stage#ID()     s
			cross	apply tvp.Spr#Const()     k
			where	t.Stage<=s.RouteAssigned
			for		xml path(N'')
		)
		select @exeSlip=Tvp from cteParcel cross apply tvp.Spr#Purify(text, default);
		execute core.RefInfo#Merge @slip=@exeSlip;
	
		-- Upd Parcel.
		with cteParcelCnee as
		(
			select	m.MatterID, ZoneCode=c.v11, t.Source
			from	tvp.Triad#Slice(@slip, default, default) x
			cross	apply core.MIC#IdOf(x.v1) m
			join	core.Matter#Raw()         t on t.ID=m.MatterID
			cross	apply tvp.Dozen#Of(x.v3, default) c
			cross	apply core.Stage#ID()     s
			cross	apply core.RefInfo#Type() r
			where	x.v2=r.CneeInfo and t.Stage<=s.RouteAssigned
		)
		update	p set SvcZone=z.Zone,   POA=f.POA,  ZoneCode=t.ZoneCode
		from	shpt._Parcel p join cteParcelCnee t on t.MatterID=p.ID
		cross	apply tms.ZoneCode#For(t.ZoneCode) c
		cross	apply tms.SvcFacility#For(t.Source, p.SvcClass, c.Zip3) f
		outer	apply tms.SvcZone#For(t.Source, p.SvcClass, f.ImportZip3, c.Zip3) z
		;
END
GO
PRINT N'Altering [core].[Activity#OnceHubAccepted]...';


GO
--PeterHo
ALTER PROCEDURE [core].[Activity#OnceHubAccepted](@matterID I64, @userID I32=0)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	declare	@stateID I32=(select HubAccepted       from core.State#ID());
	declare	@qtype    E8=(select SubscribeCallback from core.Queue#Type());
	execute	core.Activity#Once @matterID=@matterID, @stateID=@stateID, @qtype=@qtype, @userID=@userID;
END
GO
PRINT N'Altering [acct].[Payment#Insert]...';


GO
--Smile, PeterHo
ALTER PROCEDURE [acct].[Payment#Insert]
(
	@partyID   I32,  @ledgerSide E8,   @xactAmt amt,
	@payMethod E8,   @supplement nax,  @id  I64 out
)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@currencyID E8=(select CurrencyID from dbo.Currency#Decode(@xactAmt));

		insert	acct._Payment
				( PartyID,  LedgerSide,  CurrencyID,  PayMethod,  PaidAmt)
		values	(@partyID, @ledgerSide, @currencyID, @payMethod, @xactAmt);
		select	 @id=scope_identity();
		
		declare	@regID I32=(select Payment from core.Registry#ID());
		execute	core.Supplement#Merge @regID=@regID, @rowID=@id, @supplement=@supplement;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [core].[Tenant#Add]...';


GO
/*
@slip = at.Tvp.Field.Join(PID, AID, Alias, Contact, UtcPlace, UtcOffset)
*/
--PeterHo
ALTER PROCEDURE [core].[Tenant#Add](@id I32 out, @source E8, @type E8, @slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		exec	core.Party#Add @id=@id out, @source=@source, @type=@type, @slip=@slip;

		insert	core._Tenant
		(		ID,   Source, Alias, UtcPlace, UtcOffset)
		select	@id, @source, x.v3,  x.v5,     x.v6
		from	tvp.Field#Of(@slip, default) x

		declare	@contact tvp=(select v4 from tvp.Field#Of(@slip, default)); 
		execute	core.Contact#AddVia @partyID=@id, @contact=@contact;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [core].[User#Add]...';


GO
/*
@slip = at.Tvp.Field.Join(PID, AID, Alias, Contact, UserRoles)
*/
--PeterHo
ALTER PROCEDURE [core].[User#Add](@id I32 out, @source E8, @type E8, @slip tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		execute	core.Party#Add @id=@id out, @source=@source, @type=@type, @slip=@slip;

		declare	@roles tvp, @alias loc.Alias, @contact tvp;
		select	@roles=v5,  @alias=v3, @contact=v4
		from	tvp.Field#Of(@slip, default);

		insert	core._User (ID, Alias) values (@id, @alias);

		insert	core._UserRole
		(		UserID, RoleID)
		select	@id,    cast(r.Piece as int)
		from	tvp.Comma#Slice(@roles) r;

		execute	core.Contact#AddVia @partyID=@id, @contact=@contact;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [core].[Challenge#Pull]...';


GO
/*
@slip    = Many[Duad<MatterID, ChallengeType>]
@context = MessageBody
*/
--PeterHo
ALTER PROCEDURE [core].[Challenge#Pull](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@rowAuxes I64Enums;
		with	cteSlip as
		(
			select	c.MatterID, c.Type
			from	tvp.Duad#Slice(@slip, default, default) x
			join	core._Challenge c
			on		c.MatterID=cast(v1 as bigint) and c.Type=cast(v2 as tinyint)
		)
		delete	cteSlip output deleted.MatterID, deleted.Type into @rowAuxes;

		declare	@regID I32=(select Matter from core.Registry#ID());

		if  (/*HumanPull*/(select UserID from loc.Tenancy#Of(@tenancy))>0)
			execute	core.Message#Invoke @regID=@regID, @rowAuxes=@rowAuxes, @body=@context, @tenancy=@tenancy;

		else /*DaemonPull*/ begin
			with cteDameonPull as
			(
				select	RegID, RowID, AuxID, PostedOn
				from	core._Message x
				where	exists
				(
					select	* from @rowAuxes a
					where	(x.RegID=@regID and x.RowID=a.ID and x.AuxID=a.Val)
					and		x.PosterID=0 -- Daemon
				)
			) delete cteDameonPull;
		end

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [hub].[RackInOrder$Init]...';


GO
/*
	@result  = Duad<OrderInID, CreatedOn>
*/
-- Smile
ALTER PROCEDURE [hub].[RackInOrder$Init](@tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;
	
		declare	@userID I32  =(select UserID from loc.Tenancy#Of(@tenancy));
		declare	@orderType E8=(select RackIn from whse.Order#Type());
		declare	@id I32;
		execute	whse.RackOrder#Create @id=@id out, @rackerID=@userID, @orderType=@orderType;

		select	@result=Tvp from tvp.Duad#Make(@id, getutcdate());
	
END
GO
PRINT N'Altering [hub].[Parcel$EndOfDayForUSD]...';


GO
/*
	@slip	=Triad<RcvHubID, ContainAddOnSvc, OperationDate>
*/
-- Daxia
ALTER PROCEDURE [hub].[Parcel$EndOfDayForUSD](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		--	0	Tenancy
		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@hubID I32,               @containAddOnSvc bit,               @opDate DT;
		select	@hubID=cast(x.v1 as int), @containAddOnSvc=cast(x.v2 as bit), @opDate=x.v3
		from	tvp.Triad#Of(@slip, default) x
		;
		declare	@utcOffset smallint=(select UtcOffset from core.Tenant#Raw() where ID=@hubID);
		declare	@startedOn DT=dateadd(hour, @utcOffset * -1, @opDate);
		declare	@endedOn   DT=dateadd(day, 1, @startedOn);

		--	1	Transition
		declare	@source   E8 =(select USD from core.Source#ID())
		,		@actionID I32=(select EndOfDay from core.Action#ID());

		declare	@spec core.TransitionSpec;
		insert	@spec select t.*
		from	shpt.Parcel#Base() x cross apply core.State#ID() s
		cross	apply shpt.Parcel#Tobe(x.ID, @roleID, @actionID) t
		cross	apply core.AddOnSvc#Exists(x.ID) a
		where	x.StateID in (s.CfmOutGated) and x.Source=@source
		and		x.RcvHubID=@hubID and x.StatedOn>=@startedOn and x.StatedOn<@endedOn
		and		(@containAddOnSvc=1 or a.HasAddOnSvc=0)
		;
	
		exec	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=0;
		
		--	2	Bill
		declare	@parcelIDs dbo.I64Array;
		insert	@parcelIDs (ID) select MatterID from @spec;
		exec	shpt.Parcel#BillForFactor @parcelIDs=@parcelIDs, @hubID=@hubID;
		
		--	6.	Add Parcel Q for FedEx
		insert	core._OutboundQ
		(		ToSource,   QueueType,             MatterID,     StateID)
		select	s.InfoPath, q.MftPostCourierAPI, x.MatterID, x.ToStateID
		from	@spec x, core.Source#ID() s, core.Queue#Type() q
		;


		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [bo].[Account$ImportSvcRate]...';


GO
/*

@slip = Quad[SvcType, RcvHubID, SectionWt, SvcRate]
@context=Triad<TenantID, SvcType, FileID>

*/
--Smile
ALTER PROCEDURE [bo].[Account$ImportSvcRate](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;

		declare	@tenantID I32, @svcType I32, @major I32,      @fileID char(33), @contractID I32;
		select	@tenantID=v1,  @svcType=v2,  @major=t.Major,  @fileID=v3,       @contractID=c.ID
		from	tvp.Triad#Of(@context, default)  x
		cross	apply tms.SvcType#Major(cast(x.v2 as int)) t
		join	core.Party#Raw() p on p.ID=x.v1
		cross	apply acct.Contract#For(p.ID, p.Source) c;

		declare	@svcTypeVia I32;
		with cteSvcType as
		(
			select	x.ID, Marker=null
			from	tms.SvcType#Raw() x
			cross	apply tms.SvcType#Major(x.ID) m
			where	m.Major=@major and TenantID=@tenantID
			UNION ALL
			select	x.ID+1, Marker=lead(x.ID) over(order by ID)
			from	tms.SvcType#Raw() x
			cross	apply tms.SvcType#Major(x.ID) m
			where	m.Major=@major 
		)
		select	top(1) @svcTypeVia=ID from cteSvcType where Marker is null;

		if(exists(select * from tvp.Quad#Slice(@slip, default, default) where v1<>@svcType)) return;

		BEGIN TRY
		BEGIN TRAN;

		if(not exists(select * from tms.SvcType#Raw() where ID=@svcTypeVia))
		begin
		insert tms._SvcType(ID,  TenantID,  CurrencyID, DutyCurrencyID, FallbackPOA, InitStateID, ClrMethodID, CmdyRootID)
		select	   @svcTypeVia, @tenantID,  CurrencyID, DutyCurrencyID, FallbackPOA, InitStateID, ClrMethodID, CmdyRootID
		from	   tms.SvcType#Raw()
		where	   ID=@major;
		end

		delete	from tms._SvcRate where SvcType=@svcTypeVia;
		with cteSvcRate as
		(
			select	RcvHubID=x.v2, SectionWt=x.v3, SvcRate=x.v4
			from	tvp.Quad#Slice(@slip, default, default) x
		)
		insert	tms._SvcRate(SvcType, RcvHubID, SectionWt, SvcRate)
		select			 @svcTypeVia, RcvHubID, SectionWt, SvcRate
		from	cteSvcRate;

		delete	from tms._SvcContract where ContractID=@contractID and SvcType in (@major, @svcTypeVia);
		insert	tms._SvcContract(ContractID, SvcType) values(@contractID, @svcTypeVia);

		declare	@userID I32=(select UserID from	loc.Tenancy#Of(@tenancy)),
				@auxID E32=(select SvcRate from core.Attachment#Type()),
				@regID I32=(select Contract from core.Registry#ID());

		insert	core._Attachment
				( RegID,  RowID,       AuxID,  PosterID,  FileBankID)
		values	( @regID, @contractID, @auxID, @userID,  @fileID);
		
		insert	core._ChangeLog(RegID,       RowID, ChangedBy, ChangedOn)
		select			      SvcRate, @contractID,   @userID, getutcdate()
		from	core.Registry#ID();

		declare	@ids I64Array;
		with cteParcel as
		(
			select	ID, SvcType
			from	shpt.Parcel#Base()                 p
			cross	apply core.Stage#ID()              k
			cross	apply tms.SvcType#Major(p.SvcType) s
			where	p.Stage<k.RouteCfmed and s.Major=@major
			and		ContractID=@contractID
		)
		update	cteParcel set SvcType=@svcTypeVia
		output inserted.ID into @ids;

		declare	@daemon I32=0;
		declare	@actionID I32=(select ImportSvcRate from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from @ids x
		cross	apply shpt.Parcel#Tobe(x.ID, @daemon, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=0;

		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [ic].[Parcel$MergeHandWrittenOrder]...';


GO
/*
@slip    =  Triad[ParcelID, RefInfoType, RefInfo]
@context =  Duad <ParcelID, SvcType>;
*/
--Smile
ALTER PROCEDURE [ic].[Parcel$MergeHandWrittenOrder](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		execute	core.RefInfo#Merge @slip=@slip;	
		
		declare	@parcelID I64, @svcType I32;
		select	@parcelID=v1,  @svcType=v2
		from	tvp.Duad#Of(@context, default);
		with cteParcel as
		(
			select	p.SvcType, NSvcType=t.ID, 
					p.RouteID, NRouteID=r.RouteID, 
					p.POA, NPOA=r.POA, 
					p.ContractID,  NContractID=c.ID, 
					p.LastMilerID, NLastMilerID=r.CourierID
			from	shpt.Parcel#Base()                           p 
			cross	apply tms.SvcType#For(@svcType, p.SiteID)   t
			cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA) r
			cross	apply acct.Contract#For(p.SiteID, p.Source) c
			where	p.ID=@parcelID

		)		
		update	cteParcel set SvcType=NSvcType, RouteID=NRouteID, POA=NPOA
		,		ContractID=NContractID, LastMilerID=NLastMilerID;
		
		declare	@actionID I32=(select CompleteParcelInfo from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@parcelID, @actionID=@actionID, @tenancy=@tenancy;
		
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [shpt].[Parcel#UnfiledCPSInitByPlatform]...';


GO
/*
@slip    = Entry[Block< Quad<SiteID, SvcType, RchHubAlias, POA>
					, RefNbr
					, Shpr
					, Cnee
					, IDInfo
					, Bag[Path<Precourier, Shpr, Mucho[LineInfo], Weight>]
					, AddOnSvc>]
@context = batchID
*/
--Smile
ALTER PROCEDURE [shpt].[Parcel#UnfiledCPSInitByPlatform](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
	
		-- 0.	Contexts:
		declare	@siteID I32,    @userID I32,    @source tinyint;
		select	@siteID=SiteID, @userID=UserID, @source=p.Source
		from	loc.Tenancy#Of(@tenancy) x
		join	core.Party#Raw()         p on p.ID=x.UserID;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select UnityParcel from core.Matter#Type())
		,		@spec core.TransitionSpec;
		insert	core._Matter
		(		ID,  PosterID,   StateID,       Stage,  Source,  Type, PostedOn    )
		output	inserted.ID, 0, 0, inserted.StateID, inserted.Stage, inserted.Source, 0, 0 into @spec
		select	x.Master,  cast(q.v1 as int), t.InitStateID, s.Stage, @source,  @type, getutcdate()
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default)        x 
		cross	apply tvp.Quad#Of(x.House, default)                         q	
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		cross	apply core.Stage#Of(t.InitStateID)                          s

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;
		
		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef E8,  @shprInfo E8,  @cneeInfo E8,  @preCourier E8,  @IDInfo E8
		,		@declaredInfo E8,  @brokerageInfo E8, @addOnSvcInfo E8;
		select	@clientRef=n.ClientRef, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo
		,		@preCourier=n.PreCourier, @IDInfo=i.IDInfo, @declaredInfo=i.DeclaredInfo
		,		@brokerageInfo=i.BrokerageInfo, @addOnSvcInfo=I.AddOnSvcInfo
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i;

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;
		execute	core.RefNbr#AddBlock     @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefInfo#AddBlock	 @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock	 @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock	 @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@IDInfo;
		execute	core.RefInfo#AddBlock	 @index=7, @idSeqs=@idSeqs, @slip=@slip, @type=@addOnSvcInfo;
		

		-- 3.	Add  Parcels:
		declare	@batchID I64=(@context);
		
		insert	shpt._Parcel
		(		ID,       BatchID,  RouteID, LastMilerID,  
				SvcType,  SvcZone, SvcClass, POA, RcvHubID, ContractID)
		select	x.Master, @batchID, isnull(d.RouteID, r.RouteID), r.CourierID,  
				t.ID, 1, 1, iif(nullif(q.v4, '') is null, r.POA, q.v4), isnull(h.ID, 0), c.ID
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default) x 
		cross	apply tvp.Quad#Of(x.House, default)                  q
		cross	apply core.Party#Type()                              e
		left	join  core.Party#Raw()                               h on h.Alias=q.v3 and h.Type=e.ZebraHub
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		outer	apply tms.SvcRoute#For(t.ID, cast(q.v4 as char(3)))  d
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)          r	
		cross	apply acct.Contract#For(cast(q.v1 as int), @source)  c;

		--4.	init MediumParcel
		select	@type=MediumParcel from core.Matter#Type();
		declare	@mediumSeqs I64Seqs; insert @mediumSeqs(ID, Seq)
		select  next value for core.MatterSeq, x.Seq*100 + p.Seq
		from	tvp.Block#FoldT(6, @idSeqs, @slip, default, default) x 
		cross	apply tvp.Bag#Slice(x.House)                         p
        ;
		insert	core._Matter
		(		ID,  AID, PosterID, StateID, Stage, Source, Type, PostedOn    )
		output	inserted.ID, 0, 0, inserted.StateID, inserted.Stage, inserted.Source, 0, 0 into @spec
		select	h.ID, x.Master,  m.PosterID, m.StateID, m.Stage, @source,  @type, getutcdate()
		from	tvp.Block#FoldT(6, @idSeqs, @slip, default, default) x
		cross	apply tvp.Bag#Slice(x.House)                         p
		join	@mediumSeqs                                          h on h.Seq=x.Seq*100 + p.Seq
		join	core.Matter#Raw()                                    m on m.ID=x.Master

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;
		execute	core.RefNbr#AddMIC           @idSeqs=@mediumSeqs, @source=@source,  @type=@type;
		
		insert	into core._RefNbr(MatterID, Type, Number)
		select	h.ID, @preCourier, f.v1
		from	tvp.Block#FoldT(6, @idSeqs, @slip, default, default) x
		cross	apply tvp.Bag#Slice(x.House)                         p
		cross	apply tvp.Spr#Const()                                k
		cross   apply tvp.Field#Of(p.Piece, k.Path)                  f
		join	@mediumSeqs                                          h on h.Seq=x.Seq*100 + p.Seq
		;
		declare	@refInfoSlip tvp;
		with	cte(text) as
		(
			select	[text()]=concat( k.Many, h.ID, k.Triad,	@shprInfo, k.Triad, f.v2									
									,k.Many, h.ID, k.Triad, @declaredInfo, k.Triad, f.v3
									,k.Many, h.ID, k.Triad, @brokerageInfo, k.Triad, b.BrokerageInfo)
			from	tvp.Block#FoldT(6, @idSeqs, @slip, default, default) x
			cross	apply tvp.Bag#Slice(x.House)                         p
			cross	apply tvp.Spr#Const()                                k
			cross   apply tvp.Field#Of(p.Piece, k.Path)                  f
			cross	apply loc.Declared$ToBrokerage(f.v3, default)		 b
			join	@mediumSeqs                                          h on h.Seq=x.Seq*100 + p.Seq
			for		xml path(N'')
		)
		select	@refInfoSlip=Tvp from cte cross apply tvp.Spr#Purify(text, default);
		execute	core.RefInfo#Merge @slip=@refInfoSlip;

		insert	into shpt._Parcel
		(		ID,   BatchID,  RouteID,   LastMilerID,  SvcType, SvcZone, SvcClass,  POA,  Weight, RcvHubID,        ContractID)
		select	h.ID, @batchID, r.RouteID, r.LastMilerID, r.SvcType,     1,      1,   r.POA, cast(f.v6 as real),   r.RcvHubID, r.ContractID
		from	tvp.Block#FoldT(6, @idSeqs, @slip, default, default) x
		cross	apply tvp.Bag#Slice(x.House)                         p
		join	@mediumSeqs                                          h on h.Seq=x.Seq*100 + p.Seq
		cross	apply tvp.Spr#Const()                                k
		cross   apply tvp.Field#Of(p.Piece, k.Path)                  f
		join	shpt.Parcel#Raw()                                    r on r.ID=x.Master
		;

		-- PreCourier Concern
		declare	@preCouriers tvp;
		with	cte(text) as
		(
			select	[text()]=concat(N',', f.v1)
			from	tvp.Block#At(6, @slip, default, default) x
			cross	apply tvp.Spr#Const()					 k
			cross	apply tvp.Pcs#Slice(x.Tvp, k.Entry)		 p
			cross	apply tvp.Bag#Slice(p.Piece)			 m
			cross   apply tvp.Field#Of(m.Piece, k.Path)		 f
			for		xml path(N'')
		)
		select	@preCouriers=Tvp from cte cross apply tvp.Spr#Purify(text, 1)
		execute	shpt.PreCourier#Concern @slip=@preCouriers;
		
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [shpt].[Parcel#UnfiledMPSInitByPlatform]...';


GO
/*
@slip    = Entry[Block< Quad<SiteID, SvcType, RchHubAlias, POA>
				, RefNbr
				, Shpr
				, Cnee
				, Mucho[LineInfo]
				, ID
				, Mucho[Duad<Precourier, Weight>]>
				, AddOnSvc]
@context = batchID
*/
--Smile
ALTER PROCEDURE [shpt].[Parcel#UnfiledMPSInitByPlatform](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		-- 0.	Contexts:
		declare	@siteID I32,    @userID I32,    @source tinyint;
		select	@siteID=SiteID, @userID=UserID, @source=p.Source
		from	loc.Tenancy#Of(@tenancy) x
		join	core.Party#Raw()         p on p.ID=x.UserID;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select MasterParcel from core.Matter#Type())
		,		@spec core.TransitionSpec;
		insert	core._Matter
		(		ID,  PosterID,   StateID,       Stage,  Source,  Type, PostedOn    )
		output	inserted.ID, 0, 0, inserted.StateID, inserted.Stage, inserted.Source, 0, 0 into @spec
		select	x.Master,  cast(q.v1 as int), t.InitStateID, s.Stage, @source,  @type, getutcdate()
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default)        x 
		cross	apply tvp.Quad#Of(x.House, default)                         q	
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		cross	apply core.Stage#Of(t.InitStateID)                          s

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;
		

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef E8,  @shprInfo E8,  @cneeInfo E8,  @preCourier E8,  @IDInfo E8
		,		@declaredInfo E8,  @brokerageInfo E8, @addOnSvcInfo E8;
		select	@clientRef=n.ClientRef, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo
		,		@preCourier=n.PreCourier, @IDInfo=i.IDInfo, @declaredInfo=i.DeclaredInfo
		,		@brokerageInfo=i.BrokerageInfo, @addOnSvcInfo=I.AddOnSvcInfo
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i;

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;

		execute	core.RefNbr#AddBlock  @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;		
		execute	core.RefInfo#AddBlock @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@declaredInfo;
		execute	core.RefInfo#AddBlock @index=6, @idSeqs=@idSeqs, @slip=@slip, @type=@IDInfo;
		execute	core.RefInfo#AddBlock @index=8, @idSeqs=@idSeqs, @slip=@slip, @type=@addOnSvcInfo;
		insert	into core._RefInfo(MatterID, Type, Info)
		select	x.Master, @brokerageInfo, b.BrokerageInfo
		from	tvp.Block#FoldT(5, @idSeqs, @slip, default, default) x
		cross	apply loc.Declared$ToBrokerage(x.House, default)	 b	

		-- 3.	Add Matser Parcels:
		declare	@batchID I64=(@context);
		
		insert	shpt._Parcel
		(		ID, BatchID,  RouteID, LastMilerID, SvcType,
				SvcZone, SvcClass,  POA, RcvHubID, ContractID)
		select	x.Master, @batchID, isnull(d.RouteID, r.RouteID), r.CourierID,  t.ID,
				1, 1,  iif(nullif(q.v4, '') is null, r.POA, q.v4), isnull(h.ID, 0), c.ID
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default) x 
		cross	apply tvp.Quad#Of(x.House, default)                  q
		cross	apply core.Party#Type()                              e
		left	join  core.Party#Raw()                               h on h.Alias=q.v3 and h.Type=e.ZebraHub
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		outer	apply tms.SvcRoute#For(t.ID, cast(q.v4 as char(3)))  d
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)          r
		cross	apply acct.Contract#For(cast(q.v1 as int), @source)  c;

		--4.	init HouseParcel
		declare	@houseSeqs I64Seqs; insert @houseSeqs(ID, Seq)
		select  next value for core.MatterSeq, x.Seq*100 + d.Seq
		from	tvp.Block#FoldT(7, @idSeqs, @slip, default, default) x
		cross	apply tvp.Mucho#Slice(x.House)                       p
		cross	apply tvp.Duad#Slice(p.Piece, default, default)      d
        ;

		select	@type=HouseParcel from core.Matter#Type();
		insert	core._Matter
		(		ID,  AID, PosterID, StateID, Stage, Source, Type, PostedOn    )
		output	inserted.ID, 0, 0, inserted.StateID, inserted.Stage, inserted.Source, 0, 0 into @spec
		select	h.ID, x.Master,  m.PosterID, m.StateID, m.Stage, @source,  @type, getutcdate()
		from	tvp.Block#FoldT(7, @idSeqs, @slip, default, default) x
		cross	apply tvp.Mucho#Slice(x.House)                       p
		cross	apply tvp.Duad#Slice(p.Piece, default, default)      d
		join	@houseSeqs                                           h on h.Seq=x.Seq*100 + d.Seq
		join	core.Matter#Raw()                                    m on m.ID=x.Master

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;

		execute	core.RefNbr#AddMIC       @idSeqs=@houseSeqs, @source=@source,  @type=@type;
		insert	into core._RefNbr(MatterID, Type, Number)
		select	h.ID, @preCourier, d.v1
		from	tvp.Block#FoldT(7, @idSeqs, @slip, default, default) x
		cross	apply tvp.Mucho#Slice(x.House)                       p
		cross	apply tvp.Duad#Slice(p.Piece, default, default)      d
		join	@houseSeqs                                           h on h.Seq=x.Seq*100 + d.Seq
		;
		insert	into shpt._Parcel
		(		ID,   BatchID,  RouteID,   LastMilerID,  SvcType, SvcZone, SvcClass,  POA,  Weight, RcvHubID,        ContractID)
		select	h.ID, @batchID, r.RouteID, r.LastMilerID, r.SvcType,     1,      1,   r.POA, cast(d.v2 as real),   r.RcvHubID, r.ContractID
		from	tvp.Block#FoldT(7, @idSeqs, @slip, default, default) x
		cross	apply tvp.Mucho#Slice(x.House)                       p
		cross	apply tvp.Duad#Slice(p.Piece, default, default)      d
		join	@houseSeqs                                           h on h.Seq=x.Seq*100 + d.Seq
		join	shpt.Parcel#Raw()                                    r on r.ID=x.Master
		;
		
		-- PreCourier Concern
		declare	@preCouriers tvp;
		with	cte(text) as
		(
			select	[text()]=concat(N',', d.v1)
			from	tvp.Block#At(7, @slip, default, default)		x
			cross	apply tvp.Spr#Const()							k
			cross	apply tvp.Pcs#Slice(x.Tvp, k.Entry)				p
			cross	apply tvp.Mucho#Slice(p.Piece)					m
			cross	apply tvp.Duad#Slice(m.Piece, default, default) d
			for		xml path(N'')
		)
		select	@preCouriers=Tvp from cte cross apply tvp.Spr#Purify(text, 1)
		execute	shpt.PreCourier#Concern @slip=@preCouriers;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [shpt].[Parcel#UnfiledNormalInitByPlatform]...';


GO
/*
@slip    =Entry[Block< Tuplet<SiteID, SvcType, Weight, RchHubAlias, POA>
			, RefNbr
			, PreCourier
			, ShprInfo
			, CneeInfo
			, Mucho[LineInfo]
			, IDInfo
			, AddOnSvcInfo>]
@context = batchID
*/
--Smile
ALTER PROCEDURE [shpt].[Parcel#UnfiledNormalInitByPlatform](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
			-- 0.	Contexts:
		declare	@siteID I32,    @userID I32,    @source tinyint;
		select	@siteID=SiteID, @userID=UserID, @source=p.Source
		from	loc.Tenancy#Of(@tenancy) x
		join	core.Party#Raw()         p on p.ID=x.UserID;

		declare	@errorCnt int, @errors json;
		select	@errorCnt=v1,  @errors=v2
		from	tvp.Duad#Of(@context, default) x
		;

		-- 1.	Add Matters & Activities:
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		declare	@type  E8=(select Parcel from core.Matter#Type())
		,		@spec core.TransitionSpec;
		insert	core._Matter
		(		ID,  PosterID,   StateID,       Stage,  Source,  Type, PostedOn    )
		output	inserted.ID, 0, 0, inserted.StateID, inserted.Stage, inserted.Source, 0, 0 into @spec
		select	x.Master,  cast(q.v1 as int), t.InitStateID, s.Stage, @source,  @type, getutcdate()
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default)       x 
		cross	apply tvp.Tuplet#Of(x.House, default)                        q
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		cross	apply core.Stage#Of(t.InitStateID)                          s

		execute	core.Activity#AddBySpec      @spec=@spec, @userID=@userID;
		

		-- 2.	Add RefNbrs & RefInfos:
		declare	@clientRef E8,  @shprInfo E8,  @cneeInfo E8,  @preCourier E8,  @IDInfo E8
		,		@declaredInfo E8,  @brokerageInfo E8, @addOnSvcInfo E8;
		select	@clientRef=n.ClientRef, @shprInfo=i.ShprInfo, @cneeInfo=i.CneeInfo
		,		@preCourier=n.PreCourier, @IDInfo=i.IDInfo, @declaredInfo=i.DeclaredInfo
		,		@brokerageInfo=i.BrokerageInfo, @addOnSvcInfo=I.AddOnSvcInfo
		from	core.RefNbr#Type() n,   core.RefInfo#Type() i;

		execute	core.RefNbr#AddMIC       @idSeqs=@idSeqs, @source=@source,  @type=@type;

		execute	core.RefNbr#AddBlock  @index=2, @idSeqs=@idSeqs, @slip=@slip, @type=@clientRef;
		execute	core.RefNbr#AddBlock  @index=3, @idSeqs=@idSeqs, @slip=@slip, @type=@preCourier;
		execute	core.RefInfo#AddBlock @index=4, @idSeqs=@idSeqs, @slip=@slip, @type=@shprInfo;
		execute	core.RefInfo#AddBlock @index=5, @idSeqs=@idSeqs, @slip=@slip, @type=@cneeInfo;
		execute	core.RefInfo#AddBlock @index=6, @idSeqs=@idSeqs, @slip=@slip, @type=@declaredInfo;
		execute	core.RefInfo#AddBlock @index=7, @idSeqs=@idSeqs, @slip=@slip, @type=@IDInfo;
		execute	core.RefInfo#AddBlock @index=8, @idSeqs=@idSeqs, @slip=@slip, @type=@addOnSvcInfo;

		insert	into core._RefInfo(MatterID, Type, Info)
		select	x.Master, @brokerageInfo, b.BrokerageInfo
		from	tvp.Block#FoldT(6, @idSeqs, @slip, default, default) x
		cross	apply loc.Declared$ToBrokerage(x.House, default)	 b
		;
		
		-- 3.	Add Batch & Parcels:
		declare	@batchID I64=(@context);
		insert	shpt._Parcel
		(		ID, BatchID, RouteID, LastMilerID, SvcType, SvcZone, SvcClass,
				POA, Weight, RcvHubID, ContractID)
		select	x.Master, @batchID, isnull(d.RouteID, r.RouteID), r.CourierID, t.ID, 1, 1, 
				iif(nullif(q.v5, '') is null, r.POA, q.v5), q.v3, isnull(h.ID, 0), c.ID
		from	tvp.Block#FoldT(1, @idSeqs, @slip, default, default) x 
		cross	apply tvp.Tuplet#Of(x.House, default)                  q
		cross	apply core.Party#Type()                              e
		left	join  core.Party#Raw()                               h on h.Alias=q.v4 and h.Type=e.ZebraHub
		cross	apply tms.SvcType#For(cast(q.v2 as int), cast(q.v1 as int)) t
		outer	apply tms.SvcRoute#For(t.ID, cast(q.v5 as char(3)))  d
		cross	apply tms.SvcRoute#For(t.ID, t.FallbackPOA)          r
		cross	apply acct.Contract#For(cast(q.v1 as int), @source)  c;
		
		-- 4.	Precourier Concern
		execute	shpt.PreCourier#ConcernBlock @index=3, @slip=@slip;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [shpt].[Parcel#ReleaseByDeposit]...';


GO
--Smile
ALTER PROCEDURE [shpt].[Parcel#ReleaseByDeposit](@partyID I32, @tenancy tvp)
WITH ENCRYPTION--
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@actionID I32=(select CfmPayment from core.Action#ID());
		declare	@spec core.TransitionSpec;
		with	cteCumulation as
		(
			select	x.ID, x.MatterID, x.ChargeRaw,  x.CurrencyID 
			,		CurBalRaw
			,		Cumulation=sum(ChargeRaw) over( partition by x.PartyID, x.CurrencyID order by x.ID desc) 
			from	core.Matter#Raw()          m
			join	core.Party#Raw()           p on p.ID=m.PosterID and p.AID=@partyID
			join	acct.Ledger#Raw()          x on x.MatterID=m.ID
			cross	apply acct.Ledger#Side()   d
			cross	apply (
								select	PartyID, CurrencyID, CurBalRaw=sum(CurBalRaw)
								from	acct.Vault#Raw() 
								where	PartyID=x.PartyID and CurrencyID=x.CurrencyID
								group	by PartyID, CurrencyID
						  ) v
			cross	apply core.State#ID() k
			where	x.LedgerSide=d.AR and StateID=k.CreditLimitExceeded
		), cteSummary as
		(
			select	MatterID, Marker=(case when CurBalRaw>=0 then 0  										  
										   when CurBalRaw<0 and (Cumulation+CurBalRaw)>ChargeRaw then 0
										   else 1 end)
			
			from	cteCumulation	
			
		), cteParcelGroup as
		(
			select	MatterID, ParcelGroup=sum(Marker)
			from	cteSummary
			group	by MatterID			
		)
		insert	@spec select t.*
		from	cteParcelGroup x
		cross	apply shpt.Parcel#Tobe(x.MatterID, @roleID, @actionID) t
		where	x.ParcelGroup=0

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=0;
	

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [hub].[Parcel$SortForRackIn]...';


GO
/*
	@slip    = TrackingNbr
	@result  = Triad<ParcelID, StateID, ParcelID/1000000>
*/
-- Smile
ALTER PROCEDURE [hub].[Parcel$SortForRackIn](@slip tvp,  @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		declare	@minStage E32,     @maxStage E32;
		select	@minStage=PreMin, @maxStage=CurMax
		from	core.Stage#Boundary();

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@parcelType E8=(select Parcel from core.Matter#Type()); 

		declare	@matterID I64,  @matterType E8;
		select	@matterID=m.ID, @matterType=m.Type
		from	core.RefNbr#ScanOne(@slip, default, default) x
		join	core.Matter#Raw() m on m.ID=x.MatterID;

		if(@matterType<>@parcelType)
		begin
			declare	@parcelCnt I32=(select count(*) from core.Matter#Raw() where ID=@matterID or PID=@matterID);

			declare	@actionID I32=(select HubMeasure from core.Action#ID());
			declare	@spec core.TransitionSpec;
			insert	@spec select t.* 
			from	core.Matter#Raw()                                x
			cross	apply shpt.Parcel#Tobe(x.ID, @roleID, @actionID) t
			cross	apply core.State#ID()                            s
			where	(x.PID=@matterID or x.ID=@matterID) and x.StateID=s.TobeRackedIn

			declare	@specCnt I32=(select count(*) from @spec);
			if(@parcelCnt=@specCnt) 
				execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;
		end

		declare	@cartAction I32=(select Cart from core.Action#ID());
		declare	@cartSpec core.TransitionSpec;
		insert	@cartSpec select t.*
		from	shpt.Parcel#Tobe(@matterID, @roleID, @cartAction) t
		execute	core.Matter#TransitBySpec @spec=@cartSpec, @userID=@userID;

		select	@result=t.Tvp 
		from	core.Matter#Raw()        x		
		cross	apply tvp.Triad#Make(x.ID, x.StateID, format(x.ID % 1000000, '000000')) t
		where	x.ID=@matterID;

			
	COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [hub].[Parcel$Unified]...';


GO
/*
	@slip    = Comma[MediumParcelID]
	@context = UnityParcelID
	@result  = Duad<MatterID, MIC>
*/
-- Smile
ALTER PROCEDURE [hub].[Parcel$Unified](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@unityID I64=@context;
		declare	@rowCnt int, @expectedCnt int=(select count(*) from core.Matter#Raw() where AID=@unityID);

		declare	@actionID I32=(select Unify from core.Action#ID());
		declare	@spec core.TransitionSpec; insert @spec select t.*
		from	tvp.I64#Slice(@slip) x
		join	core.Matter#Raw()    m on m.ID=x.ID and m.AID=@unityID
		cross	apply shpt.Parcel#Tobe(m.ID, @roleID, @actionID) t;
		select	@rowCnt=@@ROWCOUNT;

		if(@rowCnt<>@expectedCnt) execute dbo.Assert#Fail @msg=N'';
	    
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

		declare	@hubCheckIn I32=(select HubCheckIn from core.Action#ID());
		declare	@specVia core.TransitionSpec; insert @specVia select t.*
		from	shpt.Parcel#Tobe(@unityID, @roleID, @hubCheckIn) t;
		execute	core.Matter#TransitBySpec @spec=@specVia, @userID=@userID, @beAffected=1;

		declare	@declaredInfo tvp;
		with	cte(text) as
		(
			select	[text()]=concat(k.Mucho, i.Info)
			from	tvp.I64#Slice(@slip)      x
			cross	apply core.RefInfo#Type() t
			join	core.RefInfo#Raw()        i on i.MatterID=x.ID and i.Type=t.DeclaredInfo
			cross	apply tvp.Spr#Const()     k
			for		xml path(N'')
		)
		select	@declaredInfo=Tvp from cte cross apply tvp.Spr#Purify(text, default);

		declare	@brkgInfo tvp;
		with	cte(text) as
		(
			select	[text()]=concat(k.Mucho, i.Info)
			from	tvp.I64#Slice(@slip)      x
			cross	apply core.RefInfo#Type() t
			join	core.RefInfo#Raw()        i on i.MatterID=x.ID and i.Type=t.BrokerageInfo
			cross	apply tvp.Spr#Const()     k
			for		xml path(N'')
		)
		select	@brkgInfo=Tvp from cte cross apply tvp.Spr#Purify(text, default);

		declare	@refInfoSlip tvp;
		select	@refInfoSlip=concat( k.Many, @unityID, k.Triad,	t.DeclaredInfo, k.Triad,  @declaredInfo,									
									 k.Many, @unityID, k.Triad, t.BrokerageInfo, k.Triad, @brkgInfo)
		from	core.RefInfo#Type() t, tvp.Spr#Const() k;
		execute	core.RefInfo#Merge @slip=@refInfoSlip;


		select	@result=t.Tvp
		from	core.RefNbr#Type() k, core.RefNbr#Raw()   x
		cross	apply tvp.Duad#Make(x.MatterID, x.Number) t
		where	x.MatterID=@unityID and x.Type=k.MIT


		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [hub].[PIP$TearOff]...';


GO
/*
	@slip = Comma<PIPID>
*/
-- AaronLiu
ALTER PROCEDURE [hub].[PIP$TearOff](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@actionID E32=(select TearOff=11400 from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@slip, @actionID=@actionID, @tenancy=@tenancy, @beAffected=1;

		with	cte as
		(
			select	m.ID, m.PID
			from	tvp.I64#Slice(@slip) x
			join	core.Matter#Raw()	 m on x.ID=m.PID
		)
		update	cte set PID=0;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [hub].[Sack$Close]...';


GO
/*
	@slip    = Block[Comma<AddedParceID>, Comma<RemovedParceID>]
	@context = Duad<SackID, Weight>
*/
-- AaronLiu
ALTER PROCEDURE [hub].[Sack$Close](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	declare	@userID I32,    @roleID I32;
	select	@userID=UserID, @roleID=RoleID
	from	loc.Tenancy#Of(@tenancy);
	declare @invalidIDs		tvp
	,		@addActionID	E32=(select AddParcelToSack		 from core.Action#ID())
	,		@removeActionID E32=(select RemoveParcelFromSack from core.Action#ID())
	,		@ids			I64Enums
	,		@spec			core.TransitionSpec;
	insert	@spec 
	output	inserted.MatterID, 1 into @ids
	select	t.* 
	from	tvp.Block#At(1, @slip, default, default) x
	cross	apply shpt.Parcel#TobeVia(x.Tvp, @roleID, @addActionID) t;

	insert	@spec 
	output	inserted.MatterID, 0 into @ids
	select	t.* 
	from	tvp.Block#At(2, @slip, default, default) x
	cross	apply shpt.Parcel#TobeVia(x.Tvp, @roleID, @removeActionID) t;

	with cteParcel as
	(
		select	p.ID
		from	tvp.Spr#Const() k
		cross	apply tvp.I64#Slice(replace(@slip, k.Block, N',')) p 
		where	p.ID>0
	), cte(text) as
	(
		select	[text()]=concat(N',', x.ID)
		from	cteParcel x
		left	join  @ids p on x.ID=p.ID
		where	p.ID is null for xml path (N'')
	)
	select	@invalidIDs=Tvp from cte cross apply tvp.Spr#Purify(text, 1);
	if		@invalidIDs<>N''
	begin
		select	@result=@invalidIDs;
		return;
	end	

	BEGIN TRY
		BEGIN	TRAN;

		-- 1.1	Update Sack Weight
		declare	@sackID I64, @weight float;
		select	@sackID=v1,  @weight=v2
		from	tvp.Duad#Of( @context, default);
		update	shpt._Sack set SackWt=@weight where ID=@sackID;

		-- 2.1	Merge Parcels into Sack:
		declare	@sackMftID I64=(select PID from core.Matter#Raw() where ID=@sackID)
		;
		with cteDiff as
		(
			select	m.ID, m.PID, NewPID=iif(x.Val=1, @sackID, @sackMftID)
			from	@ids x
			join	core.Matter#Raw() m on x.ID=m.ID
		)
		update cteDiff set PID=NewPID;

		-- 2.2	Transit Parcel:
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [hub].[Sack$Create]...';


GO
/*
	@slip    = Comma<ParceID>
	@context = Triad<ManifestID, ClrMethodID, Weight>
	@result  = Triad<SackID, SackNbr, Comma<ErrorParcelIDs>>
*/
-- AaronLiu
ALTER PROCEDURE [hub].[Sack$Create](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	-- 1.0	Check Parcel Transit
	declare	@userID I32,    @hubID I32,	  @roleID I32;
	select	@userID=UserID, @hubID=HubID, @roleID=RoleID
	from	loc.Tenancy#Of(@tenancy);

	declare @invalidIDs tvp
	,		@actionID	E32=(select AddParcelToSack from core.Action#ID())
	,		@ids		I64Array
	,		@spec		core.TransitionSpec;
	insert	@spec 
	output	inserted.MatterID into @ids
	select	t.* 
	from	shpt.Parcel#TobeVia(@slip, @roleID, @actionID) t;

	with cte(text) as
	(
		select	[text()]=concat(N',', x.ID)
		from	tvp.I64#Slice(@slip) x
		left	join @ids			 p on x.ID=p.ID
		where	p.ID is null for xml path (N'')
	)
	select	@invalidIDs=Tvp from cte cross apply tvp.Spr#Purify(text, 1);
	if		@invalidIDs<>N''
	begin
		select	@result=Tvp from tvp.Triad#Make(N'0', N'', @invalidIDs);
		return;
	end	

	BEGIN TRY
		BEGIN	TRAN;

		declare	@manifestID I64, @clrMethodID I32, @weight float;
		select	@manifestID=v1,  @clrMethodID=v2,  @weight=v3
		from	tvp.Triad#Of(@context, default);

		-- 1.1	Init Sack
		declare	@now      DT=getutcdate()
		,		@type     E8=(select Sack			from core.Matter#Type())
		,		@stage    E32=(select SackManifested from core.Stage#ID())
		,		@source   E8=(select InfoPath		from core.Source#ID())
		,		@stateID I32=(select SackManifested from core.State#ID())
		,		@sackID	 I64=next value for core.MatterSeq
		;

		insert	core._Matter
				(     ID,         PID, PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		values	(@sackID, @manifestID,   @hubID, @stateID, @stage, @source, @type,     @now);

		insert	shpt._Sack
				(    ID, BrokerID,  ClrMethodID, POA,  SackWt)
		select	@sackID, BrokerID, @clrMethodID, POA, @weight
		from	shpt.SackMft#Raw()
		where	ID=@manifestID

		insert	core._Activity
				(MatterID,  StateID,  UserID, TalliedOn)
		values	( @sackID, @stateID, @userID,      @now);

		declare	@idTexts I64Texts;
		insert	core._RefNbr
		(		MatterID, Type,  Number)
		output	inserted.MatterID, inserted.Number into @idTexts
		select	@sackID,  k.MIT, m.MIC
		from	core.RefNbr#Type() k
		cross	apply core.MIC#Emit(@sackID, @source, @type, @now) m
		;

		-- 2.1	Link Parcel's PID from SackMft to Sack:
		with cteParcel as
		(
			select	m.ID, m.PID
			from	tvp.I64#Slice(@slip) x
			join	core.Matter#Raw() m on x.ID=m.ID
		)
		update cteParcel set PID=@sackID;

		-- 2.2	Transit Parcel
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

		-- 3.1	Return Result
		select	@result=r.Tvp
		from	@idTexts x
		cross	apply tvp.Triad#Make(x.ID, x.Text, N'') r;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [hub].[Sack$Void]...';


GO
/*
	@slip = SackID
*/
-- AaronLiu
ALTER PROCEDURE [hub].[Sack$Void](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@sackActionID	E32=(select VoidSack			 from core.Action#ID());
		declare	@parcelActionID E32=(select RemoveParcelFromSack from core.Action#ID());
		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from core.Matter#TobeVia(@slip, @roleID, @sackActionID) t;
		insert	@spec select t.* from core.Matter#Raw() m
		cross	apply shpt.Parcel#Tobe(m.ID, @roleID, @parcelActionID) t
		where	m.PID=cast(@slip as bigint);

		-- 1.1	Link Parcel's PID to Original SackMft
		with cteParcel as
		(
			select	p.ID, p.PID, SackMftID=x.PID
			from	shpt.Sack#Base()  x
			join	core.Matter#Raw() p on p.PID=x.ID
			where	x.ID=cast(@slip as bigint)
		)
		update cteParcel set PID=SackMftID;

		-- 1.2	Change Sack's PID to 0
		update	core._Matter set PID=0, AID=0 where ID=cast(@slip as bigint);

		-- 2.0	Transit Sack&Parcel
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [ic].[Parcel$Bounce]...';


GO
/*
@slip	tvp=string.Join(at.Tvp.Comma, TrackingNbrs)
@result	tvp=Many[Duad<UnReturnID, TrackingNbr>]
*/
--Aimee
ALTER PROCEDURE [ic].[Parcel$Bounce](@slip tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		--	0.	Tenancy:
		declare	@userID I32,    @roleID I32,    @actionID I32;
		select	@userID=UserID, @roleID=RoleID, @actionID=Bounce
		from	loc.Tenancy#Of(@tenancy), core.Action#ID();

		--	1.	Ids
		declare @ids I64Array;
		insert	@ids select distinct m.MatterID
		from	tvp.Comma#Slice(@slip)        x
		cross	apply core.MIC#IdOf(x.Piece)  m

		--	3.	Parcel Transit
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from @ids x
		cross	apply shpt.Parcel#Tobe(x.ID, @roleID, @actionID) t
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;
		
		--	4.	Result
		with cteResult(text) as
		(
			select	[text()]=concat(k.Many, x.Piece)
			from	tvp.Comma#Slice(@slip)       x
			outer	apply core.MIC#IdOf(x.Piece) m
			cross	apply tvp.Spr#Const()        k
			where	not exists(select MatterID from @spec where MatterID=m.MatterID)
			for		xml path(N'')
		)
		select	@result=Tvp from cteResult cross apply tvp.Spr#Purify(text, default);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [ic].[Sack#CreateForImport]...';


GO
/*
	@slip    = Entry[Triad<PickupNbr, PickupedOn, Many[Duad<ParcelID, Weight>]>]
	@context = ManifestID
*/
-- Daxia
ALTER PROCEDURE [ic].[Sack#CreateForImport](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	BEGIN TRY
		BEGIN	TRAN;
		
		-- 0.	Tenancy & Contexts:
		declare	@userID I32,    @hubID I32,	  @roleID I32;
		select	@userID=UserID, @hubID=HubID, @roleID=RoleID    --HubID is IC Site
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@sackMftID I64=@context, @clrMethodID I32=0, @weight float=0;

		-- 1	Init Matters & Sacks
		declare	@now      DT=getutcdate()
		,		@type     E8=(select Sack			 from core.Matter#Type())
		,		@stage    E32=(select SackManifested from core.Stage#ID())
		,		@source   E8=(select InfoPath		 from core.Source#ID())
		,		@stateID I32=(select SackManifested  from core.State#ID())
		,		@sackID	 I64=next value for core.MatterSeq
		;
		
		-- 1.1	Init Matters
		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Entry@Count(@slip));

		insert	core._Matter
				( ID,        PID, PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		select	x.ID, @sackMftID,   @hubID, @stateID, @stage, @source, @type,     @now
		from	@idSeqs x;
		
		
		-- 1.2	Init Sacks
		declare	@poa char(3), @brokerID I32;
		select	@poa=POA,     @brokerID=BrokerID from shpt.SackMft#Raw() where ID=@sackMftID;

		insert	shpt._Sack
				( ID,  BrokerID,  ClrMethodID,  POA,  SackWt)
		select	  ID, @brokerID, @clrMethodID, @poa, @weight
		from	@idSeqs ;
		

		-- 1.3	Add Activities : 
		insert	core._Activity
				(MatterID,  StateID,  UserID, TalliedOn)
		select	       ID, @stateID, @userID, @now from @idSeqs ;
		
		-- 1.4	Add RefNbrs - Mic : 
		insert	core._RefNbr (MatterID, Type, Number) select x.ID, k.MIT, m.MIC
		from	@idSeqs x cross apply core.RefNbr#Type() k cross apply core.MIC#Emit(x.ID, @source, @type, @now) m
		;
		
		-- 1.5	Add RefNbrs - ClientRef : 
		insert	core._RefNbr (MatterID, Type, Number) select x.ID, k.ClientRef, s.v1
		from	@idSeqs x cross apply core.RefNbr#Type() k
		join	tvp.Triad#Slice(@slip, default, N'	;	') s on s.Seq=x.Seq
		;

		-- 2.1	Link Parcel's PID from SackMft to Sack:
		declare	@ids I64Array;
		with cteMatter as
		(
			select	m.ID, m.PID, SackID=x.ID
			from	@idSeqs x
			join	tvp.Triad#Slice(@slip, default, N'	;	') s on s.Seq=x.Seq
			cross	apply tvp.Duad#Slice(s.v3, default, default) p
			join	core.Matter#Raw() m on x.ID=p.v1
		)
		update cteMatter set PID=SackID
		output	inserted.ID into @ids
		;
		with cteParcel as
		(
			select	ID=p.v1, MeasureWt=cast(p.v2 as real)
			from	@idSeqs x
			join	tvp.Triad#Slice(@slip, default, N'	;	') s on s.Seq=x.Seq
			cross	apply tvp.Duad#Slice(s.v3, default, default) p
		)
		--update	cteParcel set Weight=NewWeight;
		update	o set o.Weight=n.MeasureWt
		from	shpt._Parcel o join cteParcel n on o.ID=n.ID;

		---- 2.2	Transit Parcel
		declare	@parcelActionID E32=(select ImportOutgateManifest from core.Action#ID())
		,		@spec           core.TransitionSpec;
		with cte(text) as
		(
			select	[text()]=concat(N',', x.ID) from @ids x
			where	x.ID is null for xml path (N'')
		)
		insert	@spec select t.* from cte     x
		cross	apply tvp.Spr#Purify(text, 1) i
		cross	apply shpt.Parcel#TobeVia(i.Tvp, @roleID, @parcelActionID) t;

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;


		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [svc].[Flight$Transit]...';


GO
/*
@slip    = at.Tvp.Duad.Join(ActionID, at.tvp.Trio.join(UtcTime, UtcOffset, UtcPlaceID))
@context = at.Tvp.Triad.Join(MatterID, ETD, ETA)			
*/
-- Aimee, Smile
ALTER PROCEDURE [svc].[Flight$Transit](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@actionID I32, @utcStamp tvp;
		select	@actionID=v1,  @utcStamp=v2
		from	tvp.Duad#Of(@slip, default);

		declare	@flightID I64, @etd datetime2(2), @eta datetime2(2)
		select	@flightID=v1
		,		@etd=isnull(nullif(v2, ''), dbo.DT@Empty())
		,		@eta=isnull(nullif(v3, ''), dbo.DT@Empty())
		from	tvp.Triad#Of(@context, default) x

		declare	@spec core.TransitionSpec; insert @spec select t.* 
		from	core.Matter#Tobe(@flightID, @roleID, @actionID) t;
		execute	core.Matter#CascadeBySpecWithStamp @spec=@spec, @userID=@userID, @utcStamp=@utcStamp;
		
		with flightCte as
		(
			select	ETD, ETA 
			from	core.Action#ID() k, tms.Flight#Raw() f 
			where	f.ID=@flightID 
			and		@actionID in (k.CfmFlightDepartureDelayed, k.CfmCustomsHeld)
		)
		update	flightCte set ETD=@etd, ETA=@eta ;
	

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [svc].[HubManifest$ImportForUSPS]...';


GO
/*
@slip    = Many[Triad<MIC, PostCourier, LocalTime>];
*/
--Smile
ALTER PROCEDURE [svc].[HubManifest$ImportForUSPS](@slip tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@ids I64Array;
		with cteSlip as
		(
			select	i.MatterID, Type=k.PostCourier, n.Number
			from	tvp.Triad#Slice(@slip, default, default)     x
			cross	apply loc.RefNbr#Cast(x.v1)                  m
			cross	apply loc.RefNbr#Cast(x.v2)                  n
			cross	apply core.RefNbr#Type()                     k
			cross	apply core.RefNbr#IdOfFirst(m.Number, k.MIT) i	
			join	shpt.Parcel#Raw()                            p on p.ID=i.MatterID
			where	p.RouteID in(select ID from tms.Route#Raw() where BrokerID=7004)
		)
		merge	into core._RefNbr as o using cteSlip as n
		on		(o.MatterID=n.MatterID and o.Type=n.Type)
		when	    matched and n.Number>N'' then update set o.Number=n.Number
		when	not matched	and n.Number>N'' then insert (  MatterID,   Type,   Number)
												  values (n.MatterID, n.Type, n.Number)
		output	inserted.MatterID into @ids;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);	

		declare	@actionID  I32=(select ImportHubManifest from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from @ids
		cross	apply shpt.Parcel#Maybe(ID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;
		
		declare	@exeSlip tvp;
		with cteStamp(Text) as
		(
			select	[text()]=concat(k.Many, i.MatterID, k.Triad, ToStateID, k.Triad
							 ,		dateadd(hour, -t.UtcOffset, x.v3), k.Trio, t.UtcOffset, k.Trio, t.ID)
			from	tvp.Triad#Slice(@slip, default, default) x		
			cross	apply core.MIC#IdOf(x.v1)                i
			join	@spec                                    s on s.MatterID=i.MatterID
			join	shpt.Parcel#Base()                       p on i.MatterID=p.ID
			join	core.Tenant#Raw()                        t on t.ID=p.RcvHubID
			cross	apply tvp.Spr#Const()                    k 
			for	xml path(N'')		
		)
		select	@exeSlip=Tvp from cteStamp cross apply tvp.Spr#Purify(text, default);
		execute core.RefStamp#Merge @slip=@exeSlip;

		select	@result=(select count(*) from @spec);

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [svc].[HubManifest$ImportToSurrender]...';


GO
/*
@slip    = idsInCsv;
@context = Quad<RcvHubID, POA, MawbNbr, LocalOutgatedOn>;
@result  = ParcelCnt
*/
--Smile
ALTER PROCEDURE [svc].[HubManifest$ImportToSurrender](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@parcelCnt int=(select count(*) from tvp.I64#Slice(@slip));
		declare	@validCnt int;
		declare	@actionID  I32=(select ImportHubManifest from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from tvp.I64#Slice(@slip)      x
		cross	apply shpt.Parcel#Maybe(ID, @roleID, @actionID) t;
		select	@validCnt=@@ROWCOUNT;

		if(@parcelCnt>@validCnt)
			execute dbo.Assert#Fail @msg=N'Please Check the Parcel Stage.';

		declare	@now       DT=getutcdate();
		declare	@stateID   I32=(select SackMftSurrendered from core.State#ID());		
		declare	@source    E8=(select  InfoPath from core.Source#ID());	
		declare	@type      E8=(select  SackMft  from core.Matter#Type());
		declare	@stage     E32=(select Stage    from core.Stage#Of(@stateID));
		declare	@sackMftID I64=next value for core.MatterSeq;
		declare	@hubID int,  @utcOffset smallint, @utcTime DT;
		select	@hubID=x.v1, @utcOffset=t.UtcOffset
		,		@utcTime=dateadd(hour, -t.UtcOffset, x.v4)
		from	tvp.Quad#Of(@context, default) x
		join	core.Tenant#Raw()              t on t.ID=cast(x.v1 as int);
	    
		insert	core._Matter
				(ID,         PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		values	(@sackMftID,   @hubID, @stateID, @stage, @source, @type,     @now);

		insert	shpt._SackMft
				(       ID, POD, POA, MawbNbr, FlightNbr)
		select	@sackMftID, '',  v2,  v3,      ''
		from	tvp.Quad#Of(@context, default)

		insert	core._Activity
				(  MatterID,  StateID,  UserID, TalliedOn)
		values	(@sackMftID, @stateID, @userID,      @now);

		insert	core._RefStamp(MatterID,  StateID,  UtcTime,  UtcOffset, UtcPlaceID)
		values	            (@sackMftID, @stateID, @utcTime, @utcOffset, @hubID);
		execute	core.Matter#TransitBySpecWithPID @spec=@spec, @userID=@userID, @pid=@sackMftID;

		declare	@utcStamp tvp=(select Tvp from tvp.Trio#Make(@utcTime, @utcOffset, @hubID));
		execute	core.RefStamp#MergeBySpec @spec=@spec, @utcStamp=@utcStamp;
		
		select	@result=@validCnt;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [svc].[Parcel$CfmRelease]...';


GO
/*
@slip    tvp=Many[Duad<TenantID, ClientRefNbr>]
@result  tvp=Duad<Many[Quad<ID,ClientRefNbr, ServiceType,Stage>],Many[Quad<ID,ClientRefNbr, ServiceType,Stage>]>
*/
--Daxia
ALTER PROCEDURE [svc].[Parcel$CfmRelease](@slip tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;
		
		declare	@userID I32,    @roleID I32,    @actionID I32;
		select	@userID=UserID, @roleID=RoleID, @actionID=SourceConfirm
		from	loc.Tenancy#Of(@tenancy), core.Action#ID();

		--	1.Parcel Transit
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* 
		from	tvp.Duad#Slice(@slip, default, default) x
		join	core.RefNbr#Raw()      r on r.Number=x.v2
		join	shpt.Parcel#Base()     p on p.ID=r.MatterID and p.SiteID=cast(x.v1 as int)
		cross	apply shpt.Parcel#Tobe(r.MatterID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		declare	@clientRef E8=(select ClientRef from core.RefNbr#Type());
		declare	@failure tvp;
		with cteResult(text) as
		(
			select	[text()]=concat(k.Many, c.MatterID, k.Quad, c.Number, k.Quad, p.SvcType, k.Quad, p.Stage)
			from	tvp.Duad#Slice(@slip, default, default) x
			join	core.RefNbr#Raw()     c on c.Number=x.v2 and c.Type=@clientRef
			join	shpt.Parcel#Base()    p on p.ID=c.MatterID
			cross	apply tvp.Spr#Const() k
			where	not exists(select MatterID from @spec where MatterID=c.MatterID)
			for		xml path(N'')
		)
		select	@failure=Tvp from cteResult cross apply tvp.Spr#Purify(text, default);
		with cteSuccess(text) as
		(
			select	[text()]=concat(k.Many, x.MatterID, k.Quad, c.Number, k.Quad, p.SvcType, k.Quad, p.Stage)
			from	@spec                 x
			join	core.RefNbr#Raw()     c on c.MatterID=x.MatterID and c.Type=@clientRef
			join	shpt.Parcel#Base()    p on p.ID=x.MatterID
			cross	apply tvp.Spr#Const() k
			for		xml path(N'')
		)
		select	@result=r.Tvp from cteSuccess 
		cross	apply tvp.Spr#Purify(text, default)  x
		cross	apply tvp.Duad#Make(x.Tvp, @failure) r
		;

		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [svc].[Parcel$Classified]...';


GO
/*
@slip    = Mucho[Triad<SkuID, CmdyInfo, LineInfo>]
@context = MatterID
*/
--Aimee
ALTER PROCEDURE [svc].[Parcel$Classified](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@exeSlip tvp=
		(
			select	Tvp   from core.RefInfo#Type() k
			cross	apply tvp.Triad#Make(@context, k.BrokerageInfo, @slip)
		);
		execute	core.RefInfo#Merge @slip=@exeSlip;

		declare	@actionID I32=(select DetermineCmdy from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@context, @actionID=@actionID, @tenancy=@tenancy;
	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [svc].[Parcel$ImportBrkgInfo]...';


GO
/*
@slip    = Duad[ParcelID, BrkgInfo]
*/
--Smile
ALTER PROCEDURE [svc].[Parcel$ImportBrkgInfo](@slip tvp,  @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@ids dbo.I64Array;
		with cteSlip as
		(
			select	MatterID=cast(v1 as bigint), Type=k.BrokerageInfo, Info=v2
			from	tvp.Duad#Slice(@slip, default, default) x
			cross	apply core.RefInfo#Type()               k
		)
		merge	core._RefInfo as o using cteSlip as n
		on		(o.MatterID=n.MatterID and o.Type=n.Type)
		when	matched and len(n.Info)=0     then delete
		when	matched and o.Info<>n.Info    then update set Info=n.Info
		when	not matched and len(n.Info)>0 then insert (  MatterID,   Type,   Info)
												   values (n.MatterID, n.Type, n.Info)
		output inserted.MatterID into @ids;
		;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@actionID I32=(select TranslateForBrokerage from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.*
		from	@ids  x
		cross	apply shpt.Parcel#Tobe(x.ID, @roleID, @actionID) t
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;
	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [svc].[Parcel$ImportClassified]...';


GO
/*
@slip    = Duad[ParcelID, BrkgInfo]
*/
--Smile
ALTER PROCEDURE [svc].[Parcel$ImportClassified](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@ids dbo.I64Array;
		with cteSlip as
		(
			select	MatterID=cast(v1 as bigint), Type=k.BrokerageInfo, Info=v2
			from	tvp.Duad#Slice(@slip, default, default) x
			cross	apply core.RefInfo#Type()               k
		)
		merge	core._RefInfo as o using cteSlip as n
		on		(o.MatterID=n.MatterID and o.Type=n.Type)
		when	matched and len(n.Info)=0     then delete
		when	matched and o.Info<>n.Info    then update set Info=n.Info
		when	not matched and len(n.Info)>0 then insert (  MatterID,   Type,   Info)
												   values (n.MatterID, n.Type, n.Info)
		output inserted.MatterID into @ids;
		;

		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@actionID I32=(select DetermineCmdy from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.*
		from	@ids  x
		cross	apply shpt.Parcel#Tobe(x.ID, @roleID, @actionID) t
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=1;

	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [svc].[Parcel$MergeBrkgInfo]...';


GO
/*
@slip    = Mucho[Triad<SkuID, CmdyInfo, LineInfo>]
@context = MatterID
*/
--Daxia, PeterHo, Aimee
ALTER PROCEDURE [svc].[Parcel$MergeBrkgInfo](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		declare	@exeSlip tvp=
		(
			select	Tvp   from core.RefInfo#Type() k
			cross	apply tvp.Triad#Make(@context, k.BrokerageInfo, @slip)
		);
		execute	core.RefInfo#Merge @slip=@exeSlip;

		declare	@actionID I32=(select TranslateForBrokerage from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@context, @actionID=@actionID, @tenancy=@tenancy;
	
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [svc].[Parcel$RequeueBrkgApi]...';


GO
--Daxia
ALTER PROCEDURE [svc].[Parcel$RequeueBrkgApi](@slip tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		declare	@actionID I32=(select RequeueBrkgApi from core.Action#ID());
		execute	svc.Parcel$Transit @idsInCsv=@slip, @actionID=@actionID, @tenancy=@tenancy;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [svc].[Parcel$VoidViaMic]...';


GO
/*
@slip    tvp=Many[Duad<TenantID, ClientRefNbr>]
@result  tvp=Duad<Many[Quad<ID,ClientRefNbr, ServiceType,Stage>],Many[Quad<ID,ClientRefNbr, ServiceType,Stage>]>
*/
--Daxia
ALTER PROCEDURE [svc].[Parcel$VoidViaMic](@slip tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET	XACT_ABORT ON;
	BEGIN TRY
		BEGIN TRAN;

		declare	@userID I32,    @roleID I32,    @actionID I32;
		select	@userID=UserID, @roleID=RoleID, @actionID=VoidParcel
		from	loc.Tenancy#Of(@tenancy), core.Action#ID();

		--	1.Parcel Transit
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* 
		from	tvp.Duad#Slice(@slip, default, default) x
		join	core.RefNbr#Raw()      r on r.Number=x.v2
		join	shpt.Parcel#Base()     p on p.ID=r.MatterID and p.SiteID=cast(x.v1 as int)
		cross	apply shpt.Parcel#Tobe(r.MatterID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID;

		declare	@clientRef E8=(select ClientRef from core.RefNbr#Type());
		declare	@voidInfo  E8=(select VoidInfo  from core.RefInfo#Type());
		--	2.  Insert VoidInfo
		with cteVoidInfo as
		(
			select	r.MatterID, Info=Number
			from	@spec             x
			join	core.RefNbr#Raw() r on r.MatterID=x.MatterID and r.Type=@clientRef
		)
		insert	into core._RefInfo(MatterID, Type,      Info)
		select					   MatterID, @voidInfo, Info
		from	cteVoidInfo;

		-- 3.	delete ClientRefNbr		
		delete	from core._RefNbr 
		where	Type=@clientRef	and MatterID in (select MatterID from @spec)
		;
		
		declare	@failure tvp;
		with cteResult(text) as
		(
			select	[text()]=concat(k.Many, c.MatterID, k.Quad, c.Number, k.Quad, p.SvcType, k.Quad, p.Stage)
			from	tvp.Duad#Slice(@slip, default, default) x
			join	core.RefNbr#Raw()     c on c.Number=x.v2 and c.Type=@clientRef
			join	shpt.Parcel#Base()    p on p.ID=c.MatterID
			cross	apply tvp.Spr#Const() k
			where	not exists(select MatterID from @spec where MatterID=c.MatterID)
			for		xml path(N'')
		)
		select	@failure=Tvp from cteResult cross apply tvp.Spr#Purify(text, default);
		with cteSuccess(text) as
		(
			select	[text()]=concat(k.Many, x.MatterID, k.Quad, c.Number, k.Quad, p.SvcType, k.Quad, p.Stage)
			from	@spec                 x
			join	core.RefNbr#Raw()     c on c.MatterID=x.MatterID and c.Type=@clientRef
			join	shpt.Parcel#Base()    p on p.ID=x.MatterID
			cross	apply tvp.Spr#Const() k
			for		xml path(N'')
		)
		select	@result=r.Tvp from cteSuccess 
		cross	apply tvp.Spr#Purify(text, default)  x
		cross	apply tvp.Duad#Make(x.Tvp, @failure) r
	
		COMMIT TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [svc].[SackMft$Import]...';


GO
/*
	@slip    = Many[Duad<MIC, TrkNbr>];
	@context = Quad<HubID, POA, BrokerID, Mawb>
*/
-- AaronLiu, Eva:For Special POA(TPE,HKG), no need postcourierNbr still can transit
ALTER PROCEDURE [svc].[SackMft$Import](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	BEGIN TRY
		BEGIN	TRAN;

		-- 1.1	Init SackMft
		declare	@userID I32,    @roleID I32;
		select	@userID=UserID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare	@hubID I32, @pOA char(3), @brokerID I32, @mawbNbr char(11)
		select	@hubID=v1,  @pOA=v2,      @brokerID=v3,  @mawbNbr=v4
		from	tvp.Quad#Of(@context, default)

		declare	@now        DT=getutcdate();
		declare	@type       E8=(select SackMft        from core.Matter#Type());
		declare	@stage      E32=(select SackManifested from core.Stage#ID());
		declare	@source     E8=(select InfoPath       from core.Source#ID());
		declare	@stateID   I32=(select SackMftCreated from core.State#ID());
		declare	@sackMftID I64=next value for core.MatterSeq;

		insert	core._Matter
				(ID,         PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		values	(@sackMftID,   @hubID, @stateID, @stage, @source, @type,     @now);

		insert	shpt._SackMft
				(       ID,  POA, POD,  BrokerID,  MawbNbr, FlightNbr)
		select	@sackMftID, @pOA, N'', @brokerID, @mawbNbr,       N''
		from	tvp.Triad#Of(@context, default)

		insert	core._Activity
				(  MatterID,  StateID,  UserID, TalliedOn)
		values	(@sackMftID, @stateID, @userID,      @now);

		-- 2.1	Merge PostCourier
		declare	@ids I64Array;
		/*BEGIN--For Special POA(TPE,HKG), no need postcourierNbr still can transit*/
		declare	@refNbrSlip tvp;
		with	cte(text) as
		(
			select	[text()]=concat(k.Many, i.MatterID, k.Triad, t.PostCourier, k.Triad, x.v2)
			from	tvp.Duad#Slice(@slip, default, default) x
			cross	apply loc.RefNbr#Cast(x.v1)   m
			cross	apply core.MIC#IdOf(m.Number) i
			cross	apply core.RefNbr#Type() t
			cross	apply tvp.Spr#Const()    k
			for		xml path(N'')
		)
		select	@refNbrSlip=Tvp from cte cross apply tvp.Spr#Purify(text, default);
		exec	core.RefNbr#Merge @slip=@refNbrSlip;

		with	cte as
		(
			select	MatterID=cast(x.v1 as bigint)
			from	tvp.Triad#Slice(@refNbrSlip, default, default) x
		)
		insert	@ids select MatterID from cte
		/*END--For Special POA(TPE,HKG), no need postcourierNbr still can transit*/
		--with cteSlip as
		--(
		--	select	i.MatterID, Type=k.PostCourier, n.Number
		--	from	tvp.Duad#Slice(@slip, default, default) x
		--	cross	apply loc.RefNbr#Cast(x.v1)   m
		--	cross	apply loc.RefNbr#Cast(x.v2)   n
		--	cross	apply core.MIC#IdOf(m.Number) i
		--	cross	apply core.RefNbr#Type()      k
		--)
		--merge	into core._RefNbr as o using cteSlip as n
		--on		(o.MatterID=n.MatterID and o.Type=n.Type)
		--when	    matched and n.Number>N'' then update set o.Number=n.Number
		--when	not matched	and n.Number>N'' then insert (  MatterID,   Type,   Number)
		--										  values (n.MatterID, n.Type, n.Number)
		--output	inserted.MatterID into @ids;

		-- 2.2	Transit Parcel To ICManifested
		declare	@actionID I32=(select ICManifest from core.Action#ID());
		declare	@spec core.TransitionSpec;
		insert	@spec select t.* from @ids
		cross	apply shpt.Parcel#Maybe(ID, @roleID, @actionID) t;
		execute	core.Matter#TransitBySpecWithPID @spec=@spec, @userID=@userID, @pid=@sackMftID;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [xpd].[Sack$CreateForXpd]...';


GO
/*
	@slip    = Many[Triad<SackNbr, Weight, string.Join(at.Spr.Comma, Mics)>]
	@context = Duad<SackMftID, ClrMethodID>
	@result  = Many[Duad<SackID, SackNbr>]
*/
-- Daxia
ALTER PROCEDURE [xpd].[Sack$CreateForXpd](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	BEGIN TRY
		BEGIN	TRAN;
		
		-- 1.0	Check Parcel Transit
		declare	@userID I32,    @siteID I32,    @roleID I32;
		select	@userID=UserID, @siteID=SiteID, @roleID=RoleID
		from	loc.Tenancy#Of(@tenancy);

		declare @actionID E32=(select ImportOutgateManifest from core.Action#ID())

		declare	@sackMftID I64, @clrMethodID I32;
		select	@sackMftID=v1,  @clrMethodID=v2
		from	tvp.Duad#Of(@context, default);

		-- 1.1	Init Sack
		declare	@now      DT=getutcdate()
		,		@type     E8 =(select Sack			from core.Matter#Type())
		,		@stage    E32=(select SackManifested from core.Stage#ID())
		,		@stateID  I32=(select SackManifested from core.State#ID())
		;
		declare	@source E8,     @brokerID I32,      @poa char(3);
		select	@source=Source, @brokerID=BrokerID, @poa=POA
		from	shpt.SackMft#Base() where ID=@sackMftID

		declare	@idSeqs I64Seqs; insert @idSeqs(ID, Seq)
		select	next value for core.MatterSeq, Nbr
		from	dbo.Nbr#Emit(tvp.Many@Count(@slip));

		insert	core._Matter
		(		ID,          PID, PosterID,  StateID,  Stage,  Source,  Type, PostedOn)
		select	x.ID, @sackMftID,  @siteID, @stateID, @stage, @source, @type,     @now
		from	@idSeqs x;

		insert	shpt._Sack
		(		  ID,  BrokerID,  ClrMethodID,  POA, SackWt)
		select	x.ID, @brokerID, @clrMethodID, @poa, s.v2
		from	@idSeqs x
		join	tvp.Triad#Slice(@slip, default, default) s on s.Seq=x.Seq;

		insert	core._Activity
		(		MatterID,  StateID,  UserID, TalliedOn)
		select	      ID, @stateID, @userID,      @now
		from	@idSeqs;
		
		-- 1.2	Insert Mic
		insert	core._RefNbr
		(		MatterID, Type,  Number)
		select	    x.ID, k.MIT, m.MIC
		from	@idSeqs x cross apply core.RefNbr#Type() k
		cross	apply core.MIC#Emit(x.ID, @source, @type, @now) m;
		-- 1.3	Insert RefNbr
		declare	@idTexts I64Texts;
		insert	core._RefNbr
		(		MatterID, Type,  Number)
		output	inserted.MatterID, inserted.Number into @idTexts
		select	    x.ID, k.ClientRef, s.v1
		from	@idSeqs x cross apply core.RefNbr#Type() k
		join	tvp.Triad#Slice(@slip, default, default) s on s.Seq=x.Seq
		;

		-- 2.1	Link Parcel's PID from SackMft to Sack:
		with cteParcel as
		(
			select	m.ID, m.PID, SackID=x.ID 
			from	@idSeqs x
			join	tvp.Triad#Slice(@slip, default, default) s on s.Seq=x.Seq
			cross	apply tvp.Comma#Slice(s.v3)                          i
			cross	apply core.RefNbr#ScanOne(i.Piece, default, default) r
			join	core.Matter#Raw() m on m.ID=r.MatterID and m.PID=0
		)
		update cteParcel set PID=SackID;


		-- 2.2	Transit Parcel
		declare	@ids I64Array; insert @ids(ID) select m.MatterID
		from	tvp.Triad#Slice(@slip, default, default)             x
		cross	apply tvp.Comma#Slice(x.v3)                          i
		cross	apply core.RefNbr#ScanOne(i.Piece, default, default) m
		;
		declare	@idCommas tvp=(select Tvp from tvp.I64#Join(@ids));

		declare	@spec core.TransitionSpec; insert @spec select t.* 
		from	shpt.Parcel#TobeVia(@idCommas, @roleID, @actionID) t;

		execute	core.Matter#TransitBySpec @spec=@spec, @userID=@userID, @beAffected=0;

		-- 3.1	Return Result
		with cteResult(text) as
		(
			select	[text()]=concat(k.Many, x.ID, k.Duad, x.Text)
			from	tvp.Spr#Const() k, @idTexts x
			for		xml path(N'')
		)
		select	@result=x.Tvp from cteResult 
		cross	apply tvp.Spr#Purify(text, default)  x
		;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [hub].[Parcel$MeasureForUSD]...';


GO
/*
	@slip    = Comma<ParcelNbr>
	@context = Quad<Weight, Length, Width, Height>
	@result  = Pair<ParcelID, IsOverlabel>
*/
-- Daxia
ALTER PROCEDURE [hub].[Parcel$MeasureForUSD](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		
		--	0	Tenancy
		declare	@userID I32,    @roleID I32,    @hubID I32;
		select	@userID=UserID, @roleID=RoleID, @hubID=HubID from loc.Tenancy#Of(@tenancy)
		;
		--	1	Scan RefNbr --From auto.ParcelMeasure
		-- Should Stage between PreMin and CurMax?
		declare	@minStage E32,    @maxStage E32;
		select	@minStage=PreMin, @maxStage=Ended from core.Stage#Boundary()
		;
		declare	@matterID I64=(select MatterID from core.RefNbr#ScanMulti(@slip, @minStage, @maxStage));
		exec	core.Activity#OnceHubAccepted @matterID=@matterID, @userID=@userID
		;
		--	2	Init FedEx
		declare	@measureWt real=(select cast(q.v1 as real) from tvp.Quad#Of(@context, N',') q);
		declare	@source dbo.E8,   @newSvcClass dbo.E8,     @isOverLabel bit;
		select	@source=p.Source, @newSvcClass=c.SvcClass, @isOverLabel=iif(p.SvcClass=c.SvcClass, 0, 1)
		from	shpt.Parcel#Base() p cross apply tms.SvcClass#For(p.SvcType, @measureWt) c
		where	p.ID=@matterID
		;
		if(@isOverLabel=1)
		begin
			declare	@svcClassLW dbo.E8=13, @svcClassPS dbo.E8=14
			;
			--	2	Check All PostCourier
			declare	@postCourierSpec as table
			(
				MatterID    dbo.I64     NOT NULL,
				SvcClass    tinyint     NOT NULL,
				Type        dbo.E8      NOT NULL,--RefNbr Type
				PostCourier varchar(40) NOT NULL
			);
			-- HACK SvcClass
			insert	@postCourierSpec
			(		 MatterID,   Type, PostCourier, SvcClass)
			select	@matterID, x.Type, x.Number,    iif(x.Type=t.PostCourierPrevious, @svcClassLW, @svcClassPS)
			from	core._RefNbr x cross apply core.RefNbr#Type() t
			where	x.MatterID=@matterID and x.Type in(t.PostCourierPrevious, t.PostCourierOriginal)
			;
			if not exists (select PostCourier from @postCourierSpec where SvcClass=@newSvcClass)
			begin
				--	2.1	Init Pic Spec
				declare	@picSpec tms.PicSpec; insert @picSpec
				(		MeasuredWt,   SvcType,   Zip3,   Plus2)
				select	@measureWt, p.SvcType, z.Zip3, z.Plus2
				from	shpt.Parcel#Base() p 
				cross	apply tms.ZoneCode#For(p.ZoneCode) z
				where	p.ID=@matterID
				;
				--	2.2	Emit PICs:
				declare	@picResult tms.PicResult; insert @picResult
				exec	tms.Pic#Emit @source=@source, @picSpec=@picSpec
				;
				-- HACK TYPE
				insert	@postCourierSpec
				(		 MatterID,     SvcClass, PostCourier,   Type)
				select	@matterID, @newSvcClass, t.TrackingNbr, iif(@newSvcClass=@svcClassLW, r.PostCourierPrevious, r.PostCourierOriginal)
				from	@picResult x cross apply core.RefNbr#Type() r
				cross	apply tms.TrackingNbr#Make(x.SvcCode, x.MailerID, x.MailerSeq, @matterID) t
				;

				--	2.3	Insert PostCourierPre Or PostCourierOrg
				insert	core._RefNbr
				(		MatterID, Type, Number) 
				select	MatterID, Type, PostCourier
				from	@postCourierSpec x where SvcClass=@newSvcClass
				;
			end

			--	2.4	Upd PostCourier
			update	x set x.Number=p.PostCourier
			from	core._RefNbr     x cross apply core.RefNbr#Type() t
			join	@postCourierSpec p on p.MatterID=x.MatterID and p.SvcClass=@newSvcClass
			where	x.MatterID=@matterID and x.Type=t.PostCourier
			;
			
			--	2.5	Insert AddOnSvc
			insert	core._AddOnSvc
			(		MatterID, OperatorID, Type,        StartedOn,    EndedOn)
			select	@matterID,     0,   k.OverLabel, getutcdate(), dbo.DT@Empty()
			from	core.AddOnSvc#Type() k

		end
		
		--	3	Upd Weight and SvcClass
		;with cteParcel as
		(
			select	ID, q.v1,   q.v2,   q.v3,  q.v4
			from	tvp.Quad#Of(@context, N',') q, shpt.Parcel#Raw() where ID=@matterID
		)
		update	o set RcvHubID=@hubID, Weight=v1, Length=v2, Width=v3, Height=v4, o.SvcClass=@newSvcClass
		from	shpt._Parcel o join cteParcel n on o.ID=n.ID
		;
		exec	shpt.Parcel#Measure @matterID=@matterID, @tenancy=@tenancy
		;
		select	@result=r.Tvp from tvp.Pair#Make(@matterID, @isOverLabel) r
		;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [svc].[Tenancy$AddSite]...';


GO
/*
@slip = Field<PID, AID, Alias, Contact, UtcPlace, UtcOffset>
        Contact=Many[Duad<type, ContactTvp>]
@context=Source
*/
--Smile
ALTER PROCEDURE [svc].[Tenancy$AddSite](@slip tvp, @context tvp, @result tvp out)
WITH ENCRYPTION--
AS
BEGIN
	SET NOCOUNT ON;

	declare	@id I64, @type E32=(select TenantSite from core.Party#Type());
	exec	core.Tenant#Add @id=@id out, @source=@context, @type=@type, @slip=@slip;
	select	@result=@id;
END
GO
PRINT N'Altering [svc].[Tenancy$AddUser]...';


GO
/*
@slip   =at.Tvp.Field.Join(PID, AID, Alias, Contact, UserRoles)
@context=Source
*/
--Smile
ALTER PROCEDURE [svc].[Tenancy$AddUser](@slip tvp, @context tvp, @result tvp out)
WITH ENCRYPTION--
AS
BEGIN
	SET NOCOUNT ON;

	declare	@id I64, @type E32=(select Operator from core.Party#Type());
	exec	core.User#Add @id=@id out, @source=@context, @type=@type, @slip=@slip;
	select	@result=@id;
END
GO
PRINT N'Altering [ic].[Parcel$Outgated]...';


GO
/*
@slip		tvp=Entry[Triad<PickupNbr, PickupedOn, Many[Duad<ParcelID, Weight>]>]
@context	tvp=POA
*/
--Daxia
ALTER PROCEDURE [ic].[Parcel$Outgated](@slip tvp, @context tvp, @tenancy tvp)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;

		--	0.	Tenancy:
		declare	@userID I32,    @roleID I32,    @actionID I32;
		select	@userID=UserID, @roleID=RoleID, @actionID=Bounce
		from	loc.Tenancy#Of(@tenancy), core.Action#ID();
		
		declare	@pod char(3)=@context
		,		@poa char(3)=@context;

		--	1.	Add SackMft
		declare	@sackMftID I64, @mawb tvp=N'', @flightNbr tvp=N'';
		--at.Quad.Of(POD, POA, Mawb, FlightNbr)
		declare	@sackMftContext tvp=(select Tvp from tvp.Quad#Make(@pod, @poa, @mawb, @flightNbr));
		execute	shpt.SackMft#Create @id=@sackMftID out, @context=@sackMftContext, @tenancy=@tenancy;

		--	2.	Add Sack
		exec	ic.Sack#CreateForImport @slip=@slip, @context=@sackMftID, @tenancy=@tenancy;

		--	3.	Add SackLoad
		--	4.	Add SackTransloaded

		--	5.1	Bill -AR
		declare	@hubID I32=(select ID from core.Hub#ByPOA(@poa));
		declare	@parcelIDs I64Array;insert into @parcelIDs(ID)
		select	i.v1 from tvp.Triad#Slice(@slip, default, N'	;	')     x
		cross	apply tvp.Duad#Slice(x.v3, default, default)           i
		join	shpt.Parcel#Raw()   p on p.ID=i.v1
		where	not exists(
					select	ID from acct.Ledger#Raw()  l
					cross	apply acct.Ledger#Side()   d
					where	MatterID=i.v1 and l.LedgerSide=d.AR
				);
		exec	shpt.Parcel#BillForFactor @parcelIDs=@parcelIDs, @hubID=@hubID;

		--	6.	Add SackMft Q for FedEx
		declare	@source   E8=(select InfoPath from core.Source#ID());
		declare	@stateID dbo.E8, @mftPostCourierQType dbo.E8;
		select	@stateID=StateID from shpt.SackMft#Base() where ID=@sackMftID;
		select	@mftPostCourierQType=q.MftPostCourierAPI from core.Queue#Type() q;
		exec	core.OutboundQ#Enqueue @source=@source, @qtype=@mftPostCourierQType, @matterID=@sackMftID, @stateID=@stateID;
		

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [xpd].[Flight$ImportForXpd]...';


GO
/*
@slip	= Many[Triad<SackNbr, Weight, string.Join(at.Spr.Comma, Mics)>];
@context= Triad<Dozen<POD, ETD, POA, ETA, FlightNbr, AirlineID, BoardedOn>, Dozen<POD, POA, MawbNbr, FlightNbr, OutgatedOn, MawbWt>, ClrMethodID>;
@result	= Pair<SackMftID, Many[Duad<ParcelID, ParcelMic>]>
*/
-- Daxia
ALTER PROCEDURE [xpd].[Flight$ImportForXpd](@slip tvp, @context tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT    ON;
	SET XACT_ABORT ON;

	BEGIN TRY
		BEGIN	TRAN;

		declare	@userID I32,    @site I32;
		select	@userID=UserID, @site=SiteID
		from	loc.Tenancy#Of(@tenancy);
		
		declare	@source E8=(select XPD from core.Source#ID());
		declare	@flightContext tvp, @sackMftContext tvp, @clrMethodID I32;
		select	@flightContext=v1,  @sackMftContext=v2,  @clrMethodID=v3 
		from	tvp.Triad#Of(@context, default);
		
		
		-- 1.	Add Flight
		declare	@flightID I64;
		execute	tms.Flight#Create @id=@flightID out, @source=@source, @context=@flightContext, @tenancy=@tenancy;

		--TODO: BoardedOn

		-- 2.1	Add SackMft
		declare	@sackMftID I64;
		execute	shpt.SackMft#CreateForFlight @id=@sackMftID out, @flightID=@flightID, @context=@sackMftContext, @tenancy=@tenancy;
		
		-- !!!Move to SackMft Create
		update	m set BrokerID=x.BrokerID
		from	shpt._SackMft m
		join	tms.Route#Raw() x on x.ClrMethodID=@clrMethodID
		join	tms.SvcRoute#Raw() s on s.RouteID=x.ID and s.POA=m.POA
		where	m.ID=@sackMftID;

		-- 2.3	Add SackMft Q for FedEx and AMS
		declare	@stateID dbo.I32, @mftPostCourierQType dbo.E8, @mftBrokerQType dbo.E8;
		select	@stateID=StateID from shpt.SackMft#Base() where ID=@sackMftID;
		select	@mftPostCourierQType=q.MftPostCourierAPI
		,		@mftBrokerQType     =q.MftBrokerAPI
		from	core.Queue#Type() q;
		exec	core.OutboundQ#Enqueue @source=@source, @qtype=@mftPostCourierQType, @matterID=@sackMftID, @stateID=@stateID;
		exec	core.OutboundQ#Enqueue @source=@source, @qtype=@mftBrokerQType,      @matterID=@sackMftID, @stateID=@stateID;
		

		--TODO: OutgatedOn

		-- 3.1	Add Sack & Upd Parcel
		declare	@sackContext tvp=(select Tvp from tvp.Duad#Make(@sackMftID, @clrMethodID));
		declare	@sackIDTexts tvp;-- Many[Duad<SackID, SackNbr>]
		execute	xpd.Sack$CreateForXpd @slip=@slip, @context=@sackContext, @tenancy=@tenancy, @result=@sackIDTexts out;
		
		-- 3.2	Auto Transloaded : Maybe don't use it.
		-- 3.2	Auto Outgated: where OutgatedOn, When if has not 3.2.
		
		-- 4.1	Parcel Bill -AR
		declare	@hubID I32;
		select	@hubID=h.ID from shpt.SackMft#Raw() x cross apply core.Hub#ByPOA(x.POA) h
		where	x.ID=@sackMftID
		;
		declare	@parcelIDs I64Array;insert into @parcelIDs(ID)
		select	r.MatterID from tvp.Triad#Slice(@slip, default, default)   x
		cross	apply tvp.Comma#Slice(x.v3)                          i
		cross	apply core.RefNbr#ScanOne(i.Piece, default, default) r
		join	shpt.Parcel#Raw()   p on p.ID=r.MatterID
		where	not exists(
					select	ID from acct.Ledger#Raw()  l
					cross	apply acct.Ledger#Side()   d
					where	MatterID=r.MatterID and l.LedgerSide=d.AR
				);
		exec	shpt.Parcel#BillForFactor @parcelIDs=@parcelIDs, @hubID=@hubID;
		
		-- 4.2	Manifest Bill -AR
		exec	shpt.SackMft#LedgerByCharge @sackMftID=@sackMftID;

		-- 5.	Result
		declare	@validIDs I64Array, @invalidIDs I64Array;
		with cteValid as
		(
			select	p.ID, r.Number
			from	core.Matter#Raw() x cross apply core.RefNbr#Type() k
			join	core.Matter#Raw() p on p.PID=x.ID
			join	core.RefNbr#Raw() r on r.MatterID=p.ID and r.Type=k.MIT
			where	x.PID=@sackMftID
		), cteInvalidText(text) as
		(
			select	[text()]=concat(k.Many, isnull(r.MatterID, 0), k.Duad, i.Piece)
			from	tvp.Spr#Const() k, tvp.Triad#Slice(@slip, default, default) x
			cross	apply tvp.Comma#Slice(x.v3)                                 i
			outer	apply core.RefNbr#ScanOne(i.Piece, default, default)        r
			where	not exists (select * from cteValid c where r.MatterID=c.ID)
			for		xml path(N'')
		)
		select	@result=concat(@sackMftID, k.Pair, isnull(stuff(f.text, 1, 3, N''), N''))
		from	cteInvalidText f, tvp.Spr#Const() k
		;

		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Altering [svc].[Parcel$MergePreCourier]...';


GO
/*
@slip   =Many[Duad<OrderNbr, FirstMilerNbr>]
*/
--Aimee, AaronLiu
ALTER PROCEDURE [svc].[Parcel$MergePreCourier](@slip tvp, @tenancy tvp, @result tvp out)
WITH ENCRYPTION
AS
BEGIN
	SET	NOCOUNT    ON;
	SET XACT_ABORT ON;
	BEGIN TRY
		BEGIN	TRAN;
		--1.Merge RefNbr
		declare	@maxStage E32=( select RouteCfmed from core.Stage#ID())
		,		@type     E8=( select PreCourier from core.RefNbr#Type())
		,		@siteID   I32=(select SiteID     from loc.Tenancy#Of(@tenancy))
		,		@clientRefType E8=( select ClientRef from core.RefNbr#Type());
		
		declare	@idSeqs I64Seqs;
		with ctePreNbr as
		(
			select	MatterID=m.ID, Number=cast(x.v2 as varchar(40)), x.Seq
			from	tvp.Duad#Slice(@slip, default, default) x
			cross	apply loc.RefNbr#Cast(x.v1)             r
			join	core.RefNbr#Raw() n on n.Number=r.Number and n.Type=@clientRefType
			join	core.Matter#Raw() m on m.ID=n.MatterID   and m.Stage<@maxStage and m.PosterID=@siteID
		)
		merge	core._RefNbr as r using ctePreNbr as n
		on		(r.MatterID=n.MatterID and r.Type=@type)
		when	matched     and n.Number=N'' then delete
		when	matched     and n.Number>N'' then update set r.Number=n.Number
		when	not matched and n.Number>N'' then insert(MatterID,  Type,   Number)
												values(n.MatterID, @type, n.Number)
		output	inserted.MatterID, n.Seq into @idSeqs;

		--2.find Orphan  TODO: 
		declare	@firstMilerNbrs tvp;
		with	cte(text) as
		(
			select	[text()]=concat(N',', v2)
			from	tvp.Duad#Slice(@slip, default, default)
			for		xml path(N'')
		)
		select	@firstMilerNbrs=Tvp from cte cross apply tvp.Spr#Purify(text, 1);
		execute	shpt.Orphan#Adopt @slip=@firstMilerNbrs, @tenancy=@tenancy;

		--3.return result
		with cteResult (text) as
		(
			select	[text()]=concat(k.Many, x.v1)
			from	tvp.Duad#Slice(@slip, default, default) x
			left	join @idSeqs i on i.Seq=x.Seq
			cross	apply tvp.Spr#Const()   k
			where	i.ID is null
			for		xml path(N'')
		)
		select	@result=Tvp from cteResult cross apply tvp.Spr#Purify(text, default);
		COMMIT	TRAN;
	END TRY
	BEGIN CATCH
		if (xact_state() = -1) ROLLBACK TRAN; throw;
	END CATCH
END
GO
PRINT N'Refreshing [svc].[Tenancy$Import]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Tenancy$Import]';


GO
PRINT N'Refreshing [vmi].[StockInOrder$Create]...';


GO
EXECUTE sp_refreshsqlmodule N'[vmi].[StockInOrder$Create]';


GO
PRINT N'Refreshing [vmi].[StockInOrder$Init]...';


GO
EXECUTE sp_refreshsqlmodule N'[vmi].[StockInOrder$Init]';


GO
PRINT N'Refreshing [vmi].[StockInOrder$InitForCainiao]...';


GO
EXECUTE sp_refreshsqlmodule N'[vmi].[StockInOrder$InitForCainiao]';


GO
PRINT N'Refreshing [svc].[Sku$ImportEndorsement]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Sku$ImportEndorsement]';


GO
PRINT N'Refreshing [svc].[AddOnSvc$Post]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[AddOnSvc$Post]';


GO
PRINT N'Refreshing [svc].[Contact$DefaultTo]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Contact$DefaultTo]';


GO
PRINT N'Refreshing [svc].[Contact$Merge]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Contact$Merge]';


GO
PRINT N'Refreshing [svc].[Flight$Assign]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Flight$Assign]';


GO
PRINT N'Refreshing [svc].[IDNbr$Import]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[IDNbr$Import]';


GO
PRINT N'Refreshing [hub].[Parcel$TryRack]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[Parcel$TryRack]';


GO
PRINT N'Refreshing [svc].[Flight$Import]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Flight$Import]';


GO
PRINT N'Refreshing [zeb].[Appt$InitForZeb]...';


GO
EXECUTE sp_refreshsqlmodule N'[zeb].[Appt$InitForZeb]';


GO
PRINT N'Refreshing [zeb].[Zack$InitForZeb]...';


GO
EXECUTE sp_refreshsqlmodule N'[zeb].[Zack$InitForZeb]';


GO
PRINT N'Refreshing [svc].[Sku$ImportByPlatform]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Sku$ImportByPlatform]';


GO
PRINT N'Refreshing [zeb].[Parcel$UpdForZeb]...';


GO
EXECUTE sp_refreshsqlmodule N'[zeb].[Parcel$UpdForZeb]';


GO
PRINT N'Refreshing [svc].[Sku$Import]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Sku$Import]';


GO
PRINT N'Refreshing [svc].[SackMft$UpdMawbNbr]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[SackMft$UpdMawbNbr]';


GO
PRINT N'Refreshing [bo].[CurrencyRate$Maintain]...';


GO
EXECUTE sp_refreshsqlmodule N'[bo].[CurrencyRate$Maintain]';


GO
PRINT N'Refreshing [svc].[SackMft$MergeStamp]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[SackMft$MergeStamp]';


GO
PRINT N'Refreshing [svc].[CourierNbr$Fetch]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[CourierNbr$Fetch]';


GO
PRINT N'Refreshing [api].[Brokerage$Dequeue]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[Brokerage$Dequeue]';


GO
PRINT N'Refreshing [shpt].[Parcel#BillForVmi]...';


GO
EXECUTE sp_refreshsqlmodule N'[shpt].[Parcel#BillForVmi]';


GO
PRINT N'Refreshing [shpt].[Parcel#TalliedOrDeduct]...';


GO
EXECUTE sp_refreshsqlmodule N'[shpt].[Parcel#TalliedOrDeduct]';


GO
PRINT N'Refreshing [whse].[RcvSkuFee#Bill]...';


GO
EXECUTE sp_refreshsqlmodule N'[whse].[RcvSkuFee#Bill]';


GO
PRINT N'Refreshing [vmi].[StorageFee$Bill]...';


GO
EXECUTE sp_refreshsqlmodule N'[vmi].[StorageFee$Bill]';


GO
PRINT N'Refreshing [zeb].[PIP$InitForZeb]...';


GO
EXECUTE sp_refreshsqlmodule N'[zeb].[PIP$InitForZeb]';


GO
PRINT N'Refreshing [vmi].[Parcel$Init]...';


GO
EXECUTE sp_refreshsqlmodule N'[vmi].[Parcel$Init]';


GO
PRINT N'Refreshing [zeb].[Parcel$InitForZeb]...';


GO
EXECUTE sp_refreshsqlmodule N'[zeb].[Parcel$InitForZeb]';


GO
PRINT N'Refreshing [app].[Parcel$InitForAmzNonSku]...';


GO
EXECUTE sp_refreshsqlmodule N'[app].[Parcel$InitForAmzNonSku]';


GO
PRINT N'Refreshing [app].[Parcel$InitForAmz]...';


GO
EXECUTE sp_refreshsqlmodule N'[app].[Parcel$InitForAmz]';


GO
PRINT N'Refreshing [app].[Parcel$InitForAae]...';


GO
EXECUTE sp_refreshsqlmodule N'[app].[Parcel$InitForAae]';


GO
PRINT N'Refreshing [co].[PaymentPlan$Init]...';


GO
EXECUTE sp_refreshsqlmodule N'[co].[PaymentPlan$Init]';


GO
PRINT N'Refreshing [api].[IDInfo$Dequeue]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[IDInfo$Dequeue]';


GO
PRINT N'Refreshing [api].[IDInfoReview$Dequeue]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[IDInfoReview$Dequeue]';


GO
PRINT N'Refreshing [api].[PolyCallback$Dequeue]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[PolyCallback$Dequeue]';


GO
PRINT N'Refreshing [api].[PostCourier$DequeueForPull]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[PostCourier$DequeueForPull]';


GO
PRINT N'Refreshing [api].[PostCourier$DequeueForTC]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[PostCourier$DequeueForTC]';


GO
PRINT N'Refreshing [api].[Subscriber$DequeueForTC]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[Subscriber$DequeueForTC]';


GO
PRINT N'Refreshing [api].[SubscribeCallback$Dequeue]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[SubscribeCallback$Dequeue]';


GO
PRINT N'Refreshing [vmi].[Parcel$Release]...';


GO
EXECUTE sp_refreshsqlmodule N'[vmi].[Parcel$Release]';


GO
PRINT N'Refreshing [xpd].[Parcel$ReweighForXpd]...';


GO
EXECUTE sp_refreshsqlmodule N'[xpd].[Parcel$ReweighForXpd]';


GO
PRINT N'Refreshing [hub].[RackOutOrder$Complete]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[RackOutOrder$Complete]';


GO
PRINT N'Refreshing [svc].[Parcel$CfmCustomsStatus]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$CfmCustomsStatus]';


GO
PRINT N'Refreshing [svc].[Parcel$Transit]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$Transit]';


GO
PRINT N'Refreshing [svc].[SackMft$Transit]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[SackMft$Transit]';


GO
PRINT N'Refreshing [svc].[Message$Post]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Message$Post]';


GO
PRINT N'Refreshing [shpt].[PreCourier#Concern]...';


GO
EXECUTE sp_refreshsqlmodule N'[shpt].[PreCourier#Concern]';


GO
PRINT N'Refreshing [shpt].[PreCourier#ConcernBlock]...';


GO
EXECUTE sp_refreshsqlmodule N'[shpt].[PreCourier#ConcernBlock]';


GO
PRINT N'Refreshing [api].[Parcel$InitForHandWrittenOrder]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[Parcel$InitForHandWrittenOrder]';


GO
PRINT N'Refreshing [api].[PostCourierApi$Dequeue]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[PostCourierApi$Dequeue]';


GO
PRINT N'Refreshing [api].[Snapshot$Merge]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[Snapshot$Merge]';


GO
PRINT N'Refreshing [svc].[Appointment$Init]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Appointment$Init]';


GO
PRINT N'Refreshing [shpt].[Orphan#Init]...';


GO
EXECUTE sp_refreshsqlmodule N'[shpt].[Orphan#Init]';


GO
PRINT N'Refreshing [api].[Activity$Subscribe]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[Activity$Subscribe]';


GO
PRINT N'Refreshing [svc].[Challenge$Pull]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Challenge$Pull]';


GO
PRINT N'Refreshing [vmi].[Parcel$ReceivedWeight]...';


GO
EXECUTE sp_refreshsqlmodule N'[vmi].[Parcel$ReceivedWeight]';


GO
PRINT N'Refreshing [svc].[Route$Confirm]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Route$Confirm]';


GO
PRINT N'Refreshing [vmi].[StockInOrder$Racked]...';


GO
EXECUTE sp_refreshsqlmodule N'[vmi].[StockInOrder$Racked]';


GO
PRINT N'Refreshing [api].[Parcel$InitForPlatformUnFiled]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[Parcel$InitForPlatformUnFiled]';


GO
PRINT N'Refreshing [api].[Parcel$InitForUnFiled]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[Parcel$InitForUnFiled]';


GO
PRINT N'Refreshing [api].[Parcel$Init]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[Parcel$Init]';


GO
PRINT N'Refreshing [app].[Parcel$InitForEship]...';


GO
EXECUTE sp_refreshsqlmodule N'[app].[Parcel$InitForEship]';


GO
PRINT N'Refreshing [app].[Parcel$InitWithSku]...';


GO
EXECUTE sp_refreshsqlmodule N'[app].[Parcel$InitWithSku]';


GO
PRINT N'Refreshing [api].[Parcel$InitForPlatform]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[Parcel$InitForPlatform]';


GO
PRINT N'Refreshing [api].[Parcel$UnfiledInitByPlatform]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[Parcel$UnfiledInitByPlatform]';


GO
PRINT N'Refreshing [svc].[Account$Transact]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Account$Transact]';


GO
PRINT N'Refreshing [lc].[Parcel$CheckIn]...';


GO
EXECUTE sp_refreshsqlmodule N'[lc].[Parcel$CheckIn]';


GO
PRINT N'Refreshing [api].[Parcel$UpdateForPlatform]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[Parcel$UpdateForPlatform]';


GO
PRINT N'Refreshing [api].[Parcel$RcvBrkgAcceptance]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[Parcel$RcvBrkgAcceptance]';


GO
PRINT N'Refreshing [api].[Parcel$RcvBrkgRejection]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[Parcel$RcvBrkgRejection]';


GO
PRINT N'Refreshing [api].[Parcel$UpdateForPlatformUnfiled]...';


GO
EXECUTE sp_refreshsqlmodule N'[api].[Parcel$UpdateForPlatformUnfiled]';


GO
PRINT N'Refreshing [hub].[Parcel$ReleaseForUsps]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[Parcel$ReleaseForUsps]';


GO
PRINT N'Refreshing [hub].[Sack$Init]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[Sack$Init]';


GO
PRINT N'Refreshing [hub].[Sack$Load]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[Sack$Load]';


GO
PRINT N'Refreshing [hub].[Sack$ReBag]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[Sack$ReBag]';


GO
PRINT N'Refreshing [hub].[Sack$Reload]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[Sack$Reload]';


GO
PRINT N'Refreshing [hub].[SackLoad$Transload]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[SackLoad$Transload]';


GO
PRINT N'Refreshing [hub].[SackMft$Create]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[SackMft$Create]';


GO
PRINT N'Refreshing [hub].[ShippingPlan$Comply]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[ShippingPlan$Comply]';


GO
PRINT N'Refreshing [ic].[Parcel$PromoteToShippingPlan]...';


GO
EXECUTE sp_refreshsqlmodule N'[ic].[Parcel$PromoteToShippingPlan]';


GO
PRINT N'Refreshing [ic].[ShippingPlan$Compose]...';


GO
EXECUTE sp_refreshsqlmodule N'[ic].[ShippingPlan$Compose]';


GO
PRINT N'Refreshing [ic].[ShippingPlan$Rollback]...';


GO
EXECUTE sp_refreshsqlmodule N'[ic].[ShippingPlan$Rollback]';


GO
PRINT N'Refreshing [shpt].[Parcel#TryRackOut]...';


GO
EXECUTE sp_refreshsqlmodule N'[shpt].[Parcel#TryRackOut]';


GO
PRINT N'Refreshing [svc].[Appointment$CallOff]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Appointment$CallOff]';


GO
PRINT N'Refreshing [svc].[Appointment$CancelStartOff]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Appointment$CancelStartOff]';


GO
PRINT N'Refreshing [svc].[Appointment$Complete]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Appointment$Complete]';


GO
PRINT N'Refreshing [svc].[Appointment$Dispatch]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Appointment$Dispatch]';


GO
PRINT N'Refreshing [svc].[Appointment$StartOff]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Appointment$StartOff]';


GO
PRINT N'Refreshing [svc].[HubManifest$Import]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[HubManifest$Import]';


GO
PRINT N'Refreshing [svc].[ICManifest$Import]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[ICManifest$Import]';


GO
PRINT N'Refreshing [svc].[Parcel$CfmIDInfo]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$CfmIDInfo]';


GO
PRINT N'Refreshing [svc].[Parcel$ChangeRouteToUsps]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$ChangeRouteToUsps]';


GO
PRINT N'Refreshing [svc].[Parcel$CheckIn]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$CheckIn]';


GO
PRINT N'Refreshing [svc].[Parcel$ComposeShippingPlan]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$ComposeShippingPlan]';


GO
PRINT N'Refreshing [svc].[Parcel$MergeIDInfo]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$MergeIDInfo]';


GO
PRINT N'Refreshing [svc].[Parcel$PromoteToShippingPlan]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$PromoteToShippingPlan]';


GO
PRINT N'Refreshing [svc].[Parcel$RequestIDInfo]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$RequestIDInfo]';


GO
PRINT N'Refreshing [svc].[Parcel$SurrenderByImport]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$SurrenderByImport]';


GO
PRINT N'Refreshing [svc].[Parcel$Verify]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$Verify]';


GO
PRINT N'Refreshing [svc].[Parcel$Void]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$Void]';


GO
PRINT N'Refreshing [svc].[SackMft$Release]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[SackMft$Release]';


GO
PRINT N'Refreshing [svc].[ShippingPlan$Fallback]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[ShippingPlan$Fallback]';


GO
PRINT N'Refreshing [svc].[ShippingPlan$Return]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[ShippingPlan$Return]';


GO
PRINT N'Refreshing [vmi].[HubMft$Import]...';


GO
EXECUTE sp_refreshsqlmodule N'[vmi].[HubMft$Import]';


GO
PRINT N'Refreshing [vmi].[Parcel$ChangeSvcTypeForCainiao]...';


GO
EXECUTE sp_refreshsqlmodule N'[vmi].[Parcel$ChangeSvcTypeForCainiao]';


GO
PRINT N'Refreshing [vmi].[Parcel$Void]...';


GO
EXECUTE sp_refreshsqlmodule N'[vmi].[Parcel$Void]';


GO
PRINT N'Refreshing [vmi].[StockInOrder$HubVerified]...';


GO
EXECUTE sp_refreshsqlmodule N'[vmi].[StockInOrder$HubVerified]';


GO
PRINT N'Refreshing [vmi].[StockInOrder$Import]...';


GO
EXECUTE sp_refreshsqlmodule N'[vmi].[StockInOrder$Import]';


GO
PRINT N'Refreshing [vmi].[StockInOrder$Void]...';


GO
EXECUTE sp_refreshsqlmodule N'[vmi].[StockInOrder$Void]';


GO
PRINT N'Refreshing [xpd].[Parcel$MeasureForXpd]...';


GO
EXECUTE sp_refreshsqlmodule N'[xpd].[Parcel$MeasureForXpd]';


GO
PRINT N'Refreshing [zeb].[ShippingPlan$Concur]...';


GO
EXECUTE sp_refreshsqlmodule N'[zeb].[ShippingPlan$Concur]';


GO
PRINT N'Refreshing [shpt].[Parcel#Measure]...';


GO
EXECUTE sp_refreshsqlmodule N'[shpt].[Parcel#Measure]';


GO
PRINT N'Refreshing [svc].[SackMft$ImportWithLabelInfo]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[SackMft$ImportWithLabelInfo]';


GO
PRINT N'Refreshing [auto].[Parcel$Measure]...';


GO
EXECUTE sp_refreshsqlmodule N'[auto].[Parcel$Measure]';


GO
PRINT N'Refreshing [svc].[Parcel$Measure]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Parcel$Measure]';


GO
PRINT N'Refreshing [svc].[Tenancy$AddTenant]...';


GO
EXECUTE sp_refreshsqlmodule N'[svc].[Tenancy$AddTenant]';


GO
PRINT N'Refreshing [bo].[Account$DepositFor]...';


GO
EXECUTE sp_refreshsqlmodule N'[bo].[Account$DepositFor]';


GO
PRINT N'Refreshing [co].[Account$Deposit]...';


GO
EXECUTE sp_refreshsqlmodule N'[co].[Account$Deposit]';


GO
PRINT N'Refreshing [lc].[Parcel$Measure]...';


GO
EXECUTE sp_refreshsqlmodule N'[lc].[Parcel$Measure]';


GO
PRINT N'Refreshing [hub].[RackInOrder$Complete]...';


GO
EXECUTE sp_refreshsqlmodule N'[hub].[RackInOrder$Complete]';


GO
PRINT N'Refreshing [shpt].[Orphan#Adopt]...';


GO
EXECUTE sp_refreshsqlmodule N'[shpt].[Orphan#Adopt]';


GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [core].[_State] WITH CHECK CHECK CONSTRAINT [CK_State];

ALTER TABLE [tms].[_SvcType] WITH CHECK CHECK CONSTRAINT [CK_SvcType];

ALTER TABLE [tms].[_SvcType] WITH CHECK CHECK CONSTRAINT [CK_SvcType_WeightMethod];

ALTER TABLE [acct].[_Invoice] WITH CHECK CHECK CONSTRAINT [CK_Invoice_DueBalance];

ALTER TABLE [acct].[_Invoice] WITH CHECK CHECK CONSTRAINT [CK_Invoice_InvoiceAmt];

ALTER TABLE [acct].[_Ledger] WITH CHECK CHECK CONSTRAINT [CK_Ledger_ChargeAmt];

ALTER TABLE [acct].[_Payment] WITH CHECK CHECK CONSTRAINT [CK_Payment_PaidAmt];

ALTER TABLE [acct].[_Vault] WITH CHECK CHECK CONSTRAINT [CK_Vault_Uninvoiced];

ALTER TABLE [acct].[_Vault] WITH CHECK CHECK CONSTRAINT [CK_Vault_VaultBal];

ALTER TABLE [acct].[_VaultXact] WITH CHECK CHECK CONSTRAINT [CK_VaultXact_XactAmt];


GO
PRINT N'Update complete.';


GO
